typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;
typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef short int __int16_t;
typedef unsigned short int __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;
typedef long int __int64_t;
typedef unsigned long int __uint64_t;
typedef long int __quad_t;
typedef unsigned long int __u_quad_t;
typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
struct  __fsid_t
{
    int __val[2];
};
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;
typedef int __daddr_t;
typedef long int __swblk_t;
typedef int __key_t;
typedef int __clockid_t;
typedef void *__timer_t;
typedef long int __blksize_t;
typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;
typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;
typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;
typedef long int __ssize_t;
typedef ::__off64_t __loff_t;
typedef ::__quad_t *__qaddr_t;
typedef char *__caddr_t;
typedef long int __intptr_t;
typedef unsigned int __socklen_t;
typedef ::__ssize_t ssize_t;
typedef unsigned long int size_t;
typedef ::__gid_t gid_t;
typedef ::__uid_t uid_t;
typedef ::__off_t off_t;
typedef ::__off64_t off64_t;
typedef ::__useconds_t useconds_t;
typedef ::__pid_t pid_t;
typedef ::__intptr_t intptr_t;
typedef ::__socklen_t socklen_t;
extern "C"
{
  extern int access(const char *__name, int __type) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int euidaccess(const char *__name, int __type) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int eaccess(const char *__name, int __type) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int faccessat(int __fd, const char *__file, int __type, int __flag) throw()__attribute__((__nonnull__(2)));
}
extern "C"
{
  extern ::__off_t lseek(int __fd, ::__off_t __offset, int __whence) throw();
}
extern "C"
{
  extern ::__off64_t lseek64(int __fd, ::__off64_t __offset, int __whence) throw();
}
extern "C"
{
  extern int close(int __fd);
}
extern "C"
{
  extern ::ssize_t read(int __fd, void *__buf, ::size_t __nbytes);
}
extern "C"
{
  extern ::ssize_t write(int __fd, const void *__buf, ::size_t __n);
}
extern "C"
{
  extern ::ssize_t pread(int __fd, void *__buf, ::size_t __nbytes, ::__off_t __offset);
}
extern "C"
{
  extern ::ssize_t pwrite(int __fd, const void *__buf, ::size_t __n, ::__off_t __offset);
}
extern "C"
{
  extern ::ssize_t pread64(int __fd, void *__buf, ::size_t __nbytes, ::__off64_t __offset);
}
extern "C"
{
  extern ::ssize_t pwrite64(int __fd, const void *__buf, ::size_t __n, ::__off64_t __offset);
}
extern "C"
{
  extern int pipe(int __pipedes[2]) throw();
}
extern "C"
{
  extern int pipe2(int __pipedes[2], int __flags) throw();
}
extern "C"
{
  extern unsigned int alarm(unsigned int __seconds) throw();
}
extern "C"
{
  extern unsigned int sleep(unsigned int __seconds);
}
extern "C"
{
  extern ::__useconds_t ualarm(::__useconds_t __value, ::__useconds_t __interval) throw();
}
extern "C"
{
  extern int usleep(::__useconds_t __useconds);
}
extern "C"
{
  extern int pause();
}
extern "C"
{
  extern int chown(const char *__file, ::__uid_t __owner, ::__gid_t __group) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int fchown(int __fd, ::__uid_t __owner, ::__gid_t __group) throw();
}
extern "C"
{
  extern int lchown(const char *__file, ::__uid_t __owner, ::__gid_t __group) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int fchownat(int __fd, const char *__file, ::__uid_t __owner, ::__gid_t __group, int __flag) throw()__attribute__((__nonnull__(2)));
}
extern "C"
{
  extern int chdir(const char *__path) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int fchdir(int __fd) throw();
}
extern "C"
{
  extern char *getcwd(char *__buf, ::size_t __size) throw();
}
extern "C"
{
  extern char *get_current_dir_name() throw();
}
extern "C"
{
  extern char *getwd(char *__buf) throw()__attribute__((__nonnull__(1))) __attribute__((__deprecated__));
}
extern "C"
{
  extern int dup(int __fd) throw();
}
extern "C"
{
  extern int dup2(int __fd, int __fd2) throw();
}
extern "C"
{
  extern int dup3(int __fd, int __fd2, int __flags) throw();
}
extern "C"
{
  extern char **__environ;
}
extern "C"
{
  extern char **environ;
}
extern "C"
{
  extern int execve(const char *__path, char *const __argv[], char *const __envp[]) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int fexecve(int __fd, char *const __argv[], char *const __envp[]) throw();
}
extern "C"
{
  extern int execv(const char *__path, char *const __argv[]) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int execle(const char *__path, const char *__arg, ...) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int execl(const char *__path, const char *__arg, ...) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int execvp(const char *__file, char *const __argv[]) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int execlp(const char *__file, const char *__arg, ...) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int execvpe(const char *__file, char *const __argv[], char *const __envp[]) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int nice(int __inc) throw();
}
extern "C"
{
  extern void _exit(int __status)__attribute__((__noreturn__));
}
enum mcc_enum_anon_0
{
  _PC_LINK_MAX = 0,
  _PC_MAX_CANON = 1,
  _PC_MAX_INPUT = 2,
  _PC_NAME_MAX = 3,
  _PC_PATH_MAX = 4,
  _PC_PIPE_BUF = 5,
  _PC_CHOWN_RESTRICTED = 6,
  _PC_NO_TRUNC = 7,
  _PC_VDISABLE = 8,
  _PC_SYNC_IO = 9,
  _PC_ASYNC_IO = 10,
  _PC_PRIO_IO = 11,
  _PC_SOCK_MAXBUF = 12,
  _PC_FILESIZEBITS = 13,
  _PC_REC_INCR_XFER_SIZE = 14,
  _PC_REC_MAX_XFER_SIZE = 15,
  _PC_REC_MIN_XFER_SIZE = 16,
  _PC_REC_XFER_ALIGN = 17,
  _PC_ALLOC_SIZE_MIN = 18,
  _PC_SYMLINK_MAX = 19,
  _PC_2_SYMLINKS = 20
};
enum mcc_enum_anon_1
{
  _SC_ARG_MAX = 0,
  _SC_CHILD_MAX = 1,
  _SC_CLK_TCK = 2,
  _SC_NGROUPS_MAX = 3,
  _SC_OPEN_MAX = 4,
  _SC_STREAM_MAX = 5,
  _SC_TZNAME_MAX = 6,
  _SC_JOB_CONTROL = 7,
  _SC_SAVED_IDS = 8,
  _SC_REALTIME_SIGNALS = 9,
  _SC_PRIORITY_SCHEDULING = 10,
  _SC_TIMERS = 11,
  _SC_ASYNCHRONOUS_IO = 12,
  _SC_PRIORITIZED_IO = 13,
  _SC_SYNCHRONIZED_IO = 14,
  _SC_FSYNC = 15,
  _SC_MAPPED_FILES = 16,
  _SC_MEMLOCK = 17,
  _SC_MEMLOCK_RANGE = 18,
  _SC_MEMORY_PROTECTION = 19,
  _SC_MESSAGE_PASSING = 20,
  _SC_SEMAPHORES = 21,
  _SC_SHARED_MEMORY_OBJECTS = 22,
  _SC_AIO_LISTIO_MAX = 23,
  _SC_AIO_MAX = 24,
  _SC_AIO_PRIO_DELTA_MAX = 25,
  _SC_DELAYTIMER_MAX = 26,
  _SC_MQ_OPEN_MAX = 27,
  _SC_MQ_PRIO_MAX = 28,
  _SC_VERSION = 29,
  _SC_PAGESIZE = 30,
  _SC_RTSIG_MAX = 31,
  _SC_SEM_NSEMS_MAX = 32,
  _SC_SEM_VALUE_MAX = 33,
  _SC_SIGQUEUE_MAX = 34,
  _SC_TIMER_MAX = 35,
  _SC_BC_BASE_MAX = 36,
  _SC_BC_DIM_MAX = 37,
  _SC_BC_SCALE_MAX = 38,
  _SC_BC_STRING_MAX = 39,
  _SC_COLL_WEIGHTS_MAX = 40,
  _SC_EQUIV_CLASS_MAX = 41,
  _SC_EXPR_NEST_MAX = 42,
  _SC_LINE_MAX = 43,
  _SC_RE_DUP_MAX = 44,
  _SC_CHARCLASS_NAME_MAX = 45,
  _SC_2_VERSION = 46,
  _SC_2_C_BIND = 47,
  _SC_2_C_DEV = 48,
  _SC_2_FORT_DEV = 49,
  _SC_2_FORT_RUN = 50,
  _SC_2_SW_DEV = 51,
  _SC_2_LOCALEDEF = 52,
  _SC_PII = 53,
  _SC_PII_XTI = 54,
  _SC_PII_SOCKET = 55,
  _SC_PII_INTERNET = 56,
  _SC_PII_OSI = 57,
  _SC_POLL = 58,
  _SC_SELECT = 59,
  _SC_UIO_MAXIOV = 60,
  _SC_IOV_MAX = ::_SC_UIO_MAXIOV,
  _SC_PII_INTERNET_STREAM = 61,
  _SC_PII_INTERNET_DGRAM = 62,
  _SC_PII_OSI_COTS = 63,
  _SC_PII_OSI_CLTS = 64,
  _SC_PII_OSI_M = 65,
  _SC_T_IOV_MAX = 66,
  _SC_THREADS = 67,
  _SC_THREAD_SAFE_FUNCTIONS = 68,
  _SC_GETGR_R_SIZE_MAX = 69,
  _SC_GETPW_R_SIZE_MAX = 70,
  _SC_LOGIN_NAME_MAX = 71,
  _SC_TTY_NAME_MAX = 72,
  _SC_THREAD_DESTRUCTOR_ITERATIONS = 73,
  _SC_THREAD_KEYS_MAX = 74,
  _SC_THREAD_STACK_MIN = 75,
  _SC_THREAD_THREADS_MAX = 76,
  _SC_THREAD_ATTR_STACKADDR = 77,
  _SC_THREAD_ATTR_STACKSIZE = 78,
  _SC_THREAD_PRIORITY_SCHEDULING = 79,
  _SC_THREAD_PRIO_INHERIT = 80,
  _SC_THREAD_PRIO_PROTECT = 81,
  _SC_THREAD_PROCESS_SHARED = 82,
  _SC_NPROCESSORS_CONF = 83,
  _SC_NPROCESSORS_ONLN = 84,
  _SC_PHYS_PAGES = 85,
  _SC_AVPHYS_PAGES = 86,
  _SC_ATEXIT_MAX = 87,
  _SC_PASS_MAX = 88,
  _SC_XOPEN_VERSION = 89,
  _SC_XOPEN_XCU_VERSION = 90,
  _SC_XOPEN_UNIX = 91,
  _SC_XOPEN_CRYPT = 92,
  _SC_XOPEN_ENH_I18N = 93,
  _SC_XOPEN_SHM = 94,
  _SC_2_CHAR_TERM = 95,
  _SC_2_C_VERSION = 96,
  _SC_2_UPE = 97,
  _SC_XOPEN_XPG2 = 98,
  _SC_XOPEN_XPG3 = 99,
  _SC_XOPEN_XPG4 = 100,
  _SC_CHAR_BIT = 101,
  _SC_CHAR_MAX = 102,
  _SC_CHAR_MIN = 103,
  _SC_INT_MAX = 104,
  _SC_INT_MIN = 105,
  _SC_LONG_BIT = 106,
  _SC_WORD_BIT = 107,
  _SC_MB_LEN_MAX = 108,
  _SC_NZERO = 109,
  _SC_SSIZE_MAX = 110,
  _SC_SCHAR_MAX = 111,
  _SC_SCHAR_MIN = 112,
  _SC_SHRT_MAX = 113,
  _SC_SHRT_MIN = 114,
  _SC_UCHAR_MAX = 115,
  _SC_UINT_MAX = 116,
  _SC_ULONG_MAX = 117,
  _SC_USHRT_MAX = 118,
  _SC_NL_ARGMAX = 119,
  _SC_NL_LANGMAX = 120,
  _SC_NL_MSGMAX = 121,
  _SC_NL_NMAX = 122,
  _SC_NL_SETMAX = 123,
  _SC_NL_TEXTMAX = 124,
  _SC_XBS5_ILP32_OFF32 = 125,
  _SC_XBS5_ILP32_OFFBIG = 126,
  _SC_XBS5_LP64_OFF64 = 127,
  _SC_XBS5_LPBIG_OFFBIG = 128,
  _SC_XOPEN_LEGACY = 129,
  _SC_XOPEN_REALTIME = 130,
  _SC_XOPEN_REALTIME_THREADS = 131,
  _SC_ADVISORY_INFO = 132,
  _SC_BARRIERS = 133,
  _SC_BASE = 134,
  _SC_C_LANG_SUPPORT = 135,
  _SC_C_LANG_SUPPORT_R = 136,
  _SC_CLOCK_SELECTION = 137,
  _SC_CPUTIME = 138,
  _SC_THREAD_CPUTIME = 139,
  _SC_DEVICE_IO = 140,
  _SC_DEVICE_SPECIFIC = 141,
  _SC_DEVICE_SPECIFIC_R = 142,
  _SC_FD_MGMT = 143,
  _SC_FIFO = 144,
  _SC_PIPE = 145,
  _SC_FILE_ATTRIBUTES = 146,
  _SC_FILE_LOCKING = 147,
  _SC_FILE_SYSTEM = 148,
  _SC_MONOTONIC_CLOCK = 149,
  _SC_MULTI_PROCESS = 150,
  _SC_SINGLE_PROCESS = 151,
  _SC_NETWORKING = 152,
  _SC_READER_WRITER_LOCKS = 153,
  _SC_SPIN_LOCKS = 154,
  _SC_REGEXP = 155,
  _SC_REGEX_VERSION = 156,
  _SC_SHELL = 157,
  _SC_SIGNALS = 158,
  _SC_SPAWN = 159,
  _SC_SPORADIC_SERVER = 160,
  _SC_THREAD_SPORADIC_SERVER = 161,
  _SC_SYSTEM_DATABASE = 162,
  _SC_SYSTEM_DATABASE_R = 163,
  _SC_TIMEOUTS = 164,
  _SC_TYPED_MEMORY_OBJECTS = 165,
  _SC_USER_GROUPS = 166,
  _SC_USER_GROUPS_R = 167,
  _SC_2_PBS = 168,
  _SC_2_PBS_ACCOUNTING = 169,
  _SC_2_PBS_LOCATE = 170,
  _SC_2_PBS_MESSAGE = 171,
  _SC_2_PBS_TRACK = 172,
  _SC_SYMLOOP_MAX = 173,
  _SC_STREAMS = 174,
  _SC_2_PBS_CHECKPOINT = 175,
  _SC_V6_ILP32_OFF32 = 176,
  _SC_V6_ILP32_OFFBIG = 177,
  _SC_V6_LP64_OFF64 = 178,
  _SC_V6_LPBIG_OFFBIG = 179,
  _SC_HOST_NAME_MAX = 180,
  _SC_TRACE = 181,
  _SC_TRACE_EVENT_FILTER = 182,
  _SC_TRACE_INHERIT = 183,
  _SC_TRACE_LOG = 184,
  _SC_LEVEL1_ICACHE_SIZE = 185,
  _SC_LEVEL1_ICACHE_ASSOC = 186,
  _SC_LEVEL1_ICACHE_LINESIZE = 187,
  _SC_LEVEL1_DCACHE_SIZE = 188,
  _SC_LEVEL1_DCACHE_ASSOC = 189,
  _SC_LEVEL1_DCACHE_LINESIZE = 190,
  _SC_LEVEL2_CACHE_SIZE = 191,
  _SC_LEVEL2_CACHE_ASSOC = 192,
  _SC_LEVEL2_CACHE_LINESIZE = 193,
  _SC_LEVEL3_CACHE_SIZE = 194,
  _SC_LEVEL3_CACHE_ASSOC = 195,
  _SC_LEVEL3_CACHE_LINESIZE = 196,
  _SC_LEVEL4_CACHE_SIZE = 197,
  _SC_LEVEL4_CACHE_ASSOC = 198,
  _SC_LEVEL4_CACHE_LINESIZE = 199,
  _SC_IPV6 = ::_SC_LEVEL1_ICACHE_SIZE + 50,
  _SC_RAW_SOCKETS = 236,
  _SC_V7_ILP32_OFF32 = 237,
  _SC_V7_ILP32_OFFBIG = 238,
  _SC_V7_LP64_OFF64 = 239,
  _SC_V7_LPBIG_OFFBIG = 240,
  _SC_SS_REPL_MAX = 241,
  _SC_TRACE_EVENT_NAME_MAX = 242,
  _SC_TRACE_NAME_MAX = 243,
  _SC_TRACE_SYS_MAX = 244,
  _SC_TRACE_USER_EVENT_MAX = 245,
  _SC_XOPEN_STREAMS = 246,
  _SC_THREAD_ROBUST_PRIO_INHERIT = 247,
  _SC_THREAD_ROBUST_PRIO_PROTECT = 248
};
enum mcc_enum_anon_2
{
  _CS_PATH = 0,
  _CS_V6_WIDTH_RESTRICTED_ENVS = 1,
  _CS_GNU_LIBC_VERSION = 2,
  _CS_GNU_LIBPTHREAD_VERSION = 3,
  _CS_V5_WIDTH_RESTRICTED_ENVS = 4,
  _CS_V7_WIDTH_RESTRICTED_ENVS = 5,
  _CS_LFS_CFLAGS = 1000,
  _CS_LFS_LDFLAGS = 1001,
  _CS_LFS_LIBS = 1002,
  _CS_LFS_LINTFLAGS = 1003,
  _CS_LFS64_CFLAGS = 1004,
  _CS_LFS64_LDFLAGS = 1005,
  _CS_LFS64_LIBS = 1006,
  _CS_LFS64_LINTFLAGS = 1007,
  _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,
  _CS_XBS5_ILP32_OFF32_LDFLAGS = 1101,
  _CS_XBS5_ILP32_OFF32_LIBS = 1102,
  _CS_XBS5_ILP32_OFF32_LINTFLAGS = 1103,
  _CS_XBS5_ILP32_OFFBIG_CFLAGS = 1104,
  _CS_XBS5_ILP32_OFFBIG_LDFLAGS = 1105,
  _CS_XBS5_ILP32_OFFBIG_LIBS = 1106,
  _CS_XBS5_ILP32_OFFBIG_LINTFLAGS = 1107,
  _CS_XBS5_LP64_OFF64_CFLAGS = 1108,
  _CS_XBS5_LP64_OFF64_LDFLAGS = 1109,
  _CS_XBS5_LP64_OFF64_LIBS = 1110,
  _CS_XBS5_LP64_OFF64_LINTFLAGS = 1111,
  _CS_XBS5_LPBIG_OFFBIG_CFLAGS = 1112,
  _CS_XBS5_LPBIG_OFFBIG_LDFLAGS = 1113,
  _CS_XBS5_LPBIG_OFFBIG_LIBS = 1114,
  _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS = 1115,
  _CS_POSIX_V6_ILP32_OFF32_CFLAGS = 1116,
  _CS_POSIX_V6_ILP32_OFF32_LDFLAGS = 1117,
  _CS_POSIX_V6_ILP32_OFF32_LIBS = 1118,
  _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS = 1119,
  _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS = 1120,
  _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS = 1121,
  _CS_POSIX_V6_ILP32_OFFBIG_LIBS = 1122,
  _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS = 1123,
  _CS_POSIX_V6_LP64_OFF64_CFLAGS = 1124,
  _CS_POSIX_V6_LP64_OFF64_LDFLAGS = 1125,
  _CS_POSIX_V6_LP64_OFF64_LIBS = 1126,
  _CS_POSIX_V6_LP64_OFF64_LINTFLAGS = 1127,
  _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS = 1128,
  _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS = 1129,
  _CS_POSIX_V6_LPBIG_OFFBIG_LIBS = 1130,
  _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS = 1131,
  _CS_POSIX_V7_ILP32_OFF32_CFLAGS = 1132,
  _CS_POSIX_V7_ILP32_OFF32_LDFLAGS = 1133,
  _CS_POSIX_V7_ILP32_OFF32_LIBS = 1134,
  _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS = 1135,
  _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS = 1136,
  _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS = 1137,
  _CS_POSIX_V7_ILP32_OFFBIG_LIBS = 1138,
  _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS = 1139,
  _CS_POSIX_V7_LP64_OFF64_CFLAGS = 1140,
  _CS_POSIX_V7_LP64_OFF64_LDFLAGS = 1141,
  _CS_POSIX_V7_LP64_OFF64_LIBS = 1142,
  _CS_POSIX_V7_LP64_OFF64_LINTFLAGS = 1143,
  _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS = 1144,
  _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS = 1145,
  _CS_POSIX_V7_LPBIG_OFFBIG_LIBS = 1146,
  _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS = 1147
};
extern "C"
{
  extern long int pathconf(const char *__path, int __name) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern long int fpathconf(int __fd, int __name) throw();
}
extern "C"
{
  extern long int sysconf(int __name) throw();
}
extern "C"
{
  extern ::size_t confstr(int __name, char *__buf, ::size_t __len) throw();
}
extern "C"
{
  extern ::__pid_t getpid() throw();
}
extern "C"
{
  extern ::__pid_t getppid() throw();
}
extern "C"
{
  extern ::__pid_t getpgrp() throw();
}
extern "C"
{
  extern ::__pid_t __getpgid(::__pid_t __pid) throw();
}
extern "C"
{
  extern ::__pid_t getpgid(::__pid_t __pid) throw();
}
extern "C"
{
  extern int setpgid(::__pid_t __pid, ::__pid_t __pgid) throw();
}
extern "C"
{
  extern int setpgrp() throw();
}
extern "C"
{
  extern ::__pid_t setsid() throw();
}
extern "C"
{
  extern ::__pid_t getsid(::__pid_t __pid) throw();
}
extern "C"
{
  extern ::__uid_t getuid() throw();
}
extern "C"
{
  extern ::__uid_t geteuid() throw();
}
extern "C"
{
  extern ::__gid_t getgid() throw();
}
extern "C"
{
  extern ::__gid_t getegid() throw();
}
extern "C"
{
  extern int getgroups(int __size, ::__gid_t __list[]) throw();
}
extern "C"
{
  extern int group_member(::__gid_t __gid) throw();
}
extern "C"
{
  extern int setuid(::__uid_t __uid) throw();
}
extern "C"
{
  extern int setreuid(::__uid_t __ruid, ::__uid_t __euid) throw();
}
extern "C"
{
  extern int seteuid(::__uid_t __uid) throw();
}
extern "C"
{
  extern int setgid(::__gid_t __gid) throw();
}
extern "C"
{
  extern int setregid(::__gid_t __rgid, ::__gid_t __egid) throw();
}
extern "C"
{
  extern int setegid(::__gid_t __gid) throw();
}
extern "C"
{
  extern int getresuid(::__uid_t *__ruid, ::__uid_t *__euid, ::__uid_t *__suid) throw();
}
extern "C"
{
  extern int getresgid(::__gid_t *__rgid, ::__gid_t *__egid, ::__gid_t *__sgid) throw();
}
extern "C"
{
  extern int setresuid(::__uid_t __ruid, ::__uid_t __euid, ::__uid_t __suid) throw();
}
extern "C"
{
  extern int setresgid(::__gid_t __rgid, ::__gid_t __egid, ::__gid_t __sgid) throw();
}
extern "C"
{
  extern ::__pid_t fork() throw();
}
extern "C"
{
  extern ::__pid_t vfork() throw();
}
extern "C"
{
  extern char *ttyname(int __fd) throw();
}
extern "C"
{
  extern int ttyname_r(int __fd, char *__buf, ::size_t __buflen) throw()__attribute__((__nonnull__(2)));
}
extern "C"
{
  extern int isatty(int __fd) throw();
}
extern "C"
{
  extern int ttyslot() throw();
}
extern "C"
{
  extern int link(const char *__from, const char *__to) throw()__attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int linkat(int __fromfd, const char *__from, int __tofd, const char *__to, int __flags) throw()__attribute__((__nonnull__(2, 4)));
}
extern "C"
{
  extern int symlink(const char *__from, const char *__to) throw()__attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern ::ssize_t readlink(const char *__restrict __path, char *__restrict __buf, ::size_t __len) throw()__attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int symlinkat(const char *__from, int __tofd, const char *__to) throw()__attribute__((__nonnull__(1, 3)));
}
extern "C"
{
  extern ::ssize_t readlinkat(int __fd, const char *__restrict __path, char *__restrict __buf, ::size_t __len) throw()__attribute__((__nonnull__(2, 3)));
}
extern "C"
{
  extern int unlink(const char *__name) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int unlinkat(int __fd, const char *__name, int __flag) throw()__attribute__((__nonnull__(2)));
}
extern "C"
{
  extern int rmdir(const char *__path) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern ::__pid_t tcgetpgrp(int __fd) throw();
}
extern "C"
{
  extern int tcsetpgrp(int __fd, ::__pid_t __pgrp_id) throw();
}
extern "C"
{
  extern char *getlogin();
}
extern "C"
{
  extern int getlogin_r(char *__name, ::size_t __name_len)__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int setlogin(const char *__name) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern char *optarg;
}
extern "C"
{
  extern int optind;
}
extern "C"
{
  extern int opterr;
}
extern "C"
{
  extern int optopt;
}
extern "C"
{
  extern int getopt(int ___argc, char *const *___argv, const char *__shortopts) throw();
}
extern "C"
{
  extern int gethostname(char *__name, ::size_t __len) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int sethostname(const char *__name, ::size_t __len) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int sethostid(long int __id) throw();
}
extern "C"
{
  extern int getdomainname(char *__name, ::size_t __len) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int setdomainname(const char *__name, ::size_t __len) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int vhangup() throw();
}
extern "C"
{
  extern int revoke(const char *__file) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int profil(unsigned short int *__sample_buffer, ::size_t __size, ::size_t __offset, unsigned int __scale) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int acct(const char *__name) throw();
}
extern "C"
{
  extern char *getusershell() throw();
}
extern "C"
{
  extern void endusershell() throw();
}
extern "C"
{
  extern void setusershell() throw();
}
extern "C"
{
  extern int daemon(int __nochdir, int __noclose) throw();
}
extern "C"
{
  extern int chroot(const char *__path) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern char *getpass(const char *__prompt)__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int fsync(int __fd);
}
extern "C"
{
  extern long int gethostid();
}
extern "C"
{
  extern void sync() throw();
}
extern "C"
{
  extern int getpagesize() throw()__attribute__((__const__));
}
extern "C"
{
  extern int getdtablesize() throw();
}
extern "C"
{
  extern int truncate(const char *__file, ::__off_t __length) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int truncate64(const char *__file, ::__off64_t __length) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int ftruncate(int __fd, ::__off_t __length) throw();
}
extern "C"
{
  extern int ftruncate64(int __fd, ::__off64_t __length) throw();
}
extern "C"
{
  extern int brk(void *__addr) throw();
}
extern "C"
{
  extern void *sbrk(::intptr_t __delta) throw();
}
extern "C"
{
  extern long int syscall(long int __sysno, ...) throw();
}
extern "C"
{
  extern int lockf(int __fd, int __cmd, ::__off_t __len);
}
extern "C"
{
  extern int lockf64(int __fd, int __cmd, ::__off64_t __len);
}
extern "C"
{
  extern int fdatasync(int __fildes);
}
extern "C"
{
  extern char *crypt(const char *__key, const char *__salt) throw()__attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern void encrypt(char *__block, int __edflag) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern void swab(const void *__restrict __from, void *__restrict __to, ::ssize_t __n) throw()__attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern char *ctermid(char *__s) throw();
}
struct _IO_FILE;
typedef ::_IO_FILE FILE;
typedef ::_IO_FILE __FILE;
struct  __mbstate_t
{
    union mcc_union_anon_2;
    int __count;
    union  mcc_union_anon_2
    {
        unsigned int __wch;
        char __wchb[4];
    };
    ::__mbstate_t::mcc_union_anon_2 __value;
};
struct  _G_fpos_t
{
    ::__off_t __pos;
    ::__mbstate_t __state;
};
struct  _G_fpos64_t
{
    ::__off64_t __pos;
    ::__mbstate_t __state;
};
typedef short int _G_int16_t;
typedef int _G_int32_t;
typedef unsigned short int _G_uint16_t;
typedef unsigned int _G_uint32_t;
typedef ::__builtin_va_list __gnuc_va_list;
struct _IO_jump_t;
typedef void _IO_lock_t;
struct _IO_marker;
struct  _IO_marker
{
    struct _IO_marker *_next;
    ::_IO_FILE *_sbuf;
    int _pos;
};
enum __codecvt_result
{
  __codecvt_ok = 0,
  __codecvt_partial = 1,
  __codecvt_error = 2,
  __codecvt_noconv = 3
};
struct  _IO_FILE
{
    int _flags;
    char *_IO_read_ptr;
    char *_IO_read_end;
    char *_IO_read_base;
    char *_IO_write_base;
    char *_IO_write_ptr;
    char *_IO_write_end;
    char *_IO_buf_base;
    char *_IO_buf_end;
    char *_IO_save_base;
    char *_IO_backup_base;
    char *_IO_save_end;
    ::_IO_marker *_markers;
    struct _IO_FILE *_chain;
    int _fileno;
    int _flags2;
    ::__off_t _old_offset;
    unsigned short int _cur_column;
    signed char _vtable_offset;
    char _shortbuf[1];
    ::_IO_lock_t *_lock;
    ::__off64_t _offset;
    void *__pad1;
    void *__pad2;
    void *__pad3;
    void *__pad4;
    ::size_t __pad5;
    int _mode;
    char _unused2[20U];
};
struct _IO_FILE_plus;
extern "C"
{
  extern ::_IO_FILE_plus _IO_2_1_stdin_;
}
extern "C"
{
  extern ::_IO_FILE_plus _IO_2_1_stdout_;
}
extern "C"
{
  extern ::_IO_FILE_plus _IO_2_1_stderr_;
}
typedef ::__ssize_t __io_read_fn(void *, char *, ::size_t);
typedef ::__ssize_t __io_write_fn(void *, const char *, ::size_t);
typedef int __io_seek_fn(void *, ::__off64_t *, int);
typedef int __io_close_fn(void *);
typedef ::__io_read_fn cookie_read_function_t;
typedef ::__io_write_fn cookie_write_function_t;
typedef ::__io_seek_fn cookie_seek_function_t;
typedef ::__io_close_fn cookie_close_function_t;
struct  _IO_cookie_io_functions_t
{
    ::__io_read_fn (*read);
    ::__io_write_fn (*write);
    ::__io_seek_fn (*seek);
    ::__io_close_fn (*close);
};
typedef ::_IO_cookie_io_functions_t cookie_io_functions_t;
struct _IO_cookie_file;
extern "C"
{
  extern void _IO_cookie_init(::_IO_cookie_file *__cfile, int __read_write, void *__cookie, ::_IO_cookie_io_functions_t __fns);
}
extern "C"
{
  extern int __underflow(::_IO_FILE *);
}
extern "C"
{
  extern int __uflow(::_IO_FILE *);
}
extern "C"
{
  extern int __overflow(::_IO_FILE *, int);
}
extern "C"
{
  extern int _IO_getc(::_IO_FILE *__fp);
}
extern "C"
{
  extern int _IO_putc(int __c, ::_IO_FILE *__fp);
}
extern "C"
{
  extern int _IO_feof(::_IO_FILE *__fp) throw();
}
extern "C"
{
  extern int _IO_ferror(::_IO_FILE *__fp) throw();
}
extern "C"
{
  extern int _IO_peekc_locked(::_IO_FILE *__fp);
}
extern "C"
{
  extern void _IO_flockfile(::_IO_FILE *) throw();
}
extern "C"
{
  extern void _IO_funlockfile(::_IO_FILE *) throw();
}
extern "C"
{
  extern int _IO_ftrylockfile(::_IO_FILE *) throw();
}
extern "C"
{
  extern int _IO_vfscanf(::_IO_FILE *__restrict , const char *__restrict , ::__gnuc_va_list, int *__restrict );
}
extern "C"
{
  extern int _IO_vfprintf(::_IO_FILE *__restrict , const char *__restrict , ::__gnuc_va_list);
}
extern "C"
{
  extern ::__ssize_t _IO_padn(::_IO_FILE *, int, ::__ssize_t);
}
extern "C"
{
  extern ::size_t _IO_sgetn(::_IO_FILE *, void *, ::size_t);
}
extern "C"
{
  extern ::__off64_t _IO_seekoff(::_IO_FILE *, ::__off64_t, int, int);
}
extern "C"
{
  extern ::__off64_t _IO_seekpos(::_IO_FILE *, ::__off64_t, int);
}
extern "C"
{
  extern void _IO_free_backup_area(::_IO_FILE *) throw();
}
typedef ::__gnuc_va_list va_list;
typedef ::_G_fpos_t fpos_t;
typedef ::_G_fpos64_t fpos64_t;
extern "C"
{
  extern ::_IO_FILE *stdin;
}
extern "C"
{
  extern ::_IO_FILE *stdout;
}
extern "C"
{
  extern ::_IO_FILE *stderr;
}
extern "C"
{
  extern int remove(const char *__filename) throw();
}
extern "C"
{
  extern int rename(const char *__old, const char *__new) throw();
}
extern "C"
{
  extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new) throw();
}
extern "C"
{
  extern ::FILE *tmpfile();
}
extern "C"
{
  extern ::FILE *tmpfile64();
}
extern "C"
{
  extern char *tmpnam(char *__s) throw();
}
extern "C"
{
  extern char *tmpnam_r(char *__s) throw();
}
extern "C"
{
  extern char *tempnam(const char *__dir, const char *__pfx) throw()__attribute__((__malloc__));
}
extern "C"
{
  extern int fclose(::FILE *__stream);
}
extern "C"
{
  extern int fflush(::FILE *__stream);
}
extern "C"
{
  extern int fflush_unlocked(::FILE *__stream);
}
extern "C"
{
  extern int fcloseall();
}
extern "C"
{
  extern ::FILE *fopen(const char *__restrict __filename, const char *__restrict __modes);
}
extern "C"
{
  extern ::FILE *freopen(const char *__restrict __filename, const char *__restrict __modes, ::FILE *__restrict __stream);
}
extern "C"
{
  extern ::FILE *fopen64(const char *__restrict __filename, const char *__restrict __modes);
}
extern "C"
{
  extern ::FILE *freopen64(const char *__restrict __filename, const char *__restrict __modes, ::FILE *__restrict __stream);
}
extern "C"
{
  extern ::FILE *fdopen(int __fd, const char *__modes) throw();
}
extern "C"
{
  extern ::FILE *fopencookie(void *__restrict __magic_cookie, const char *__restrict __modes, ::_IO_cookie_io_functions_t __io_funcs) throw();
}
extern "C"
{
  extern ::FILE *fmemopen(void *__s, ::size_t __len, const char *__modes) throw();
}
extern "C"
{
  extern ::FILE *open_memstream(char **__bufloc, ::size_t *__sizeloc) throw();
}
extern "C"
{
  extern void setbuf(::FILE *__restrict __stream, char *__restrict __buf) throw();
}
extern "C"
{
  extern int setvbuf(::FILE *__restrict __stream, char *__restrict __buf, int __modes, ::size_t __n) throw();
}
extern "C"
{
  extern void setbuffer(::FILE *__restrict __stream, char *__restrict __buf, ::size_t __size) throw();
}
extern "C"
{
  extern void setlinebuf(::FILE *__stream) throw();
}
extern "C"
{
  extern int fprintf(::FILE *__restrict __stream, const char *__restrict __format, ...);
}
extern "C"
{
  extern int printf(const char *__restrict __format, ...);
}
extern "C"
{
  extern int sprintf(char *__restrict __s, const char *__restrict __format, ...) throw();
}
extern "C"
{
  extern int vfprintf(::FILE *__restrict __s, const char *__restrict __format, ::__gnuc_va_list __arg);
}
extern "C"
{
  extern int vprintf(const char *__restrict __format, ::__gnuc_va_list __arg);
}
extern "C"
{
  extern int vsprintf(char *__restrict __s, const char *__restrict __format, ::__gnuc_va_list __arg) throw();
}
extern "C"
{
  extern int snprintf(char *__restrict __s, ::size_t __maxlen, const char *__restrict __format, ...) throw()__attribute__((__format__(__printf__, 3, 4)));
}
extern "C"
{
  extern int vsnprintf(char *__restrict __s, ::size_t __maxlen, const char *__restrict __format, ::__gnuc_va_list __arg) throw()__attribute__((__format__(__printf__, 3, 0)));
}
extern "C"
{
  extern int vasprintf(char **__restrict __ptr, const char *__restrict __f, ::__gnuc_va_list __arg) throw()__attribute__((__format__(__printf__, 2, 0)));
}
extern "C"
{
  extern int __asprintf(char **__restrict __ptr, const char *__restrict __fmt, ...) throw()__attribute__((__format__(__printf__, 2, 3)));
}
extern "C"
{
  extern int asprintf(char **__restrict __ptr, const char *__restrict __fmt, ...) throw()__attribute__((__format__(__printf__, 2, 3)));
}
extern "C"
{
  extern int vdprintf(int __fd, const char *__restrict __fmt, ::__gnuc_va_list __arg)__attribute__((__format__(__printf__, 2, 0)));
}
extern "C"
{
  extern int dprintf(int __fd, const char *__restrict __fmt, ...)__attribute__((__format__(__printf__, 2, 3)));
}
extern "C"
{
  extern int fscanf(::FILE *__restrict __stream, const char *__restrict __format, ...);
}
extern "C"
{
  extern int scanf(const char *__restrict __format, ...);
}
extern "C"
{
  extern int sscanf(const char *__restrict __s, const char *__restrict __format, ...) throw();
}
extern "C"
{
  extern int vfscanf(::FILE *__restrict __s, const char *__restrict __format, ::__gnuc_va_list __arg)__attribute__((__format__(__scanf__, 2, 0)));
}
extern "C"
{
  extern int vscanf(const char *__restrict __format, ::__gnuc_va_list __arg)__attribute__((__format__(__scanf__, 1, 0)));
}
extern "C"
{
  extern int vsscanf(const char *__restrict __s, const char *__restrict __format, ::__gnuc_va_list __arg) throw()__attribute__((__format__(__scanf__, 2, 0)));
}
extern "C"
{
  extern int fgetc(::FILE *__stream);
}
extern "C"
{
  extern int getc(::FILE *__stream);
}
extern "C"
{
  extern int getchar();
}
extern "C"
{
  extern int getc_unlocked(::FILE *__stream);
}
extern "C"
{
  extern int getchar_unlocked();
}
extern "C"
{
  extern int fgetc_unlocked(::FILE *__stream);
}
extern "C"
{
  extern int fputc(int __c, ::FILE *__stream);
}
extern "C"
{
  extern int putc(int __c, ::FILE *__stream);
}
extern "C"
{
  extern int putchar(int __c);
}
extern "C"
{
  extern int fputc_unlocked(int __c, ::FILE *__stream);
}
extern "C"
{
  extern int putc_unlocked(int __c, ::FILE *__stream);
}
extern "C"
{
  extern int putchar_unlocked(int __c);
}
extern "C"
{
  extern int getw(::FILE *__stream);
}
extern "C"
{
  extern int putw(int __w, ::FILE *__stream);
}
extern "C"
{
  extern char *fgets(char *__restrict __s, int __n, ::FILE *__restrict __stream);
}
extern "C"
{
  extern char *gets(char *__s);
}
extern "C"
{
  extern char *fgets_unlocked(char *__restrict __s, int __n, ::FILE *__restrict __stream);
}
extern "C"
{
  extern ::__ssize_t __getdelim(char **__restrict __lineptr, ::size_t *__restrict __n, int __delimiter, ::FILE *__restrict __stream);
}
extern "C"
{
  extern ::__ssize_t getdelim(char **__restrict __lineptr, ::size_t *__restrict __n, int __delimiter, ::FILE *__restrict __stream);
}
extern "C"
{
  extern ::__ssize_t getline(char **__restrict __lineptr, ::size_t *__restrict __n, ::FILE *__restrict __stream);
}
extern "C"
{
  extern int fputs(const char *__restrict __s, ::FILE *__restrict __stream);
}
extern "C"
{
  extern int puts(const char *__s);
}
extern "C"
{
  extern int ungetc(int __c, ::FILE *__stream);
}
extern "C"
{
  extern ::size_t fread(void *__restrict __ptr, ::size_t __size, ::size_t __n, ::FILE *__restrict __stream);
}
extern "C"
{
  extern ::size_t fwrite(const void *__restrict __ptr, ::size_t __size, ::size_t __n, ::FILE *__restrict __s);
}
extern "C"
{
  extern int fputs_unlocked(const char *__restrict __s, ::FILE *__restrict __stream);
}
extern "C"
{
  extern ::size_t fread_unlocked(void *__restrict __ptr, ::size_t __size, ::size_t __n, ::FILE *__restrict __stream);
}
extern "C"
{
  extern ::size_t fwrite_unlocked(const void *__restrict __ptr, ::size_t __size, ::size_t __n, ::FILE *__restrict __stream);
}
extern "C"
{
  extern int fseek(::FILE *__stream, long int __off, int __whence);
}
extern "C"
{
  extern long int ftell(::FILE *__stream);
}
extern "C"
{
  extern void rewind(::FILE *__stream);
}
extern "C"
{
  extern int fseeko(::FILE *__stream, ::__off_t __off, int __whence);
}
extern "C"
{
  extern ::__off_t ftello(::FILE *__stream);
}
extern "C"
{
  extern int fgetpos(::FILE *__restrict __stream, ::fpos_t *__restrict __pos);
}
extern "C"
{
  extern int fsetpos(::FILE *__stream, const ::fpos_t *__pos);
}
extern "C"
{
  extern int fseeko64(::FILE *__stream, ::__off64_t __off, int __whence);
}
extern "C"
{
  extern ::__off64_t ftello64(::FILE *__stream);
}
extern "C"
{
  extern int fgetpos64(::FILE *__restrict __stream, ::fpos64_t *__restrict __pos);
}
extern "C"
{
  extern int fsetpos64(::FILE *__stream, const ::fpos64_t *__pos);
}
extern "C"
{
  extern void clearerr(::FILE *__stream) throw();
}
extern "C"
{
  extern int feof(::FILE *__stream) throw();
}
extern "C"
{
  extern int ferror(::FILE *__stream) throw();
}
extern "C"
{
  extern void clearerr_unlocked(::FILE *__stream) throw();
}
extern "C"
{
  extern int feof_unlocked(::FILE *__stream) throw();
}
extern "C"
{
  extern int ferror_unlocked(::FILE *__stream) throw();
}
extern "C"
{
  extern void perror(const char *__s);
}
extern "C"
{
  extern int sys_nerr;
}
extern "C"
{
  extern const char *const sys_errlist[];
}
extern "C"
{
  extern int _sys_nerr;
}
extern "C"
{
  extern const char *const _sys_errlist[];
}
extern "C"
{
  extern int fileno(::FILE *__stream) throw();
}
extern "C"
{
  extern int fileno_unlocked(::FILE *__stream) throw();
}
extern "C"
{
  extern ::FILE *popen(const char *__command, const char *__modes);
}
extern "C"
{
  extern int pclose(::FILE *__stream);
}
extern "C"
{
  extern char *cuserid(char *__s);
}
struct obstack;
extern "C"
{
  extern int obstack_printf(::obstack *__restrict __obstack, const char *__restrict __format, ...) throw()__attribute__((__format__(__printf__, 2, 3)));
}
extern "C"
{
  extern int obstack_vprintf(::obstack *__restrict __obstack, const char *__restrict __format, ::__gnuc_va_list __args) throw()__attribute__((__format__(__printf__, 2, 0)));
}
extern "C"
{
  extern void flockfile(::FILE *__stream) throw();
}
extern "C"
{
  extern int ftrylockfile(::FILE *__stream) throw();
}
extern "C"
{
  extern void funlockfile(::FILE *__stream) throw();
}
typedef signed char int8_t;
typedef short int int16_t;
typedef int int32_t;
typedef long int int64_t;
typedef unsigned char uint8_t;
typedef unsigned short int uint16_t;
typedef unsigned int uint32_t;
typedef unsigned long int uint64_t;
typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef int int_least32_t;
typedef long int int_least64_t;
typedef unsigned char uint_least8_t;
typedef unsigned short int uint_least16_t;
typedef unsigned int uint_least32_t;
typedef unsigned long int uint_least64_t;
typedef signed char int_fast8_t;
typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
typedef unsigned char uint_fast8_t;
typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
typedef unsigned long int uintptr_t;
typedef long int intmax_t;
typedef unsigned long int uintmax_t;
typedef long int ptrdiff_t;
struct  nanos_region_dimension_internal_t
{
    ::size_t size;
    ::size_t lower_bound;
    ::size_t accessed_length;
};
struct  nanos_access_type_internal_t
{
    bool input:1;
    bool output:1;
    bool can_rename:1;
    bool concurrent:1;
    bool commutative:1;
};
struct  nanos_data_access_internal_t
{
    void *address;
    ::nanos_access_type_internal_t flags;
    short int dimension_count;
    const ::nanos_region_dimension_internal_t *dimensions;
    ::ptrdiff_t offset;
};
enum nanos_sharing_t
{
  NANOS_PRIVATE = 0,
  NANOS_SHARED = 1
};
struct  nanos_reduction_t
{
    void *original;
    void *privates;
    ::size_t element_size;
    ::size_t num_scalars;
    void *descriptor;
    void (*bop)(void *, void *, int);
    void (*vop)(int, void *, void *);
    void (*cleanup)(void *);
};
struct  nanos_copy_data_internal_t
{
    struct mcc_struct_anon_11;
    void *address;
    ::nanos_sharing_t sharing;
    struct  mcc_struct_anon_11
    {
        bool input:1;
        bool output:1;
    };
    ::nanos_copy_data_internal_t::mcc_struct_anon_11 flags;
    short int dimension_count;
    const ::nanos_region_dimension_internal_t *dimensions;
    ::ptrdiff_t offset;
};
typedef ::nanos_access_type_internal_t nanos_access_type_t;
typedef ::nanos_region_dimension_internal_t nanos_region_dimension_t;
typedef ::nanos_data_access_internal_t nanos_data_access_t;
typedef ::nanos_copy_data_internal_t nanos_copy_data_t;
typedef void *nanos_thread_t;
typedef void *nanos_wd_t;
struct  nanos_compound_wd_data_t
{
    int nsect;
    ::nanos_wd_t lwd[];
};
struct  nanos_repeat_n_info_t
{
    int n;
};
struct  nanos_loop_info_t
{
    int lower;
    int upper;
    int step;
    bool last;
    bool wait;
    int chunk;
    int stride;
    int thid;
    int threads;
    void *args;
};
typedef void *nanos_ws_t;
typedef void *nanos_ws_info_t;
typedef void *nanos_ws_data_t;
typedef void *nanos_ws_item_t;
struct  nanos_ws_info_loop_t
{
    int lower_bound;
    int upper_bound;
    int loop_step;
    int chunk_size;
};
struct  nanos_ws_item_loop_t
{
    int lower;
    int upper;
    bool execute:1;
    bool last:1;
};
struct nanos_ws_desc;
struct  nanos_ws_desc
{
    volatile ::nanos_ws_t ws;
    ::nanos_ws_data_t data;
    struct nanos_ws_desc *next;
    ::nanos_thread_t *threads;
    int nths;
};
typedef ::nanos_ws_desc nanos_ws_desc_t;
struct  nanos_wd_props_t
{
    bool mandatory_creation:1;
    bool tied:1;
    bool clear_chunk:1;
    bool reserved0:1;
    bool reserved1:1;
    bool reserved2:1;
    bool reserved3:1;
    bool reserved4:1;
};
struct  nanos_wd_dyn_flags_t
{
    bool is_final:1;
    bool reserved1:1;
    bool reserved2:1;
    bool reserved3:1;
    bool reserved4:1;
    bool reserved5:1;
    bool reserved6:1;
    bool reserved7:1;
};
struct  nanos_wd_dyn_props_t
{
    ::nanos_wd_dyn_flags_t flags;
    ::nanos_thread_t tie_to;
    int priority;
};
struct  nanos_device_t
{
    void *(*factory)(void *);
    void *arg;
};
struct  nanos_smp_args_t
{
    void (*outline)(void *);
};
extern "C"
{
  extern void *nanos_smp_factory_(void *args);
}
extern "C"
{
  extern void *nanos_smp_factory(void *args);
}
enum nanos_event_type_t
{
  NANOS_STATE_START = 0,
  NANOS_STATE_END = 1,
  NANOS_SUBSTATE_START = 2,
  NANOS_SUBSTATE_END = 3,
  NANOS_BURST_START = 4,
  NANOS_BURST_END = 5,
  NANOS_PTP_START = 6,
  NANOS_PTP_END = 7,
  NANOS_POINT = 8,
  EVENT_TYPES = 9
};
typedef unsigned int nanos_event_key_t;
typedef unsigned long long int nanos_event_value_t;
enum nanos_event_state_value_t
{
  NANOS_NOT_CREATED = 0,
  NANOS_NOT_RUNNING = 1,
  NANOS_STARTUP = 2,
  NANOS_SHUTDOWN = 3,
  NANOS_ERROR = 4,
  NANOS_IDLE = 5,
  NANOS_RUNTIME = 6,
  NANOS_RUNNING = 7,
  NANOS_SYNCHRONIZATION = 8,
  NANOS_SCHEDULING = 9,
  NANOS_CREATION = 10,
  NANOS_MEM_TRANSFER_IN = 11,
  NANOS_MEM_TRANSFER_OUT = 12,
  NANOS_MEM_TRANSFER_LOCAL = 13,
  NANOS_MEM_TRANSFER_DEVICE_IN = 14,
  NANOS_MEM_TRANSFER_DEVICE_OUT = 15,
  NANOS_MEM_TRANSFER_DEVICE_LOCAL = 16,
  NANOS_CACHE = 17,
  NANOS_YIELD = 18,
  NANOS_ACQUIRING_LOCK = 19,
  NANOS_CONTEXT_SWITCH = 20,
  NANOS_DEBUG = 21,
  NANOS_EVENT_STATE_TYPES = 22
};
enum nanos_event_domain_t
{
  NANOS_WD_DOMAIN = 0,
  NANOS_WD_DEPENDENCY = 1,
  NANOS_WAIT = 2,
  NANOS_WD_REMOTE = 3,
  NANOS_XFER_PUT = 4,
  NANOS_XFER_GET = 5
};
typedef long long int nanos_event_id_t;
struct  nanos_event_t
{
    ::nanos_event_type_t type;
    ::nanos_event_key_t key;
    ::nanos_event_value_t value;
    ::nanos_event_domain_t domain;
    ::nanos_event_id_t id;
};
enum nanos_lock_state_t
{
  NANOS_LOCK_FREE = 0,
  NANOS_LOCK_BUSY = 1
};
struct  nanos_lock_t
{
    volatile ::nanos_lock_state_t state_;
    inline nanos_lock_t(::nanos_lock_state_t init  = ::NANOS_LOCK_FREE)
      : state_(init)
    {
    }
};
typedef void (*nanos_translate_args_t)(void *, ::nanos_wd_t);
typedef void nanos_init_func_t(void *);
struct  nanos_init_desc_t
{
    ::nanos_init_func_t (*func);
    void *data;
};
enum nanos_err_t
{
  NANOS_OK = 0,
  NANOS_UNKNOWN_ERR = 1,
  NANOS_UNIMPLEMENTED = 2,
  NANOS_ENOMEM = 3,
  NANOS_INVALID_PARAM = 4
};
typedef void *nanos_wg_t;
typedef void *nanos_team_t;
typedef void *nanos_sched_t;
typedef void *nanos_slicer_t;
typedef void *nanos_dd_t;
typedef void *nanos_sync_cond_t;
typedef unsigned int nanos_copy_id_t;
struct  nanos_const_wd_definition_tag
{
    ::nanos_wd_props_t props;
    ::size_t data_alignment;
    ::size_t num_copies;
    ::size_t num_devices;
    ::size_t num_dimensions;
    const char *description;
};
typedef ::nanos_const_wd_definition_tag nanos_const_wd_definition_t;
struct  nanos_constraint_t
{
    int nthreads;
    void *arch;
};
extern "C"
{
  extern char *nanos_get_mode_();
}
extern "C"
{
  extern char *nanos_get_mode();
}
extern "C"
{
  extern ::nanos_wd_t nanos_current_wd_();
}
extern "C"
{
  extern ::nanos_wd_t nanos_current_wd();
}
extern "C"
{
  extern int nanos_get_wd_id_(::nanos_wd_t wd);
}
extern "C"
{
  extern int nanos_get_wd_id(::nanos_wd_t wd);
}
extern "C"
{
  extern int nanos_get_wd_priority_(::nanos_wd_t wd);
}
extern "C"
{
  extern int nanos_get_wd_priority(::nanos_wd_t wd);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_wd_description_(char **description, ::nanos_wd_t wd);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_wd_description(char **description, ::nanos_wd_t wd);
}
extern "C"
{
  extern ::nanos_slicer_t nanos_find_slicer_(const char *slicer);
}
extern "C"
{
  extern ::nanos_slicer_t nanos_find_slicer(const char *slicer);
}
extern "C"
{
  extern ::nanos_ws_t nanos_find_worksharing_(const char *label);
}
extern "C"
{
  extern ::nanos_ws_t nanos_find_worksharing(const char *label);
}
extern "C"
{
  extern ::nanos_err_t nanos_create_wd_compact_(::nanos_wd_t *wd, ::nanos_const_wd_definition_t *const_data, ::nanos_wd_dyn_props_t *dyn_props, ::size_t data_size, void **data, ::nanos_wg_t wg, ::nanos_copy_data_t **copies, ::nanos_region_dimension_internal_t **dimensions);
}
extern "C"
{
  extern ::nanos_err_t nanos_create_wd_compact(::nanos_wd_t *wd, ::nanos_const_wd_definition_t *const_data, ::nanos_wd_dyn_props_t *dyn_props, ::size_t data_size, void **data, ::nanos_wg_t wg, ::nanos_copy_data_t **copies, ::nanos_region_dimension_internal_t **dimensions);
}
extern "C"
{
  extern ::nanos_err_t nanos_set_translate_function_(::nanos_wd_t wd, ::nanos_translate_args_t translate_args);
}
extern "C"
{
  extern ::nanos_err_t nanos_set_translate_function(::nanos_wd_t wd, ::nanos_translate_args_t translate_args);
}
extern "C"
{
  extern ::nanos_err_t nanos_create_sliced_wd_(::nanos_wd_t *uwd, ::size_t num_devices, ::nanos_device_t *devices, ::size_t outline_data_size, int outline_data_align, void **outline_data, ::nanos_wg_t uwg, ::nanos_slicer_t slicer, ::nanos_wd_props_t *props, ::nanos_wd_dyn_props_t *dyn_props, ::size_t num_copies, ::nanos_copy_data_t **copies, ::size_t num_dimensions, ::nanos_region_dimension_internal_t **dimensions);
}
extern "C"
{
  extern ::nanos_err_t nanos_create_sliced_wd(::nanos_wd_t *uwd, ::size_t num_devices, ::nanos_device_t *devices, ::size_t outline_data_size, int outline_data_align, void **outline_data, ::nanos_wg_t uwg, ::nanos_slicer_t slicer, ::nanos_wd_props_t *props, ::nanos_wd_dyn_props_t *dyn_props, ::size_t num_copies, ::nanos_copy_data_t **copies, ::size_t num_dimensions, ::nanos_region_dimension_internal_t **dimensions);
}
extern "C"
{
  extern ::nanos_err_t nanos_submit_(::nanos_wd_t wd, ::size_t num_data_accesses, ::nanos_data_access_t *data_accesses, ::nanos_team_t team);
}
extern "C"
{
  extern ::nanos_err_t nanos_submit(::nanos_wd_t wd, ::size_t num_data_accesses, ::nanos_data_access_t *data_accesses, ::nanos_team_t team);
}
extern "C"
{
  extern ::nanos_err_t nanos_create_wd_and_run_compact_(::nanos_const_wd_definition_t *const_data, ::nanos_wd_dyn_props_t *dyn_props, ::size_t data_size, void *data, ::size_t num_data_accesses, ::nanos_data_access_t *data_accesses, ::nanos_copy_data_t *copies, ::nanos_region_dimension_internal_t *dimensions, ::nanos_translate_args_t translate_args);
}
extern "C"
{
  extern ::nanos_err_t nanos_create_wd_and_run_compact(::nanos_const_wd_definition_t *const_data, ::nanos_wd_dyn_props_t *dyn_props, ::size_t data_size, void *data, ::size_t num_data_accesses, ::nanos_data_access_t *data_accesses, ::nanos_copy_data_t *copies, ::nanos_region_dimension_internal_t *dimensions, ::nanos_translate_args_t translate_args);
}
extern "C"
{
  extern ::nanos_err_t nanos_create_for_();
}
extern "C"
{
  extern ::nanos_err_t nanos_create_for();
}
extern "C"
{
  extern ::nanos_err_t nanos_set_internal_wd_data_(::nanos_wd_t wd, void *data);
}
extern "C"
{
  extern ::nanos_err_t nanos_set_internal_wd_data(::nanos_wd_t wd, void *data);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_internal_wd_data_(::nanos_wd_t wd, void **data);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_internal_wd_data(::nanos_wd_t wd, void **data);
}
extern "C"
{
  extern ::nanos_err_t nanos_yield_();
}
extern "C"
{
  extern ::nanos_err_t nanos_yield();
}
extern "C"
{
  extern ::nanos_err_t nanos_slicer_get_specific_data_(::nanos_slicer_t slicer, void **data);
}
extern "C"
{
  extern ::nanos_err_t nanos_slicer_get_specific_data(::nanos_slicer_t slicer, void **data);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_num_ready_tasks_(unsigned int *ready_tasks);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_num_ready_tasks(unsigned int *ready_tasks);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_num_total_tasks_(unsigned int *total_tasks);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_num_total_tasks(unsigned int *total_tasks);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_num_nonready_tasks_(unsigned int *nonready_tasks);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_num_nonready_tasks(unsigned int *nonready_tasks);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_num_running_tasks_(unsigned int *running_tasks);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_num_running_tasks(unsigned int *running_tasks);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_num_blocked_tasks_(unsigned int *blocked_tasks);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_num_blocked_tasks(unsigned int *blocked_tasks);
}
extern "C"
{
  extern ::nanos_err_t nanos_in_final_(bool *result);
}
extern "C"
{
  extern ::nanos_err_t nanos_in_final(bool *result);
}
extern "C"
{
  extern ::nanos_err_t nanos_set_final_(bool value);
}
extern "C"
{
  extern ::nanos_err_t nanos_set_final(bool value);
}
extern "C"
{
  extern ::nanos_err_t nanos_create_team_(::nanos_team_t *team, ::nanos_sched_t sg, unsigned int *nthreads, ::nanos_constraint_t *constraints, bool reuse, ::nanos_thread_t *info);
}
extern "C"
{
  extern ::nanos_err_t nanos_create_team(::nanos_team_t *team, ::nanos_sched_t sg, unsigned int *nthreads, ::nanos_constraint_t *constraints, bool reuse, ::nanos_thread_t *info);
}
extern "C"
{
  extern ::nanos_err_t nanos_create_team_mapped_(::nanos_team_t *team, ::nanos_sched_t sg, unsigned int *nthreads, unsigned int *mapping);
}
extern "C"
{
  extern ::nanos_err_t nanos_create_team_mapped(::nanos_team_t *team, ::nanos_sched_t sg, unsigned int *nthreads, unsigned int *mapping);
}
extern "C"
{
  extern ::nanos_err_t nanos_enter_team_();
}
extern "C"
{
  extern ::nanos_err_t nanos_enter_team();
}
extern "C"
{
  extern ::nanos_err_t nanos_leave_team_();
}
extern "C"
{
  extern ::nanos_err_t nanos_leave_team();
}
extern "C"
{
  extern ::nanos_err_t nanos_end_team_(::nanos_team_t team);
}
extern "C"
{
  extern ::nanos_err_t nanos_end_team(::nanos_team_t team);
}
extern "C"
{
  extern ::nanos_err_t nanos_team_barrier_();
}
extern "C"
{
  extern ::nanos_err_t nanos_team_barrier();
}
extern "C"
{
  extern ::nanos_err_t nanos_single_guard_(bool *);
}
extern "C"
{
  extern ::nanos_err_t nanos_single_guard(bool *);
}
extern "C"
{
  extern ::nanos_err_t nanos_enter_sync_init_(bool *b);
}
extern "C"
{
  extern ::nanos_err_t nanos_enter_sync_init(bool *b);
}
extern "C"
{
  extern ::nanos_err_t nanos_wait_sync_init_();
}
extern "C"
{
  extern ::nanos_err_t nanos_wait_sync_init();
}
extern "C"
{
  extern ::nanos_err_t nanos_release_sync_init_();
}
extern "C"
{
  extern ::nanos_err_t nanos_release_sync_init();
}
extern "C"
{
  extern ::nanos_err_t nanos_memory_fence_();
}
extern "C"
{
  extern ::nanos_err_t nanos_memory_fence();
}
extern "C"
{
  extern ::nanos_err_t nanos_team_get_num_starring_threads_(int *n);
}
extern "C"
{
  extern ::nanos_err_t nanos_team_get_num_starring_threads(int *n);
}
extern "C"
{
  extern ::nanos_err_t nanos_team_get_starring_threads_(int *n, ::nanos_thread_t *list_of_threads);
}
extern "C"
{
  extern ::nanos_err_t nanos_team_get_starring_threads(int *n, ::nanos_thread_t *list_of_threads);
}
extern "C"
{
  extern ::nanos_err_t nanos_team_get_num_supporting_threads_(int *n);
}
extern "C"
{
  extern ::nanos_err_t nanos_team_get_num_supporting_threads(int *n);
}
extern "C"
{
  extern ::nanos_err_t nanos_team_get_supporting_threads_(int *n, ::nanos_thread_t *list_of_threads);
}
extern "C"
{
  extern ::nanos_err_t nanos_team_get_supporting_threads(int *n, ::nanos_thread_t *list_of_threads);
}
extern "C"
{
  extern ::nanos_err_t nanos_register_reduction_(::nanos_reduction_t *red);
}
extern "C"
{
  extern ::nanos_err_t nanos_register_reduction(::nanos_reduction_t *red);
}
extern "C"
{
  extern ::nanos_err_t nanos_reduction_get_private_data_(void **copy, void *original);
}
extern "C"
{
  extern ::nanos_err_t nanos_reduction_get_private_data(void **copy, void *original);
}
extern "C"
{
  extern ::nanos_err_t nanos_reduction_get_(::nanos_reduction_t **dest, void *original);
}
extern "C"
{
  extern ::nanos_err_t nanos_reduction_get(::nanos_reduction_t **dest, void *original);
}
extern "C"
{
  extern ::nanos_err_t nanos_admit_current_thread_();
}
extern "C"
{
  extern ::nanos_err_t nanos_admit_current_thread();
}
extern "C"
{
  extern ::nanos_err_t nanos_expel_current_thread_();
}
extern "C"
{
  extern ::nanos_err_t nanos_expel_current_thread();
}
extern "C"
{
  extern ::nanos_err_t nanos_dependence_release_all_();
}
extern "C"
{
  extern ::nanos_err_t nanos_dependence_release_all();
}
extern "C"
{
  extern ::nanos_err_t nanos_dependence_pendant_writes_(bool *res, void *addr);
}
extern "C"
{
  extern ::nanos_err_t nanos_dependence_pendant_writes(bool *res, void *addr);
}
extern "C"
{
  extern ::nanos_err_t nanos_worksharing_create_(::nanos_ws_desc_t **wsd, ::nanos_ws_t ws, ::nanos_ws_info_t *info, bool *b);
}
extern "C"
{
  extern ::nanos_err_t nanos_worksharing_create(::nanos_ws_desc_t **wsd, ::nanos_ws_t ws, ::nanos_ws_info_t *info, bool *b);
}
extern "C"
{
  extern ::nanos_err_t nanos_worksharing_next_item_(::nanos_ws_desc_t *wsd, ::nanos_ws_item_t *wsi);
}
extern "C"
{
  extern ::nanos_err_t nanos_worksharing_next_item(::nanos_ws_desc_t *wsd, ::nanos_ws_item_t *wsi);
}
extern "C"
{
  extern ::nanos_err_t nanos_wg_wait_completion_(::nanos_wg_t wg, bool avoid_flush);
}
extern "C"
{
  extern ::nanos_err_t nanos_wg_wait_completion(::nanos_wg_t wg, bool avoid_flush);
}
extern "C"
{
  extern ::nanos_err_t nanos_create_int_sync_cond_(::nanos_sync_cond_t *sync_cond, volatile int *p, int condition);
}
extern "C"
{
  extern ::nanos_err_t nanos_create_int_sync_cond(::nanos_sync_cond_t *sync_cond, volatile int *p, int condition);
}
extern "C"
{
  extern ::nanos_err_t nanos_create_bool_sync_cond_(::nanos_sync_cond_t *sync_cond, volatile bool *p, bool condition);
}
extern "C"
{
  extern ::nanos_err_t nanos_create_bool_sync_cond(::nanos_sync_cond_t *sync_cond, volatile bool *p, bool condition);
}
extern "C"
{
  extern ::nanos_err_t nanos_sync_cond_wait_(::nanos_sync_cond_t sync_cond);
}
extern "C"
{
  extern ::nanos_err_t nanos_sync_cond_wait(::nanos_sync_cond_t sync_cond);
}
extern "C"
{
  extern ::nanos_err_t nanos_sync_cond_signal_(::nanos_sync_cond_t sync_cond);
}
extern "C"
{
  extern ::nanos_err_t nanos_sync_cond_signal(::nanos_sync_cond_t sync_cond);
}
extern "C"
{
  extern ::nanos_err_t nanos_destroy_sync_cond_(::nanos_sync_cond_t sync_cond);
}
extern "C"
{
  extern ::nanos_err_t nanos_destroy_sync_cond(::nanos_sync_cond_t sync_cond);
}
extern "C"
{
  extern ::nanos_err_t nanos_wait_on_(::size_t num_data_accesses, ::nanos_data_access_t *data_accesses);
}
extern "C"
{
  extern ::nanos_err_t nanos_wait_on(::size_t num_data_accesses, ::nanos_data_access_t *data_accesses);
}
extern "C"
{
  extern ::nanos_err_t nanos_init_lock_(::nanos_lock_t **lock);
}
extern "C"
{
  extern ::nanos_err_t nanos_init_lock(::nanos_lock_t **lock);
}
extern "C"
{
  extern ::nanos_err_t nanos_init_lock_at_(::nanos_lock_t *lock);
}
extern "C"
{
  extern ::nanos_err_t nanos_init_lock_at(::nanos_lock_t *lock);
}
extern "C"
{
  extern ::nanos_err_t nanos_set_lock_(::nanos_lock_t *lock);
}
extern "C"
{
  extern ::nanos_err_t nanos_set_lock(::nanos_lock_t *lock);
}
extern "C"
{
  extern ::nanos_err_t nanos_unset_lock_(::nanos_lock_t *lock);
}
extern "C"
{
  extern ::nanos_err_t nanos_unset_lock(::nanos_lock_t *lock);
}
extern "C"
{
  extern ::nanos_err_t nanos_try_lock_(::nanos_lock_t *lock, bool *result);
}
extern "C"
{
  extern ::nanos_err_t nanos_try_lock(::nanos_lock_t *lock, bool *result);
}
extern "C"
{
  extern ::nanos_err_t nanos_destroy_lock_(::nanos_lock_t *lock);
}
extern "C"
{
  extern ::nanos_err_t nanos_destroy_lock(::nanos_lock_t *lock);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_lock_address_(void *addr, ::nanos_lock_t **lock);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_lock_address(void *addr, ::nanos_lock_t **lock);
}
extern "C"
{
  extern ::nanos_err_t nanos_set_copies_(::nanos_wd_t wd, int num_copies, ::nanos_copy_data_t *copies);
}
extern "C"
{
  extern ::nanos_err_t nanos_set_copies(::nanos_wd_t wd, int num_copies, ::nanos_copy_data_t *copies);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_addr_(::nanos_copy_id_t copy_id, void **addr, ::nanos_wd_t cwd);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_addr(::nanos_copy_id_t copy_id, void **addr, ::nanos_wd_t cwd);
}
extern "C"
{
  extern ::nanos_err_t nanos_copy_value_(void *dst, ::nanos_copy_id_t copy_id, ::nanos_wd_t cwd);
}
extern "C"
{
  extern ::nanos_err_t nanos_copy_value(void *dst, ::nanos_copy_id_t copy_id, ::nanos_wd_t cwd);
}
extern "C"
{
  extern const char *nanos_get_default_architecture_();
}
extern "C"
{
  extern const char *nanos_get_default_architecture();
}
extern "C"
{
  extern const char *nanos_get_pm_();
}
extern "C"
{
  extern const char *nanos_get_pm();
}
extern "C"
{
  extern ::nanos_err_t nanos_get_default_binding_(bool *res);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_default_binding(bool *res);
}
extern "C"
{
  extern ::nanos_err_t nanos_delay_start_();
}
extern "C"
{
  extern ::nanos_err_t nanos_delay_start();
}
extern "C"
{
  extern ::nanos_err_t nanos_start_();
}
extern "C"
{
  extern ::nanos_err_t nanos_start();
}
extern "C"
{
  extern ::nanos_err_t nanos_finish_();
}
extern "C"
{
  extern ::nanos_err_t nanos_finish();
}
extern "C"
{
  extern ::nanos_err_t nanos_current_socket_(int socket);
}
extern "C"
{
  extern ::nanos_err_t nanos_current_socket(int socket);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_num_sockets_(int *num_sockets);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_num_sockets(int *num_sockets);
}
extern "C"
{
  extern ::nanos_err_t nanos_malloc_(void **p, ::size_t size, const char *file, int line);
}
extern "C"
{
  extern ::nanos_err_t nanos_malloc(void **p, ::size_t size, const char *file, int line);
}
extern "C"
{
  extern ::nanos_err_t nanos_free_(void *p);
}
extern "C"
{
  extern ::nanos_err_t nanos_free(void *p);
}
extern "C"
{
  extern void nanos_free0_(void *p);
}
extern "C"
{
  extern void nanos_free0(void *p);
}
extern "C"
{
  extern void nanos_handle_error_(::nanos_err_t err);
}
extern "C"
{
  extern void nanos_handle_error(::nanos_err_t err);
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_register_key_(::nanos_event_key_t *event_key, const char *key, const char *description, bool abort_when_registered);
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_register_key(::nanos_event_key_t *event_key, const char *key, const char *description, bool abort_when_registered);
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_register_value_(::nanos_event_value_t *event_value, const char *key, const char *value, const char *description, bool abort_when_registered);
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_register_value(::nanos_event_value_t *event_value, const char *key, const char *value, const char *description, bool abort_when_registered);
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_register_value_with_val_(::nanos_event_value_t val, const char *key, const char *value, const char *description, bool abort_when_registered);
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_register_value_with_val(::nanos_event_value_t val, const char *key, const char *value, const char *description, bool abort_when_registered);
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_get_key_(const char *key, ::nanos_event_key_t *event_key);
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_get_key(const char *key, ::nanos_event_key_t *event_key);
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_get_value_(const char *key, const char *value, ::nanos_event_value_t *event_value);
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_get_value(const char *key, const char *value, ::nanos_event_value_t *event_value);
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_events_(unsigned int num_events, ::nanos_event_t events[]);
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_events(unsigned int num_events, ::nanos_event_t events[]);
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_close_user_fun_event_();
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_close_user_fun_event();
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_enable_();
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_enable();
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_disable_();
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_disable();
}
typedef const char *nanos_string_t;
extern "C"
{
  extern ::nanos_err_t nanos_instrument_begin_burst_(::nanos_string_t key, ::nanos_string_t key_descr, ::nanos_string_t value, ::nanos_string_t value_descr);
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_begin_burst(::nanos_string_t key, ::nanos_string_t key_descr, ::nanos_string_t value, ::nanos_string_t value_descr);
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_end_burst_(::nanos_string_t key, ::nanos_string_t value);
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_end_burst(::nanos_string_t key, ::nanos_string_t value);
}
extern "C"
{
  extern ::nanos_err_t nanos_memcpy_(void *dest, const void *src, ::size_t n);
}
extern "C"
{
  extern ::nanos_err_t nanos_memcpy(void *dest, const void *src, ::size_t n);
}
extern "C"
{
  extern const char *nanos_get_default_scheduler_();
}
extern "C"
{
  extern const char *nanos_get_default_scheduler();
}
extern "C"
{
  extern ::nanos_err_t nanos_start_scheduler_();
}
extern "C"
{
  extern ::nanos_err_t nanos_start_scheduler();
}
extern "C"
{
  extern ::nanos_err_t nanos_stop_scheduler_();
}
extern "C"
{
  extern ::nanos_err_t nanos_stop_scheduler();
}
extern "C"
{
  extern ::nanos_err_t nanos_scheduler_enabled_(bool *res);
}
extern "C"
{
  extern ::nanos_err_t nanos_scheduler_enabled(bool *res);
}
extern "C"
{
  extern ::nanos_err_t nanos_wait_until_threads_paused_();
}
extern "C"
{
  extern ::nanos_err_t nanos_wait_until_threads_paused();
}
extern "C"
{
  extern ::nanos_err_t nanos_wait_until_threads_unpaused_();
}
extern "C"
{
  extern ::nanos_err_t nanos_wait_until_threads_unpaused();
}
extern "C"
{
  extern ::nanos_err_t nanos_scheduler_get_stealing_(bool *res);
}
extern "C"
{
  extern ::nanos_err_t nanos_scheduler_get_stealing(bool *res);
}
extern "C"
{
  extern ::nanos_err_t nanos_scheduler_set_stealing_(bool value);
}
extern "C"
{
  extern ::nanos_err_t nanos_scheduler_set_stealing(bool value);
}
extern "C"
{
  extern void ompss_nanox_main_();
}
extern "C"
{
  extern void ompss_nanox_main();
}
extern "C"
{
  void nanos_reduction_int_vop(int, void *, void *);
}
extern "C"
{
  void nanos_reduction_bop_add_char(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_add_char_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_add_char(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_add_char_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_add_uchar(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_add_uchar_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_add_uchar(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_add_uchar_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_add_schar(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_add_schar_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_add_schar(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_add_schar_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_add_short(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_add_short_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_add_short(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_add_short_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_add_ushort(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_add_ushort_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_add_ushort(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_add_ushort_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_add_int(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_add_int_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_add_int(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_add_int_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_add_uint(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_add_uint_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_add_uint(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_add_uint_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_add_long(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_add_long_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_add_long(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_add_long_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_add_ulong(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_add_ulong_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_add_ulong(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_add_ulong_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_add_longlong(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_add_longlong_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_add_longlong(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_add_longlong_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_add_ulonglong(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_add_ulonglong_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_add_ulonglong(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_add_ulonglong_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_add__Bool(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_add__Bool_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_add__Bool(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_add__Bool_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_add_float(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_add_float_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_add_float(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_add_float_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_add_double(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_add_double_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_add_double(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_add_double_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_add_longdouble(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_add_longdouble_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_add_longdouble(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_add_longdouble_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_add_cfloat(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_add_cfloat_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_add_cfloat(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_add_cfloat_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_add_cdouble(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_add_cdouble_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_add_cdouble(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_add_cdouble_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_add_clongdouble(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_add_clongdouble_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_add_clongdouble(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_add_clongdouble_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_sub_char(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_sub_char_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_sub_char(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_sub_char_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_sub_uchar(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_sub_uchar_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_sub_uchar(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_sub_uchar_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_sub_schar(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_sub_schar_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_sub_schar(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_sub_schar_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_sub_short(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_sub_short_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_sub_short(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_sub_short_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_sub_ushort(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_sub_ushort_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_sub_ushort(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_sub_ushort_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_sub_int(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_sub_int_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_sub_int(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_sub_int_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_sub_uint(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_sub_uint_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_sub_uint(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_sub_uint_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_sub_long(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_sub_long_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_sub_long(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_sub_long_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_sub_ulong(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_sub_ulong_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_sub_ulong(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_sub_ulong_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_sub_longlong(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_sub_longlong_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_sub_longlong(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_sub_longlong_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_sub_ulonglong(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_sub_ulonglong_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_sub_ulonglong(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_sub_ulonglong_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_sub__Bool(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_sub__Bool_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_sub__Bool(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_sub__Bool_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_sub_float(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_sub_float_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_sub_float(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_sub_float_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_sub_double(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_sub_double_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_sub_double(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_sub_double_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_sub_longdouble(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_sub_longdouble_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_sub_longdouble(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_sub_longdouble_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_sub_cfloat(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_sub_cfloat_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_sub_cfloat(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_sub_cfloat_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_sub_cdouble(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_sub_cdouble_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_sub_cdouble(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_sub_cdouble_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_sub_clongdouble(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_sub_clongdouble_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_sub_clongdouble(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_sub_clongdouble_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_prod_char(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_prod_char_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_prod_char(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_prod_char_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_prod_uchar(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_prod_uchar_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_prod_uchar(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_prod_uchar_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_prod_schar(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_prod_schar_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_prod_schar(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_prod_schar_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_prod_short(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_prod_short_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_prod_short(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_prod_short_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_prod_ushort(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_prod_ushort_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_prod_ushort(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_prod_ushort_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_prod_int(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_prod_int_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_prod_int(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_prod_int_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_prod_uint(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_prod_uint_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_prod_uint(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_prod_uint_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_prod_long(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_prod_long_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_prod_long(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_prod_long_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_prod_ulong(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_prod_ulong_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_prod_ulong(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_prod_ulong_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_prod_longlong(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_prod_longlong_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_prod_longlong(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_prod_longlong_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_prod_ulonglong(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_prod_ulonglong_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_prod_ulonglong(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_prod_ulonglong_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_prod__Bool(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_prod__Bool_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_prod__Bool(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_prod__Bool_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_prod_float(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_prod_float_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_prod_float(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_prod_float_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_prod_double(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_prod_double_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_prod_double(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_prod_double_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_prod_longdouble(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_prod_longdouble_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_prod_longdouble(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_prod_longdouble_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_prod_cfloat(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_prod_cfloat_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_prod_cfloat(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_prod_cfloat_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_prod_cdouble(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_prod_cdouble_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_prod_cdouble(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_prod_cdouble_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_prod_clongdouble(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_prod_clongdouble_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_prod_clongdouble(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_prod_clongdouble_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_and_char(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_and_char_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_and_char(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_and_char_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_and_uchar(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_and_uchar_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_and_uchar(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_and_uchar_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_and_schar(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_and_schar_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_and_schar(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_and_schar_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_and_short(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_and_short_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_and_short(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_and_short_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_and_ushort(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_and_ushort_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_and_ushort(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_and_ushort_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_and_int(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_and_int_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_and_int(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_and_int_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_and_uint(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_and_uint_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_and_uint(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_and_uint_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_and_long(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_and_long_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_and_long(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_and_long_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_and_ulong(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_and_ulong_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_and_ulong(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_and_ulong_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_and_longlong(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_and_longlong_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_and_longlong(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_and_longlong_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_and_ulonglong(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_and_ulonglong_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_and_ulonglong(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_and_ulonglong_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_and__Bool(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_and__Bool_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_and__Bool(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_and__Bool_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_or_char(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_or_char_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_or_char(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_or_char_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_or_uchar(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_or_uchar_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_or_uchar(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_or_uchar_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_or_schar(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_or_schar_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_or_schar(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_or_schar_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_or_short(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_or_short_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_or_short(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_or_short_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_or_ushort(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_or_ushort_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_or_ushort(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_or_ushort_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_or_int(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_or_int_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_or_int(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_or_int_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_or_uint(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_or_uint_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_or_uint(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_or_uint_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_or_long(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_or_long_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_or_long(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_or_long_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_or_ulong(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_or_ulong_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_or_ulong(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_or_ulong_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_or_longlong(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_or_longlong_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_or_longlong(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_or_longlong_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_or_ulonglong(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_or_ulonglong_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_or_ulonglong(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_or_ulonglong_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_or__Bool(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_or__Bool_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_or__Bool(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_or__Bool_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_xor_char(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_xor_char_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_xor_char(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_xor_char_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_xor_uchar(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_xor_uchar_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_xor_uchar(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_xor_uchar_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_xor_schar(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_xor_schar_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_xor_schar(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_xor_schar_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_xor_short(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_xor_short_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_xor_short(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_xor_short_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_xor_ushort(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_xor_ushort_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_xor_ushort(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_xor_ushort_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_xor_int(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_xor_int_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_xor_int(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_xor_int_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_xor_uint(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_xor_uint_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_xor_uint(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_xor_uint_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_xor_long(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_xor_long_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_xor_long(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_xor_long_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_xor_ulong(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_xor_ulong_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_xor_ulong(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_xor_ulong_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_xor_longlong(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_xor_longlong_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_xor_longlong(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_xor_longlong_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_xor_ulonglong(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_xor_ulonglong_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_xor_ulonglong(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_xor_ulonglong_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_xor__Bool(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_xor__Bool_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_xor__Bool(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_xor__Bool_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_land_char(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_land_char_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_land_char(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_land_char_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_land_uchar(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_land_uchar_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_land_uchar(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_land_uchar_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_land_schar(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_land_schar_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_land_schar(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_land_schar_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_land_short(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_land_short_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_land_short(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_land_short_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_land_ushort(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_land_ushort_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_land_ushort(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_land_ushort_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_land_int(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_land_int_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_land_int(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_land_int_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_land_uint(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_land_uint_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_land_uint(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_land_uint_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_land_long(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_land_long_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_land_long(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_land_long_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_land_ulong(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_land_ulong_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_land_ulong(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_land_ulong_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_land_longlong(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_land_longlong_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_land_longlong(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_land_longlong_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_land_ulonglong(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_land_ulonglong_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_land_ulonglong(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_land_ulonglong_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_land__Bool(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_land__Bool_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_land__Bool(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_land__Bool_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_land_float(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_land_float_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_land_float(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_land_float_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_land_double(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_land_double_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_land_double(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_land_double_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_land_longdouble(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_land_longdouble_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_land_longdouble(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_land_longdouble_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_land_cfloat(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_land_cfloat_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_land_cfloat(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_land_cfloat_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_land_cdouble(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_land_cdouble_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_land_cdouble(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_land_cdouble_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_land_clongdouble(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_land_clongdouble_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_land_clongdouble(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_land_clongdouble_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_lor_char(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_lor_char_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_lor_char(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_lor_char_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_lor_uchar(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_lor_uchar_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_lor_uchar(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_lor_uchar_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_lor_schar(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_lor_schar_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_lor_schar(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_lor_schar_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_lor_short(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_lor_short_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_lor_short(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_lor_short_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_lor_ushort(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_lor_ushort_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_lor_ushort(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_lor_ushort_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_lor_int(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_lor_int_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_lor_int(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_lor_int_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_lor_uint(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_lor_uint_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_lor_uint(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_lor_uint_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_lor_long(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_lor_long_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_lor_long(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_lor_long_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_lor_ulong(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_lor_ulong_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_lor_ulong(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_lor_ulong_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_lor_longlong(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_lor_longlong_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_lor_longlong(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_lor_longlong_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_lor_ulonglong(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_lor_ulonglong_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_lor_ulonglong(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_lor_ulonglong_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_lor__Bool(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_lor__Bool_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_lor__Bool(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_lor__Bool_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_lor_float(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_lor_float_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_lor_float(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_lor_float_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_lor_double(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_lor_double_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_lor_double(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_lor_double_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_lor_longdouble(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_lor_longdouble_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_lor_longdouble(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_lor_longdouble_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_lor_cfloat(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_lor_cfloat_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_lor_cfloat(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_lor_cfloat_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_lor_cdouble(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_lor_cdouble_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_lor_cdouble(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_lor_cdouble_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_lor_clongdouble(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_lor_clongdouble_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_lor_clongdouble(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_lor_clongdouble_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_max_char(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_max_char_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_max_char(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_max_char_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_max_uchar(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_max_uchar_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_max_uchar(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_max_uchar_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_max_schar(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_max_schar_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_max_schar(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_max_schar_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_max_short(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_max_short_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_max_short(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_max_short_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_max_ushort(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_max_ushort_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_max_ushort(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_max_ushort_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_max_int(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_max_int_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_max_int(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_max_int_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_max_uint(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_max_uint_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_max_uint(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_max_uint_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_max_long(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_max_long_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_max_long(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_max_long_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_max_ulong(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_max_ulong_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_max_ulong(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_max_ulong_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_max_longlong(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_max_longlong_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_max_longlong(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_max_longlong_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_max_ulonglong(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_max_ulonglong_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_max_ulonglong(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_max_ulonglong_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_max__Bool(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_max__Bool_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_max__Bool(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_max__Bool_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_max_float(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_max_float_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_max_float(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_max_float_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_max_double(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_max_double_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_max_double(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_max_double_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_max_longdouble(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_max_longdouble_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_max_longdouble(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_max_longdouble_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_min_char(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_min_char_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_min_char(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_min_char_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_min_uchar(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_min_uchar_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_min_uchar(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_min_uchar_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_min_schar(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_min_schar_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_min_schar(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_min_schar_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_min_short(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_min_short_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_min_short(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_min_short_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_min_ushort(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_min_ushort_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_min_ushort(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_min_ushort_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_min_int(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_min_int_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_min_int(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_min_int_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_min_uint(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_min_uint_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_min_uint(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_min_uint_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_min_long(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_min_long_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_min_long(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_min_long_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_min_ulong(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_min_ulong_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_min_ulong(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_min_ulong_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_min_longlong(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_min_longlong_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_min_longlong(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_min_longlong_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_min_ulonglong(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_min_ulonglong_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_min_ulonglong(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_min_ulonglong_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_min__Bool(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_min__Bool_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_min__Bool(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_min__Bool_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_min_float(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_min_float_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_min_float(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_min_float_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_min_double(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_min_double_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_min_double(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_min_double_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_min_longdouble(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_bop_min_longdouble_(void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_min_longdouble(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_vop_min_longdouble_(int i, void *arg1, void *arg2);
}
extern "C"
{
  void nanos_reduction_default_cleanup_char(void *r);
}
extern "C"
{
  void nanos_reduction_default_cleanup_uchar(void *r);
}
extern "C"
{
  void nanos_reduction_default_cleanup_schar(void *r);
}
extern "C"
{
  void nanos_reduction_default_cleanup_short(void *r);
}
extern "C"
{
  void nanos_reduction_default_cleanup_ushort(void *r);
}
extern "C"
{
  void nanos_reduction_default_cleanup_int(void *r);
}
extern "C"
{
  void nanos_reduction_default_cleanup_uint(void *r);
}
extern "C"
{
  void nanos_reduction_default_cleanup_long(void *r);
}
extern "C"
{
  void nanos_reduction_default_cleanup_ulong(void *r);
}
extern "C"
{
  void nanos_reduction_default_cleanup_longlong(void *r);
}
extern "C"
{
  void nanos_reduction_default_cleanup_ulonglong(void *r);
}
extern "C"
{
  void nanos_reduction_default_cleanup__Bool(void *r);
}
extern "C"
{
  void nanos_reduction_default_cleanup_float(void *r);
}
extern "C"
{
  void nanos_reduction_default_cleanup_double(void *r);
}
extern "C"
{
  void nanos_reduction_default_cleanup_longdouble(void *r);
}
extern "C"
{
  void nanos_reduction_default_cleanup_cfloat(void *r);
}
extern "C"
{
  void nanos_reduction_default_cleanup_cdouble(void *r);
}
extern "C"
{
  void nanos_reduction_default_cleanup_clongdouble(void *r);
}
extern "C"
{
  extern void nanos_reduction_default_cleanup_fortran_(void *);
}
extern "C"
{
  extern void nanos_reduction_default_cleanup_fortran(void *);
}
extern "C"
{
  extern void nanos_atomic_assig_schar_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_assig_schar(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_assig_short_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_assig_short(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_assig_int_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_assig_int(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_assig_long_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_assig_long(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_assig_longlong_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_assig_longlong(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_assig_uchar_(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_assig_uchar(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_assig_ushort_(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_assig_ushort(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_assig_uint_(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_assig_uint(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_assig_ulong_(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_assig_ulong(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_assig_ulonglong_(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_assig_ulonglong(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_assig_bytebool_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_assig_bytebool(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_assig_shortbool_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_assig_shortbool(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_assig_intbool_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_assig_intbool(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_assig_longbool_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_assig_longbool(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_assig_longlongbool_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_assig_longlongbool(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_assig_float_(volatile float *, float);
}
extern "C"
{
  extern void nanos_atomic_assig_float(volatile float *, float);
}
extern "C"
{
  extern void nanos_atomic_assig_double_(volatile double *, double);
}
extern "C"
{
  extern void nanos_atomic_assig_double(volatile double *, double);
}
extern "C"
{
  extern void nanos_atomic_assig_ldouble_(volatile long double *, long double);
}
extern "C"
{
  extern void nanos_atomic_assig_ldouble(volatile long double *, long double);
}
extern "C"
{
  extern void nanos_atomic_assig_cfloat_(volatile _Complex float *, _Complex float);
}
extern "C"
{
  extern void nanos_atomic_assig_cfloat(volatile _Complex float *, _Complex float);
}
extern "C"
{
  extern void nanos_atomic_assig_cdouble_(volatile _Complex double *, _Complex double);
}
extern "C"
{
  extern void nanos_atomic_assig_cdouble(volatile _Complex double *, _Complex double);
}
extern "C"
{
  extern void nanos_atomic_assig_cldouble_(volatile _Complex long double *, _Complex long double);
}
extern "C"
{
  extern void nanos_atomic_assig_cldouble(volatile _Complex long double *, _Complex long double);
}
extern "C"
{
  extern void nanos_atomic_add_schar_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_add_schar(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_add_short_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_add_short(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_add_int_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_add_int(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_add_long_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_add_long(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_add_longlong_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_add_longlong(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_add_uchar_(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_add_uchar(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_add_ushort_(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_add_ushort(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_add_uint_(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_add_uint(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_add_ulong_(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_add_ulong(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_add_ulonglong_(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_add_ulonglong(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_add_bytebool_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_add_bytebool(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_add_shortbool_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_add_shortbool(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_add_intbool_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_add_intbool(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_add_longbool_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_add_longbool(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_add_longlongbool_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_add_longlongbool(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_add_float_(volatile float *, float);
}
extern "C"
{
  extern void nanos_atomic_add_float(volatile float *, float);
}
extern "C"
{
  extern void nanos_atomic_add_double_(volatile double *, double);
}
extern "C"
{
  extern void nanos_atomic_add_double(volatile double *, double);
}
extern "C"
{
  extern void nanos_atomic_add_ldouble_(volatile long double *, long double);
}
extern "C"
{
  extern void nanos_atomic_add_ldouble(volatile long double *, long double);
}
extern "C"
{
  extern void nanos_atomic_add_cfloat_(volatile _Complex float *, _Complex float);
}
extern "C"
{
  extern void nanos_atomic_add_cfloat(volatile _Complex float *, _Complex float);
}
extern "C"
{
  extern void nanos_atomic_add_cdouble_(volatile _Complex double *, _Complex double);
}
extern "C"
{
  extern void nanos_atomic_add_cdouble(volatile _Complex double *, _Complex double);
}
extern "C"
{
  extern void nanos_atomic_add_cldouble_(volatile _Complex long double *, _Complex long double);
}
extern "C"
{
  extern void nanos_atomic_add_cldouble(volatile _Complex long double *, _Complex long double);
}
extern "C"
{
  extern void nanos_atomic_sub_schar_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_sub_schar(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_sub_short_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_sub_short(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_sub_int_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_sub_int(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_sub_long_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_sub_long(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_sub_longlong_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_sub_longlong(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_sub_uchar_(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_sub_uchar(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_sub_ushort_(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_sub_ushort(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_sub_uint_(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_sub_uint(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_sub_ulong_(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_sub_ulong(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_sub_ulonglong_(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_sub_ulonglong(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_sub_bytebool_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_sub_bytebool(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_sub_shortbool_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_sub_shortbool(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_sub_intbool_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_sub_intbool(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_sub_longbool_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_sub_longbool(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_sub_longlongbool_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_sub_longlongbool(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_sub_float_(volatile float *, float);
}
extern "C"
{
  extern void nanos_atomic_sub_float(volatile float *, float);
}
extern "C"
{
  extern void nanos_atomic_sub_double_(volatile double *, double);
}
extern "C"
{
  extern void nanos_atomic_sub_double(volatile double *, double);
}
extern "C"
{
  extern void nanos_atomic_sub_ldouble_(volatile long double *, long double);
}
extern "C"
{
  extern void nanos_atomic_sub_ldouble(volatile long double *, long double);
}
extern "C"
{
  extern void nanos_atomic_sub_cfloat_(volatile _Complex float *, _Complex float);
}
extern "C"
{
  extern void nanos_atomic_sub_cfloat(volatile _Complex float *, _Complex float);
}
extern "C"
{
  extern void nanos_atomic_sub_cdouble_(volatile _Complex double *, _Complex double);
}
extern "C"
{
  extern void nanos_atomic_sub_cdouble(volatile _Complex double *, _Complex double);
}
extern "C"
{
  extern void nanos_atomic_sub_cldouble_(volatile _Complex long double *, _Complex long double);
}
extern "C"
{
  extern void nanos_atomic_sub_cldouble(volatile _Complex long double *, _Complex long double);
}
extern "C"
{
  extern void nanos_atomic_mul_schar_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_mul_schar(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_mul_short_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_mul_short(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_mul_int_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_mul_int(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_mul_long_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_mul_long(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_mul_longlong_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_mul_longlong(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_mul_uchar_(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_mul_uchar(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_mul_ushort_(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_mul_ushort(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_mul_uint_(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_mul_uint(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_mul_ulong_(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_mul_ulong(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_mul_ulonglong_(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_mul_ulonglong(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_mul_bytebool_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_mul_bytebool(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_mul_shortbool_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_mul_shortbool(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_mul_intbool_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_mul_intbool(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_mul_longbool_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_mul_longbool(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_mul_longlongbool_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_mul_longlongbool(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_mul_float_(volatile float *, float);
}
extern "C"
{
  extern void nanos_atomic_mul_float(volatile float *, float);
}
extern "C"
{
  extern void nanos_atomic_mul_double_(volatile double *, double);
}
extern "C"
{
  extern void nanos_atomic_mul_double(volatile double *, double);
}
extern "C"
{
  extern void nanos_atomic_mul_ldouble_(volatile long double *, long double);
}
extern "C"
{
  extern void nanos_atomic_mul_ldouble(volatile long double *, long double);
}
extern "C"
{
  extern void nanos_atomic_mul_cfloat_(volatile _Complex float *, _Complex float);
}
extern "C"
{
  extern void nanos_atomic_mul_cfloat(volatile _Complex float *, _Complex float);
}
extern "C"
{
  extern void nanos_atomic_mul_cdouble_(volatile _Complex double *, _Complex double);
}
extern "C"
{
  extern void nanos_atomic_mul_cdouble(volatile _Complex double *, _Complex double);
}
extern "C"
{
  extern void nanos_atomic_mul_cldouble_(volatile _Complex long double *, _Complex long double);
}
extern "C"
{
  extern void nanos_atomic_mul_cldouble(volatile _Complex long double *, _Complex long double);
}
extern "C"
{
  extern void nanos_atomic_div_schar_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_div_schar(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_div_short_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_div_short(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_div_int_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_div_int(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_div_long_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_div_long(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_div_longlong_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_div_longlong(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_div_uchar_(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_div_uchar(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_div_ushort_(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_div_ushort(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_div_uint_(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_div_uint(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_div_ulong_(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_div_ulong(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_div_ulonglong_(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_div_ulonglong(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_div_bytebool_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_div_bytebool(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_div_shortbool_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_div_shortbool(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_div_intbool_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_div_intbool(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_div_longbool_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_div_longbool(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_div_longlongbool_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_div_longlongbool(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_div_float_(volatile float *, float);
}
extern "C"
{
  extern void nanos_atomic_div_float(volatile float *, float);
}
extern "C"
{
  extern void nanos_atomic_div_double_(volatile double *, double);
}
extern "C"
{
  extern void nanos_atomic_div_double(volatile double *, double);
}
extern "C"
{
  extern void nanos_atomic_div_ldouble_(volatile long double *, long double);
}
extern "C"
{
  extern void nanos_atomic_div_ldouble(volatile long double *, long double);
}
extern "C"
{
  extern void nanos_atomic_div_cfloat_(volatile _Complex float *, _Complex float);
}
extern "C"
{
  extern void nanos_atomic_div_cfloat(volatile _Complex float *, _Complex float);
}
extern "C"
{
  extern void nanos_atomic_div_cdouble_(volatile _Complex double *, _Complex double);
}
extern "C"
{
  extern void nanos_atomic_div_cdouble(volatile _Complex double *, _Complex double);
}
extern "C"
{
  extern void nanos_atomic_div_cldouble_(volatile _Complex long double *, _Complex long double);
}
extern "C"
{
  extern void nanos_atomic_div_cldouble(volatile _Complex long double *, _Complex long double);
}
extern "C"
{
  extern void nanos_atomic_pow_schar_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_pow_schar(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_pow_short_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_pow_short(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_pow_int_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_pow_int(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_pow_long_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_pow_long(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_pow_longlong_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_pow_longlong(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_pow_uchar_(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_pow_uchar(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_pow_ushort_(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_pow_ushort(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_pow_uint_(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_pow_uint(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_pow_ulong_(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_pow_ulong(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_pow_ulonglong_(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_pow_ulonglong(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_pow_bytebool_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_pow_bytebool(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_pow_shortbool_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_pow_shortbool(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_pow_intbool_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_pow_intbool(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_pow_longbool_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_pow_longbool(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_pow_longlongbool_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_pow_longlongbool(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_pow_float_(volatile float *, float);
}
extern "C"
{
  extern void nanos_atomic_pow_float(volatile float *, float);
}
extern "C"
{
  extern void nanos_atomic_pow_double_(volatile double *, double);
}
extern "C"
{
  extern void nanos_atomic_pow_double(volatile double *, double);
}
extern "C"
{
  extern void nanos_atomic_pow_ldouble_(volatile long double *, long double);
}
extern "C"
{
  extern void nanos_atomic_pow_ldouble(volatile long double *, long double);
}
extern "C"
{
  extern void nanos_atomic_pow_cfloat_(volatile _Complex float *, _Complex float);
}
extern "C"
{
  extern void nanos_atomic_pow_cfloat(volatile _Complex float *, _Complex float);
}
extern "C"
{
  extern void nanos_atomic_pow_cdouble_(volatile _Complex double *, _Complex double);
}
extern "C"
{
  extern void nanos_atomic_pow_cdouble(volatile _Complex double *, _Complex double);
}
extern "C"
{
  extern void nanos_atomic_pow_cldouble_(volatile _Complex long double *, _Complex long double);
}
extern "C"
{
  extern void nanos_atomic_pow_cldouble(volatile _Complex long double *, _Complex long double);
}
extern "C"
{
  extern void nanos_atomic_max_schar_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_max_schar(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_max_short_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_max_short(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_max_int_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_max_int(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_max_long_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_max_long(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_max_longlong_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_max_longlong(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_max_uchar_(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_max_uchar(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_max_ushort_(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_max_ushort(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_max_uint_(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_max_uint(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_max_ulong_(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_max_ulong(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_max_ulonglong_(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_max_ulonglong(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_max_bytebool_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_max_bytebool(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_max_shortbool_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_max_shortbool(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_max_intbool_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_max_intbool(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_max_longbool_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_max_longbool(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_max_longlongbool_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_max_longlongbool(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_min_schar_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_min_schar(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_min_short_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_min_short(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_min_int_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_min_int(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_min_long_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_min_long(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_min_longlong_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_min_longlong(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_min_uchar_(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_min_uchar(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_min_ushort_(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_min_ushort(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_min_uint_(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_min_uint(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_min_ulong_(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_min_ulong(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_min_ulonglong_(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_min_ulonglong(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_min_bytebool_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_min_bytebool(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_min_shortbool_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_min_shortbool(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_min_intbool_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_min_intbool(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_min_longbool_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_min_longbool(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_min_longlongbool_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_min_longlongbool(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_max_float_(volatile float *, float);
}
extern "C"
{
  extern void nanos_atomic_max_float(volatile float *, float);
}
extern "C"
{
  extern void nanos_atomic_max_double_(volatile double *, double);
}
extern "C"
{
  extern void nanos_atomic_max_double(volatile double *, double);
}
extern "C"
{
  extern void nanos_atomic_max_ldouble_(volatile long double *, long double);
}
extern "C"
{
  extern void nanos_atomic_max_ldouble(volatile long double *, long double);
}
extern "C"
{
  extern void nanos_atomic_min_float_(volatile float *, float);
}
extern "C"
{
  extern void nanos_atomic_min_float(volatile float *, float);
}
extern "C"
{
  extern void nanos_atomic_min_double_(volatile double *, double);
}
extern "C"
{
  extern void nanos_atomic_min_double(volatile double *, double);
}
extern "C"
{
  extern void nanos_atomic_min_ldouble_(volatile long double *, long double);
}
extern "C"
{
  extern void nanos_atomic_min_ldouble(volatile long double *, long double);
}
extern "C"
{
  extern void nanos_atomic_eq_schar_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_eq_schar(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_eq_short_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_eq_short(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_eq_int_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_eq_int(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_eq_long_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_eq_long(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_eq_longlong_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_eq_longlong(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_eq_uchar_(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_eq_uchar(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_eq_ushort_(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_eq_ushort(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_eq_uint_(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_eq_uint(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_eq_ulong_(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_eq_ulong(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_eq_ulonglong_(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_eq_ulonglong(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_eq_bytebool_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_eq_bytebool(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_eq_shortbool_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_eq_shortbool(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_eq_intbool_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_eq_intbool(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_eq_longbool_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_eq_longbool(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_eq_longlongbool_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_eq_longlongbool(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_eq_float_(volatile float *, float);
}
extern "C"
{
  extern void nanos_atomic_eq_float(volatile float *, float);
}
extern "C"
{
  extern void nanos_atomic_eq_double_(volatile double *, double);
}
extern "C"
{
  extern void nanos_atomic_eq_double(volatile double *, double);
}
extern "C"
{
  extern void nanos_atomic_eq_ldouble_(volatile long double *, long double);
}
extern "C"
{
  extern void nanos_atomic_eq_ldouble(volatile long double *, long double);
}
extern "C"
{
  extern void nanos_atomic_eq_cfloat_(volatile _Complex float *, _Complex float);
}
extern "C"
{
  extern void nanos_atomic_eq_cfloat(volatile _Complex float *, _Complex float);
}
extern "C"
{
  extern void nanos_atomic_eq_cdouble_(volatile _Complex double *, _Complex double);
}
extern "C"
{
  extern void nanos_atomic_eq_cdouble(volatile _Complex double *, _Complex double);
}
extern "C"
{
  extern void nanos_atomic_eq_cldouble_(volatile _Complex long double *, _Complex long double);
}
extern "C"
{
  extern void nanos_atomic_eq_cldouble(volatile _Complex long double *, _Complex long double);
}
extern "C"
{
  extern void nanos_atomic_neq_schar_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_neq_schar(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_neq_short_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_neq_short(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_neq_int_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_neq_int(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_neq_long_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_neq_long(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_neq_longlong_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_neq_longlong(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_neq_uchar_(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_neq_uchar(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_neq_ushort_(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_neq_ushort(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_neq_uint_(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_neq_uint(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_neq_ulong_(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_neq_ulong(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_neq_ulonglong_(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_neq_ulonglong(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_neq_bytebool_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_neq_bytebool(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_neq_shortbool_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_neq_shortbool(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_neq_intbool_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_neq_intbool(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_neq_longbool_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_neq_longbool(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_neq_longlongbool_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_neq_longlongbool(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_neq_float_(volatile float *, float);
}
extern "C"
{
  extern void nanos_atomic_neq_float(volatile float *, float);
}
extern "C"
{
  extern void nanos_atomic_neq_double_(volatile double *, double);
}
extern "C"
{
  extern void nanos_atomic_neq_double(volatile double *, double);
}
extern "C"
{
  extern void nanos_atomic_neq_ldouble_(volatile long double *, long double);
}
extern "C"
{
  extern void nanos_atomic_neq_ldouble(volatile long double *, long double);
}
extern "C"
{
  extern void nanos_atomic_neq_cfloat_(volatile _Complex float *, _Complex float);
}
extern "C"
{
  extern void nanos_atomic_neq_cfloat(volatile _Complex float *, _Complex float);
}
extern "C"
{
  extern void nanos_atomic_neq_cdouble_(volatile _Complex double *, _Complex double);
}
extern "C"
{
  extern void nanos_atomic_neq_cdouble(volatile _Complex double *, _Complex double);
}
extern "C"
{
  extern void nanos_atomic_neq_cldouble_(volatile _Complex long double *, _Complex long double);
}
extern "C"
{
  extern void nanos_atomic_neq_cldouble(volatile _Complex long double *, _Complex long double);
}
extern "C"
{
  extern void nanos_atomic_mod_schar_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_mod_schar(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_mod_short_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_mod_short(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_mod_int_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_mod_int(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_mod_long_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_mod_long(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_mod_longlong_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_mod_longlong(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_mod_uchar_(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_mod_uchar(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_mod_ushort_(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_mod_ushort(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_mod_uint_(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_mod_uint(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_mod_ulong_(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_mod_ulong(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_mod_ulonglong_(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_mod_ulonglong(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_mod_bytebool_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_mod_bytebool(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_mod_shortbool_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_mod_shortbool(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_mod_intbool_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_mod_intbool(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_mod_longbool_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_mod_longbool(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_mod_longlongbool_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_mod_longlongbool(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_shl_schar_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_shl_schar(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_shl_short_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_shl_short(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_shl_int_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_shl_int(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_shl_long_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_shl_long(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_shl_longlong_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_shl_longlong(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_shl_uchar_(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_shl_uchar(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_shl_ushort_(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_shl_ushort(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_shl_uint_(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_shl_uint(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_shl_ulong_(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_shl_ulong(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_shl_ulonglong_(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_shl_ulonglong(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_shl_bytebool_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_shl_bytebool(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_shl_shortbool_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_shl_shortbool(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_shl_intbool_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_shl_intbool(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_shl_longbool_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_shl_longbool(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_shl_longlongbool_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_shl_longlongbool(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_shr_schar_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_shr_schar(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_shr_short_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_shr_short(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_shr_int_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_shr_int(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_shr_long_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_shr_long(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_shr_longlong_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_shr_longlong(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_shr_uchar_(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_shr_uchar(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_shr_ushort_(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_shr_ushort(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_shr_uint_(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_shr_uint(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_shr_ulong_(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_shr_ulong(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_shr_ulonglong_(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_shr_ulonglong(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_shr_bytebool_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_shr_bytebool(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_shr_shortbool_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_shr_shortbool(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_shr_intbool_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_shr_intbool(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_shr_longbool_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_shr_longbool(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_shr_longlongbool_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_shr_longlongbool(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_land_schar_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_land_schar(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_land_short_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_land_short(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_land_int_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_land_int(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_land_long_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_land_long(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_land_longlong_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_land_longlong(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_land_uchar_(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_land_uchar(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_land_ushort_(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_land_ushort(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_land_uint_(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_land_uint(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_land_ulong_(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_land_ulong(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_land_ulonglong_(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_land_ulonglong(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_land_bytebool_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_land_bytebool(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_land_shortbool_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_land_shortbool(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_land_intbool_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_land_intbool(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_land_longbool_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_land_longbool(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_land_longlongbool_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_land_longlongbool(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_lor_schar_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_lor_schar(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_lor_short_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_lor_short(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_lor_int_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_lor_int(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_lor_long_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_lor_long(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_lor_longlong_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_lor_longlong(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_lor_uchar_(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_lor_uchar(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_lor_ushort_(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_lor_ushort(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_lor_uint_(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_lor_uint(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_lor_ulong_(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_lor_ulong(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_lor_ulonglong_(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_lor_ulonglong(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_lor_bytebool_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_lor_bytebool(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_lor_shortbool_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_lor_shortbool(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_lor_intbool_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_lor_intbool(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_lor_longbool_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_lor_longbool(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_lor_longlongbool_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_lor_longlongbool(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_band_schar_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_band_schar(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_band_short_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_band_short(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_band_int_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_band_int(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_band_long_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_band_long(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_band_longlong_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_band_longlong(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_band_uchar_(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_band_uchar(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_band_ushort_(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_band_ushort(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_band_uint_(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_band_uint(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_band_ulong_(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_band_ulong(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_band_ulonglong_(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_band_ulonglong(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_band_bytebool_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_band_bytebool(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_band_shortbool_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_band_shortbool(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_band_intbool_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_band_intbool(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_band_longbool_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_band_longbool(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_band_longlongbool_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_band_longlongbool(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_bor_schar_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_bor_schar(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_bor_short_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_bor_short(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_bor_int_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_bor_int(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_bor_long_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_bor_long(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_bor_longlong_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_bor_longlong(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_bor_uchar_(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_bor_uchar(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_bor_ushort_(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_bor_ushort(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_bor_uint_(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_bor_uint(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_bor_ulong_(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_bor_ulong(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_bor_ulonglong_(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_bor_ulonglong(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_bor_bytebool_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_bor_bytebool(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_bor_shortbool_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_bor_shortbool(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_bor_intbool_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_bor_intbool(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_bor_longbool_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_bor_longbool(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_bor_longlongbool_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_bor_longlongbool(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_bxor_schar_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_bxor_schar(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_bxor_short_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_bxor_short(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_bxor_int_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_bxor_int(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_bxor_long_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_bxor_long(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_bxor_longlong_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_bxor_longlong(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_bxor_uchar_(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_bxor_uchar(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_bxor_ushort_(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_bxor_ushort(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_bxor_uint_(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_bxor_uint(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_bxor_ulong_(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_bxor_ulong(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_bxor_ulonglong_(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_bxor_ulonglong(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_bxor_bytebool_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_bxor_bytebool(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_bxor_shortbool_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_bxor_shortbool(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_bxor_intbool_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_bxor_intbool(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_bxor_longbool_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_bxor_longbool(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_bxor_longlongbool_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_bxor_longlongbool(volatile long long int *, long long int);
}
typedef void *nanos_cpu_set_t;
enum nanos_omp_sched_t
{
  nanos_omp_sched_static = 1,
  nanos_omp_sched_dynamic = 2,
  nanos_omp_sched_guided = 3,
  nanos_omp_sched_auto = 4
};
extern "C"
{
  extern ::nanos_err_t nanos_omp_single_(bool *);
}
extern "C"
{
  extern ::nanos_err_t nanos_omp_single(bool *);
}
extern "C"
{
  extern ::nanos_err_t nanos_omp_barrier_();
}
extern "C"
{
  extern ::nanos_err_t nanos_omp_barrier();
}
extern "C"
{
  void nanos_omp_set_interface(void *);
}
extern "C"
{
  extern ::nanos_err_t nanos_omp_set_implicit_(::nanos_wd_t uwd);
}
extern "C"
{
  extern ::nanos_err_t nanos_omp_set_implicit(::nanos_wd_t uwd);
}
extern "C"
{
  extern int nanos_omp_get_max_threads_();
}
extern "C"
{
  extern int nanos_omp_get_max_threads();
}
extern "C"
{
  extern int nanos_omp_get_num_threads_();
}
extern "C"
{
  extern int nanos_omp_get_num_threads();
}
extern "C"
{
  extern int nanos_omp_get_thread_num_();
}
extern "C"
{
  extern int nanos_omp_get_thread_num();
}
extern "C"
{
  extern int nanos_omp_set_num_threads_(int nthreads);
}
extern "C"
{
  extern int nanos_omp_set_num_threads(int nthreads);
}
extern "C"
{
  extern ::nanos_ws_t nanos_omp_find_worksharing_(::nanos_omp_sched_t kind);
}
extern "C"
{
  extern ::nanos_ws_t nanos_omp_find_worksharing(::nanos_omp_sched_t kind);
}
extern "C"
{
  extern ::nanos_err_t nanos_omp_get_schedule_(::nanos_omp_sched_t *kind, int *modifier);
}
extern "C"
{
  extern ::nanos_err_t nanos_omp_get_schedule(::nanos_omp_sched_t *kind, int *modifier);
}
extern "C"
{
  extern int nanos_omp_get_num_threads_next_parallel_(int threads_requested);
}
extern "C"
{
  extern int nanos_omp_get_num_threads_next_parallel(int threads_requested);
}
extern "C"
{
  extern void nanos_omp_get_mask_(::nanos_cpu_set_t cpu_set);
}
extern "C"
{
  extern void nanos_omp_get_mask(::nanos_cpu_set_t cpu_set);
}
extern "C"
{
  extern void nanos_omp_set_mask_(const ::nanos_cpu_set_t cpu_set);
}
extern "C"
{
  extern void nanos_omp_set_mask(const ::nanos_cpu_set_t cpu_set);
}
extern "C"
{
  extern void nanos_omp_add_mask_(const ::nanos_cpu_set_t cpu_set);
}
extern "C"
{
  extern void nanos_omp_add_mask(const ::nanos_cpu_set_t cpu_set);
}
namespace std __attribute__((__visibility__("default"))) {
  typedef unsigned long int size_t;
  typedef long int ptrdiff_t;
}
#pragma GCC visibility push(default)
namespace std __attribute__((__visibility__("default"))) {
  class  exception
  {
    public:
      inline exception() throw()
      {
      }
      virtual ~exception() throw();
      virtual const char *what() const  throw();
  };
  class  bad_exception : public ::std::exception
  {
    public:
      inline bad_exception() throw()
      {
      }
      virtual ~bad_exception() throw();
      virtual const char *what() const  throw();
  };
  typedef void (*terminate_handler)();
  typedef void (*unexpected_handler)();
  ::std::terminate_handler set_terminate(::std::terminate_handler) throw();
  void terminate() throw()__attribute__((__noreturn__));
  ::std::unexpected_handler set_unexpected(::std::unexpected_handler) throw();
  void unexpected()__attribute__((__noreturn__));
  bool uncaught_exception() throw()__attribute__((__pure__));
}
namespace __gnu_cxx __attribute__((__visibility__("default"))) {
  void __verbose_terminate_handler();
}
#pragma GCC visibility pop
#pragma GCC visibility push(default)
namespace std __attribute__((__visibility__("default"))) {
  class  bad_alloc : public ::std::exception
  {
    public:
      inline bad_alloc() throw()
      {
      }
      virtual ~bad_alloc() throw();
      virtual const char *what() const  throw();
  };
  struct  nothrow_t
  {
  };
  extern const ::std::nothrow_t nothrow;
  typedef void (*new_handler)();
  ::std::new_handler set_new_handler(::std::new_handler) throw();
}
void *operator new(::std::size_t, const ::std::nothrow_t &) throw()__attribute__((__externally_visible__));
void *operator new[](::std::size_t, const ::std::nothrow_t &) throw()__attribute__((__externally_visible__));
void operator delete(void *, const ::std::nothrow_t &) throw()__attribute__((__externally_visible__));
void operator delete[](void *, const ::std::nothrow_t &) throw()__attribute__((__externally_visible__));
inline void *operator new(::std::size_t, void *__p) throw()
{
  return __p;
}
inline void *operator new[](::std::size_t, void *__p) throw()
{
  return __p;
}
inline void operator delete(void *, void *) throw()
{
}
inline void operator delete[](void *, void *) throw()
{
}
#pragma GCC visibility pop
struct  nanos_opencl_args_t
{
    void (*outline)(void *);
};
extern "C"
{
  extern void *nanos_opencl_factory_(void *args);
}
extern "C"
{
  extern void *nanos_opencl_factory(void *args);
}
extern "C"
{
  extern void *nanos_create_current_kernel_(const char *kernel_name, const char *opencl_code, const char *compiler_opts);
}
extern "C"
{
  extern void *nanos_create_current_kernel(const char *kernel_name, const char *opencl_code, const char *compiler_opts);
}
extern "C"
{
  extern ::nanos_err_t nanos_opencl_set_bufferarg_(void *opencl_kernel, int arg_num, void *pointer);
}
extern "C"
{
  extern ::nanos_err_t nanos_opencl_set_bufferarg(void *opencl_kernel, int arg_num, void *pointer);
}
extern "C"
{
  extern ::nanos_err_t nanos_opencl_set_arg_(void *opencl_kernel, int arg_num, ::size_t size, void *pointer);
}
extern "C"
{
  extern ::nanos_err_t nanos_opencl_set_arg(void *opencl_kernel, int arg_num, ::size_t size, void *pointer);
}
extern "C"
{
  extern ::nanos_err_t nanos_exec_kernel_(void *opencl_kernel, int work_dim, ::size_t *ndr_offset, ::size_t *ndr_local_size, ::size_t *ndr_global_size);
}
extern "C"
{
  extern ::nanos_err_t nanos_exec_kernel(void *opencl_kernel, int work_dim, ::size_t *ndr_offset, ::size_t *ndr_local_size, ::size_t *ndr_global_size);
}
extern "C"
{
  extern unsigned int nanos_get_opencl_num_devices_();
}
extern "C"
{
  extern unsigned int nanos_get_opencl_num_devices();
}
extern "C"
{
  extern void *nanos_malloc_opencl_(::size_t size);
}
extern "C"
{
  extern void *nanos_malloc_opencl(::size_t size);
}
extern "C"
{
  extern ::intptr_t nanos_malloc_openclf_(int size);
}
extern "C"
{
  extern ::intptr_t nanos_malloc_openclf(int size);
}
extern "C"
{
  extern void nanos_free_opencl_(void *address);
}
extern "C"
{
  extern void nanos_free_opencl(void *address);
}
extern "C"
{
  extern void nanos_free_openclf_(::intptr_t address);
}
extern "C"
{
  extern void nanos_free_openclf(::intptr_t address);
}
union  wait
{
    struct mcc_struct_anon_26;
    struct mcc_struct_anon_27;
    int w_status;
    struct  mcc_struct_anon_26
    {
        unsigned int __w_termsig:7;
        unsigned int __w_coredump:1;
        unsigned int __w_retcode:8;
    };
    ::wait::mcc_struct_anon_26 __wait_terminated;
    struct  mcc_struct_anon_27
    {
        unsigned int __w_stopval:8;
        unsigned int __w_stopsig:8;
    };
    ::wait::mcc_struct_anon_27 __wait_stopped;
};
struct  div_t
{
    int quot;
    int rem;
};
struct  ldiv_t
{
    long int quot;
    long int rem;
};
__extension__ struct  lldiv_t
{
    __extension__ long long int quot;
    __extension__ long long int rem;
};
extern "C"
{
  extern ::size_t __ctype_get_mb_cur_max() throw();
}
extern "C"
{
  extern double atof(const char *__nptr) throw()__attribute__((__pure__)) __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int atoi(const char *__nptr) throw()__attribute__((__pure__)) __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern long int atol(const char *__nptr) throw()__attribute__((__pure__)) __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern long long int atoll(const char *__nptr) throw()__attribute__((__pure__)) __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern double strtod(const char *__restrict __nptr, char **__restrict __endptr) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern float strtof(const char *__restrict __nptr, char **__restrict __endptr) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern long double strtold(const char *__restrict __nptr, char **__restrict __endptr) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern long int strtol(const char *__restrict __nptr, char **__restrict __endptr, int __base) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern unsigned long int strtoul(const char *__restrict __nptr, char **__restrict __endptr, int __base) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern long long int strtoq(const char *__restrict __nptr, char **__restrict __endptr, int __base) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern unsigned long long int strtouq(const char *__restrict __nptr, char **__restrict __endptr, int __base) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern long long int strtoll(const char *__restrict __nptr, char **__restrict __endptr, int __base) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern unsigned long long int strtoull(const char *__restrict __nptr, char **__restrict __endptr, int __base) throw()__attribute__((__nonnull__(1)));
}
struct locale_data;
struct  __locale_struct
{
    ::locale_data *__locales[13];
    const unsigned short int *__ctype_b;
    const int *__ctype_tolower;
    const int *__ctype_toupper;
    const char *__names[13];
};
typedef ::__locale_struct *__locale_t;
typedef ::__locale_t locale_t;
extern "C"
{
  extern long int strtol_l(const char *__restrict __nptr, char **__restrict __endptr, int __base, ::__locale_t __loc) throw()__attribute__((__nonnull__(1, 4)));
}
extern "C"
{
  extern unsigned long int strtoul_l(const char *__restrict __nptr, char **__restrict __endptr, int __base, ::__locale_t __loc) throw()__attribute__((__nonnull__(1, 4)));
}
extern "C"
{
  extern long long int strtoll_l(const char *__restrict __nptr, char **__restrict __endptr, int __base, ::__locale_t __loc) throw()__attribute__((__nonnull__(1, 4)));
}
extern "C"
{
  extern unsigned long long int strtoull_l(const char *__restrict __nptr, char **__restrict __endptr, int __base, ::__locale_t __loc) throw()__attribute__((__nonnull__(1, 4)));
}
extern "C"
{
  extern double strtod_l(const char *__restrict __nptr, char **__restrict __endptr, ::__locale_t __loc) throw()__attribute__((__nonnull__(1, 3)));
}
extern "C"
{
  extern float strtof_l(const char *__restrict __nptr, char **__restrict __endptr, ::__locale_t __loc) throw()__attribute__((__nonnull__(1, 3)));
}
extern "C"
{
  extern long double strtold_l(const char *__restrict __nptr, char **__restrict __endptr, ::__locale_t __loc) throw()__attribute__((__nonnull__(1, 3)));
}
extern "C"
{
  extern char *l64a(long int __n) throw();
}
extern "C"
{
  extern long int a64l(const char *__s) throw()__attribute__((__pure__)) __attribute__((__nonnull__(1)));
}
typedef ::__u_char u_char;
typedef ::__u_short u_short;
typedef ::__u_int u_int;
typedef ::__u_long u_long;
typedef ::__quad_t quad_t;
typedef ::__u_quad_t u_quad_t;
typedef ::__fsid_t fsid_t;
typedef ::__loff_t loff_t;
typedef ::__ino_t ino_t;
typedef ::__ino64_t ino64_t;
typedef ::__dev_t dev_t;
typedef ::__mode_t mode_t;
typedef ::__nlink_t nlink_t;
typedef ::__id_t id_t;
typedef ::__daddr_t daddr_t;
typedef ::__caddr_t caddr_t;
typedef ::__key_t key_t;
typedef ::__clock_t clock_t;
typedef ::__time_t time_t;
typedef ::__clockid_t clockid_t;
typedef ::__timer_t timer_t;
typedef ::__suseconds_t suseconds_t;
typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
typedef unsigned char u_int8_t;
typedef unsigned short int u_int16_t;
typedef unsigned int u_int32_t;
typedef unsigned long int u_int64_t;
typedef long int register_t;
typedef int __sig_atomic_t;
struct  __sigset_t
{
    unsigned long int __val[16U];
};
typedef ::__sigset_t sigset_t;
struct  timespec
{
    ::__time_t tv_sec;
    long int tv_nsec;
};
struct  timeval
{
    ::__time_t tv_sec;
    ::__suseconds_t tv_usec;
};
typedef long int __fd_mask;
struct  fd_set
{
    ::__fd_mask fds_bits[16];
};
typedef ::__fd_mask fd_mask;
extern "C"
{
  extern int select(int __nfds, ::fd_set *__restrict __readfds, ::fd_set *__restrict __writefds, ::fd_set *__restrict __exceptfds, ::timeval *__restrict __timeout);
}
extern "C"
{
  extern int pselect(int __nfds, ::fd_set *__restrict __readfds, ::fd_set *__restrict __writefds, ::fd_set *__restrict __exceptfds, const ::timespec *__restrict __timeout, const ::__sigset_t *__restrict __sigmask);
}
extern "C"
{
  extern unsigned int gnu_dev_major(unsigned long long int __dev) throw();
}
extern "C"
{
  extern unsigned int gnu_dev_minor(unsigned long long int __dev) throw();
}
extern "C"
{
  extern unsigned long long int gnu_dev_makedev(unsigned int __major, unsigned int __minor) throw();
}
typedef ::__blksize_t blksize_t;
typedef ::__blkcnt_t blkcnt_t;
typedef ::__fsblkcnt_t fsblkcnt_t;
typedef ::__fsfilcnt_t fsfilcnt_t;
typedef ::__blkcnt64_t blkcnt64_t;
typedef ::__fsblkcnt64_t fsblkcnt64_t;
typedef ::__fsfilcnt64_t fsfilcnt64_t;
typedef unsigned long int pthread_t;
union  pthread_attr_t
{
    char __size[56];
    long int __align;
};
struct __pthread_internal_list;
struct  __pthread_internal_list
{
    struct __pthread_internal_list *__prev;
    struct __pthread_internal_list *__next;
};
typedef ::__pthread_internal_list __pthread_list_t;
union  pthread_mutex_t
{
    struct __pthread_mutex_s;
    struct  __pthread_mutex_s
    {
        int __lock;
        unsigned int __count;
        int __owner;
        unsigned int __nusers;
        int __kind;
        int __spins;
        ::__pthread_list_t __list;
    };
    ::pthread_mutex_t::__pthread_mutex_s __data;
    char __size[40];
    long int __align;
};
union  pthread_mutexattr_t
{
    char __size[4];
    int __align;
};
union  pthread_cond_t
{
    struct mcc_struct_anon_37;
    struct  mcc_struct_anon_37
    {
        int __lock;
        unsigned int __futex;
        __extension__ unsigned long long int __total_seq;
        __extension__ unsigned long long int __wakeup_seq;
        __extension__ unsigned long long int __woken_seq;
        void *__mutex;
        unsigned int __nwaiters;
        unsigned int __broadcast_seq;
    };
    ::pthread_cond_t::mcc_struct_anon_37 __data;
    char __size[48];
    __extension__ long long int __align;
};
union  pthread_condattr_t
{
    char __size[4];
    int __align;
};
typedef unsigned int pthread_key_t;
typedef int pthread_once_t;
union  pthread_rwlock_t
{
    struct mcc_struct_anon_40;
    struct  mcc_struct_anon_40
    {
        int __lock;
        unsigned int __nr_readers;
        unsigned int __readers_wakeup;
        unsigned int __writer_wakeup;
        unsigned int __nr_readers_queued;
        unsigned int __nr_writers_queued;
        int __writer;
        int __shared;
        unsigned long int __pad1;
        unsigned long int __pad2;
        unsigned int __flags;
    };
    ::pthread_rwlock_t::mcc_struct_anon_40 __data;
    char __size[56];
    long int __align;
};
union  pthread_rwlockattr_t
{
    char __size[8];
    long int __align;
};
typedef volatile int pthread_spinlock_t;
union  pthread_barrier_t
{
    char __size[32];
    long int __align;
};
union  pthread_barrierattr_t
{
    char __size[4];
    int __align;
};
extern "C"
{
  extern long int random() throw();
}
extern "C"
{
  extern void srandom(unsigned int __seed) throw();
}
extern "C"
{
  extern char *initstate(unsigned int __seed, char *__statebuf, ::size_t __statelen) throw()__attribute__((__nonnull__(2)));
}
extern "C"
{
  extern char *setstate(char *__statebuf) throw()__attribute__((__nonnull__(1)));
}
struct  random_data
{
    ::int32_t *fptr;
    ::int32_t *rptr;
    ::int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    ::int32_t *end_ptr;
};
extern "C"
{
  extern int random_r(::random_data *__restrict __buf, ::int32_t *__restrict __result) throw()__attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int srandom_r(unsigned int __seed, ::random_data *__buf) throw()__attribute__((__nonnull__(2)));
}
extern "C"
{
  extern int initstate_r(unsigned int __seed, char *__restrict __statebuf, ::size_t __statelen, ::random_data *__restrict __buf) throw()__attribute__((__nonnull__(2, 4)));
}
extern "C"
{
  extern int setstate_r(char *__restrict __statebuf, ::random_data *__restrict __buf) throw()__attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int rand() throw();
}
extern "C"
{
  extern void srand(unsigned int __seed) throw();
}
extern "C"
{
  extern int rand_r(unsigned int *__seed) throw();
}
extern "C"
{
  extern double drand48() throw();
}
extern "C"
{
  extern double erand48(unsigned short int __xsubi[3]) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern long int lrand48() throw();
}
extern "C"
{
  extern long int nrand48(unsigned short int __xsubi[3]) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern long int mrand48() throw();
}
extern "C"
{
  extern long int jrand48(unsigned short int __xsubi[3]) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern void srand48(long int __seedval) throw();
}
extern "C"
{
  extern unsigned short int *seed48(unsigned short int __seed16v[3]) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern void lcong48(unsigned short int __param[7]) throw()__attribute__((__nonnull__(1)));
}
struct  drand48_data
{
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    unsigned long long int __a;
};
extern "C"
{
  extern int drand48_r(::drand48_data *__restrict __buffer, double *__restrict __result) throw()__attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int erand48_r(unsigned short int __xsubi[3], ::drand48_data *__restrict __buffer, double *__restrict __result) throw()__attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int lrand48_r(::drand48_data *__restrict __buffer, long int *__restrict __result) throw()__attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int nrand48_r(unsigned short int __xsubi[3], ::drand48_data *__restrict __buffer, long int *__restrict __result) throw()__attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int mrand48_r(::drand48_data *__restrict __buffer, long int *__restrict __result) throw()__attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int jrand48_r(unsigned short int __xsubi[3], ::drand48_data *__restrict __buffer, long int *__restrict __result) throw()__attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int srand48_r(long int __seedval, ::drand48_data *__buffer) throw()__attribute__((__nonnull__(2)));
}
extern "C"
{
  extern int seed48_r(unsigned short int __seed16v[3], ::drand48_data *__buffer) throw()__attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int lcong48_r(unsigned short int __param[7], ::drand48_data *__buffer) throw()__attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern void *malloc(::size_t __size) throw()__attribute__((__malloc__));
}
extern "C"
{
  extern void *calloc(::size_t __nmemb, ::size_t __size) throw()__attribute__((__malloc__));
}
extern "C"
{
  extern void *realloc(void *__ptr, ::size_t __size) throw()__attribute__((__warn_unused_result__));
}
extern "C"
{
  extern void free(void *__ptr) throw();
}
extern "C"
{
  extern void cfree(void *__ptr) throw();
}
extern "C"
{
  extern void *alloca(::size_t __size) throw();
}
extern "C"
{
  extern void *valloc(::size_t __size) throw()__attribute__((__malloc__));
}
extern "C"
{
  extern int posix_memalign(void **__memptr, ::size_t __alignment, ::size_t __size) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern void abort() throw()__attribute__((__noreturn__));
}
extern "C"
{
  extern int atexit(void (*__func)()) throw()__attribute__((__nonnull__(1)));
}
int at_quick_exit(void (*__func)()) throw() __asm("at_quick_exit")__attribute__((__nonnull__(1)));
extern "C"
{
  extern int on_exit(void (*__func)(int, void *), void *__arg) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern void exit(int __status) throw()__attribute__((__noreturn__));
}
extern "C"
{
  extern void quick_exit(int __status) throw()__attribute__((__noreturn__));
}
extern "C"
{
  extern void _Exit(int __status) throw()__attribute__((__noreturn__));
}
extern "C"
{
  extern char *getenv(const char *__name) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern char *__secure_getenv(const char *__name) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int putenv(char *__string) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int setenv(const char *__name, const char *__value, int __replace) throw()__attribute__((__nonnull__(2)));
}
extern "C"
{
  extern int unsetenv(const char *__name) throw();
}
extern "C"
{
  extern int clearenv() throw();
}
extern "C"
{
  extern char *mktemp(char *__template) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int mkstemp(char *__template)__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int mkstemp64(char *__template)__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int mkstemps(char *__template, int __suffixlen)__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int mkstemps64(char *__template, int __suffixlen)__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern char *mkdtemp(char *__template) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int mkostemp(char *__template, int __flags)__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int mkostemp64(char *__template, int __flags)__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int mkostemps(char *__template, int __suffixlen, int __flags)__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int mkostemps64(char *__template, int __suffixlen, int __flags)__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int system(const char *__command);
}
extern "C"
{
  extern char *canonicalize_file_name(const char *__name) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern char *realpath(const char *__restrict __name, char *__restrict __resolved) throw();
}
typedef int (*__compar_fn_t)(const void *, const void *);
typedef ::__compar_fn_t comparison_fn_t;
typedef int (*__compar_d_fn_t)(const void *, const void *, void *);
extern "C"
{
  extern void *bsearch(const void *__key, const void *__base, ::size_t __nmemb, ::size_t __size, ::__compar_fn_t __compar)__attribute__((__nonnull__(1, 2, 5)));
}
extern "C"
{
  extern void qsort(void *__base, ::size_t __nmemb, ::size_t __size, ::__compar_fn_t __compar)__attribute__((__nonnull__(1, 4)));
}
extern "C"
{
  extern void qsort_r(void *__base, ::size_t __nmemb, ::size_t __size, ::__compar_d_fn_t __compar, void *__arg)__attribute__((__nonnull__(1, 4)));
}
extern "C"
{
  extern int abs(int __x) throw()__attribute__((__const__));
}
extern "C"
{
  extern long int labs(long int __x) throw()__attribute__((__const__));
}
extern "C"
{
  extern long long int llabs(long long int __x) throw()__attribute__((__const__));
}
extern "C"
{
  extern ::div_t div(int __numer, int __denom) throw()__attribute__((__const__));
}
extern "C"
{
  extern ::ldiv_t ldiv(long int __numer, long int __denom) throw()__attribute__((__const__));
}
extern "C"
{
  extern ::lldiv_t lldiv(long long int __numer, long long int __denom) throw()__attribute__((__const__));
}
extern "C"
{
  extern char *ecvt(double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign) throw()__attribute__((__nonnull__(3, 4)));
}
extern "C"
{
  extern char *fcvt(double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign) throw()__attribute__((__nonnull__(3, 4)));
}
extern "C"
{
  extern char *gcvt(double __value, int __ndigit, char *__buf) throw()__attribute__((__nonnull__(3)));
}
extern "C"
{
  extern char *qecvt(long double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign) throw()__attribute__((__nonnull__(3, 4)));
}
extern "C"
{
  extern char *qfcvt(long double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign) throw()__attribute__((__nonnull__(3, 4)));
}
extern "C"
{
  extern char *qgcvt(long double __value, int __ndigit, char *__buf) throw()__attribute__((__nonnull__(3)));
}
extern "C"
{
  extern int ecvt_r(double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign, char *__restrict __buf, ::size_t __len) throw()__attribute__((__nonnull__(3, 4, 5)));
}
extern "C"
{
  extern int fcvt_r(double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign, char *__restrict __buf, ::size_t __len) throw()__attribute__((__nonnull__(3, 4, 5)));
}
extern "C"
{
  extern int qecvt_r(long double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign, char *__restrict __buf, ::size_t __len) throw()__attribute__((__nonnull__(3, 4, 5)));
}
extern "C"
{
  extern int qfcvt_r(long double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign, char *__restrict __buf, ::size_t __len) throw()__attribute__((__nonnull__(3, 4, 5)));
}
extern "C"
{
  extern int mblen(const char *__s, ::size_t __n) throw();
}
extern "C"
{
  extern int mbtowc(wchar_t *__restrict __pwc, const char *__restrict __s, ::size_t __n) throw();
}
extern "C"
{
  extern int wctomb(char *__s, wchar_t __wchar) throw();
}
extern "C"
{
  extern ::size_t mbstowcs(wchar_t *__restrict __pwcs, const char *__restrict __s, ::size_t __n) throw();
}
extern "C"
{
  extern ::size_t wcstombs(char *__restrict __s, const wchar_t *__restrict __pwcs, ::size_t __n) throw();
}
extern "C"
{
  extern int rpmatch(const char *__response) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int getsubopt(char **__restrict __optionp, char *const *__restrict __tokens, char **__restrict __valuep) throw()__attribute__((__nonnull__(1, 2, 3)));
}
extern "C"
{
  extern void setkey(const char *__key) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int posix_openpt(int __oflag);
}
extern "C"
{
  extern int grantpt(int __fd) throw();
}
extern "C"
{
  extern int unlockpt(int __fd) throw();
}
extern "C"
{
  extern char *ptsname(int __fd) throw();
}
extern "C"
{
  extern int ptsname_r(int __fd, char *__buf, ::size_t __buflen) throw()__attribute__((__nonnull__(2)));
}
extern "C"
{
  extern int getpt();
}
extern "C"
{
  extern int getloadavg(double __loadavg[], int __nelem) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern void __assert_fail(const char *__assertion, const char *__file, unsigned int __line, const char *__function) throw()__attribute__((__noreturn__));
}
extern "C"
{
  extern void __assert_perror_fail(int __errnum, const char *__file, unsigned int __line, const char *__function) throw()__attribute__((__noreturn__));
}
extern "C"
{
  extern void __assert(const char *__assertion, const char *__file, int __line) throw()__attribute__((__noreturn__));
}
typedef float float_t;
typedef double double_t;
extern "C"
{
  extern double acos(double __x) throw();
}
extern "C"
{
  extern double __acos(double __x) throw();
}
extern "C"
{
  extern double asin(double __x) throw();
}
extern "C"
{
  extern double __asin(double __x) throw();
}
extern "C"
{
  extern double atan(double __x) throw();
}
extern "C"
{
  extern double __atan(double __x) throw();
}
extern "C"
{
  extern double atan2(double __y, double __x) throw();
}
extern "C"
{
  extern double __atan2(double __y, double __x) throw();
}
extern "C"
{
  extern double cos(double __x) throw();
}
extern "C"
{
  extern double __cos(double __x) throw();
}
extern "C"
{
  extern double sin(double __x) throw();
}
extern "C"
{
  extern double __sin(double __x) throw();
}
extern "C"
{
  extern double tan(double __x) throw();
}
extern "C"
{
  extern double __tan(double __x) throw();
}
extern "C"
{
  extern double cosh(double __x) throw();
}
extern "C"
{
  extern double __cosh(double __x) throw();
}
extern "C"
{
  extern double sinh(double __x) throw();
}
extern "C"
{
  extern double __sinh(double __x) throw();
}
extern "C"
{
  extern double tanh(double __x) throw();
}
extern "C"
{
  extern double __tanh(double __x) throw();
}
extern "C"
{
  extern void sincos(double __x, double *__sinx, double *__cosx) throw();
}
extern "C"
{
  extern void __sincos(double __x, double *__sinx, double *__cosx) throw();
}
extern "C"
{
  extern double acosh(double __x) throw();
}
extern "C"
{
  extern double __acosh(double __x) throw();
}
extern "C"
{
  extern double asinh(double __x) throw();
}
extern "C"
{
  extern double __asinh(double __x) throw();
}
extern "C"
{
  extern double atanh(double __x) throw();
}
extern "C"
{
  extern double __atanh(double __x) throw();
}
extern "C"
{
  extern double exp(double __x) throw();
}
extern "C"
{
  extern double __exp(double __x) throw();
}
extern "C"
{
  extern double frexp(double __x, int *__exponent) throw();
}
extern "C"
{
  extern double __frexp(double __x, int *__exponent) throw();
}
extern "C"
{
  extern double ldexp(double __x, int __exponent) throw();
}
extern "C"
{
  extern double __ldexp(double __x, int __exponent) throw();
}
extern "C"
{
  extern double log(double __x) throw();
}
extern "C"
{
  extern double __log(double __x) throw();
}
extern "C"
{
  extern double log10(double __x) throw();
}
extern "C"
{
  extern double __log10(double __x) throw();
}
extern "C"
{
  extern double modf(double __x, double *__iptr) throw();
}
extern "C"
{
  extern double __modf(double __x, double *__iptr) throw();
}
extern "C"
{
  extern double exp10(double __x) throw();
}
extern "C"
{
  extern double __exp10(double __x) throw();
}
extern "C"
{
  extern double pow10(double __x) throw();
}
extern "C"
{
  extern double __pow10(double __x) throw();
}
extern "C"
{
  extern double expm1(double __x) throw();
}
extern "C"
{
  extern double __expm1(double __x) throw();
}
extern "C"
{
  extern double log1p(double __x) throw();
}
extern "C"
{
  extern double __log1p(double __x) throw();
}
extern "C"
{
  extern double logb(double __x) throw();
}
extern "C"
{
  extern double __logb(double __x) throw();
}
extern "C"
{
  extern double exp2(double __x) throw();
}
extern "C"
{
  extern double __exp2(double __x) throw();
}
extern "C"
{
  extern double log2(double __x) throw();
}
extern "C"
{
  extern double __log2(double __x) throw();
}
extern "C"
{
  extern double pow(double __x, double __y) throw();
}
extern "C"
{
  extern double __pow(double __x, double __y) throw();
}
extern "C"
{
  extern double sqrt(double __x) throw();
}
extern "C"
{
  extern double __sqrt(double __x) throw();
}
extern "C"
{
  extern double hypot(double __x, double __y) throw();
}
extern "C"
{
  extern double __hypot(double __x, double __y) throw();
}
extern "C"
{
  extern double cbrt(double __x) throw();
}
extern "C"
{
  extern double __cbrt(double __x) throw();
}
extern "C"
{
  extern double ceil(double __x) throw()__attribute__((__const__));
}
extern "C"
{
  extern double __ceil(double __x) throw()__attribute__((__const__));
}
extern "C"
{
  extern double fabs(double __x) throw()__attribute__((__const__));
}
extern "C"
{
  extern double __fabs(double __x) throw()__attribute__((__const__));
}
extern "C"
{
  extern double floor(double __x) throw()__attribute__((__const__));
}
extern "C"
{
  extern double __floor(double __x) throw()__attribute__((__const__));
}
extern "C"
{
  extern double fmod(double __x, double __y) throw();
}
extern "C"
{
  extern double __fmod(double __x, double __y) throw();
}
extern "C"
{
  extern int __isinf(double __value) throw()__attribute__((__const__));
}
extern "C"
{
  extern int __finite(double __value) throw()__attribute__((__const__));
}
extern "C"
{
  extern int isinf(double __value) throw()__attribute__((__const__));
}
extern "C"
{
  extern int finite(double __value) throw()__attribute__((__const__));
}
extern "C"
{
  extern double drem(double __x, double __y) throw();
}
extern "C"
{
  extern double __drem(double __x, double __y) throw();
}
extern "C"
{
  extern double significand(double __x) throw();
}
extern "C"
{
  extern double __significand(double __x) throw();
}
extern "C"
{
  extern double copysign(double __x, double __y) throw()__attribute__((__const__));
}
extern "C"
{
  extern double __copysign(double __x, double __y) throw()__attribute__((__const__));
}
extern "C"
{
  extern double nan(const char *__tagb) throw()__attribute__((__const__));
}
extern "C"
{
  extern double __nan(const char *__tagb) throw()__attribute__((__const__));
}
extern "C"
{
  extern int __isnan(double __value) throw()__attribute__((__const__));
}
extern "C"
{
  extern int isnan(double __value) throw()__attribute__((__const__));
}
extern "C"
{
  extern double j0(double) throw();
}
extern "C"
{
  extern double __j0(double) throw();
}
extern "C"
{
  extern double j1(double) throw();
}
extern "C"
{
  extern double __j1(double) throw();
}
extern "C"
{
  extern double jn(int, double) throw();
}
extern "C"
{
  extern double __jn(int, double) throw();
}
extern "C"
{
  extern double y0(double) throw();
}
extern "C"
{
  extern double __y0(double) throw();
}
extern "C"
{
  extern double y1(double) throw();
}
extern "C"
{
  extern double __y1(double) throw();
}
extern "C"
{
  extern double yn(int, double) throw();
}
extern "C"
{
  extern double __yn(int, double) throw();
}
extern "C"
{
  extern double erf(double) throw();
}
extern "C"
{
  extern double __erf(double) throw();
}
extern "C"
{
  extern double erfc(double) throw();
}
extern "C"
{
  extern double __erfc(double) throw();
}
extern "C"
{
  extern double lgamma(double) throw();
}
extern "C"
{
  extern double __lgamma(double) throw();
}
extern "C"
{
  extern double tgamma(double) throw();
}
extern "C"
{
  extern double __tgamma(double) throw();
}
extern "C"
{
  extern double gamma(double) throw();
}
extern "C"
{
  extern double __gamma(double) throw();
}
extern "C"
{
  extern double lgamma_r(double, int *__signgamp) throw();
}
extern "C"
{
  extern double __lgamma_r(double, int *__signgamp) throw();
}
extern "C"
{
  extern double rint(double __x) throw();
}
extern "C"
{
  extern double __rint(double __x) throw();
}
extern "C"
{
  extern double nextafter(double __x, double __y) throw()__attribute__((__const__));
}
extern "C"
{
  extern double __nextafter(double __x, double __y) throw()__attribute__((__const__));
}
extern "C"
{
  extern double nexttoward(double __x, long double __y) throw()__attribute__((__const__));
}
extern "C"
{
  extern double __nexttoward(double __x, long double __y) throw()__attribute__((__const__));
}
extern "C"
{
  extern double remainder(double __x, double __y) throw();
}
extern "C"
{
  extern double __remainder(double __x, double __y) throw();
}
extern "C"
{
  extern double scalbn(double __x, int __n) throw();
}
extern "C"
{
  extern double __scalbn(double __x, int __n) throw();
}
extern "C"
{
  extern int ilogb(double __x) throw();
}
extern "C"
{
  extern int __ilogb(double __x) throw();
}
extern "C"
{
  extern double scalbln(double __x, long int __n) throw();
}
extern "C"
{
  extern double __scalbln(double __x, long int __n) throw();
}
extern "C"
{
  extern double nearbyint(double __x) throw();
}
extern "C"
{
  extern double __nearbyint(double __x) throw();
}
extern "C"
{
  extern double round(double __x) throw()__attribute__((__const__));
}
extern "C"
{
  extern double __round(double __x) throw()__attribute__((__const__));
}
extern "C"
{
  extern double trunc(double __x) throw()__attribute__((__const__));
}
extern "C"
{
  extern double __trunc(double __x) throw()__attribute__((__const__));
}
extern "C"
{
  extern double remquo(double __x, double __y, int *__quo) throw();
}
extern "C"
{
  extern double __remquo(double __x, double __y, int *__quo) throw();
}
extern "C"
{
  extern long int lrint(double __x) throw();
}
extern "C"
{
  extern long int __lrint(double __x) throw();
}
extern "C"
{
  extern long long int llrint(double __x) throw();
}
extern "C"
{
  extern long long int __llrint(double __x) throw();
}
extern "C"
{
  extern long int lround(double __x) throw();
}
extern "C"
{
  extern long int __lround(double __x) throw();
}
extern "C"
{
  extern long long int llround(double __x) throw();
}
extern "C"
{
  extern long long int __llround(double __x) throw();
}
extern "C"
{
  extern double fdim(double __x, double __y) throw();
}
extern "C"
{
  extern double __fdim(double __x, double __y) throw();
}
extern "C"
{
  extern double fmax(double __x, double __y) throw();
}
extern "C"
{
  extern double __fmax(double __x, double __y) throw();
}
extern "C"
{
  extern double fmin(double __x, double __y) throw();
}
extern "C"
{
  extern double __fmin(double __x, double __y) throw();
}
extern "C"
{
  extern int __fpclassify(double __value) throw()__attribute__((__const__));
}
extern "C"
{
  extern int __signbit(double __value) throw()__attribute__((__const__));
}
extern "C"
{
  extern double fma(double __x, double __y, double __z) throw();
}
extern "C"
{
  extern double __fma(double __x, double __y, double __z) throw();
}
extern "C"
{
  extern double scalb(double __x, double __n) throw();
}
extern "C"
{
  extern double __scalb(double __x, double __n) throw();
}
extern "C"
{
  extern float acosf(float __x) throw();
}
extern "C"
{
  extern float __acosf(float __x) throw();
}
extern "C"
{
  extern float asinf(float __x) throw();
}
extern "C"
{
  extern float __asinf(float __x) throw();
}
extern "C"
{
  extern float atanf(float __x) throw();
}
extern "C"
{
  extern float __atanf(float __x) throw();
}
extern "C"
{
  extern float atan2f(float __y, float __x) throw();
}
extern "C"
{
  extern float __atan2f(float __y, float __x) throw();
}
extern "C"
{
  extern float cosf(float __x) throw();
}
extern "C"
{
  extern float __cosf(float __x) throw();
}
extern "C"
{
  extern float sinf(float __x) throw();
}
extern "C"
{
  extern float __sinf(float __x) throw();
}
extern "C"
{
  extern float tanf(float __x) throw();
}
extern "C"
{
  extern float __tanf(float __x) throw();
}
extern "C"
{
  extern float coshf(float __x) throw();
}
extern "C"
{
  extern float __coshf(float __x) throw();
}
extern "C"
{
  extern float sinhf(float __x) throw();
}
extern "C"
{
  extern float __sinhf(float __x) throw();
}
extern "C"
{
  extern float tanhf(float __x) throw();
}
extern "C"
{
  extern float __tanhf(float __x) throw();
}
extern "C"
{
  extern void sincosf(float __x, float *__sinx, float *__cosx) throw();
}
extern "C"
{
  extern void __sincosf(float __x, float *__sinx, float *__cosx) throw();
}
extern "C"
{
  extern float acoshf(float __x) throw();
}
extern "C"
{
  extern float __acoshf(float __x) throw();
}
extern "C"
{
  extern float asinhf(float __x) throw();
}
extern "C"
{
  extern float __asinhf(float __x) throw();
}
extern "C"
{
  extern float atanhf(float __x) throw();
}
extern "C"
{
  extern float __atanhf(float __x) throw();
}
extern "C"
{
  extern float expf(float __x) throw();
}
extern "C"
{
  extern float __expf(float __x) throw();
}
extern "C"
{
  extern float frexpf(float __x, int *__exponent) throw();
}
extern "C"
{
  extern float __frexpf(float __x, int *__exponent) throw();
}
extern "C"
{
  extern float ldexpf(float __x, int __exponent) throw();
}
extern "C"
{
  extern float __ldexpf(float __x, int __exponent) throw();
}
extern "C"
{
  extern float logf(float __x) throw();
}
extern "C"
{
  extern float __logf(float __x) throw();
}
extern "C"
{
  extern float log10f(float __x) throw();
}
extern "C"
{
  extern float __log10f(float __x) throw();
}
extern "C"
{
  extern float modff(float __x, float *__iptr) throw();
}
extern "C"
{
  extern float __modff(float __x, float *__iptr) throw();
}
extern "C"
{
  extern float exp10f(float __x) throw();
}
extern "C"
{
  extern float __exp10f(float __x) throw();
}
extern "C"
{
  extern float pow10f(float __x) throw();
}
extern "C"
{
  extern float __pow10f(float __x) throw();
}
extern "C"
{
  extern float expm1f(float __x) throw();
}
extern "C"
{
  extern float __expm1f(float __x) throw();
}
extern "C"
{
  extern float log1pf(float __x) throw();
}
extern "C"
{
  extern float __log1pf(float __x) throw();
}
extern "C"
{
  extern float logbf(float __x) throw();
}
extern "C"
{
  extern float __logbf(float __x) throw();
}
extern "C"
{
  extern float exp2f(float __x) throw();
}
extern "C"
{
  extern float __exp2f(float __x) throw();
}
extern "C"
{
  extern float log2f(float __x) throw();
}
extern "C"
{
  extern float __log2f(float __x) throw();
}
extern "C"
{
  extern float powf(float __x, float __y) throw();
}
extern "C"
{
  extern float __powf(float __x, float __y) throw();
}
extern "C"
{
  extern float sqrtf(float __x) throw();
}
extern "C"
{
  extern float __sqrtf(float __x) throw();
}
extern "C"
{
  extern float hypotf(float __x, float __y) throw();
}
extern "C"
{
  extern float __hypotf(float __x, float __y) throw();
}
extern "C"
{
  extern float cbrtf(float __x) throw();
}
extern "C"
{
  extern float __cbrtf(float __x) throw();
}
extern "C"
{
  extern float ceilf(float __x) throw()__attribute__((__const__));
}
extern "C"
{
  extern float __ceilf(float __x) throw()__attribute__((__const__));
}
extern "C"
{
  extern float fabsf(float __x) throw()__attribute__((__const__));
}
extern "C"
{
  extern float __fabsf(float __x) throw()__attribute__((__const__));
}
extern "C"
{
  extern float floorf(float __x) throw()__attribute__((__const__));
}
extern "C"
{
  extern float __floorf(float __x) throw()__attribute__((__const__));
}
extern "C"
{
  extern float fmodf(float __x, float __y) throw();
}
extern "C"
{
  extern float __fmodf(float __x, float __y) throw();
}
extern "C"
{
  extern int __isinff(float __value) throw()__attribute__((__const__));
}
extern "C"
{
  extern int __finitef(float __value) throw()__attribute__((__const__));
}
extern "C"
{
  extern int isinff(float __value) throw()__attribute__((__const__));
}
extern "C"
{
  extern int finitef(float __value) throw()__attribute__((__const__));
}
extern "C"
{
  extern float dremf(float __x, float __y) throw();
}
extern "C"
{
  extern float __dremf(float __x, float __y) throw();
}
extern "C"
{
  extern float significandf(float __x) throw();
}
extern "C"
{
  extern float __significandf(float __x) throw();
}
extern "C"
{
  extern float copysignf(float __x, float __y) throw()__attribute__((__const__));
}
extern "C"
{
  extern float __copysignf(float __x, float __y) throw()__attribute__((__const__));
}
extern "C"
{
  extern float nanf(const char *__tagb) throw()__attribute__((__const__));
}
extern "C"
{
  extern float __nanf(const char *__tagb) throw()__attribute__((__const__));
}
extern "C"
{
  extern int __isnanf(float __value) throw()__attribute__((__const__));
}
extern "C"
{
  extern int isnanf(float __value) throw()__attribute__((__const__));
}
extern "C"
{
  extern float j0f(float) throw();
}
extern "C"
{
  extern float __j0f(float) throw();
}
extern "C"
{
  extern float j1f(float) throw();
}
extern "C"
{
  extern float __j1f(float) throw();
}
extern "C"
{
  extern float jnf(int, float) throw();
}
extern "C"
{
  extern float __jnf(int, float) throw();
}
extern "C"
{
  extern float y0f(float) throw();
}
extern "C"
{
  extern float __y0f(float) throw();
}
extern "C"
{
  extern float y1f(float) throw();
}
extern "C"
{
  extern float __y1f(float) throw();
}
extern "C"
{
  extern float ynf(int, float) throw();
}
extern "C"
{
  extern float __ynf(int, float) throw();
}
extern "C"
{
  extern float erff(float) throw();
}
extern "C"
{
  extern float __erff(float) throw();
}
extern "C"
{
  extern float erfcf(float) throw();
}
extern "C"
{
  extern float __erfcf(float) throw();
}
extern "C"
{
  extern float lgammaf(float) throw();
}
extern "C"
{
  extern float __lgammaf(float) throw();
}
extern "C"
{
  extern float tgammaf(float) throw();
}
extern "C"
{
  extern float __tgammaf(float) throw();
}
extern "C"
{
  extern float gammaf(float) throw();
}
extern "C"
{
  extern float __gammaf(float) throw();
}
extern "C"
{
  extern float lgammaf_r(float, int *__signgamp) throw();
}
extern "C"
{
  extern float __lgammaf_r(float, int *__signgamp) throw();
}
extern "C"
{
  extern float rintf(float __x) throw();
}
extern "C"
{
  extern float __rintf(float __x) throw();
}
extern "C"
{
  extern float nextafterf(float __x, float __y) throw()__attribute__((__const__));
}
extern "C"
{
  extern float __nextafterf(float __x, float __y) throw()__attribute__((__const__));
}
extern "C"
{
  extern float nexttowardf(float __x, long double __y) throw()__attribute__((__const__));
}
extern "C"
{
  extern float __nexttowardf(float __x, long double __y) throw()__attribute__((__const__));
}
extern "C"
{
  extern float remainderf(float __x, float __y) throw();
}
extern "C"
{
  extern float __remainderf(float __x, float __y) throw();
}
extern "C"
{
  extern float scalbnf(float __x, int __n) throw();
}
extern "C"
{
  extern float __scalbnf(float __x, int __n) throw();
}
extern "C"
{
  extern int ilogbf(float __x) throw();
}
extern "C"
{
  extern int __ilogbf(float __x) throw();
}
extern "C"
{
  extern float scalblnf(float __x, long int __n) throw();
}
extern "C"
{
  extern float __scalblnf(float __x, long int __n) throw();
}
extern "C"
{
  extern float nearbyintf(float __x) throw();
}
extern "C"
{
  extern float __nearbyintf(float __x) throw();
}
extern "C"
{
  extern float roundf(float __x) throw()__attribute__((__const__));
}
extern "C"
{
  extern float __roundf(float __x) throw()__attribute__((__const__));
}
extern "C"
{
  extern float truncf(float __x) throw()__attribute__((__const__));
}
extern "C"
{
  extern float __truncf(float __x) throw()__attribute__((__const__));
}
extern "C"
{
  extern float remquof(float __x, float __y, int *__quo) throw();
}
extern "C"
{
  extern float __remquof(float __x, float __y, int *__quo) throw();
}
extern "C"
{
  extern long int lrintf(float __x) throw();
}
extern "C"
{
  extern long int __lrintf(float __x) throw();
}
extern "C"
{
  extern long long int llrintf(float __x) throw();
}
extern "C"
{
  extern long long int __llrintf(float __x) throw();
}
extern "C"
{
  extern long int lroundf(float __x) throw();
}
extern "C"
{
  extern long int __lroundf(float __x) throw();
}
extern "C"
{
  extern long long int llroundf(float __x) throw();
}
extern "C"
{
  extern long long int __llroundf(float __x) throw();
}
extern "C"
{
  extern float fdimf(float __x, float __y) throw();
}
extern "C"
{
  extern float __fdimf(float __x, float __y) throw();
}
extern "C"
{
  extern float fmaxf(float __x, float __y) throw();
}
extern "C"
{
  extern float __fmaxf(float __x, float __y) throw();
}
extern "C"
{
  extern float fminf(float __x, float __y) throw();
}
extern "C"
{
  extern float __fminf(float __x, float __y) throw();
}
extern "C"
{
  extern int __fpclassifyf(float __value) throw()__attribute__((__const__));
}
extern "C"
{
  extern int __signbitf(float __value) throw()__attribute__((__const__));
}
extern "C"
{
  extern float fmaf(float __x, float __y, float __z) throw();
}
extern "C"
{
  extern float __fmaf(float __x, float __y, float __z) throw();
}
extern "C"
{
  extern float scalbf(float __x, float __n) throw();
}
extern "C"
{
  extern float __scalbf(float __x, float __n) throw();
}
extern "C"
{
  extern long double acosl(long double __x) throw();
}
extern "C"
{
  extern long double __acosl(long double __x) throw();
}
extern "C"
{
  extern long double asinl(long double __x) throw();
}
extern "C"
{
  extern long double __asinl(long double __x) throw();
}
extern "C"
{
  extern long double atanl(long double __x) throw();
}
extern "C"
{
  extern long double __atanl(long double __x) throw();
}
extern "C"
{
  extern long double atan2l(long double __y, long double __x) throw();
}
extern "C"
{
  extern long double __atan2l(long double __y, long double __x) throw();
}
extern "C"
{
  extern long double cosl(long double __x) throw();
}
extern "C"
{
  extern long double __cosl(long double __x) throw();
}
extern "C"
{
  extern long double sinl(long double __x) throw();
}
extern "C"
{
  extern long double __sinl(long double __x) throw();
}
extern "C"
{
  extern long double tanl(long double __x) throw();
}
extern "C"
{
  extern long double __tanl(long double __x) throw();
}
extern "C"
{
  extern long double coshl(long double __x) throw();
}
extern "C"
{
  extern long double __coshl(long double __x) throw();
}
extern "C"
{
  extern long double sinhl(long double __x) throw();
}
extern "C"
{
  extern long double __sinhl(long double __x) throw();
}
extern "C"
{
  extern long double tanhl(long double __x) throw();
}
extern "C"
{
  extern long double __tanhl(long double __x) throw();
}
extern "C"
{
  extern void sincosl(long double __x, long double *__sinx, long double *__cosx) throw();
}
extern "C"
{
  extern void __sincosl(long double __x, long double *__sinx, long double *__cosx) throw();
}
extern "C"
{
  extern long double acoshl(long double __x) throw();
}
extern "C"
{
  extern long double __acoshl(long double __x) throw();
}
extern "C"
{
  extern long double asinhl(long double __x) throw();
}
extern "C"
{
  extern long double __asinhl(long double __x) throw();
}
extern "C"
{
  extern long double atanhl(long double __x) throw();
}
extern "C"
{
  extern long double __atanhl(long double __x) throw();
}
extern "C"
{
  extern long double expl(long double __x) throw();
}
extern "C"
{
  extern long double __expl(long double __x) throw();
}
extern "C"
{
  extern long double frexpl(long double __x, int *__exponent) throw();
}
extern "C"
{
  extern long double __frexpl(long double __x, int *__exponent) throw();
}
extern "C"
{
  extern long double ldexpl(long double __x, int __exponent) throw();
}
extern "C"
{
  extern long double __ldexpl(long double __x, int __exponent) throw();
}
extern "C"
{
  extern long double logl(long double __x) throw();
}
extern "C"
{
  extern long double __logl(long double __x) throw();
}
extern "C"
{
  extern long double log10l(long double __x) throw();
}
extern "C"
{
  extern long double __log10l(long double __x) throw();
}
extern "C"
{
  extern long double modfl(long double __x, long double *__iptr) throw();
}
extern "C"
{
  extern long double __modfl(long double __x, long double *__iptr) throw();
}
extern "C"
{
  extern long double exp10l(long double __x) throw();
}
extern "C"
{
  extern long double __exp10l(long double __x) throw();
}
extern "C"
{
  extern long double pow10l(long double __x) throw();
}
extern "C"
{
  extern long double __pow10l(long double __x) throw();
}
extern "C"
{
  extern long double expm1l(long double __x) throw();
}
extern "C"
{
  extern long double __expm1l(long double __x) throw();
}
extern "C"
{
  extern long double log1pl(long double __x) throw();
}
extern "C"
{
  extern long double __log1pl(long double __x) throw();
}
extern "C"
{
  extern long double logbl(long double __x) throw();
}
extern "C"
{
  extern long double __logbl(long double __x) throw();
}
extern "C"
{
  extern long double exp2l(long double __x) throw();
}
extern "C"
{
  extern long double __exp2l(long double __x) throw();
}
extern "C"
{
  extern long double log2l(long double __x) throw();
}
extern "C"
{
  extern long double __log2l(long double __x) throw();
}
extern "C"
{
  extern long double powl(long double __x, long double __y) throw();
}
extern "C"
{
  extern long double __powl(long double __x, long double __y) throw();
}
extern "C"
{
  extern long double sqrtl(long double __x) throw();
}
extern "C"
{
  extern long double __sqrtl(long double __x) throw();
}
extern "C"
{
  extern long double hypotl(long double __x, long double __y) throw();
}
extern "C"
{
  extern long double __hypotl(long double __x, long double __y) throw();
}
extern "C"
{
  extern long double cbrtl(long double __x) throw();
}
extern "C"
{
  extern long double __cbrtl(long double __x) throw();
}
extern "C"
{
  extern long double ceill(long double __x) throw()__attribute__((__const__));
}
extern "C"
{
  extern long double __ceill(long double __x) throw()__attribute__((__const__));
}
extern "C"
{
  extern long double fabsl(long double __x) throw()__attribute__((__const__));
}
extern "C"
{
  extern long double __fabsl(long double __x) throw()__attribute__((__const__));
}
extern "C"
{
  extern long double floorl(long double __x) throw()__attribute__((__const__));
}
extern "C"
{
  extern long double __floorl(long double __x) throw()__attribute__((__const__));
}
extern "C"
{
  extern long double fmodl(long double __x, long double __y) throw();
}
extern "C"
{
  extern long double __fmodl(long double __x, long double __y) throw();
}
extern "C"
{
  extern int __isinfl(long double __value) throw()__attribute__((__const__));
}
extern "C"
{
  extern int __finitel(long double __value) throw()__attribute__((__const__));
}
extern "C"
{
  extern int isinfl(long double __value) throw()__attribute__((__const__));
}
extern "C"
{
  extern int finitel(long double __value) throw()__attribute__((__const__));
}
extern "C"
{
  extern long double dreml(long double __x, long double __y) throw();
}
extern "C"
{
  extern long double __dreml(long double __x, long double __y) throw();
}
extern "C"
{
  extern long double significandl(long double __x) throw();
}
extern "C"
{
  extern long double __significandl(long double __x) throw();
}
extern "C"
{
  extern long double copysignl(long double __x, long double __y) throw()__attribute__((__const__));
}
extern "C"
{
  extern long double __copysignl(long double __x, long double __y) throw()__attribute__((__const__));
}
extern "C"
{
  extern long double nanl(const char *__tagb) throw()__attribute__((__const__));
}
extern "C"
{
  extern long double __nanl(const char *__tagb) throw()__attribute__((__const__));
}
extern "C"
{
  extern int __isnanl(long double __value) throw()__attribute__((__const__));
}
extern "C"
{
  extern int isnanl(long double __value) throw()__attribute__((__const__));
}
extern "C"
{
  extern long double j0l(long double) throw();
}
extern "C"
{
  extern long double __j0l(long double) throw();
}
extern "C"
{
  extern long double j1l(long double) throw();
}
extern "C"
{
  extern long double __j1l(long double) throw();
}
extern "C"
{
  extern long double jnl(int, long double) throw();
}
extern "C"
{
  extern long double __jnl(int, long double) throw();
}
extern "C"
{
  extern long double y0l(long double) throw();
}
extern "C"
{
  extern long double __y0l(long double) throw();
}
extern "C"
{
  extern long double y1l(long double) throw();
}
extern "C"
{
  extern long double __y1l(long double) throw();
}
extern "C"
{
  extern long double ynl(int, long double) throw();
}
extern "C"
{
  extern long double __ynl(int, long double) throw();
}
extern "C"
{
  extern long double erfl(long double) throw();
}
extern "C"
{
  extern long double __erfl(long double) throw();
}
extern "C"
{
  extern long double erfcl(long double) throw();
}
extern "C"
{
  extern long double __erfcl(long double) throw();
}
extern "C"
{
  extern long double lgammal(long double) throw();
}
extern "C"
{
  extern long double __lgammal(long double) throw();
}
extern "C"
{
  extern long double tgammal(long double) throw();
}
extern "C"
{
  extern long double __tgammal(long double) throw();
}
extern "C"
{
  extern long double gammal(long double) throw();
}
extern "C"
{
  extern long double __gammal(long double) throw();
}
extern "C"
{
  extern long double lgammal_r(long double, int *__signgamp) throw();
}
extern "C"
{
  extern long double __lgammal_r(long double, int *__signgamp) throw();
}
extern "C"
{
  extern long double rintl(long double __x) throw();
}
extern "C"
{
  extern long double __rintl(long double __x) throw();
}
extern "C"
{
  extern long double nextafterl(long double __x, long double __y) throw()__attribute__((__const__));
}
extern "C"
{
  extern long double __nextafterl(long double __x, long double __y) throw()__attribute__((__const__));
}
extern "C"
{
  extern long double nexttowardl(long double __x, long double __y) throw()__attribute__((__const__));
}
extern "C"
{
  extern long double __nexttowardl(long double __x, long double __y) throw()__attribute__((__const__));
}
extern "C"
{
  extern long double remainderl(long double __x, long double __y) throw();
}
extern "C"
{
  extern long double __remainderl(long double __x, long double __y) throw();
}
extern "C"
{
  extern long double scalbnl(long double __x, int __n) throw();
}
extern "C"
{
  extern long double __scalbnl(long double __x, int __n) throw();
}
extern "C"
{
  extern int ilogbl(long double __x) throw();
}
extern "C"
{
  extern int __ilogbl(long double __x) throw();
}
extern "C"
{
  extern long double scalblnl(long double __x, long int __n) throw();
}
extern "C"
{
  extern long double __scalblnl(long double __x, long int __n) throw();
}
extern "C"
{
  extern long double nearbyintl(long double __x) throw();
}
extern "C"
{
  extern long double __nearbyintl(long double __x) throw();
}
extern "C"
{
  extern long double roundl(long double __x) throw()__attribute__((__const__));
}
extern "C"
{
  extern long double __roundl(long double __x) throw()__attribute__((__const__));
}
extern "C"
{
  extern long double truncl(long double __x) throw()__attribute__((__const__));
}
extern "C"
{
  extern long double __truncl(long double __x) throw()__attribute__((__const__));
}
extern "C"
{
  extern long double remquol(long double __x, long double __y, int *__quo) throw();
}
extern "C"
{
  extern long double __remquol(long double __x, long double __y, int *__quo) throw();
}
extern "C"
{
  extern long int lrintl(long double __x) throw();
}
extern "C"
{
  extern long int __lrintl(long double __x) throw();
}
extern "C"
{
  extern long long int llrintl(long double __x) throw();
}
extern "C"
{
  extern long long int __llrintl(long double __x) throw();
}
extern "C"
{
  extern long int lroundl(long double __x) throw();
}
extern "C"
{
  extern long int __lroundl(long double __x) throw();
}
extern "C"
{
  extern long long int llroundl(long double __x) throw();
}
extern "C"
{
  extern long long int __llroundl(long double __x) throw();
}
extern "C"
{
  extern long double fdiml(long double __x, long double __y) throw();
}
extern "C"
{
  extern long double __fdiml(long double __x, long double __y) throw();
}
extern "C"
{
  extern long double fmaxl(long double __x, long double __y) throw();
}
extern "C"
{
  extern long double __fmaxl(long double __x, long double __y) throw();
}
extern "C"
{
  extern long double fminl(long double __x, long double __y) throw();
}
extern "C"
{
  extern long double __fminl(long double __x, long double __y) throw();
}
extern "C"
{
  extern int __fpclassifyl(long double __value) throw()__attribute__((__const__));
}
extern "C"
{
  extern int __signbitl(long double __value) throw()__attribute__((__const__));
}
extern "C"
{
  extern long double fmal(long double __x, long double __y, long double __z) throw();
}
extern "C"
{
  extern long double __fmal(long double __x, long double __y, long double __z) throw();
}
extern "C"
{
  extern long double scalbl(long double __x, long double __n) throw();
}
extern "C"
{
  extern long double __scalbl(long double __x, long double __n) throw();
}
extern "C"
{
  extern int signgam;
}
enum mcc_enum_anon_9
{
  FP_NAN = 0,
  FP_INFINITE = 1,
  FP_ZERO = 2,
  FP_SUBNORMAL = 3,
  FP_NORMAL = 4
};
enum _LIB_VERSION_TYPE
{
  _IEEE_ =  -1,
  _SVID_ = 0,
  _XOPEN_ = 1,
  _POSIX_ = 2,
  _ISOC_ = 3
};
extern "C"
{
  extern ::_LIB_VERSION_TYPE _LIB_VERSION;
}
struct  __exception
{
    int type;
    char *name;
    double arg1;
    double arg2;
    double retval;
};
extern "C"
{
  extern int matherr(::__exception *__exc) throw();
}
namespace RTTL {
  static const char *defaultBVHBuilder("default");
}
extern "C"
{
  extern void *memalign(::size_t __alignment, ::size_t __size) throw()__attribute__((__malloc__));
}
extern "C"
{
  extern void *pvalloc(::size_t __size) throw()__attribute__((__malloc__));
}
extern "C"
{
  extern void *(*__morecore)(::ptrdiff_t);
}
extern "C"
{
  extern void *__default_morecore(::ptrdiff_t __size) throw()__attribute__((__malloc__));
}
struct  mallinfo
{
    int arena;
    int ordblks;
    int smblks;
    int hblks;
    int hblkhd;
    int usmblks;
    int fsmblks;
    int uordblks;
    int fordblks;
    int keepcost;
};
extern "C"
{
  extern struct ::mallinfo mallinfo() throw();
}
extern "C"
{
  extern int mallopt(int __param, int __val) throw();
}
extern "C"
{
  extern int malloc_trim(::size_t __pad) throw();
}
extern "C"
{
  extern ::size_t malloc_usable_size(void *__ptr) throw();
}
extern "C"
{
  extern void malloc_stats() throw();
}
extern "C"
{
  extern int malloc_info(int __options, ::FILE *__fp);
}
extern "C"
{
  extern void *malloc_get_state() throw();
}
extern "C"
{
  extern int malloc_set_state(void *__ptr) throw();
}
extern "C"
{
  extern void (*__malloc_initialize_hook)();
}
extern "C"
{
  extern void (*__free_hook)(void *, const void *);
}
extern "C"
{
  extern void *(*__malloc_hook)(::size_t, const void *);
}
extern "C"
{
  extern void *(*__realloc_hook)(void *, ::size_t, const void *);
}
extern "C"
{
  extern void *(*__memalign_hook)(::size_t, ::size_t, const void *);
}
extern "C"
{
  extern void (*__after_morecore_hook)();
}
extern "C"
{
  extern void __malloc_check_init() throw();
}
namespace std __attribute__((__visibility__("default"))) {
  template < typename _Alloc >
  class allocator;
  template < typename _CharT >
  struct char_traits;
  template < typename _CharT, typename _Traits = ::std::char_traits<_CharT>, typename _Alloc = ::std::allocator<_CharT> >
  class basic_string;
  template < typename _CharT >
  struct char_traits;
  template <>
  struct char_traits<char>;
  typedef ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> > string;
  template < typename _CharT >
  struct char_traits;
  template <>
  struct char_traits<wchar_t>;
  typedef ::std::basic_string<wchar_t, ::std::char_traits<wchar_t>, ::std::allocator<wchar_t> > wstring;
}
typedef unsigned int wint_t;
typedef ::__mbstate_t mbstate_t;
struct tm;
extern "C"
{
  extern wchar_t *wcscpy(wchar_t *__restrict __dest, const wchar_t *__restrict __src) throw();
}
extern "C"
{
  extern wchar_t *wcsncpy(wchar_t *__restrict __dest, const wchar_t *__restrict __src, ::size_t __n) throw();
}
extern "C"
{
  extern wchar_t *wcscat(wchar_t *__restrict __dest, const wchar_t *__restrict __src) throw();
}
extern "C"
{
  extern wchar_t *wcsncat(wchar_t *__restrict __dest, const wchar_t *__restrict __src, ::size_t __n) throw();
}
extern "C"
{
  extern int wcscmp(const wchar_t *__s1, const wchar_t *__s2) throw()__attribute__((__pure__));
}
extern "C"
{
  extern int wcsncmp(const wchar_t *__s1, const wchar_t *__s2, ::size_t __n) throw()__attribute__((__pure__));
}
extern "C"
{
  extern int wcscasecmp(const wchar_t *__s1, const wchar_t *__s2) throw();
}
extern "C"
{
  extern int wcsncasecmp(const wchar_t *__s1, const wchar_t *__s2, ::size_t __n) throw();
}
extern "C"
{
  extern int wcscasecmp_l(const wchar_t *__s1, const wchar_t *__s2, ::__locale_t __loc) throw();
}
extern "C"
{
  extern int wcsncasecmp_l(const wchar_t *__s1, const wchar_t *__s2, ::size_t __n, ::__locale_t __loc) throw();
}
extern "C"
{
  extern int wcscoll(const wchar_t *__s1, const wchar_t *__s2) throw();
}
extern "C"
{
  extern ::size_t wcsxfrm(wchar_t *__restrict __s1, const wchar_t *__restrict __s2, ::size_t __n) throw();
}
extern "C"
{
  extern int wcscoll_l(const wchar_t *__s1, const wchar_t *__s2, ::__locale_t __loc) throw();
}
extern "C"
{
  extern ::size_t wcsxfrm_l(wchar_t *__s1, const wchar_t *__s2, ::size_t __n, ::__locale_t __loc) throw();
}
extern "C"
{
  extern wchar_t *wcsdup(const wchar_t *__s) throw()__attribute__((__malloc__));
}
wchar_t *wcschr(wchar_t *__wcs, wchar_t __wc) throw() __asm("wcschr")__attribute__((__pure__));
const wchar_t *wcschr(const wchar_t *__wcs, wchar_t __wc) throw() __asm("wcschr")__attribute__((__pure__));
wchar_t *wcsrchr(wchar_t *__wcs, wchar_t __wc) throw() __asm("wcsrchr")__attribute__((__pure__));
const wchar_t *wcsrchr(const wchar_t *__wcs, wchar_t __wc) throw() __asm("wcsrchr")__attribute__((__pure__));
extern "C"
{
  extern wchar_t *wcschrnul(const wchar_t *__s, wchar_t __wc) throw()__attribute__((__pure__));
}
extern "C"
{
  extern ::size_t wcscspn(const wchar_t *__wcs, const wchar_t *__reject) throw()__attribute__((__pure__));
}
extern "C"
{
  extern ::size_t wcsspn(const wchar_t *__wcs, const wchar_t *__accept) throw()__attribute__((__pure__));
}
wchar_t *wcspbrk(wchar_t *__wcs, const wchar_t *__accept) throw() __asm("wcspbrk")__attribute__((__pure__));
const wchar_t *wcspbrk(const wchar_t *__wcs, const wchar_t *__accept) throw() __asm("wcspbrk")__attribute__((__pure__));
wchar_t *wcsstr(wchar_t *__haystack, const wchar_t *__needle) throw() __asm("wcsstr")__attribute__((__pure__));
const wchar_t *wcsstr(const wchar_t *__haystack, const wchar_t *__needle) throw() __asm("wcsstr")__attribute__((__pure__));
extern "C"
{
  extern wchar_t *wcstok(wchar_t *__restrict __s, const wchar_t *__restrict __delim, wchar_t **__restrict __ptr) throw();
}
extern "C"
{
  extern ::size_t wcslen(const wchar_t *__s) throw()__attribute__((__pure__));
}
wchar_t *wcswcs(wchar_t *__haystack, const wchar_t *__needle) throw() __asm("wcswcs")__attribute__((__pure__));
const wchar_t *wcswcs(const wchar_t *__haystack, const wchar_t *__needle) throw() __asm("wcswcs")__attribute__((__pure__));
extern "C"
{
  extern ::size_t wcsnlen(const wchar_t *__s, ::size_t __maxlen) throw()__attribute__((__pure__));
}
wchar_t *wmemchr(wchar_t *__s, wchar_t __c, ::size_t __n) throw() __asm("wmemchr")__attribute__((__pure__));
const wchar_t *wmemchr(const wchar_t *__s, wchar_t __c, ::size_t __n) throw() __asm("wmemchr")__attribute__((__pure__));
extern "C"
{
  extern int wmemcmp(const wchar_t *__s1, const wchar_t *__s2, ::size_t __n) throw()__attribute__((__pure__));
}
extern "C"
{
  extern wchar_t *wmemcpy(wchar_t *__restrict __s1, const wchar_t *__restrict __s2, ::size_t __n) throw();
}
extern "C"
{
  extern wchar_t *wmemmove(wchar_t *__s1, const wchar_t *__s2, ::size_t __n) throw();
}
extern "C"
{
  extern wchar_t *wmemset(wchar_t *__s, wchar_t __c, ::size_t __n) throw();
}
extern "C"
{
  extern wchar_t *wmempcpy(wchar_t *__restrict __s1, const wchar_t *__restrict __s2, ::size_t __n) throw();
}
extern "C"
{
  extern ::wint_t btowc(int __c) throw();
}
extern "C"
{
  extern int wctob(::wint_t __c) throw();
}
extern "C"
{
  extern int mbsinit(const ::mbstate_t *__ps) throw()__attribute__((__pure__));
}
extern "C"
{
  extern ::size_t mbrtowc(wchar_t *__restrict __pwc, const char *__restrict __s, ::size_t __n, ::mbstate_t *__p) throw();
}
extern "C"
{
  extern ::size_t wcrtomb(char *__restrict __s, wchar_t __wc, ::mbstate_t *__restrict __ps) throw();
}
extern "C"
{
  extern ::size_t __mbrlen(const char *__restrict __s, ::size_t __n, ::mbstate_t *__restrict __ps) throw();
}
extern "C"
{
  extern ::size_t mbrlen(const char *__restrict __s, ::size_t __n, ::mbstate_t *__restrict __ps) throw();
}
extern "C"
{
  extern ::size_t mbsrtowcs(wchar_t *__restrict __dst, const char **__restrict __src, ::size_t __len, ::mbstate_t *__restrict __ps) throw();
}
extern "C"
{
  extern ::size_t wcsrtombs(char *__restrict __dst, const wchar_t **__restrict __src, ::size_t __len, ::mbstate_t *__restrict __ps) throw();
}
extern "C"
{
  extern ::size_t mbsnrtowcs(wchar_t *__restrict __dst, const char **__restrict __src, ::size_t __nmc, ::size_t __len, ::mbstate_t *__restrict __ps) throw();
}
extern "C"
{
  extern ::size_t wcsnrtombs(char *__restrict __dst, const wchar_t **__restrict __src, ::size_t __nwc, ::size_t __len, ::mbstate_t *__restrict __ps) throw();
}
extern "C"
{
  extern int wcwidth(wchar_t __c) throw();
}
extern "C"
{
  extern int wcswidth(const wchar_t *__s, ::size_t __n) throw();
}
extern "C"
{
  extern double wcstod(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) throw();
}
extern "C"
{
  extern float wcstof(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) throw();
}
extern "C"
{
  extern long double wcstold(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) throw();
}
extern "C"
{
  extern long int wcstol(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) throw();
}
extern "C"
{
  extern unsigned long int wcstoul(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) throw();
}
extern "C"
{
  extern long long int wcstoll(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) throw();
}
extern "C"
{
  extern unsigned long long int wcstoull(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) throw();
}
extern "C"
{
  extern long long int wcstoq(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) throw();
}
extern "C"
{
  extern unsigned long long int wcstouq(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) throw();
}
extern "C"
{
  extern long int wcstol_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base, ::__locale_t __loc) throw();
}
extern "C"
{
  extern unsigned long int wcstoul_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base, ::__locale_t __loc) throw();
}
extern "C"
{
  extern long long int wcstoll_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base, ::__locale_t __loc) throw();
}
extern "C"
{
  extern unsigned long long int wcstoull_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base, ::__locale_t __loc) throw();
}
extern "C"
{
  extern double wcstod_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, ::__locale_t __loc) throw();
}
extern "C"
{
  extern float wcstof_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, ::__locale_t __loc) throw();
}
extern "C"
{
  extern long double wcstold_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, ::__locale_t __loc) throw();
}
extern "C"
{
  extern wchar_t *wcpcpy(wchar_t *__restrict __dest, const wchar_t *__restrict __src) throw();
}
extern "C"
{
  extern wchar_t *wcpncpy(wchar_t *__restrict __dest, const wchar_t *__restrict __src, ::size_t __n) throw();
}
extern "C"
{
  extern ::__FILE *open_wmemstream(wchar_t **__bufloc, ::size_t *__sizeloc) throw();
}
extern "C"
{
  extern int fwide(::__FILE *__fp, int __mode) throw();
}
extern "C"
{
  extern int fwprintf(::__FILE *__restrict __stream, const wchar_t *__restrict __format, ...);
}
extern "C"
{
  extern int wprintf(const wchar_t *__restrict __format, ...);
}
extern "C"
{
  extern int swprintf(wchar_t *__restrict __s, ::size_t __n, const wchar_t *__restrict __format, ...) throw();
}
extern "C"
{
  extern int vfwprintf(::__FILE *__restrict __s, const wchar_t *__restrict __format, ::__gnuc_va_list __arg);
}
extern "C"
{
  extern int vwprintf(const wchar_t *__restrict __format, ::__gnuc_va_list __arg);
}
extern "C"
{
  extern int vswprintf(wchar_t *__restrict __s, ::size_t __n, const wchar_t *__restrict __format, ::__gnuc_va_list __arg) throw();
}
extern "C"
{
  extern int fwscanf(::__FILE *__restrict __stream, const wchar_t *__restrict __format, ...);
}
extern "C"
{
  extern int wscanf(const wchar_t *__restrict __format, ...);
}
extern "C"
{
  extern int swscanf(const wchar_t *__restrict __s, const wchar_t *__restrict __format, ...) throw();
}
extern "C"
{
  extern int vfwscanf(::__FILE *__restrict __s, const wchar_t *__restrict __format, ::__gnuc_va_list __arg);
}
extern "C"
{
  extern int vwscanf(const wchar_t *__restrict __format, ::__gnuc_va_list __arg);
}
extern "C"
{
  extern int vswscanf(const wchar_t *__restrict __s, const wchar_t *__restrict __format, ::__gnuc_va_list __arg) throw();
}
extern "C"
{
  extern ::wint_t fgetwc(::__FILE *__stream);
}
extern "C"
{
  extern ::wint_t getwc(::__FILE *__stream);
}
extern "C"
{
  extern ::wint_t getwchar();
}
extern "C"
{
  extern ::wint_t fputwc(wchar_t __wc, ::__FILE *__stream);
}
extern "C"
{
  extern ::wint_t putwc(wchar_t __wc, ::__FILE *__stream);
}
extern "C"
{
  extern ::wint_t putwchar(wchar_t __wc);
}
extern "C"
{
  extern wchar_t *fgetws(wchar_t *__restrict __ws, int __n, ::__FILE *__restrict __stream);
}
extern "C"
{
  extern int fputws(const wchar_t *__restrict __ws, ::__FILE *__restrict __stream);
}
extern "C"
{
  extern ::wint_t ungetwc(::wint_t __wc, ::__FILE *__stream);
}
extern "C"
{
  extern ::wint_t getwc_unlocked(::__FILE *__stream);
}
extern "C"
{
  extern ::wint_t getwchar_unlocked();
}
extern "C"
{
  extern ::wint_t fgetwc_unlocked(::__FILE *__stream);
}
extern "C"
{
  extern ::wint_t fputwc_unlocked(wchar_t __wc, ::__FILE *__stream);
}
extern "C"
{
  extern ::wint_t putwc_unlocked(wchar_t __wc, ::__FILE *__stream);
}
extern "C"
{
  extern ::wint_t putwchar_unlocked(wchar_t __wc);
}
extern "C"
{
  extern wchar_t *fgetws_unlocked(wchar_t *__restrict __ws, int __n, ::__FILE *__restrict __stream);
}
extern "C"
{
  extern int fputws_unlocked(const wchar_t *__restrict __ws, ::__FILE *__restrict __stream);
}
extern "C"
{
  extern ::size_t wcsftime(wchar_t *__restrict __s, ::size_t __maxsize, const wchar_t *__restrict __format, const ::tm *__restrict __tp) throw();
}
extern "C"
{
  extern ::size_t wcsftime_l(wchar_t *__restrict __s, ::size_t __maxsize, const wchar_t *__restrict __format, const ::tm *__restrict __tp, ::__locale_t __loc) throw();
}
namespace std __attribute__((__visibility__("default"))) {
  using ::mbstate_t;
  using ::wint_t;
  using ::btowc;
  using ::fgetwc;
  using ::fgetws;
  using ::fputwc;
  using ::fputws;
  using ::fwide;
  using ::fwprintf;
  using ::fwscanf;
  using ::getwc;
  using ::getwchar;
  using ::mbrlen;
  using ::mbrtowc;
  using ::mbsinit;
  using ::mbsrtowcs;
  using ::putwc;
  using ::putwchar;
  using ::swprintf;
  using ::swscanf;
  using ::ungetwc;
  using ::vfwprintf;
  using ::vfwscanf;
  using ::vswprintf;
  using ::vswscanf;
  using ::vwprintf;
  using ::vwscanf;
  using ::wcrtomb;
  using ::wcscat;
  using ::wcscmp;
  using ::wcscoll;
  using ::wcscpy;
  using ::wcscspn;
  using ::wcsftime;
  using ::wcslen;
  using ::wcsncat;
  using ::wcsncmp;
  using ::wcsncpy;
  using ::wcsrtombs;
  using ::wcsspn;
  using ::wcstod;
  using ::wcstof;
  using ::wcstok;
  using ::wcstol;
  using ::wcstoul;
  using ::wcsxfrm;
  using ::wctob;
  using ::wmemcmp;
  using ::wmemcpy;
  using ::wmemmove;
  using ::wmemset;
  using ::wprintf;
  using ::wscanf;
  using ::wcschr;
  using ::wcspbrk;
  using ::wcsrchr;
  using ::wcsstr;
  using ::wmemchr;
}
namespace __gnu_cxx __attribute__((__visibility__("default"))) {
  using ::wcstold;
  using ::wcstoll;
  using ::wcstoull;
}
namespace std __attribute__((__visibility__("default"))) {
  using ::__gnu_cxx::wcstold;
  using ::__gnu_cxx::wcstoll;
  using ::__gnu_cxx::wcstoull;
  typedef long int streamoff;
  typedef ::std::ptrdiff_t streamsize;
  template < typename _StateT >
  class  fpos
  {
      ::std::streamoff _M_off;
      _StateT _M_state;
    public:
      inline fpos()
        : _M_off(0), _M_state()
      {
      }
      inline fpos(::std::streamoff __off)
        : _M_off(__off), _M_state()
      {
      }
      inline operator ::std::streamoff() const 
      {
        return _M_off;
      }
      inline void state(_StateT __st)
      {
        _M_state = __st;
      }
      inline _StateT state() const 
      {
        return _M_state;
      }
      inline ::std::fpos<_StateT> &operator +=(::std::streamoff __off)
      {
        _M_off += __off;
        return *this;
      }
      inline ::std::fpos<_StateT> &operator -=(::std::streamoff __off)
      {
        _M_off -= __off;
        return *this;
      }
      inline ::std::fpos<_StateT> operator +(::std::streamoff __off) const 
      {
        ::std::fpos<_StateT> __pos(*this);
        __pos += __off;
        return __pos;
      }
      inline ::std::fpos<_StateT> operator -(::std::streamoff __off) const 
      {
        ::std::fpos<_StateT> __pos(*this);
        __pos -= __off;
        return __pos;
      }
      inline ::std::streamoff operator -(const ::std::fpos<_StateT> &__other) const 
      {
        return _M_off - __other._M_off;
      }
  };
  template < typename _StateT >
  inline bool operator ==(const ::std::fpos<_StateT> &__lhs, const ::std::fpos<_StateT> &__rhs);
  template < typename _StateT >
  inline bool operator ==(const ::std::fpos<_StateT> &__lhs, const ::std::fpos<_StateT> &__rhs)
  {
    return (::std::streamoff)__lhs == (::std::streamoff)__rhs;
  }
  template < typename _StateT >
  inline bool operator !=(const ::std::fpos<_StateT> &__lhs, const ::std::fpos<_StateT> &__rhs);
  template < typename _StateT >
  inline bool operator !=(const ::std::fpos<_StateT> &__lhs, const ::std::fpos<_StateT> &__rhs)
  {
    return (::std::streamoff)__lhs != (::std::streamoff)__rhs;
  }
  typedef ::std::fpos< ::mbstate_t> streampos;
  typedef ::std::fpos< ::mbstate_t> wstreampos;
  class ios_base;
  template < typename _CharT, typename _Traits = ::std::char_traits<_CharT> >
  class basic_ios;
  template < typename _CharT, typename _Traits = ::std::char_traits<_CharT> >
  class basic_streambuf;
  template < typename _CharT, typename _Traits = ::std::char_traits<_CharT> >
  class basic_istream;
  template < typename _CharT, typename _Traits = ::std::char_traits<_CharT> >
  class basic_ostream;
  template < typename _CharT, typename _Traits = ::std::char_traits<_CharT> >
  class basic_iostream;
  template < typename _CharT, typename _Traits = ::std::char_traits<_CharT>, typename _Alloc = ::std::allocator<_CharT> >
  class basic_stringbuf;
  template < typename _CharT, typename _Traits = ::std::char_traits<_CharT>, typename _Alloc = ::std::allocator<_CharT> >
  class basic_istringstream;
  template < typename _CharT, typename _Traits = ::std::char_traits<_CharT>, typename _Alloc = ::std::allocator<_CharT> >
  class basic_ostringstream;
  template < typename _CharT, typename _Traits = ::std::char_traits<_CharT>, typename _Alloc = ::std::allocator<_CharT> >
  class basic_stringstream;
  template < typename _CharT, typename _Traits = ::std::char_traits<_CharT> >
  class basic_filebuf;
  template < typename _CharT, typename _Traits = ::std::char_traits<_CharT> >
  class basic_ifstream;
  template < typename _CharT, typename _Traits = ::std::char_traits<_CharT> >
  class basic_ofstream;
  template < typename _CharT, typename _Traits = ::std::char_traits<_CharT> >
  class basic_fstream;
  template < typename _CharT, typename _Traits = ::std::char_traits<_CharT> >
  class istreambuf_iterator;
  template < typename _CharT, typename _Traits = ::std::char_traits<_CharT> >
  class ostreambuf_iterator;
  typedef ::std::basic_ios<char, ::std::char_traits<char> > ios;
  typedef ::std::basic_streambuf<char, ::std::char_traits<char> > streambuf;
  typedef ::std::basic_istream<char, ::std::char_traits<char> > istream;
  typedef ::std::basic_ostream<char, ::std::char_traits<char> > ostream;
  typedef ::std::basic_iostream<char, ::std::char_traits<char> > iostream;
  typedef ::std::basic_stringbuf<char, ::std::char_traits<char>, ::std::allocator<char> > stringbuf;
  typedef ::std::basic_istringstream<char, ::std::char_traits<char>, ::std::allocator<char> > istringstream;
  typedef ::std::basic_ostringstream<char, ::std::char_traits<char>, ::std::allocator<char> > ostringstream;
  typedef ::std::basic_stringstream<char, ::std::char_traits<char>, ::std::allocator<char> > stringstream;
  typedef ::std::basic_filebuf<char, ::std::char_traits<char> > filebuf;
  typedef ::std::basic_ifstream<char, ::std::char_traits<char> > ifstream;
  typedef ::std::basic_ofstream<char, ::std::char_traits<char> > ofstream;
  typedef ::std::basic_fstream<char, ::std::char_traits<char> > fstream;
  typedef ::std::basic_ios<wchar_t, ::std::char_traits<wchar_t> > wios;
  typedef ::std::basic_streambuf<wchar_t, ::std::char_traits<wchar_t> > wstreambuf;
  typedef ::std::basic_istream<wchar_t, ::std::char_traits<wchar_t> > wistream;
  typedef ::std::basic_ostream<wchar_t, ::std::char_traits<wchar_t> > wostream;
  typedef ::std::basic_iostream<wchar_t, ::std::char_traits<wchar_t> > wiostream;
  typedef ::std::basic_stringbuf<wchar_t, ::std::char_traits<wchar_t>, ::std::allocator<wchar_t> > wstringbuf;
  typedef ::std::basic_istringstream<wchar_t, ::std::char_traits<wchar_t>, ::std::allocator<wchar_t> > wistringstream;
  typedef ::std::basic_ostringstream<wchar_t, ::std::char_traits<wchar_t>, ::std::allocator<wchar_t> > wostringstream;
  typedef ::std::basic_stringstream<wchar_t, ::std::char_traits<wchar_t>, ::std::allocator<wchar_t> > wstringstream;
  typedef ::std::basic_filebuf<wchar_t, ::std::char_traits<wchar_t> > wfilebuf;
  typedef ::std::basic_ifstream<wchar_t, ::std::char_traits<wchar_t> > wifstream;
  typedef ::std::basic_ofstream<wchar_t, ::std::char_traits<wchar_t> > wofstream;
  typedef ::std::basic_fstream<wchar_t, ::std::char_traits<wchar_t> > wfstream;
  void __throw_bad_exception()__attribute__((__noreturn__));
  void __throw_bad_alloc()__attribute__((__noreturn__));
  void __throw_bad_cast()__attribute__((__noreturn__));
  void __throw_bad_typeid()__attribute__((__noreturn__));
  void __throw_logic_error(const char *)__attribute__((__noreturn__));
  void __throw_domain_error(const char *)__attribute__((__noreturn__));
  void __throw_invalid_argument(const char *)__attribute__((__noreturn__));
  void __throw_length_error(const char *)__attribute__((__noreturn__));
  void __throw_out_of_range(const char *)__attribute__((__noreturn__));
  void __throw_runtime_error(const char *)__attribute__((__noreturn__));
  void __throw_range_error(const char *)__attribute__((__noreturn__));
  void __throw_overflow_error(const char *)__attribute__((__noreturn__));
  void __throw_underflow_error(const char *)__attribute__((__noreturn__));
  void __throw_ios_failure(const char *)__attribute__((__noreturn__));
  void __throw_system_error(int)__attribute__((__noreturn__));
  void __throw_future_error(int)__attribute__((__noreturn__));
  void __throw_bad_function_call()__attribute__((__noreturn__));
}
namespace __gnu_cxx __attribute__((__visibility__("default"))) {
  template < typename _Iterator, typename _Container >
  class __normal_iterator;
}
namespace std __attribute__((__visibility__("default"))) {
  struct  __true_type
  {
  };
  struct  __false_type
  {
  };
  template < bool __nontype_tpl_param_1_0__ >
  struct  __truth_type
  {
      typedef ::std::__false_type __type;
  };
  template <>
  struct  __truth_type<true>
  {
      typedef ::std::__true_type __type;
  };
  template < typename _Sp, typename _Tp >
  struct  __traitor
  {
      enum mcc_enum_anon_11
      {
        __value = (bool)_Sp::__value || (bool)_Tp::__value
      };
      typedef typename ::std::__truth_type<__value>::__type __type;
  };
  template < typename __type_tpl__param_1_0__, typename __type_tpl__param_1_1__ >
  struct  __are_same
  {
      enum mcc_enum_anon_12
      {
        __value = 0
      };
      typedef ::std::__false_type __type;
  };
  template < typename _Tp >
  struct  __are_same<_Tp, _Tp>
  {
      enum mcc_enum_anon_13
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template < typename _Tp >
  struct  __is_void
  {
      enum mcc_enum_anon_14
      {
        __value = 0
      };
      typedef ::std::__false_type __type;
  };
  template <>
  struct  __is_void<void>
  {
      enum mcc_enum_anon_15
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template < typename _Tp >
  struct  __is_integer
  {
      enum mcc_enum_anon_16
      {
        __value = 0
      };
      typedef ::std::__false_type __type;
  };
  template <>
  struct  __is_integer<bool>
  {
      enum mcc_enum_anon_17
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_integer<char>
  {
      enum mcc_enum_anon_18
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_integer<signed char>
  {
      enum mcc_enum_anon_19
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_integer<unsigned char>
  {
      enum mcc_enum_anon_20
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_integer<wchar_t>
  {
      enum mcc_enum_anon_21
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_integer<short int>
  {
      enum mcc_enum_anon_22
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_integer<unsigned short int>
  {
      enum mcc_enum_anon_23
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_integer<int>
  {
      enum mcc_enum_anon_24
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_integer<unsigned int>
  {
      enum mcc_enum_anon_25
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_integer<long int>
  {
      enum mcc_enum_anon_26
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_integer<unsigned long int>
  {
      enum mcc_enum_anon_27
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_integer<long long int>
  {
      enum mcc_enum_anon_28
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_integer<unsigned long long int>
  {
      enum mcc_enum_anon_29
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template < typename _Tp >
  struct  __is_floating
  {
      enum mcc_enum_anon_30
      {
        __value = 0
      };
      typedef ::std::__false_type __type;
  };
  template <>
  struct  __is_floating<float>
  {
      enum mcc_enum_anon_31
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_floating<double>
  {
      enum mcc_enum_anon_32
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_floating<long double>
  {
      enum mcc_enum_anon_33
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template < typename _Tp >
  struct  __is_pointer
  {
      enum mcc_enum_anon_34
      {
        __value = 0
      };
      typedef ::std::__false_type __type;
  };
  template < typename _Tp >
  struct  __is_pointer<_Tp *>
  {
      enum mcc_enum_anon_35
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template < typename _Tp >
  struct  __is_normal_iterator
  {
      enum mcc_enum_anon_36
      {
        __value = 0
      };
      typedef ::std::__false_type __type;
  };
  template < typename _Iterator, typename _Container >
  struct  __is_normal_iterator< ::__gnu_cxx::__normal_iterator<_Iterator, _Container> >
  {
      enum mcc_enum_anon_37
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template < typename _Tp >
  struct  __is_arithmetic : ::std::__traitor< ::std::__is_integer<_Tp>, ::std::__is_floating<_Tp> >
  {
  };
  template < typename _Tp >
  struct  __is_fundamental : ::std::__traitor< ::std::__is_void<_Tp>, ::std::__is_arithmetic<_Tp> >
  {
  };
  template < typename _Tp >
  struct  __is_scalar : ::std::__traitor< ::std::__is_arithmetic<_Tp>, ::std::__is_pointer<_Tp> >
  {
  };
  template < typename _Tp >
  struct  __is_char
  {
      enum mcc_enum_anon_38
      {
        __value = 0
      };
      typedef ::std::__false_type __type;
  };
  template <>
  struct  __is_char<char>
  {
      enum mcc_enum_anon_39
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_char<wchar_t>
  {
      enum mcc_enum_anon_40
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template < typename _Tp >
  struct  __is_byte
  {
      enum mcc_enum_anon_41
      {
        __value = 0
      };
      typedef ::std::__false_type __type;
  };
  template <>
  struct  __is_byte<char>
  {
      enum mcc_enum_anon_42
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_byte<signed char>
  {
      enum mcc_enum_anon_43
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_byte<unsigned char>
  {
      enum mcc_enum_anon_44
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template < typename _Tp >
  struct  __is_move_iterator
  {
      enum mcc_enum_anon_45
      {
        __value = 0
      };
      typedef ::std::__false_type __type;
  };
}
namespace __gnu_cxx __attribute__((__visibility__("default"))) {
  template < bool __nontype_tpl_param_1_0__, typename __type_tpl__param_1_1__ >
  struct  __enable_if
  {
  };
  template < typename _Tp >
  struct  __enable_if<true, _Tp>
  {
      typedef _Tp __type;
  };
  template < bool _Cond, typename _Iftrue, typename _Iffalse >
  struct  __conditional_type
  {
      typedef _Iftrue __type;
  };
  template < typename _Iftrue, typename _Iffalse >
  struct  __conditional_type<false, _Iftrue, _Iffalse>
  {
      typedef _Iffalse __type;
  };
  template < typename _Tp >
  struct  __add_unsigned
  {
    private:
      typedef ::__gnu_cxx::__enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;
    public:
      typedef typename ::__gnu_cxx::__enable_if<std::__is_integer<_Tp>::__value, _Tp>::__type __type;
  };
  template <>
  struct  __add_unsigned<char>
  {
      typedef unsigned char __type;
  };
  template <>
  struct  __add_unsigned<signed char>
  {
      typedef unsigned char __type;
  };
  template <>
  struct  __add_unsigned<short int>
  {
      typedef unsigned short int __type;
  };
  template <>
  struct  __add_unsigned<int>
  {
      typedef unsigned int __type;
  };
  template <>
  struct  __add_unsigned<long int>
  {
      typedef unsigned long int __type;
  };
  template <>
  struct  __add_unsigned<long long int>
  {
      typedef unsigned long long int __type;
  };
  template < typename _Tp >
  struct __add_unsigned;
  template <>
  struct __add_unsigned<bool>;
  template < typename _Tp >
  struct __add_unsigned;
  template <>
  struct __add_unsigned<wchar_t>;
  template < typename _Tp >
  struct  __remove_unsigned
  {
    private:
      typedef ::__gnu_cxx::__enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;
    public:
      typedef typename ::__gnu_cxx::__enable_if<std::__is_integer<_Tp>::__value, _Tp>::__type __type;
  };
  template <>
  struct  __remove_unsigned<char>
  {
      typedef signed char __type;
  };
  template <>
  struct  __remove_unsigned<unsigned char>
  {
      typedef signed char __type;
  };
  template <>
  struct  __remove_unsigned<unsigned short int>
  {
      typedef short int __type;
  };
  template <>
  struct  __remove_unsigned<unsigned int>
  {
      typedef int __type;
  };
  template <>
  struct  __remove_unsigned<unsigned long int>
  {
      typedef long int __type;
  };
  template <>
  struct  __remove_unsigned<unsigned long long int>
  {
      typedef long long int __type;
  };
  template < typename _Tp >
  struct __remove_unsigned;
  template <>
  struct __remove_unsigned<bool>;
  template < typename _Tp >
  struct __remove_unsigned;
  template <>
  struct __remove_unsigned<wchar_t>;
  template < typename _Type >
  inline bool __is_null_pointer(_Type *__ptr);
  template < typename _Type >
  inline bool __is_null_pointer(_Type *__ptr)
  {
    return __ptr == 0;
  }
  template < typename _Type >
  inline bool __is_null_pointer(_Type);
  template < typename _Type >
  inline bool __is_null_pointer(_Type)
  {
    return false;
  }
  template < typename _Tp, bool __nontype_tpl_param_1_1__ = std::__is_integer<_Tp>::__value >
  struct  __promote
  {
      typedef double __type;
  };
  template < typename _Tp >
  struct  __promote<_Tp, false>
  {
  };
  template <>
  struct  __promote<long double, false>
  {
      typedef long double __type;
  };
  template <>
  struct  __promote<double, false>
  {
      typedef double __type;
  };
  template <>
  struct  __promote<float, false>
  {
      typedef float __type;
  };
  template < typename _Tp, typename _Up, typename _Tp2 = typename ::__gnu_cxx::__promote<_Tp, ::std::__is_integer<_Tp>::__value>::__type, typename _Up2 = typename ::__gnu_cxx::__promote<_Up, ::std::__is_integer<_Up>::__value>::__type >
  struct  __promote_2
  {
      typedef __typeof__(_Tp2() + _Up2()) __type;
  };
  template < typename _Tp, typename _Up, typename _Vp, typename _Tp2 = typename ::__gnu_cxx::__promote<_Tp, ::std::__is_integer<_Tp>::__value>::__type, typename _Up2 = typename ::__gnu_cxx::__promote<_Up, ::std::__is_integer<_Up>::__value>::__type, typename _Vp2 = typename ::__gnu_cxx::__promote<_Vp, ::std::__is_integer<_Vp>::__value>::__type >
  struct  __promote_3
  {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2()) __type;
  };
  template < typename _Tp, typename _Up, typename _Vp, typename _Wp, typename _Tp2 = typename ::__gnu_cxx::__promote<_Tp, ::std::__is_integer<_Tp>::__value>::__type, typename _Up2 = typename ::__gnu_cxx::__promote<_Up, ::std::__is_integer<_Up>::__value>::__type, typename _Vp2 = typename ::__gnu_cxx::__promote<_Vp, ::std::__is_integer<_Vp>::__value>::__type, typename _Wp2 = typename ::__gnu_cxx::__promote<_Wp, ::std::__is_integer<_Wp>::__value>::__type >
  struct  __promote_4
  {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2() + _Wp2()) __type;
  };
  template < typename _Value >
  struct  __numeric_traits_integer
  {
      static const _Value __min = (_Value) -1 < 0 ? (_Value)1 << (sizeof(_Value) * 8 - ((_Value) -1 < 0)) : (_Value)0;
      static const _Value __max = (_Value) -1 < 0 ? ((((_Value)1 << (sizeof(_Value) * 8 - ((_Value) -1 < 0) - 1)) - 1) << 1) + 1 : ~((_Value)0);
      static const bool __is_signed = (_Value) -1 < 0;
      static const int __digits = sizeof(_Value) * 8 - ((_Value) -1 < 0);
  };
  template < typename _Value >
  struct  __numeric_traits_floating
  {
      static const int __max_digits10 = 2 + (std::__are_same<_Value, float>::__value ? 24 : std::__are_same<_Value, double>::__value ? 53 : 64) * 643L / 2136;
      static const bool __is_signed = true;
      static const int __digits10 = std::__are_same<_Value, float>::__value ? 6 : std::__are_same<_Value, double>::__value ? 15 : 18;
      static const int __max_exponent10 = std::__are_same<_Value, float>::__value ? 38 : std::__are_same<_Value, double>::__value ? 308 : 4932;
  };
  template < typename _Value >
  struct  __numeric_traits : ::__gnu_cxx::__conditional_type<std::__is_integer<_Value>::__value, ::__gnu_cxx::__numeric_traits_integer<_Value>, ::__gnu_cxx::__numeric_traits_floating<_Value> >::__type
  {
  };
}
namespace std __attribute__((__visibility__("default"))) {
  template < typename _Tp >
  inline _Tp *__addressof(_Tp &__r);
  template < typename _Tp >
  inline _Tp *__addressof(_Tp &__r)
  {
    return reinterpret_cast<_Tp *>(&const_cast<char &>(reinterpret_cast<const volatile char &>(__r)));
  }
  template < typename _Tp >
  inline void swap(_Tp &__a, _Tp &__b);
  template < typename _Tp >
  inline void swap(_Tp &__a, _Tp &__b)
  {
    _Tp __tmp = __a;
    __a = __b;
    __b = __tmp;
  }
  template < typename _Tp, ::std::size_t _Nm >
  inline void swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm]);
  template < typename _Tp, ::std::size_t _Nm >
  inline void swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
  {
    for (::std::size_t __n = 0; __n < _Nm; ++__n)
      {
        swap(__a[__n], __b[__n]);
      }
  }
  template < typename _T1, typename _T2 >
  struct  pair
  {
      typedef _T1 first_type;
      typedef _T2 second_type;
      _T1 first;
      _T2 second;
      inline pair()
        : first(), second()
      {
      }
      inline pair(const _T1 &__a, const _T2 &__b)
        : first(__a), second(__b)
      {
      }
      template < typename _U1, typename _U2 >
      inline pair(const ::std::pair<_U1, _U2> &__p)
        : first(__p.first), second(__p.second)
      {
      }
  };
  template < typename _T1, typename _T2 >
  inline bool operator ==(const ::std::pair<_T1, _T2> &__x, const ::std::pair<_T1, _T2> &__y);
  template < typename _T1, typename _T2 >
  inline bool operator ==(const ::std::pair<_T1, _T2> &__x, const ::std::pair<_T1, _T2> &__y)
  {
    return __x.first == __y.first && __x.second == __y.second;
  }
  template < typename _T1, typename _T2 >
  inline bool operator <(const ::std::pair<_T1, _T2> &__x, const ::std::pair<_T1, _T2> &__y);
  template < typename _T1, typename _T2 >
  inline bool operator <(const ::std::pair<_T1, _T2> &__x, const ::std::pair<_T1, _T2> &__y)
  {
    return __x.first < __y.first || (!(__y.first < __x.first) && __x.second < __y.second);
  }
  template < typename _T1, typename _T2 >
  inline bool operator !=(const ::std::pair<_T1, _T2> &__x, const ::std::pair<_T1, _T2> &__y);
  template < typename _T1, typename _T2 >
  inline bool operator !=(const ::std::pair<_T1, _T2> &__x, const ::std::pair<_T1, _T2> &__y)
  {
    return !(__x == __y);
  }
  template < typename _T1, typename _T2 >
  inline bool operator >(const ::std::pair<_T1, _T2> &__x, const ::std::pair<_T1, _T2> &__y);
  template < typename _T1, typename _T2 >
  inline bool operator >(const ::std::pair<_T1, _T2> &__x, const ::std::pair<_T1, _T2> &__y)
  {
    return __y < __x;
  }
  template < typename _T1, typename _T2 >
  inline bool operator <=(const ::std::pair<_T1, _T2> &__x, const ::std::pair<_T1, _T2> &__y);
  template < typename _T1, typename _T2 >
  inline bool operator <=(const ::std::pair<_T1, _T2> &__x, const ::std::pair<_T1, _T2> &__y)
  {
    return !(__y < __x);
  }
  template < typename _T1, typename _T2 >
  inline bool operator >=(const ::std::pair<_T1, _T2> &__x, const ::std::pair<_T1, _T2> &__y);
  template < typename _T1, typename _T2 >
  inline bool operator >=(const ::std::pair<_T1, _T2> &__x, const ::std::pair<_T1, _T2> &__y)
  {
    return !(__x < __y);
  }
  template < typename _T1, typename _T2 >
  inline ::std::pair<_T1, _T2> make_pair(_T1 __x, _T2 __y);
  template < typename _T1, typename _T2 >
  inline ::std::pair<_T1, _T2> make_pair(_T1 __x, _T2 __y)
  {
    return ::std::pair<_T1, _T2>(__x, __y);
  }
  struct  input_iterator_tag
  {
  };
  struct  output_iterator_tag
  {
  };
  struct  forward_iterator_tag : ::std::input_iterator_tag
  {
  };
  struct  bidirectional_iterator_tag : ::std::forward_iterator_tag
  {
  };
  struct  random_access_iterator_tag : ::std::bidirectional_iterator_tag
  {
  };
  template < typename _Category, typename _Tp, typename _Distance = ::std::ptrdiff_t, typename _Pointer = _Tp *, typename _Reference = _Tp & >
  struct  iterator
  {
      typedef _Category iterator_category;
      typedef _Tp value_type;
      typedef _Distance difference_type;
      typedef _Pointer pointer;
      typedef _Reference reference;
  };
  template < typename _Iterator >
  struct  iterator_traits
  {
      typedef typename _Iterator::iterator_category iterator_category;
      typedef typename _Iterator::value_type value_type;
      typedef typename _Iterator::difference_type difference_type;
      typedef typename _Iterator::pointer pointer;
      typedef typename _Iterator::reference reference;
  };
  template < typename _Tp >
  struct  iterator_traits<_Tp *>
  {
      typedef ::std::random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ::std::ptrdiff_t difference_type;
      typedef _Tp *pointer;
      typedef _Tp &reference;
  };
  template < typename _Tp >
  struct  iterator_traits<const _Tp *>
  {
      typedef ::std::random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ::std::ptrdiff_t difference_type;
      typedef const _Tp *pointer;
      typedef const _Tp &reference;
  };
  template < typename _Iter >
  inline typename ::std::iterator_traits<_Iter>::iterator_category __iterator_category(const _Iter &);
  template < typename _Iter >
  inline typename ::std::iterator_traits<_Iter>::iterator_category __iterator_category(const _Iter &)
  {
    return typename ::std::iterator_traits<_Iter>::iterator_category();
  }
  template < typename _Iterator, bool _HasBase >
  struct  _Iter_base
  {
      typedef _Iterator iterator_type;
      static inline typename ::std::_Iter_base<_Iterator, _HasBase>::iterator_type _S_base(_Iterator __it)
      {
        return __it;
      }
  };
  template < typename _Iterator >
  struct  _Iter_base<_Iterator, true>
  {
      typedef typename _Iterator::iterator_type iterator_type;
      static inline typename ::std::_Iter_base<_Iterator, true>::iterator_type _S_base(_Iterator __it)
      {
        return __it.base();
      }
  };
  template < typename _InputIterator >
  inline typename ::std::iterator_traits<_InputIterator>::difference_type __distance(_InputIterator __first, _InputIterator __last, ::std::input_iterator_tag);
  template < typename _InputIterator >
  inline typename ::std::iterator_traits<_InputIterator>::difference_type __distance(_InputIterator __first, _InputIterator __last, ::std::input_iterator_tag)
  {
    typename ::std::iterator_traits<_InputIterator>::difference_type __n = 0;
    while (__first != __last)
      {
        ++__first;
        ++__n;
      }
    return __n;
  }
  template < typename _RandomAccessIterator >
  inline typename ::std::iterator_traits<_RandomAccessIterator>::difference_type __distance(_RandomAccessIterator __first, _RandomAccessIterator __last, ::std::random_access_iterator_tag);
  template < typename _RandomAccessIterator >
  inline typename ::std::iterator_traits<_RandomAccessIterator>::difference_type __distance(_RandomAccessIterator __first, _RandomAccessIterator __last, ::std::random_access_iterator_tag)
  {
    return __last - __first;
  }
  template < typename _InputIterator >
  inline typename ::std::iterator_traits<_InputIterator>::difference_type distance(_InputIterator __first, _InputIterator __last);
  template < typename _InputIterator >
  inline typename ::std::iterator_traits<_InputIterator>::difference_type distance(_InputIterator __first, _InputIterator __last)
  {
    return std::__distance(__first, __last, std::__iterator_category(__first));
  }
  template < typename _InputIterator, typename _Distance >
  inline void __advance(_InputIterator &__i, _Distance __n, ::std::input_iterator_tag);
  template < typename _InputIterator, typename _Distance >
  inline void __advance(_InputIterator &__i, _Distance __n, ::std::input_iterator_tag)
  {
    while (__n--)
      {
        ++__i;
      }
  }
  template < typename _BidirectionalIterator, typename _Distance >
  inline void __advance(_BidirectionalIterator &__i, _Distance __n, ::std::bidirectional_iterator_tag);
  template < typename _BidirectionalIterator, typename _Distance >
  inline void __advance(_BidirectionalIterator &__i, _Distance __n, ::std::bidirectional_iterator_tag)
  {
    if (__n > 0)
      {
        while (__n--)
          {
            ++__i;
          }
      }
    else
      {
        while (__n++)
          {
            --__i;
          }
      }
  }
  template < typename _RandomAccessIterator, typename _Distance >
  inline void __advance(_RandomAccessIterator &__i, _Distance __n, ::std::random_access_iterator_tag);
  template < typename _RandomAccessIterator, typename _Distance >
  inline void __advance(_RandomAccessIterator &__i, _Distance __n, ::std::random_access_iterator_tag)
  {
    __i += __n;
  }
  template < typename _InputIterator, typename _Distance >
  inline void advance(_InputIterator &__i, _Distance __n);
  template < typename _InputIterator, typename _Distance >
  inline void advance(_InputIterator &__i, _Distance __n)
  {
    typename ::std::iterator_traits<_InputIterator>::difference_type __d = __n;
    std::__advance(__i, __d, std::__iterator_category(__i));
  }
  template < typename _Iterator >
  class  reverse_iterator : public ::std::iterator<typename ::std::iterator_traits<_Iterator>::iterator_category, typename ::std::iterator_traits<_Iterator>::value_type, typename ::std::iterator_traits<_Iterator>::difference_type, typename ::std::iterator_traits<_Iterator>::pointer, typename ::std::iterator_traits<_Iterator>::reference>
  {
    protected:
      _Iterator current;
      typedef ::std::iterator_traits<_Iterator> __traits_type;
    public:
      typedef _Iterator iterator_type;
      typedef typename ::std::iterator_traits<_Iterator>::difference_type difference_type;
      typedef typename ::std::iterator_traits<_Iterator>::pointer pointer;
      typedef typename ::std::iterator_traits<_Iterator>::reference reference;
      inline reverse_iterator()
        : current()
      {
      }
      inline explicit reverse_iterator(typename ::std::reverse_iterator<_Iterator>::iterator_type __x)
        : current(__x)
      {
      }
      inline reverse_iterator(const ::std::reverse_iterator<_Iterator> &__x)
        : current(__x.current)
      {
      }
      template < typename _Iter >
      inline reverse_iterator(const ::std::reverse_iterator<_Iter> &__x)
        : current(__x.base())
      {
      }
      inline typename ::std::reverse_iterator<_Iterator>::iterator_type base() const 
      {
        return current;
      }
      inline typename ::std::reverse_iterator<_Iterator>::reference operator *() const 
      {
        _Iterator __tmp = current;
        return *--__tmp;
      }
      inline typename ::std::reverse_iterator<_Iterator>::pointer operator ->() const 
      {
        return &operator *();
      }
      inline ::std::reverse_iterator<_Iterator> &operator ++()
      {
        --current;
        return *this;
      }
      inline ::std::reverse_iterator<_Iterator> operator ++(int)
      {
        ::std::reverse_iterator<_Iterator> __tmp = *this;
        --current;
        return __tmp;
      }
      inline ::std::reverse_iterator<_Iterator> &operator --()
      {
        ++current;
        return *this;
      }
      inline ::std::reverse_iterator<_Iterator> operator --(int)
      {
        ::std::reverse_iterator<_Iterator> __tmp = *this;
        ++current;
        return __tmp;
      }
      inline ::std::reverse_iterator<_Iterator> operator +(typename ::std::reverse_iterator<_Iterator>::difference_type __n) const 
      {
        return ::std::reverse_iterator<_Iterator>(current - __n);
      }
      inline ::std::reverse_iterator<_Iterator> &operator +=(typename ::std::reverse_iterator<_Iterator>::difference_type __n)
      {
        current -= __n;
        return *this;
      }
      inline ::std::reverse_iterator<_Iterator> operator -(typename ::std::reverse_iterator<_Iterator>::difference_type __n) const 
      {
        return ::std::reverse_iterator<_Iterator>(current + __n);
      }
      inline ::std::reverse_iterator<_Iterator> &operator -=(typename ::std::reverse_iterator<_Iterator>::difference_type __n)
      {
        current += __n;
        return *this;
      }
      inline typename ::std::reverse_iterator<_Iterator>::reference operator [](typename ::std::reverse_iterator<_Iterator>::difference_type __n) const 
      {
        return *(*this + __n);
      }
  };
  template < typename _Iterator >
  inline bool operator ==(const ::std::reverse_iterator<_Iterator> &__x, const ::std::reverse_iterator<_Iterator> &__y);
  template < typename _Iterator >
  inline bool operator ==(const ::std::reverse_iterator<_Iterator> &__x, const ::std::reverse_iterator<_Iterator> &__y)
  {
    return __x.base() == __y.base();
  }
  template < typename _Iterator >
  inline bool operator <(const ::std::reverse_iterator<_Iterator> &__x, const ::std::reverse_iterator<_Iterator> &__y);
  template < typename _Iterator >
  inline bool operator <(const ::std::reverse_iterator<_Iterator> &__x, const ::std::reverse_iterator<_Iterator> &__y)
  {
    return __y.base() < __x.base();
  }
  template < typename _Iterator >
  inline bool operator !=(const ::std::reverse_iterator<_Iterator> &__x, const ::std::reverse_iterator<_Iterator> &__y);
  template < typename _Iterator >
  inline bool operator !=(const ::std::reverse_iterator<_Iterator> &__x, const ::std::reverse_iterator<_Iterator> &__y)
  {
    return !(__x == __y);
  }
  template < typename _Iterator >
  inline bool operator >(const ::std::reverse_iterator<_Iterator> &__x, const ::std::reverse_iterator<_Iterator> &__y);
  template < typename _Iterator >
  inline bool operator >(const ::std::reverse_iterator<_Iterator> &__x, const ::std::reverse_iterator<_Iterator> &__y)
  {
    return __y < __x;
  }
  template < typename _Iterator >
  inline bool operator <=(const ::std::reverse_iterator<_Iterator> &__x, const ::std::reverse_iterator<_Iterator> &__y);
  template < typename _Iterator >
  inline bool operator <=(const ::std::reverse_iterator<_Iterator> &__x, const ::std::reverse_iterator<_Iterator> &__y)
  {
    return !(__y < __x);
  }
  template < typename _Iterator >
  inline bool operator >=(const ::std::reverse_iterator<_Iterator> &__x, const ::std::reverse_iterator<_Iterator> &__y);
  template < typename _Iterator >
  inline bool operator >=(const ::std::reverse_iterator<_Iterator> &__x, const ::std::reverse_iterator<_Iterator> &__y)
  {
    return !(__x < __y);
  }
  template < typename _Iterator >
  inline typename ::std::reverse_iterator<_Iterator>::difference_type operator -(const ::std::reverse_iterator<_Iterator> &__x, const ::std::reverse_iterator<_Iterator> &__y);
  template < typename _Iterator >
  inline typename ::std::reverse_iterator<_Iterator>::difference_type operator -(const ::std::reverse_iterator<_Iterator> &__x, const ::std::reverse_iterator<_Iterator> &__y)
  {
    return __y.base() - __x.base();
  }
  template < typename _Iterator >
  inline ::std::reverse_iterator<_Iterator> operator +(typename ::std::reverse_iterator<_Iterator>::difference_type __n, const ::std::reverse_iterator<_Iterator> &__x);
  template < typename _Iterator >
  inline ::std::reverse_iterator<_Iterator> operator +(typename ::std::reverse_iterator<_Iterator>::difference_type __n, const ::std::reverse_iterator<_Iterator> &__x)
  {
    return ::std::reverse_iterator<_Iterator>(__x.base() - __n);
  }
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator ==(const ::std::reverse_iterator<_IteratorL> &__x, const ::std::reverse_iterator<_IteratorR> &__y);
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator ==(const ::std::reverse_iterator<_IteratorL> &__x, const ::std::reverse_iterator<_IteratorR> &__y)
  {
    return __x.base() == __y.base();
  }
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator <(const ::std::reverse_iterator<_IteratorL> &__x, const ::std::reverse_iterator<_IteratorR> &__y);
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator <(const ::std::reverse_iterator<_IteratorL> &__x, const ::std::reverse_iterator<_IteratorR> &__y)
  {
    return __y.base() < __x.base();
  }
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator !=(const ::std::reverse_iterator<_IteratorL> &__x, const ::std::reverse_iterator<_IteratorR> &__y);
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator !=(const ::std::reverse_iterator<_IteratorL> &__x, const ::std::reverse_iterator<_IteratorR> &__y)
  {
    return !(__x == __y);
  }
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator >(const ::std::reverse_iterator<_IteratorL> &__x, const ::std::reverse_iterator<_IteratorR> &__y);
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator >(const ::std::reverse_iterator<_IteratorL> &__x, const ::std::reverse_iterator<_IteratorR> &__y)
  {
    return __y < __x;
  }
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator <=(const ::std::reverse_iterator<_IteratorL> &__x, const ::std::reverse_iterator<_IteratorR> &__y);
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator <=(const ::std::reverse_iterator<_IteratorL> &__x, const ::std::reverse_iterator<_IteratorR> &__y)
  {
    return !(__y < __x);
  }
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator >=(const ::std::reverse_iterator<_IteratorL> &__x, const ::std::reverse_iterator<_IteratorR> &__y);
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator >=(const ::std::reverse_iterator<_IteratorL> &__x, const ::std::reverse_iterator<_IteratorR> &__y)
  {
    return !(__x < __y);
  }
  template < typename _IteratorL, typename _IteratorR >
  inline typename ::std::reverse_iterator<_IteratorL>::difference_type operator -(const ::std::reverse_iterator<_IteratorL> &__x, const ::std::reverse_iterator<_IteratorR> &__y);
  template < typename _IteratorL, typename _IteratorR >
  inline typename ::std::reverse_iterator<_IteratorL>::difference_type operator -(const ::std::reverse_iterator<_IteratorL> &__x, const ::std::reverse_iterator<_IteratorR> &__y)
  {
    return __y.base() - __x.base();
  }
  template < typename _Container >
  class  back_insert_iterator : public ::std::iterator< ::std::output_iterator_tag, void, void, void, void>
  {
    protected:
      _Container *container;
    public:
      typedef _Container container_type;
      inline explicit back_insert_iterator(_Container &__x)
        : container(&__x)
      {
      }
      inline ::std::back_insert_iterator<_Container> &operator =(typename _Container::const_reference __value)
      {
        container->push_back(__value);
        return *this;
      }
      inline ::std::back_insert_iterator<_Container> &operator *()
      {
        return *this;
      }
      inline ::std::back_insert_iterator<_Container> &operator ++()
      {
        return *this;
      }
      inline ::std::back_insert_iterator<_Container> operator ++(int)
      {
        return *this;
      }
  };
  template < typename _Container >
  inline ::std::back_insert_iterator<_Container> back_inserter(_Container &__x);
  template < typename _Container >
  inline ::std::back_insert_iterator<_Container> back_inserter(_Container &__x)
  {
    return ::std::back_insert_iterator<_Container>(__x);
  }
  template < typename _Container >
  class  front_insert_iterator : public ::std::iterator< ::std::output_iterator_tag, void, void, void, void>
  {
    protected:
      _Container *container;
    public:
      typedef _Container container_type;
      inline explicit front_insert_iterator(_Container &__x)
        : container(&__x)
      {
      }
      inline ::std::front_insert_iterator<_Container> &operator =(typename _Container::const_reference __value)
      {
        container->push_front(__value);
        return *this;
      }
      inline ::std::front_insert_iterator<_Container> &operator *()
      {
        return *this;
      }
      inline ::std::front_insert_iterator<_Container> &operator ++()
      {
        return *this;
      }
      inline ::std::front_insert_iterator<_Container> operator ++(int)
      {
        return *this;
      }
  };
  template < typename _Container >
  inline ::std::front_insert_iterator<_Container> front_inserter(_Container &__x);
  template < typename _Container >
  inline ::std::front_insert_iterator<_Container> front_inserter(_Container &__x)
  {
    return ::std::front_insert_iterator<_Container>(__x);
  }
  template < typename _Container >
  class  insert_iterator : public ::std::iterator< ::std::output_iterator_tag, void, void, void, void>
  {
    protected:
      _Container *container;
      typename _Container::iterator iter;
    public:
      typedef _Container container_type;
      inline insert_iterator(_Container &__x, typename _Container::iterator __i)
        : container(&__x), iter(__i)
      {
      }
      inline ::std::insert_iterator<_Container> &operator =(typename _Container::const_reference __value)
      {
        iter = container->insert(iter, __value);
        ++iter;
        return *this;
      }
      inline ::std::insert_iterator<_Container> &operator *()
      {
        return *this;
      }
      inline ::std::insert_iterator<_Container> &operator ++()
      {
        return *this;
      }
      inline ::std::insert_iterator<_Container> &operator ++(int)
      {
        return *this;
      }
  };
  template < typename _Container, typename _Iterator >
  inline ::std::insert_iterator<_Container> inserter(_Container &__x, _Iterator __i);
  template < typename _Container, typename _Iterator >
  inline ::std::insert_iterator<_Container> inserter(_Container &__x, _Iterator __i)
  {
    return ::std::insert_iterator<_Container>(__x, typename _Container::iterator(__i));
  }
}
namespace __gnu_cxx __attribute__((__visibility__("default"))) {
  using ::std::iterator_traits;
  using ::std::iterator;
  template < typename _Iterator, typename _Container >
  class  __normal_iterator
  {
    protected:
      _Iterator _M_current;
      typedef ::std::iterator_traits<_Iterator> __traits_type;
    public:
      typedef _Iterator iterator_type;
      typedef typename ::std::iterator_traits<_Iterator>::iterator_category iterator_category;
      typedef typename ::std::iterator_traits<_Iterator>::value_type value_type;
      typedef typename ::std::iterator_traits<_Iterator>::difference_type difference_type;
      typedef typename ::std::iterator_traits<_Iterator>::reference reference;
      typedef typename ::std::iterator_traits<_Iterator>::pointer pointer;
      inline __normal_iterator()
        : _M_current(_Iterator())
      {
      }
      inline explicit __normal_iterator(const _Iterator &__i)
        : _M_current(__i)
      {
      }
      template < typename _Iter >
      inline __normal_iterator(const ::__gnu_cxx::__normal_iterator<_Iter, typename ::__gnu_cxx::__enable_if<std::__are_same<_Iter, typename _Container::pointer>::__value, _Container>::__type> &__i)
        : _M_current(__i.base())
      {
      }
      inline typename ::__gnu_cxx::__normal_iterator<_Iterator, _Container>::reference operator *() const 
      {
        return *_M_current;
      }
      inline typename ::__gnu_cxx::__normal_iterator<_Iterator, _Container>::pointer operator ->() const 
      {
        return _M_current;
      }
      inline ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &operator ++()
      {
        ++_M_current;
        return *this;
      }
      inline ::__gnu_cxx::__normal_iterator<_Iterator, _Container> operator ++(int)
      {
        return ::__gnu_cxx::__normal_iterator<_Iterator, _Container>(_M_current++);
      }
      inline ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &operator --()
      {
        --_M_current;
        return *this;
      }
      inline ::__gnu_cxx::__normal_iterator<_Iterator, _Container> operator --(int)
      {
        return ::__gnu_cxx::__normal_iterator<_Iterator, _Container>(_M_current--);
      }
      inline typename ::__gnu_cxx::__normal_iterator<_Iterator, _Container>::reference operator [](const typename ::__gnu_cxx::__normal_iterator<_Iterator, _Container>::difference_type &__n) const 
      {
        return _M_current[__n];
      }
      inline ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &operator +=(const typename ::__gnu_cxx::__normal_iterator<_Iterator, _Container>::difference_type &__n)
      {
        _M_current += __n;
        return *this;
      }
      inline ::__gnu_cxx::__normal_iterator<_Iterator, _Container> operator +(const typename ::__gnu_cxx::__normal_iterator<_Iterator, _Container>::difference_type &__n) const 
      {
        return ::__gnu_cxx::__normal_iterator<_Iterator, _Container>(_M_current + __n);
      }
      inline ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &operator -=(const typename ::__gnu_cxx::__normal_iterator<_Iterator, _Container>::difference_type &__n)
      {
        _M_current -= __n;
        return *this;
      }
      inline ::__gnu_cxx::__normal_iterator<_Iterator, _Container> operator -(const typename ::__gnu_cxx::__normal_iterator<_Iterator, _Container>::difference_type &__n) const 
      {
        return ::__gnu_cxx::__normal_iterator<_Iterator, _Container>(_M_current - __n);
      }
      inline const _Iterator &base() const 
      {
        return _M_current;
      }
  };
  template < typename _IteratorL, typename _IteratorR, typename _Container >
  inline bool operator ==(const ::__gnu_cxx::__normal_iterator<_IteratorL, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_IteratorR, _Container> &__rhs);
  template < typename _IteratorL, typename _IteratorR, typename _Container >
  inline bool operator ==(const ::__gnu_cxx::__normal_iterator<_IteratorL, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_IteratorR, _Container> &__rhs)
  {
    return __lhs.base() == __rhs.base();
  }
  template < typename _Iterator, typename _Container >
  inline bool operator ==(const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__rhs);
  template < typename _Iterator, typename _Container >
  inline bool operator ==(const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__rhs)
  {
    return __lhs.base() == __rhs.base();
  }
  template < typename _IteratorL, typename _IteratorR, typename _Container >
  inline bool operator !=(const ::__gnu_cxx::__normal_iterator<_IteratorL, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_IteratorR, _Container> &__rhs);
  template < typename _IteratorL, typename _IteratorR, typename _Container >
  inline bool operator !=(const ::__gnu_cxx::__normal_iterator<_IteratorL, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_IteratorR, _Container> &__rhs)
  {
    return __lhs.base() != __rhs.base();
  }
  template < typename _Iterator, typename _Container >
  inline bool operator !=(const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__rhs);
  template < typename _Iterator, typename _Container >
  inline bool operator !=(const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__rhs)
  {
    return __lhs.base() != __rhs.base();
  }
  template < typename _IteratorL, typename _IteratorR, typename _Container >
  inline bool operator <(const ::__gnu_cxx::__normal_iterator<_IteratorL, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_IteratorR, _Container> &__rhs);
  template < typename _IteratorL, typename _IteratorR, typename _Container >
  inline bool operator <(const ::__gnu_cxx::__normal_iterator<_IteratorL, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_IteratorR, _Container> &__rhs)
  {
    return __lhs.base() < __rhs.base();
  }
  template < typename _Iterator, typename _Container >
  inline bool operator <(const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__rhs);
  template < typename _Iterator, typename _Container >
  inline bool operator <(const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__rhs)
  {
    return __lhs.base() < __rhs.base();
  }
  template < typename _IteratorL, typename _IteratorR, typename _Container >
  inline bool operator >(const ::__gnu_cxx::__normal_iterator<_IteratorL, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_IteratorR, _Container> &__rhs);
  template < typename _IteratorL, typename _IteratorR, typename _Container >
  inline bool operator >(const ::__gnu_cxx::__normal_iterator<_IteratorL, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_IteratorR, _Container> &__rhs)
  {
    return __lhs.base() > __rhs.base();
  }
  template < typename _Iterator, typename _Container >
  inline bool operator >(const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__rhs);
  template < typename _Iterator, typename _Container >
  inline bool operator >(const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__rhs)
  {
    return __lhs.base() > __rhs.base();
  }
  template < typename _IteratorL, typename _IteratorR, typename _Container >
  inline bool operator <=(const ::__gnu_cxx::__normal_iterator<_IteratorL, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_IteratorR, _Container> &__rhs);
  template < typename _IteratorL, typename _IteratorR, typename _Container >
  inline bool operator <=(const ::__gnu_cxx::__normal_iterator<_IteratorL, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_IteratorR, _Container> &__rhs)
  {
    return __lhs.base() <= __rhs.base();
  }
  template < typename _Iterator, typename _Container >
  inline bool operator <=(const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__rhs);
  template < typename _Iterator, typename _Container >
  inline bool operator <=(const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__rhs)
  {
    return __lhs.base() <= __rhs.base();
  }
  template < typename _IteratorL, typename _IteratorR, typename _Container >
  inline bool operator >=(const ::__gnu_cxx::__normal_iterator<_IteratorL, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_IteratorR, _Container> &__rhs);
  template < typename _IteratorL, typename _IteratorR, typename _Container >
  inline bool operator >=(const ::__gnu_cxx::__normal_iterator<_IteratorL, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_IteratorR, _Container> &__rhs)
  {
    return __lhs.base() >= __rhs.base();
  }
  template < typename _Iterator, typename _Container >
  inline bool operator >=(const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__rhs);
  template < typename _Iterator, typename _Container >
  inline bool operator >=(const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__rhs)
  {
    return __lhs.base() >= __rhs.base();
  }
  template < typename _IteratorL, typename _IteratorR, typename _Container >
  inline typename ::__gnu_cxx::__normal_iterator<_IteratorL, _Container>::difference_type operator -(const ::__gnu_cxx::__normal_iterator<_IteratorL, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_IteratorR, _Container> &__rhs);
  template < typename _IteratorL, typename _IteratorR, typename _Container >
  inline typename ::__gnu_cxx::__normal_iterator<_IteratorL, _Container>::difference_type operator -(const ::__gnu_cxx::__normal_iterator<_IteratorL, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_IteratorR, _Container> &__rhs)
  {
    return __lhs.base() - __rhs.base();
  }
  template < typename _Iterator, typename _Container >
  inline typename ::__gnu_cxx::__normal_iterator<_Iterator, _Container>::difference_type operator -(const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__rhs);
  template < typename _Iterator, typename _Container >
  inline typename ::__gnu_cxx::__normal_iterator<_Iterator, _Container>::difference_type operator -(const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__rhs)
  {
    return __lhs.base() - __rhs.base();
  }
  template < typename _Iterator, typename _Container >
  inline ::__gnu_cxx::__normal_iterator<_Iterator, _Container> operator +(typename ::__gnu_cxx::__normal_iterator<_Iterator, _Container>::difference_type __n, const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__i);
  template < typename _Iterator, typename _Container >
  inline ::__gnu_cxx::__normal_iterator<_Iterator, _Container> operator +(typename ::__gnu_cxx::__normal_iterator<_Iterator, _Container>::difference_type __n, const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__i)
  {
    return ::__gnu_cxx::__normal_iterator<_Iterator, _Container>(__i.base() + __n);
  }
}
namespace std __attribute__((__visibility__("default"))) {
  namespace __debug { }
}
namespace __gnu_debug {
  using namespace ::std::__debug;
}
namespace std __attribute__((__visibility__("default"))) {
  template < bool _BoolType >
  struct  __iter_swap
  {
      template < typename _ForwardIterator1, typename _ForwardIterator2 >
      static inline void iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
      {
        typedef typename ::std::iterator_traits<_ForwardIterator1>::value_type _ValueType1;
        _ValueType1 __tmp = *__a;
        *__a = *__b;
        *__b = __tmp;
      }
  };
  template <>
  struct  __iter_swap<true>
  {
      template < typename _ForwardIterator1, typename _ForwardIterator2 >
      static inline void iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
      {
        swap(*__a, *__b);
      }
  };
  template < typename _ForwardIterator1, typename _ForwardIterator2 >
  inline void iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b);
  template < typename _ForwardIterator1, typename _ForwardIterator2 >
  inline void iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
  {
    typedef typename ::std::iterator_traits<_ForwardIterator1>::value_type _ValueType1;
    typedef typename ::std::iterator_traits<_ForwardIterator2>::value_type _ValueType2;
    typedef typename ::std::iterator_traits<_ForwardIterator1>::reference _ReferenceType1;
    typedef typename ::std::iterator_traits<_ForwardIterator2>::reference _ReferenceType2;
    std::__iter_swap<(__are_same<_ValueType1, _ValueType2>::__value && __are_same<_ValueType1 &, _ReferenceType1>::__value) && __are_same<_ValueType2 &, _ReferenceType2>::__value>::iter_swap(__a, __b);
  }
  template < typename _ForwardIterator1, typename _ForwardIterator2 >
  _ForwardIterator2 swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2);
  template < typename _ForwardIterator1, typename _ForwardIterator2 >
  _ForwardIterator2 swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2)
  {
    ;
    for (; __first1 != __last1; (++__first1, ++__first2))
      {
        std::iter_swap(__first1, __first2);
      }
    return __first2;
  }
  template < typename _Tp >
  inline const _Tp &min(const _Tp &__a, const _Tp &__b);
  template < typename _Tp >
  inline const _Tp &min(const _Tp &__a, const _Tp &__b)
  {
    if (__b < __a)
      {
        return __b;
      }
    return __a;
  }
  template < typename _Tp >
  inline const _Tp &max(const _Tp &__a, const _Tp &__b);
  template < typename _Tp >
  inline const _Tp &max(const _Tp &__a, const _Tp &__b)
  {
    if (__a < __b)
      {
        return __b;
      }
    return __a;
  }
  template < typename _Tp, typename _Compare >
  inline const _Tp &min(const _Tp &__a, const _Tp &__b, _Compare __comp);
  template < typename _Tp, typename _Compare >
  inline const _Tp &min(const _Tp &__a, const _Tp &__b, _Compare __comp)
  {
    if (__comp(__b, __a))
      {
        return __b;
      }
    return __a;
  }
  template < typename _Tp, typename _Compare >
  inline const _Tp &max(const _Tp &__a, const _Tp &__b, _Compare __comp);
  template < typename _Tp, typename _Compare >
  inline const _Tp &max(const _Tp &__a, const _Tp &__b, _Compare __comp)
  {
    if (__comp(__a, __b))
      {
        return __b;
      }
    return __a;
  }
  template < typename _Iterator >
  struct  _Niter_base : ::std::_Iter_base<_Iterator, __is_normal_iterator<_Iterator>::__value>
  {
  };
  template < typename _Iterator >
  inline typename ::std::_Niter_base<_Iterator>::iterator_type __niter_base(_Iterator __it);
  template < typename _Iterator >
  inline typename ::std::_Niter_base<_Iterator>::iterator_type __niter_base(_Iterator __it)
  {
    return std::_Niter_base<_Iterator>::_S_base(__it);
  }
  template < typename _Iterator >
  struct  _Miter_base : ::std::_Iter_base<_Iterator, __is_move_iterator<_Iterator>::__value>
  {
  };
  template < typename _Iterator >
  inline typename ::std::_Miter_base<_Iterator>::iterator_type __miter_base(_Iterator __it);
  template < typename _Iterator >
  inline typename ::std::_Miter_base<_Iterator>::iterator_type __miter_base(_Iterator __it)
  {
    return std::_Miter_base<_Iterator>::_S_base(__it);
  }
  template < bool __nontype_tpl_param_1_0__, bool __nontype_tpl_param_1_1__, typename __type_tpl__param_1_2__ >
  struct  __copy_move
  {
      template < typename _II, typename _OI >
      static inline _OI __copy_m(_II __first, _II __last, _OI __result)
      {
        for (; __first != __last; (++__result, ++__first))
          {
            *__result = *__first;
          }
        return __result;
      }
  };
  template <>
  struct  __copy_move<false, false, ::std::random_access_iterator_tag>
  {
      template < typename _II, typename _OI >
      static inline _OI __copy_m(_II __first, _II __last, _OI __result)
      {
        typedef typename ::std::iterator_traits<_II>::difference_type _Distance;
        for (_Distance __n = __last - __first; __n > 0; --__n)
          {
            *__result = *__first;
            ++__first;
            ++__result;
          }
        return __result;
      }
  };
  template < bool _IsMove >
  struct  __copy_move<_IsMove, true, ::std::random_access_iterator_tag>
  {
      template < typename _Tp >
      static inline _Tp *__copy_m(const _Tp *__first, const _Tp *__last, _Tp *__result)
      {
        const ::std::ptrdiff_t _Num = __last - __first;
        if (_Num)
          {
            __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
          }
        return __result + _Num;
      }
  };
  template < bool _IsMove, typename _II, typename _OI >
  inline _OI __copy_move_a(_II __first, _II __last, _OI __result);
  template < bool _IsMove, typename _II, typename _OI >
  inline _OI __copy_move_a(_II __first, _II __last, _OI __result)
  {
    typedef typename ::std::iterator_traits<_II>::value_type _ValueTypeI;
    typedef typename ::std::iterator_traits<_OI>::value_type _ValueTypeO;
    typedef typename ::std::iterator_traits<_II>::iterator_category _Category;
    const bool __simple = (((__is_trivial(_ValueTypeI)) && __is_pointer<_II>::__value) && __is_pointer<_OI>::__value) && __are_same<_ValueTypeI, _ValueTypeO>::__value;
    return std::__copy_move<_IsMove, __simple, _Category>::__copy_m(__first, __last, __result);
  }
  template < typename _CharT >
  struct char_traits;
  template < typename _CharT, typename _Traits >
  class istreambuf_iterator;
  template < typename _CharT, typename _Traits >
  class ostreambuf_iterator;
  template < bool _IsMove, typename _CharT >
  typename ::__gnu_cxx::__enable_if<__is_char<_CharT>::__value, ::std::ostreambuf_iterator<_CharT, ::std::char_traits<_CharT> > >::__type __copy_move_a2(_CharT *__first, _CharT *__last, ::std::ostreambuf_iterator<_CharT, ::std::char_traits<_CharT> > __result);
  template < bool _IsMove, typename _CharT >
  typename ::__gnu_cxx::__enable_if<__is_char<_CharT>::__value, ::std::ostreambuf_iterator<_CharT, ::std::char_traits<_CharT> > >::__type __copy_move_a2(const _CharT *__first, const _CharT *__last, ::std::ostreambuf_iterator<_CharT, ::std::char_traits<_CharT> > __result);
  template < bool _IsMove, typename _CharT >
  typename ::__gnu_cxx::__enable_if<__is_char<_CharT>::__value, _CharT *>::__type __copy_move_a2(::std::istreambuf_iterator<_CharT, ::std::char_traits<_CharT> > __first, ::std::istreambuf_iterator<_CharT, ::std::char_traits<_CharT> > __last, _CharT *__result);
  template < bool _IsMove, typename _II, typename _OI >
  inline _OI __copy_move_a2(_II __first, _II __last, _OI __result);
  template < bool _IsMove, typename _II, typename _OI >
  inline _OI __copy_move_a2(_II __first, _II __last, _OI __result)
  {
    return _OI(std::__copy_move_a<_IsMove>(std::__niter_base(__first), std::__niter_base(__last), std::__niter_base(__result)));
  }
  template < typename _II, typename _OI >
  inline _OI copy(_II __first, _II __last, _OI __result);
  template < typename _II, typename _OI >
  inline _OI copy(_II __first, _II __last, _OI __result)
  {
    ;
    return std::__copy_move_a2<__is_move_iterator<_II>::__value>(std::__miter_base(__first), std::__miter_base(__last), __result);
  }
  template < bool __nontype_tpl_param_1_0__, bool __nontype_tpl_param_1_1__, typename __type_tpl__param_1_2__ >
  struct  __copy_move_backward
  {
      template < typename _BI1, typename _BI2 >
      static inline _BI2 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
      {
        while (__first != __last)
          {
            *--__result = *--__last;
          }
        return __result;
      }
  };
  template <>
  struct  __copy_move_backward<false, false, ::std::random_access_iterator_tag>
  {
      template < typename _BI1, typename _BI2 >
      static inline _BI2 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
      {
        typename ::std::iterator_traits<_BI1>::difference_type __n;
        for (__n = __last - __first; __n > 0; --__n)
          {
            *--__result = *--__last;
          }
        return __result;
      }
  };
  template < bool _IsMove >
  struct  __copy_move_backward<_IsMove, true, ::std::random_access_iterator_tag>
  {
      template < typename _Tp >
      static inline _Tp *__copy_move_b(const _Tp *__first, const _Tp *__last, _Tp *__result)
      {
        const ::std::ptrdiff_t _Num = __last - __first;
        if (_Num)
          {
            __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
          }
        return __result - _Num;
      }
  };
  template < bool _IsMove, typename _BI1, typename _BI2 >
  inline _BI2 __copy_move_backward_a(_BI1 __first, _BI1 __last, _BI2 __result);
  template < bool _IsMove, typename _BI1, typename _BI2 >
  inline _BI2 __copy_move_backward_a(_BI1 __first, _BI1 __last, _BI2 __result)
  {
    typedef typename ::std::iterator_traits<_BI1>::value_type _ValueType1;
    typedef typename ::std::iterator_traits<_BI2>::value_type _ValueType2;
    typedef typename ::std::iterator_traits<_BI1>::iterator_category _Category;
    const bool __simple = (((__is_trivial(_ValueType1)) && __is_pointer<_BI1>::__value) && __is_pointer<_BI2>::__value) && __are_same<_ValueType1, _ValueType2>::__value;
    return std::__copy_move_backward<_IsMove, __simple, _Category>::__copy_move_b(__first, __last, __result);
  }
  template < bool _IsMove, typename _BI1, typename _BI2 >
  inline _BI2 __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result);
  template < bool _IsMove, typename _BI1, typename _BI2 >
  inline _BI2 __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
  {
    return _BI2(std::__copy_move_backward_a<_IsMove>(std::__niter_base(__first), std::__niter_base(__last), std::__niter_base(__result)));
  }
  template < typename _BI1, typename _BI2 >
  inline _BI2 copy_backward(_BI1 __first, _BI1 __last, _BI2 __result);
  template < typename _BI1, typename _BI2 >
  inline _BI2 copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
  {
    ;
    return std::__copy_move_backward_a2<__is_move_iterator<_BI1>::__value>(std::__miter_base(__first), std::__miter_base(__last), __result);
  }
  template < typename _ForwardIterator, typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type __fill_a(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value);
  template < typename _ForwardIterator, typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type __fill_a(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value)
  {
    for (; __first != __last; ++__first)
      {
        *__first = __value;
      }
  }
  template < typename _ForwardIterator, typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type __fill_a(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value);
  template < typename _ForwardIterator, typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type __fill_a(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value)
  {
    const _Tp __tmp = __value;
    for (; __first != __last; ++__first)
      {
        *__first = __tmp;
      }
  }
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type __fill_a(_Tp *__first, _Tp *__last, const _Tp &__c);
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type __fill_a(_Tp *__first, _Tp *__last, const _Tp &__c)
  {
    const _Tp __tmp = __c;
    __builtin_memset(__first, static_cast<unsigned char>(__tmp), __last - __first);
  }
  template < typename _ForwardIterator, typename _Tp >
  inline void fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value);
  template < typename _ForwardIterator, typename _Tp >
  inline void fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value)
  {
    ;
    std::__fill_a(std::__niter_base(__first), std::__niter_base(__last), __value);
  }
  template < typename _OutputIterator, typename _Size, typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type __fill_n_a(_OutputIterator __first, _Size __n, const _Tp &__value);
  template < typename _OutputIterator, typename _Size, typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type __fill_n_a(_OutputIterator __first, _Size __n, const _Tp &__value)
  {
    for (__decltype(__n + 0) __niter = __n; __niter > 0; (--__niter, ++__first))
      {
        *__first = __value;
      }
    return __first;
  }
  template < typename _OutputIterator, typename _Size, typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type __fill_n_a(_OutputIterator __first, _Size __n, const _Tp &__value);
  template < typename _OutputIterator, typename _Size, typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type __fill_n_a(_OutputIterator __first, _Size __n, const _Tp &__value)
  {
    const _Tp __tmp = __value;
    for (__decltype(__n + 0) __niter = __n; __niter > 0; (--__niter, ++__first))
      {
        *__first = __tmp;
      }
    return __first;
  }
  template < typename _Size, typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_byte<_Tp>::__value, _Tp *>::__type __fill_n_a(_Tp *__first, _Size __n, const _Tp &__c);
  template < typename _Size, typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_byte<_Tp>::__value, _Tp *>::__type __fill_n_a(_Tp *__first, _Size __n, const _Tp &__c)
  {
    std::__fill_a(__first, __first + __n, __c);
    return __first + __n;
  }
  template < typename _OI, typename _Size, typename _Tp >
  inline _OI fill_n(_OI __first, _Size __n, const _Tp &__value);
  template < typename _OI, typename _Size, typename _Tp >
  inline _OI fill_n(_OI __first, _Size __n, const _Tp &__value)
  {
    return _OI(std::__fill_n_a(std::__niter_base(__first), __n, __value));
  }
  template < bool _BoolType >
  struct  __equal
  {
      template < typename _II1, typename _II2 >
      static inline bool equal(_II1 __first1, _II1 __last1, _II2 __first2)
      {
        for (; __first1 != __last1; (++__first1, ++__first2))
          {
            if (!(*__first1 == *__first2))
              {
                return false;
              }
          }
        return true;
      }
  };
  template <>
  struct  __equal<true>
  {
      template < typename _Tp >
      static inline bool equal(const _Tp *__first1, const _Tp *__last1, const _Tp *__first2)
      {
        return !__builtin_memcmp(__first1, __first2, sizeof(_Tp) * (__last1 - __first1));
      }
  };
  template < typename _II1, typename _II2 >
  inline bool __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2);
  template < typename _II1, typename _II2 >
  inline bool __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)
  {
    typedef typename ::std::iterator_traits<_II1>::value_type _ValueType1;
    typedef typename ::std::iterator_traits<_II2>::value_type _ValueType2;
    const bool __simple = (((__is_integer<_ValueType1>::__value || __is_pointer<_ValueType1>::__value) && __is_pointer<_II1>::__value) && __is_pointer<_II2>::__value) && __are_same<_ValueType1, _ValueType2>::__value;
    return std::__equal<__simple>::equal(__first1, __last1, __first2);
  }
  template < typename __type_tpl__param_1_0__, typename __type_tpl__param_1_1__ >
  struct  __lc_rai
  {
      template < typename _II1, typename _II2 >
      static inline _II1 __newlast1(_II1, _II1 __last1, _II2, _II2)
      {
        return __last1;
      }
      template < typename _II >
      static inline bool __cnd2(_II __first, _II __last)
      {
        return __first != __last;
      }
  };
  template <>
  struct  __lc_rai< ::std::random_access_iterator_tag, ::std::random_access_iterator_tag>
  {
      template < typename _RAI1, typename _RAI2 >
      static inline _RAI1 __newlast1(_RAI1 __first1, _RAI1 __last1, _RAI2 __first2, _RAI2 __last2)
      {
        const typename ::std::iterator_traits<_RAI1>::difference_type __diff1 = __last1 - __first1;
        const typename ::std::iterator_traits<_RAI2>::difference_type __diff2 = __last2 - __first2;
        return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
      }
      template < typename _RAI >
      static inline bool __cnd2(_RAI, _RAI)
      {
        return true;
      }
  };
  template < bool _BoolType >
  struct  __lexicographical_compare
  {
      template < typename _II1, typename _II2 >
      static bool __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2);
  };
  template < bool _BoolType >
  template < typename _II1, typename _II2 >
  bool __lexicographical_compare<_BoolType>::__lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
  {
    typedef typename ::std::iterator_traits<_II1>::iterator_category _Category1;
    typedef typename ::std::iterator_traits<_II2>::iterator_category _Category2;
    typedef ::std::__lc_rai<_Category1, _Category2> __rai_type;
    __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
    for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2); (++__first1, ++__first2))
      {
        if (*__first1 < *__first2)
          {
            return true;
          }
        if (*__first2 < *__first1)
          {
            return false;
          }
      }
    return __first1 == __last1 && __first2 != __last2;
  }
  template <>
  struct  __lexicographical_compare<true>
  {
      template < typename _Tp, typename _Up >
      static inline bool __lc(const _Tp *__first1, const _Tp *__last1, const _Up *__first2, const _Up *__last2)
      {
        const ::std::size_t __len1 = __last1 - __first1;
        const ::std::size_t __len2 = __last2 - __first2;
        const int __result(__builtin_memcmp(__first1, __first2, ::std::min /* <unsigned long int> */ (__len1, __len2)));
        return __result != 0 ? __result < 0 : __len1 < __len2;
      }
  };
  template < typename _II1, typename _II2 >
  inline bool __lexicographical_compare_aux(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2);
  template < typename _II1, typename _II2 >
  inline bool __lexicographical_compare_aux(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
  {
    typedef typename ::std::iterator_traits<_II1>::value_type _ValueType1;
    typedef typename ::std::iterator_traits<_II2>::value_type _ValueType2;
    const bool __simple = ((((__is_byte<_ValueType1>::__value && __is_byte<_ValueType2>::__value) && !__gnu_cxx::__numeric_traits<_ValueType1>::__is_signed) && !__gnu_cxx::__numeric_traits<_ValueType2>::__is_signed) && __is_pointer<_II1>::__value) && __is_pointer<_II2>::__value;
    return std::__lexicographical_compare<__simple>::__lc(__first1, __last1, __first2, __last2);
  }
  template < typename _ForwardIterator, typename _Tp >
  _ForwardIterator lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val);
  template < typename _ForwardIterator, typename _Tp >
  _ForwardIterator lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val)
  {
    typedef typename ::std::iterator_traits<_ForwardIterator>::value_type _ValueType;
    typedef typename ::std::iterator_traits<_ForwardIterator>::difference_type _DistanceType;
    ;
    _DistanceType __len = std::distance(__first, __last);
    while (__len > 0)
      {
        _DistanceType __half = __len >> 1;
        _ForwardIterator __middle = __first;
        std::advance(__middle, __half);
        if (*__middle < __val)
          {
            __first = __middle;
            ++__first;
            __len = __len - __half - 1;
          }
        else
          {
            __len = __half;
          }
      }
    return __first;
  }
  template < typename _Size >
  inline _Size __lg(_Size __n);
  template < typename _Size >
  inline _Size __lg(_Size __n)
  {
    _Size __k;
    for (__k = 0; __n != 0; __n >>= 1)
      {
        ++__k;
      }
    return __k - 1;
  }
  inline int __lg(int __n)
  {
    return sizeof(int) * 8 - 1 - __builtin_clz(__n);
  }
  inline unsigned int __lg(unsigned int __n)
  {
    return sizeof(int) * 8 - 1 - __builtin_clz(__n);
  }
  inline long int __lg(long int __n)
  {
    return sizeof(long int) * 8 - 1 - __builtin_clzl(__n);
  }
  inline unsigned long int __lg(unsigned long int __n)
  {
    return sizeof(long int) * 8 - 1 - __builtin_clzl(__n);
  }
  inline long long int __lg(long long int __n)
  {
    return sizeof(long long int) * 8 - 1 - __builtin_clzll(__n);
  }
  inline unsigned long long int __lg(unsigned long long int __n)
  {
    return sizeof(long long int) * 8 - 1 - __builtin_clzll(__n);
  }
  template < typename _II1, typename _II2 >
  inline bool equal(_II1 __first1, _II1 __last1, _II2 __first2);
  template < typename _II1, typename _II2 >
  inline bool equal(_II1 __first1, _II1 __last1, _II2 __first2)
  {
    ;
    return std::__equal_aux(std::__niter_base(__first1), std::__niter_base(__last1), std::__niter_base(__first2));
  }
  template < typename _IIter1, typename _IIter2, typename _BinaryPredicate >
  inline bool equal(_IIter1 __first1, _IIter1 __last1, _IIter2 __first2, _BinaryPredicate __binary_pred);
  template < typename _IIter1, typename _IIter2, typename _BinaryPredicate >
  inline bool equal(_IIter1 __first1, _IIter1 __last1, _IIter2 __first2, _BinaryPredicate __binary_pred)
  {
    ;
    for (; __first1 != __last1; (++__first1, ++__first2))
      {
        if (!((bool)__binary_pred(*__first1, *__first2)))
          {
            return false;
          }
      }
    return true;
  }
  template < typename _II1, typename _II2 >
  inline bool lexicographical_compare(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2);
  template < typename _II1, typename _II2 >
  inline bool lexicographical_compare(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
  {
    typedef typename ::std::iterator_traits<_II1>::value_type _ValueType1;
    typedef typename ::std::iterator_traits<_II2>::value_type _ValueType2;
    ;
    ;
    return std::__lexicographical_compare_aux(std::__niter_base(__first1), std::__niter_base(__last1), std::__niter_base(__first2), std::__niter_base(__last2));
  }
  template < typename _II1, typename _II2, typename _Compare >
  bool lexicographical_compare(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2, _Compare __comp);
  template < typename _II1, typename _II2, typename _Compare >
  bool lexicographical_compare(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2, _Compare __comp)
  {
    typedef typename ::std::iterator_traits<_II1>::iterator_category _Category1;
    typedef typename ::std::iterator_traits<_II2>::iterator_category _Category2;
    typedef ::std::__lc_rai<_Category1, _Category2> __rai_type;
    ;
    ;
    __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
    for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2); (++__first1, ++__first2))
      {
        if (__comp(*__first1, *__first2))
          {
            return true;
          }
        if (__comp(*__first2, *__first1))
          {
            return false;
          }
      }
    return __first1 == __last1 && __first2 != __last2;
  }
  template < typename _InputIterator1, typename _InputIterator2 >
  ::std::pair<_InputIterator1, _InputIterator2> mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2);
  template < typename _InputIterator1, typename _InputIterator2 >
  ::std::pair<_InputIterator1, _InputIterator2> mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)
  {
    ;
    while (__first1 != __last1 && *__first1 == *__first2)
      {
        ++__first1;
        ++__first2;
      }
    return ::std::pair<_InputIterator1, _InputIterator2>(__first1, __first2);
  }
  template < typename _InputIterator1, typename _InputIterator2, typename _BinaryPredicate >
  ::std::pair<_InputIterator1, _InputIterator2> mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __binary_pred);
  template < typename _InputIterator1, typename _InputIterator2, typename _BinaryPredicate >
  ::std::pair<_InputIterator1, _InputIterator2> mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __binary_pred)
  {
    ;
    while (__first1 != __last1 && (bool)__binary_pred(*__first1, *__first2))
      {
        ++__first1;
        ++__first2;
      }
    return ::std::pair<_InputIterator1, _InputIterator2>(__first1, __first2);
  }
}
namespace __gnu_cxx __attribute__((__visibility__("default"))) {
  template < typename _CharT >
  struct  _Char_types
  {
      typedef unsigned long int int_type;
      typedef ::std::streampos pos_type;
      typedef ::std::streamoff off_type;
      typedef ::mbstate_t state_type;
  };
  template < typename _CharT >
  struct  char_traits
  {
      typedef _CharT char_type;
      typedef typename ::__gnu_cxx::_Char_types<_CharT>::int_type int_type;
      typedef typename ::__gnu_cxx::_Char_types<_CharT>::pos_type pos_type;
      typedef typename ::__gnu_cxx::_Char_types<_CharT>::off_type off_type;
      typedef typename ::__gnu_cxx::_Char_types<_CharT>::state_type state_type;
      static inline void assign(typename ::__gnu_cxx::char_traits<_CharT>::char_type &__c1, const typename ::__gnu_cxx::char_traits<_CharT>::char_type &__c2)
      {
        __c1 = __c2;
      }
      static inline bool eq(const typename ::__gnu_cxx::char_traits<_CharT>::char_type &__c1, const typename ::__gnu_cxx::char_traits<_CharT>::char_type &__c2)
      {
        return __c1 == __c2;
      }
      static inline bool lt(const typename ::__gnu_cxx::char_traits<_CharT>::char_type &__c1, const typename ::__gnu_cxx::char_traits<_CharT>::char_type &__c2)
      {
        return __c1 < __c2;
      }
      static int compare(const typename ::__gnu_cxx::char_traits<_CharT>::char_type *__s1, const typename ::__gnu_cxx::char_traits<_CharT>::char_type *__s2, ::std::size_t __n);
      static ::std::size_t length(const typename ::__gnu_cxx::char_traits<_CharT>::char_type *__p);
      static const typename ::__gnu_cxx::char_traits<_CharT>::char_type *find(const typename ::__gnu_cxx::char_traits<_CharT>::char_type *__s, ::std::size_t __n, const typename ::__gnu_cxx::char_traits<_CharT>::char_type &__a);
      static typename ::__gnu_cxx::char_traits<_CharT>::char_type *move(typename ::__gnu_cxx::char_traits<_CharT>::char_type *__s1, const typename ::__gnu_cxx::char_traits<_CharT>::char_type *__s2, ::std::size_t __n);
      static typename ::__gnu_cxx::char_traits<_CharT>::char_type *copy(typename ::__gnu_cxx::char_traits<_CharT>::char_type *__s1, const typename ::__gnu_cxx::char_traits<_CharT>::char_type *__s2, ::std::size_t __n);
      static typename ::__gnu_cxx::char_traits<_CharT>::char_type *assign(typename ::__gnu_cxx::char_traits<_CharT>::char_type *__s, ::std::size_t __n, typename ::__gnu_cxx::char_traits<_CharT>::char_type __a);
      static inline typename ::__gnu_cxx::char_traits<_CharT>::char_type to_char_type(const typename ::__gnu_cxx::char_traits<_CharT>::int_type &__c)
      {
        return static_cast<typename ::__gnu_cxx::char_traits<_CharT>::char_type>(__c);
      }
      static inline typename ::__gnu_cxx::char_traits<_CharT>::int_type to_int_type(const typename ::__gnu_cxx::char_traits<_CharT>::char_type &__c)
      {
        return static_cast<typename ::__gnu_cxx::char_traits<_CharT>::int_type>(__c);
      }
      static inline bool eq_int_type(const typename ::__gnu_cxx::char_traits<_CharT>::int_type &__c1, const typename ::__gnu_cxx::char_traits<_CharT>::int_type &__c2)
      {
        return __c1 == __c2;
      }
      static inline typename ::__gnu_cxx::char_traits<_CharT>::int_type eof()
      {
        return static_cast<typename ::__gnu_cxx::char_traits<_CharT>::int_type>( -1);
      }
      static inline typename ::__gnu_cxx::char_traits<_CharT>::int_type not_eof(const typename ::__gnu_cxx::char_traits<_CharT>::int_type &__c)
      {
        return !eq_int_type(__c, eof()) ? __c : to_int_type(typename ::__gnu_cxx::char_traits<_CharT>::char_type());
      }
  };
  template < typename _CharT >
  int char_traits<_CharT>::compare(const typename ::__gnu_cxx::char_traits<_CharT>::char_type *__s1, const typename ::__gnu_cxx::char_traits<_CharT>::char_type *__s2, ::std::size_t __n)
  {
    for (::std::size_t __i = 0; __i < __n; ++__i)
      {
        if (lt(__s1[__i], __s2[__i]))
          {
            return  -1;
          }
        else
          {
            if (lt(__s2[__i], __s1[__i]))
              {
                return 1;
              }
          }
      }
    return 0;
  }
  template < typename _CharT >
  ::std::size_t char_traits<_CharT>::length(const typename ::__gnu_cxx::char_traits<_CharT>::char_type *__p)
  {
    ::std::size_t __i(0);
    while (!eq(__p[__i], typename ::__gnu_cxx::char_traits<_CharT>::char_type()))
      {
        ++__i;
      }
    return __i;
  }
  template < typename _CharT >
  const typename ::__gnu_cxx::char_traits<_CharT>::char_type *char_traits<_CharT>::find(const typename ::__gnu_cxx::char_traits<_CharT>::char_type *__s, ::std::size_t __n, const typename ::__gnu_cxx::char_traits<_CharT>::char_type &__a)
  {
    for (::std::size_t __i = 0; __i < __n; ++__i)
      {
        if (eq(__s[__i], __a))
          {
            return __s + __i;
          }
      }
    return 0;
  }
  template < typename _CharT >
  typename ::__gnu_cxx::char_traits<_CharT>::char_type *char_traits<_CharT>::move(typename ::__gnu_cxx::char_traits<_CharT>::char_type *__s1, const typename ::__gnu_cxx::char_traits<_CharT>::char_type *__s2, ::std::size_t __n)
  {
    return static_cast<_CharT *>(__builtin_memmove(__s1, __s2, __n * sizeof(typename ::__gnu_cxx::char_traits<_CharT>::char_type)));
  }
  template < typename _CharT >
  typename ::__gnu_cxx::char_traits<_CharT>::char_type *char_traits<_CharT>::copy(typename ::__gnu_cxx::char_traits<_CharT>::char_type *__s1, const typename ::__gnu_cxx::char_traits<_CharT>::char_type *__s2, ::std::size_t __n)
  {
    std::copy(__s2, __s2 + __n, __s1);
    return __s1;
  }
  template < typename _CharT >
  typename ::__gnu_cxx::char_traits<_CharT>::char_type *char_traits<_CharT>::assign(typename ::__gnu_cxx::char_traits<_CharT>::char_type *__s, ::std::size_t __n, typename ::__gnu_cxx::char_traits<_CharT>::char_type __a)
  {
    std::fill_n(__s, __n, __a);
    return __s;
  }
}
namespace std __attribute__((__visibility__("default"))) {
  template < typename _CharT >
  struct  char_traits : ::__gnu_cxx::char_traits<_CharT>
  {
  };
  template <>
  struct  char_traits<char>
  {
      typedef char char_type;
      typedef int int_type;
      typedef ::std::streampos pos_type;
      typedef ::std::streamoff off_type;
      typedef ::mbstate_t state_type;
      static inline void assign(::std::char_traits<char>::char_type &__c1, const ::std::char_traits<char>::char_type &__c2)
      {
        __c1 = __c2;
      }
      static inline bool eq(const ::std::char_traits<char>::char_type &__c1, const ::std::char_traits<char>::char_type &__c2)
      {
        return __c1 == __c2;
      }
      static inline bool lt(const ::std::char_traits<char>::char_type &__c1, const ::std::char_traits<char>::char_type &__c2)
      {
        return __c1 < __c2;
      }
      static inline int compare(const ::std::char_traits<char>::char_type *__s1, const ::std::char_traits<char>::char_type *__s2, ::std::size_t __n)
      {
        return __builtin_memcmp(__s1, __s2, __n);
      }
      static inline ::std::size_t length(const ::std::char_traits<char>::char_type *__s)
      {
        return __builtin_strlen(__s);
      }
      static inline const ::std::char_traits<char>::char_type *find(const ::std::char_traits<char>::char_type *__s, ::std::size_t __n, const ::std::char_traits<char>::char_type &__a)
      {
        return static_cast<const ::std::char_traits<char>::char_type *>(__builtin_memchr(__s, __a, __n));
      }
      static inline ::std::char_traits<char>::char_type *move(::std::char_traits<char>::char_type *__s1, const ::std::char_traits<char>::char_type *__s2, ::std::size_t __n)
      {
        return static_cast< ::std::char_traits<char>::char_type *>(__builtin_memmove(__s1, __s2, __n));
      }
      static inline ::std::char_traits<char>::char_type *copy(::std::char_traits<char>::char_type *__s1, const ::std::char_traits<char>::char_type *__s2, ::std::size_t __n)
      {
        return static_cast< ::std::char_traits<char>::char_type *>(__builtin_memcpy(__s1, __s2, __n));
      }
      static inline ::std::char_traits<char>::char_type *assign(::std::char_traits<char>::char_type *__s, ::std::size_t __n, ::std::char_traits<char>::char_type __a)
      {
        return static_cast< ::std::char_traits<char>::char_type *>(__builtin_memset(__s, __a, __n));
      }
      static inline ::std::char_traits<char>::char_type to_char_type(const ::std::char_traits<char>::int_type &__c)
      {
        return static_cast< ::std::char_traits<char>::char_type>(__c);
      }
      static inline ::std::char_traits<char>::int_type to_int_type(const ::std::char_traits<char>::char_type &__c)
      {
        return static_cast< ::std::char_traits<char>::int_type>(static_cast<unsigned char>(__c));
      }
      static inline bool eq_int_type(const ::std::char_traits<char>::int_type &__c1, const ::std::char_traits<char>::int_type &__c2)
      {
        return __c1 == __c2;
      }
      static inline ::std::char_traits<char>::int_type eof()
      {
        return static_cast< ::std::char_traits<char>::int_type>( -1);
      }
      static inline ::std::char_traits<char>::int_type not_eof(const ::std::char_traits<char>::int_type &__c)
      {
        return __c == ::std::char_traits<char>::eof() ? 0 : __c;
      }
  };
  template <>
  struct  char_traits<wchar_t>
  {
      typedef wchar_t char_type;
      typedef ::wint_t int_type;
      typedef ::std::streamoff off_type;
      typedef ::std::wstreampos pos_type;
      typedef ::mbstate_t state_type;
      static inline void assign(::std::char_traits<wchar_t>::char_type &__c1, const ::std::char_traits<wchar_t>::char_type &__c2)
      {
        __c1 = __c2;
      }
      static inline bool eq(const ::std::char_traits<wchar_t>::char_type &__c1, const ::std::char_traits<wchar_t>::char_type &__c2)
      {
        return __c1 == __c2;
      }
      static inline bool lt(const ::std::char_traits<wchar_t>::char_type &__c1, const ::std::char_traits<wchar_t>::char_type &__c2)
      {
        return __c1 < __c2;
      }
      static inline int compare(const ::std::char_traits<wchar_t>::char_type *__s1, const ::std::char_traits<wchar_t>::char_type *__s2, ::std::size_t __n)
      {
        return ::std::wmemcmp(__s1, __s2, __n);
      }
      static inline ::std::size_t length(const ::std::char_traits<wchar_t>::char_type *__s)
      {
        return ::std::wcslen(__s);
      }
      static inline const ::std::char_traits<wchar_t>::char_type *find(const ::std::char_traits<wchar_t>::char_type *__s, ::std::size_t __n, const ::std::char_traits<wchar_t>::char_type &__a)
      {
        return ::std::wmemchr(__s, __a, __n);
      }
      static inline ::std::char_traits<wchar_t>::char_type *move(::std::char_traits<wchar_t>::char_type *__s1, const ::std::char_traits<wchar_t>::char_type *__s2, ::std::size_t __n)
      {
        return ::std::wmemmove(__s1, __s2, __n);
      }
      static inline ::std::char_traits<wchar_t>::char_type *copy(::std::char_traits<wchar_t>::char_type *__s1, const ::std::char_traits<wchar_t>::char_type *__s2, ::std::size_t __n)
      {
        return ::std::wmemcpy(__s1, __s2, __n);
      }
      static inline ::std::char_traits<wchar_t>::char_type *assign(::std::char_traits<wchar_t>::char_type *__s, ::std::size_t __n, ::std::char_traits<wchar_t>::char_type __a)
      {
        return ::std::wmemset(__s, __a, __n);
      }
      static inline ::std::char_traits<wchar_t>::char_type to_char_type(const ::std::char_traits<wchar_t>::int_type &__c)
      {
        return (::std::char_traits<wchar_t>::char_type)__c;
      }
      static inline ::std::char_traits<wchar_t>::int_type to_int_type(const ::std::char_traits<wchar_t>::char_type &__c)
      {
        return (::std::char_traits<wchar_t>::int_type)__c;
      }
      static inline bool eq_int_type(const ::std::char_traits<wchar_t>::int_type &__c1, const ::std::char_traits<wchar_t>::int_type &__c2)
      {
        return __c1 == __c2;
      }
      static inline ::std::char_traits<wchar_t>::int_type eof()
      {
        return static_cast< ::std::char_traits<wchar_t>::int_type>(4294967295U);
      }
      static inline ::std::char_traits<wchar_t>::int_type not_eof(const ::std::char_traits<wchar_t>::int_type &__c)
      {
        return ::std::char_traits<wchar_t>::eq_int_type(__c, ::std::char_traits<wchar_t>::eof()) ? 0 : __c;
      }
  };
}
enum mcc_enum_anon_46
{
  __LC_CTYPE = 0,
  __LC_NUMERIC = 1,
  __LC_TIME = 2,
  __LC_COLLATE = 3,
  __LC_MONETARY = 4,
  __LC_MESSAGES = 5,
  __LC_ALL = 6,
  __LC_PAPER = 7,
  __LC_NAME = 8,
  __LC_ADDRESS = 9,
  __LC_TELEPHONE = 10,
  __LC_MEASUREMENT = 11,
  __LC_IDENTIFICATION = 12
};
struct  lconv
{
    char *decimal_point;
    char *thousands_sep;
    char *grouping;
    char *int_curr_symbol;
    char *currency_symbol;
    char *mon_decimal_point;
    char *mon_thousands_sep;
    char *mon_grouping;
    char *positive_sign;
    char *negative_sign;
    char int_frac_digits;
    char frac_digits;
    char p_cs_precedes;
    char p_sep_by_space;
    char n_cs_precedes;
    char n_sep_by_space;
    char p_sign_posn;
    char n_sign_posn;
    char int_p_cs_precedes;
    char int_p_sep_by_space;
    char int_n_cs_precedes;
    char int_n_sep_by_space;
    char int_p_sign_posn;
    char int_n_sign_posn;
};
extern "C"
{
  extern char *setlocale(int __category, const char *__locale) throw();
}
extern "C"
{
  extern ::lconv *localeconv() throw();
}
extern "C"
{
  extern ::__locale_t newlocale(int __category_mask, const char *__locale, ::__locale_t __base) throw();
}
extern "C"
{
  extern ::__locale_t duplocale(::__locale_t __dataset) throw();
}
extern "C"
{
  extern void freelocale(::__locale_t __dataset) throw();
}
extern "C"
{
  extern ::__locale_t uselocale(::__locale_t __dataset) throw();
}
namespace std __attribute__((__visibility__("default"))) {
  using ::lconv;
  using ::setlocale;
  using ::localeconv;
}
namespace __gnu_cxx __attribute__((__visibility__("default"))) {
extern "C"
  {
    ::__locale_t __uselocale(::__locale_t) throw();
  }
}
namespace std __attribute__((__visibility__("default"))) {
  typedef ::__locale_t __c_locale;
  inline int __convert_from_v(const ::std::__c_locale &__cloc __attribute__((__unused__)), char *__out, const int __size __attribute__((__unused__)), const char *__fmt, ...)
  {
    ::std::__c_locale __old(::__gnu_cxx::__uselocale(__cloc));
    ::__builtin_va_list __args;
    __builtin_va_start(__args, __fmt);
    const int __ret(__builtin_vsnprintf(__out, __size, __fmt, __args));
    __builtin_va_end(__args);
    ::__gnu_cxx::__uselocale(__old);
    return __ret;
  }
}
enum mcc_enum_anon_47
{
  _ISupper = 0 < 8 ? 1 << 0 << 8 : 1 << 0 >> 8,
  _ISlower = 1 < 8 ? 1 << 1 << 8 : 1 << 1 >> 8,
  _ISalpha = 2 < 8 ? 1 << 2 << 8 : 1 << 2 >> 8,
  _ISdigit = 3 < 8 ? 1 << 3 << 8 : 1 << 3 >> 8,
  _ISxdigit = 4 < 8 ? 1 << 4 << 8 : 1 << 4 >> 8,
  _ISspace = 5 < 8 ? 1 << 5 << 8 : 1 << 5 >> 8,
  _ISprint = 6 < 8 ? 1 << 6 << 8 : 1 << 6 >> 8,
  _ISgraph = 7 < 8 ? 1 << 7 << 8 : 1 << 7 >> 8,
  _ISblank = 8 < 8 ? 1 << 8 << 8 : 1 << 8 >> 8,
  _IScntrl = 9 < 8 ? 1 << 9 << 8 : 1 << 9 >> 8,
  _ISpunct = 10 < 8 ? 1 << 10 << 8 : 1 << 10 >> 8,
  _ISalnum = 11 < 8 ? 1 << 11 << 8 : 1 << 11 >> 8
};
extern "C"
{
  extern const unsigned short int **__ctype_b_loc() throw()__attribute__((__const));
}
extern "C"
{
  extern const ::__int32_t **__ctype_tolower_loc() throw()__attribute__((__const));
}
extern "C"
{
  extern const ::__int32_t **__ctype_toupper_loc() throw()__attribute__((__const));
}
extern "C"
{
  extern int isalnum(int) throw();
}
extern "C"
{
  extern int isalpha(int) throw();
}
extern "C"
{
  extern int iscntrl(int) throw();
}
extern "C"
{
  extern int isdigit(int) throw();
}
extern "C"
{
  extern int islower(int) throw();
}
extern "C"
{
  extern int isgraph(int) throw();
}
extern "C"
{
  extern int isprint(int) throw();
}
extern "C"
{
  extern int ispunct(int) throw();
}
extern "C"
{
  extern int isspace(int) throw();
}
extern "C"
{
  extern int isupper(int) throw();
}
extern "C"
{
  extern int isxdigit(int) throw();
}
extern "C"
{
  extern int tolower(int __c) throw();
}
extern "C"
{
  extern int toupper(int __c) throw();
}
extern "C"
{
  extern int isblank(int) throw();
}
extern "C"
{
  extern int isctype(int __c, int __mask) throw();
}
extern "C"
{
  extern int isascii(int __c) throw();
}
extern "C"
{
  extern int toascii(int __c) throw();
}
extern "C"
{
  extern int _toupper(int) throw();
}
extern "C"
{
  extern int _tolower(int) throw();
}
extern "C"
{
  extern int isalnum_l(int, ::__locale_t) throw();
}
extern "C"
{
  extern int isalpha_l(int, ::__locale_t) throw();
}
extern "C"
{
  extern int iscntrl_l(int, ::__locale_t) throw();
}
extern "C"
{
  extern int isdigit_l(int, ::__locale_t) throw();
}
extern "C"
{
  extern int islower_l(int, ::__locale_t) throw();
}
extern "C"
{
  extern int isgraph_l(int, ::__locale_t) throw();
}
extern "C"
{
  extern int isprint_l(int, ::__locale_t) throw();
}
extern "C"
{
  extern int ispunct_l(int, ::__locale_t) throw();
}
extern "C"
{
  extern int isspace_l(int, ::__locale_t) throw();
}
extern "C"
{
  extern int isupper_l(int, ::__locale_t) throw();
}
extern "C"
{
  extern int isxdigit_l(int, ::__locale_t) throw();
}
extern "C"
{
  extern int isblank_l(int, ::__locale_t) throw();
}
extern "C"
{
  extern int __tolower_l(int __c, ::__locale_t __l) throw();
}
extern "C"
{
  extern int tolower_l(int __c, ::__locale_t __l) throw();
}
extern "C"
{
  extern int __toupper_l(int __c, ::__locale_t __l) throw();
}
extern "C"
{
  extern int toupper_l(int __c, ::__locale_t __l) throw();
}
namespace std __attribute__((__visibility__("default"))) {
  using ::isalnum;
  using ::isalpha;
  using ::iscntrl;
  using ::isdigit;
  using ::isgraph;
  using ::islower;
  using ::isprint;
  using ::ispunct;
  using ::isspace;
  using ::isupper;
  using ::isxdigit;
  using ::tolower;
  using ::toupper;
  class locale;
  template < typename _Facet >
  bool has_facet(const ::std::locale &__loc) throw();
  template < typename _Facet >
  const _Facet &use_facet(const ::std::locale &__loc);
  template < typename _CharT >
  inline bool isspace(_CharT __c, const ::std::locale &__loc);
  template < typename _CharT >
  inline bool isprint(_CharT __c, const ::std::locale &__loc);
  template < typename _CharT >
  inline bool iscntrl(_CharT __c, const ::std::locale &__loc);
  template < typename _CharT >
  inline bool isupper(_CharT __c, const ::std::locale &__loc);
  template < typename _CharT >
  inline bool islower(_CharT __c, const ::std::locale &__loc);
  template < typename _CharT >
  inline bool isalpha(_CharT __c, const ::std::locale &__loc);
  template < typename _CharT >
  inline bool isdigit(_CharT __c, const ::std::locale &__loc);
  template < typename _CharT >
  inline bool ispunct(_CharT __c, const ::std::locale &__loc);
  template < typename _CharT >
  inline bool isxdigit(_CharT __c, const ::std::locale &__loc);
  template < typename _CharT >
  inline bool isalnum(_CharT __c, const ::std::locale &__loc);
  template < typename _CharT >
  inline bool isgraph(_CharT __c, const ::std::locale &__loc);
  template < typename _CharT >
  inline _CharT toupper(_CharT __c, const ::std::locale &__loc);
  template < typename _CharT >
  inline _CharT tolower(_CharT __c, const ::std::locale &__loc);
  class ctype_base;
  template < typename _CharT >
  class ctype;
  template < typename _CharT >
  class ctype;
  template <>
  class ctype<char>;
  template < typename _CharT >
  class ctype;
  template <>
  class ctype<wchar_t>;
  template < typename _CharT >
  class ctype_byname;
  class codecvt_base;
  template < typename _InternT, typename _ExternT, typename _StateT >
  class codecvt;
  template < typename _InternT, typename _ExternT, typename _StateT >
  class codecvt;
  template <>
  class codecvt<char, char, ::mbstate_t>;
  template < typename _InternT, typename _ExternT, typename _StateT >
  class codecvt;
  template <>
  class codecvt<wchar_t, char, ::mbstate_t>;
  template < typename _InternT, typename _ExternT, typename _StateT >
  class codecvt_byname;
  template < typename _CharT, typename _InIter = ::std::istreambuf_iterator<_CharT, ::std::char_traits<_CharT> > >
  class num_get;
  template < typename _CharT, typename _OutIter = ::std::ostreambuf_iterator<_CharT, ::std::char_traits<_CharT> > >
  class num_put;
  template < typename _CharT >
  class numpunct;
  template < typename _CharT >
  class numpunct_byname;
  template < typename _CharT >
  class collate;
  template < typename _CharT >
  class collate_byname;
  class time_base;
  template < typename _CharT, typename _InIter = ::std::istreambuf_iterator<_CharT, ::std::char_traits<_CharT> > >
  class time_get;
  template < typename _CharT, typename _InIter = ::std::istreambuf_iterator<_CharT, ::std::char_traits<_CharT> > >
  class time_get_byname;
  template < typename _CharT, typename _OutIter = ::std::ostreambuf_iterator<_CharT, ::std::char_traits<_CharT> > >
  class time_put;
  template < typename _CharT, typename _OutIter = ::std::ostreambuf_iterator<_CharT, ::std::char_traits<_CharT> > >
  class time_put_byname;
  class money_base;
  template < typename _CharT, typename _InIter = ::std::istreambuf_iterator<_CharT, ::std::char_traits<_CharT> > >
  class money_get;
  template < typename _CharT, typename _OutIter = ::std::ostreambuf_iterator<_CharT, ::std::char_traits<_CharT> > >
  class money_put;
  template < typename _CharT, bool _Intl = false >
  class moneypunct;
  template < typename _CharT, bool _Intl = false >
  class moneypunct_byname;
  class messages_base;
  template < typename _CharT >
  class messages;
  template < typename _CharT >
  class messages_byname;
}
#pragma GCC visibility push(default)
struct  sched_param
{
    int __sched_priority;
};
extern "C"
{
  extern int clone(int (*__fn)(void *), void *__child_stack, int __flags, void *__arg, ...) throw();
}
extern "C"
{
  extern int unshare(int __flags) throw();
}
extern "C"
{
  extern int sched_getcpu() throw();
}
struct  __sched_param
{
    int __sched_priority;
};
typedef unsigned long int __cpu_mask;
struct  cpu_set_t
{
    ::__cpu_mask __bits[64U];
};
extern "C"
{
  extern int __sched_cpucount(::size_t __setsize, const ::cpu_set_t *__setp) throw();
}
extern "C"
{
  extern ::cpu_set_t *__sched_cpualloc(::size_t __count) throw();
}
extern "C"
{
  extern void __sched_cpufree(::cpu_set_t *__set) throw();
}
extern "C"
{
  extern int sched_setparam(::__pid_t __pid, const ::sched_param *__param) throw();
}
extern "C"
{
  extern int sched_getparam(::__pid_t __pid, ::sched_param *__param) throw();
}
extern "C"
{
  extern int sched_setscheduler(::__pid_t __pid, int __policy, const ::sched_param *__param) throw();
}
extern "C"
{
  extern int sched_getscheduler(::__pid_t __pid) throw();
}
extern "C"
{
  extern int sched_yield() throw();
}
extern "C"
{
  extern int sched_get_priority_max(int __algorithm) throw();
}
extern "C"
{
  extern int sched_get_priority_min(int __algorithm) throw();
}
extern "C"
{
  extern int sched_rr_get_interval(::__pid_t __pid, ::timespec *__t) throw();
}
extern "C"
{
  extern int sched_setaffinity(::__pid_t __pid, ::size_t __cpusetsize, const ::cpu_set_t *__cpuset) throw();
}
extern "C"
{
  extern int sched_getaffinity(::__pid_t __pid, ::size_t __cpusetsize, ::cpu_set_t *__cpuset) throw();
}
struct  tm
{
    int tm_sec;
    int tm_min;
    int tm_hour;
    int tm_mday;
    int tm_mon;
    int tm_year;
    int tm_wday;
    int tm_yday;
    int tm_isdst;
    long int tm_gmtoff;
    const char *tm_zone;
};
struct  itimerspec
{
    ::timespec it_interval;
    ::timespec it_value;
};
struct sigevent;
extern "C"
{
  extern ::clock_t clock() throw();
}
extern "C"
{
  extern ::time_t time(::time_t *__timer) throw();
}
extern "C"
{
  extern double difftime(::time_t __time1, ::time_t __time0) throw()__attribute__((__const__));
}
extern "C"
{
  extern ::time_t mktime(::tm *__tp) throw();
}
extern "C"
{
  extern ::size_t strftime(char *__restrict __s, ::size_t __maxsize, const char *__restrict __format, const ::tm *__restrict __tp) throw();
}
extern "C"
{
  extern char *strptime(const char *__restrict __s, const char *__restrict __fmt, ::tm *__tp) throw();
}
extern "C"
{
  extern ::size_t strftime_l(char *__restrict __s, ::size_t __maxsize, const char *__restrict __format, const ::tm *__restrict __tp, ::__locale_t __loc) throw();
}
extern "C"
{
  extern char *strptime_l(const char *__restrict __s, const char *__restrict __fmt, ::tm *__tp, ::__locale_t __loc) throw();
}
extern "C"
{
  extern ::tm *gmtime(const ::time_t *__timer) throw();
}
extern "C"
{
  extern ::tm *localtime(const ::time_t *__timer) throw();
}
extern "C"
{
  extern ::tm *gmtime_r(const ::time_t *__restrict __timer, ::tm *__restrict __tp) throw();
}
extern "C"
{
  extern ::tm *localtime_r(const ::time_t *__restrict __timer, ::tm *__restrict __tp) throw();
}
extern "C"
{
  extern char *asctime(const ::tm *__tp) throw();
}
extern "C"
{
  extern char *ctime(const ::time_t *__timer) throw();
}
extern "C"
{
  extern char *asctime_r(const ::tm *__restrict __tp, char *__restrict __buf) throw();
}
extern "C"
{
  extern char *ctime_r(const ::time_t *__restrict __timer, char *__restrict __buf) throw();
}
extern "C"
{
  extern char *__tzname[2];
}
extern "C"
{
  extern int __daylight;
}
extern "C"
{
  extern long int __timezone;
}
extern "C"
{
  extern char *tzname[2];
}
extern "C"
{
  extern void tzset() throw();
}
extern "C"
{
  extern int daylight;
}
extern "C"
{
  extern long int timezone;
}
extern "C"
{
  extern int stime(const ::time_t *__when) throw();
}
extern "C"
{
  extern ::time_t timegm(::tm *__tp) throw();
}
extern "C"
{
  extern ::time_t timelocal(::tm *__tp) throw();
}
extern "C"
{
  extern int dysize(int __year) throw()__attribute__((__const__));
}
extern "C"
{
  extern int nanosleep(const ::timespec *__requested_time, ::timespec *__remaining);
}
extern "C"
{
  extern int clock_getres(::clockid_t __clock_id, ::timespec *__res) throw();
}
extern "C"
{
  extern int clock_gettime(::clockid_t __clock_id, ::timespec *__tp) throw();
}
extern "C"
{
  extern int clock_settime(::clockid_t __clock_id, const ::timespec *__tp) throw();
}
extern "C"
{
  extern int clock_nanosleep(::clockid_t __clock_id, int __flags, const ::timespec *__req, ::timespec *__rem);
}
extern "C"
{
  extern int clock_getcpuclockid(::pid_t __pid, ::clockid_t *__clock_id) throw();
}
extern "C"
{
  extern int timer_create(::clockid_t __clock_id, ::sigevent *__restrict __evp, ::timer_t *__restrict __timerid) throw();
}
extern "C"
{
  extern int timer_delete(::timer_t __timerid) throw();
}
extern "C"
{
  extern int timer_settime(::timer_t __timerid, int __flags, const ::itimerspec *__restrict __value, ::itimerspec *__restrict __ovalue) throw();
}
extern "C"
{
  extern int timer_gettime(::timer_t __timerid, ::itimerspec *__value) throw();
}
extern "C"
{
  extern int timer_getoverrun(::timer_t __timerid) throw();
}
extern "C"
{
  extern int getdate_err;
}
extern "C"
{
  extern ::tm *getdate(const char *__string);
}
extern "C"
{
  extern int getdate_r(const char *__restrict __string, ::tm *__restrict __resbufp);
}
typedef long int __jmp_buf[8];
enum mcc_enum_anon_48
{
  PTHREAD_CREATE_JOINABLE = 0,
  PTHREAD_CREATE_DETACHED = 1
};
enum mcc_enum_anon_49
{
  PTHREAD_MUTEX_TIMED_NP = 0,
  PTHREAD_MUTEX_RECURSIVE_NP = 1,
  PTHREAD_MUTEX_ERRORCHECK_NP = 2,
  PTHREAD_MUTEX_ADAPTIVE_NP = 3,
  PTHREAD_MUTEX_NORMAL = ::PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE = ::PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK = ::PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_DEFAULT = ::PTHREAD_MUTEX_NORMAL,
  PTHREAD_MUTEX_FAST_NP = ::PTHREAD_MUTEX_TIMED_NP
};
enum mcc_enum_anon_50
{
  PTHREAD_MUTEX_STALLED = 0,
  PTHREAD_MUTEX_STALLED_NP = ::PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_ROBUST = 1,
  PTHREAD_MUTEX_ROBUST_NP = ::PTHREAD_MUTEX_ROBUST
};
enum mcc_enum_anon_51
{
  PTHREAD_PRIO_NONE = 0,
  PTHREAD_PRIO_INHERIT = 1,
  PTHREAD_PRIO_PROTECT = 2
};
enum mcc_enum_anon_52
{
  PTHREAD_RWLOCK_PREFER_READER_NP = 0,
  PTHREAD_RWLOCK_PREFER_WRITER_NP = 1,
  PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP = 2,
  PTHREAD_RWLOCK_DEFAULT_NP = ::PTHREAD_RWLOCK_PREFER_READER_NP
};
enum mcc_enum_anon_53
{
  PTHREAD_INHERIT_SCHED = 0,
  PTHREAD_EXPLICIT_SCHED = 1
};
enum mcc_enum_anon_54
{
  PTHREAD_SCOPE_SYSTEM = 0,
  PTHREAD_SCOPE_PROCESS = 1
};
enum mcc_enum_anon_55
{
  PTHREAD_PROCESS_PRIVATE = 0,
  PTHREAD_PROCESS_SHARED = 1
};
struct _pthread_cleanup_buffer;
struct  _pthread_cleanup_buffer
{
    void (*__routine)(void *);
    void *__arg;
    int __canceltype;
    struct _pthread_cleanup_buffer *__prev;
};
enum mcc_enum_anon_56
{
  PTHREAD_CANCEL_ENABLE = 0,
  PTHREAD_CANCEL_DISABLE = 1
};
enum mcc_enum_anon_57
{
  PTHREAD_CANCEL_DEFERRED = 0,
  PTHREAD_CANCEL_ASYNCHRONOUS = 1
};
extern "C"
{
  extern int pthread_create(::pthread_t *__restrict __newthread, const ::pthread_attr_t *__restrict __attr, void *(*__start_routine)(void *), void *__restrict __arg) throw()__attribute__((__nonnull__(1, 3)));
}
extern "C"
{
  extern void pthread_exit(void *__retval)__attribute__((__noreturn__));
}
extern "C"
{
  extern int pthread_join(::pthread_t __th, void **__thread_return);
}
extern "C"
{
  extern int pthread_tryjoin_np(::pthread_t __th, void **__thread_return) throw();
}
extern "C"
{
  extern int pthread_timedjoin_np(::pthread_t __th, void **__thread_return, const ::timespec *__abstime);
}
extern "C"
{
  extern int pthread_detach(::pthread_t __th) throw();
}
extern "C"
{
  extern ::pthread_t pthread_self() throw()__attribute__((__const__));
}
extern "C"
{
  extern int pthread_equal(::pthread_t __thread1, ::pthread_t __thread2) throw();
}
extern "C"
{
  extern int pthread_attr_init(::pthread_attr_t *__attr) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_attr_destroy(::pthread_attr_t *__attr) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_attr_getdetachstate(const ::pthread_attr_t *__attr, int *__detachstate) throw()__attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_attr_setdetachstate(::pthread_attr_t *__attr, int __detachstate) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_attr_getguardsize(const ::pthread_attr_t *__attr, ::size_t *__guardsize) throw()__attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_attr_setguardsize(::pthread_attr_t *__attr, ::size_t __guardsize) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_attr_getschedparam(const ::pthread_attr_t *__restrict __attr, ::sched_param *__restrict __param) throw()__attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_attr_setschedparam(::pthread_attr_t *__restrict __attr, const ::sched_param *__restrict __param) throw()__attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_attr_getschedpolicy(const ::pthread_attr_t *__restrict __attr, int *__restrict __policy) throw()__attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_attr_setschedpolicy(::pthread_attr_t *__attr, int __policy) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_attr_getinheritsched(const ::pthread_attr_t *__restrict __attr, int *__restrict __inherit) throw()__attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_attr_setinheritsched(::pthread_attr_t *__attr, int __inherit) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_attr_getscope(const ::pthread_attr_t *__restrict __attr, int *__restrict __scope) throw()__attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_attr_setscope(::pthread_attr_t *__attr, int __scope) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_attr_getstackaddr(const ::pthread_attr_t *__restrict __attr, void **__restrict __stackaddr) throw()__attribute__((__nonnull__(1, 2))) __attribute__((__deprecated__));
}
extern "C"
{
  extern int pthread_attr_setstackaddr(::pthread_attr_t *__attr, void *__stackaddr) throw()__attribute__((__nonnull__(1))) __attribute__((__deprecated__));
}
extern "C"
{
  extern int pthread_attr_getstacksize(const ::pthread_attr_t *__restrict __attr, ::size_t *__restrict __stacksize) throw()__attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_attr_setstacksize(::pthread_attr_t *__attr, ::size_t __stacksize) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_attr_getstack(const ::pthread_attr_t *__restrict __attr, void **__restrict __stackaddr, ::size_t *__restrict __stacksize) throw()__attribute__((__nonnull__(1, 2, 3)));
}
extern "C"
{
  extern int pthread_attr_setstack(::pthread_attr_t *__attr, void *__stackaddr, ::size_t __stacksize) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_attr_setaffinity_np(::pthread_attr_t *__attr, ::size_t __cpusetsize, const ::cpu_set_t *__cpuset) throw()__attribute__((__nonnull__(1, 3)));
}
extern "C"
{
  extern int pthread_attr_getaffinity_np(const ::pthread_attr_t *__attr, ::size_t __cpusetsize, ::cpu_set_t *__cpuset) throw()__attribute__((__nonnull__(1, 3)));
}
extern "C"
{
  extern int pthread_getattr_np(::pthread_t __th, ::pthread_attr_t *__attr) throw()__attribute__((__nonnull__(2)));
}
extern "C"
{
  extern int pthread_setschedparam(::pthread_t __target_thread, int __policy, const ::sched_param *__param) throw()__attribute__((__nonnull__(3)));
}
extern "C"
{
  extern int pthread_getschedparam(::pthread_t __target_thread, int *__restrict __policy, ::sched_param *__restrict __param) throw()__attribute__((__nonnull__(2, 3)));
}
extern "C"
{
  extern int pthread_setschedprio(::pthread_t __target_thread, int __prio) throw();
}
extern "C"
{
  extern int pthread_getconcurrency() throw();
}
extern "C"
{
  extern int pthread_setconcurrency(int __level) throw();
}
extern "C"
{
  extern int pthread_yield() throw();
}
extern "C"
{
  extern int pthread_setaffinity_np(::pthread_t __th, ::size_t __cpusetsize, const ::cpu_set_t *__cpuset) throw()__attribute__((__nonnull__(3)));
}
extern "C"
{
  extern int pthread_getaffinity_np(::pthread_t __th, ::size_t __cpusetsize, ::cpu_set_t *__cpuset) throw()__attribute__((__nonnull__(3)));
}
extern "C"
{
  extern int pthread_once(::pthread_once_t *__once_control, void (*__init_routine)())__attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_setcancelstate(int __state, int *__oldstate);
}
extern "C"
{
  extern int pthread_setcanceltype(int __type, int *__oldtype);
}
extern "C"
{
  extern int pthread_cancel(::pthread_t __th);
}
extern "C"
{
  extern void pthread_testcancel();
}
struct __attribute__((__aligned__))  __pthread_unwind_buf_t
{
    struct mcc_struct_anon_46;
    struct  mcc_struct_anon_46
    {
        ::__jmp_buf __cancel_jmp_buf;
        int __mask_was_saved;
    };
    ::__pthread_unwind_buf_t::mcc_struct_anon_46 __cancel_jmp_buf[1];
    void *__pad[4];
};
struct  __pthread_cleanup_frame
{
    void (*__cancel_routine)(void *);
    void *__cancel_arg;
    int __do_it;
    int __cancel_type;
};
class  __pthread_cleanup_class
{
    void (*__cancel_routine)(void *);
    void *__cancel_arg;
    int __do_it;
    int __cancel_type;
  public:
    inline __pthread_cleanup_class(void (*__fct)(void *), void *__arg)
      : __cancel_routine(__fct), __cancel_arg(__arg), __do_it(1)
    {
    }
    inline ~__pthread_cleanup_class()
    {
      if ((*this).__do_it)
        {
          (*this).__cancel_routine((*this).__cancel_arg);
        }
    }
    inline void __setdoit(int __newval)
    {
      (*this).__do_it = __newval;
    }
    inline void __defer()
    {
      ::pthread_setcanceltype(::PTHREAD_CANCEL_DEFERRED, &(*this).__cancel_type);
    }
    inline void __restore() const 
    {
      ::pthread_setcanceltype((*this).__cancel_type, 0);
    }
};
struct __jmp_buf_tag;
extern "C"
{
  extern int __sigsetjmp(::__jmp_buf_tag *__env, int __savemask) throw();
}
extern "C"
{
  extern int pthread_mutex_init(::pthread_mutex_t *__mutex, const ::pthread_mutexattr_t *__mutexattr) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_mutex_destroy(::pthread_mutex_t *__mutex) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_mutex_trylock(::pthread_mutex_t *__mutex) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_mutex_lock(::pthread_mutex_t *__mutex) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_mutex_timedlock(::pthread_mutex_t *__restrict __mutex, const ::timespec *__restrict __abstime) throw()__attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_mutex_unlock(::pthread_mutex_t *__mutex) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_mutex_getprioceiling(const ::pthread_mutex_t *__restrict __mutex, int *__restrict __prioceiling) throw()__attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_mutex_setprioceiling(::pthread_mutex_t *__restrict __mutex, int __prioceiling, int *__restrict __old_ceiling) throw()__attribute__((__nonnull__(1, 3)));
}
extern "C"
{
  extern int pthread_mutex_consistent_np(::pthread_mutex_t *__mutex) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_mutexattr_init(::pthread_mutexattr_t *__attr) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_mutexattr_destroy(::pthread_mutexattr_t *__attr) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_mutexattr_getpshared(const ::pthread_mutexattr_t *__restrict __attr, int *__restrict __pshared) throw()__attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_mutexattr_setpshared(::pthread_mutexattr_t *__attr, int __pshared) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_mutexattr_gettype(const ::pthread_mutexattr_t *__restrict __attr, int *__restrict __kind) throw()__attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_mutexattr_settype(::pthread_mutexattr_t *__attr, int __kind) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_mutexattr_getprotocol(const ::pthread_mutexattr_t *__restrict __attr, int *__restrict __protocol) throw()__attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_mutexattr_setprotocol(::pthread_mutexattr_t *__attr, int __protocol) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_mutexattr_getprioceiling(const ::pthread_mutexattr_t *__restrict __attr, int *__restrict __prioceiling) throw()__attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_mutexattr_setprioceiling(::pthread_mutexattr_t *__attr, int __prioceiling) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_mutexattr_getrobust(const ::pthread_mutexattr_t *__attr, int *__robustness) throw()__attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_mutexattr_getrobust_np(const ::pthread_mutexattr_t *__attr, int *__robustness) throw()__attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_mutexattr_setrobust(::pthread_mutexattr_t *__attr, int __robustness) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_mutexattr_setrobust_np(::pthread_mutexattr_t *__attr, int __robustness) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_rwlock_init(::pthread_rwlock_t *__restrict __rwlock, const ::pthread_rwlockattr_t *__restrict __attr) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_rwlock_destroy(::pthread_rwlock_t *__rwlock) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_rwlock_rdlock(::pthread_rwlock_t *__rwlock) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_rwlock_tryrdlock(::pthread_rwlock_t *__rwlock) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_rwlock_timedrdlock(::pthread_rwlock_t *__restrict __rwlock, const ::timespec *__restrict __abstime) throw()__attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_rwlock_wrlock(::pthread_rwlock_t *__rwlock) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_rwlock_trywrlock(::pthread_rwlock_t *__rwlock) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_rwlock_timedwrlock(::pthread_rwlock_t *__restrict __rwlock, const ::timespec *__restrict __abstime) throw()__attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_rwlock_unlock(::pthread_rwlock_t *__rwlock) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_rwlockattr_init(::pthread_rwlockattr_t *__attr) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_rwlockattr_destroy(::pthread_rwlockattr_t *__attr) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_rwlockattr_getpshared(const ::pthread_rwlockattr_t *__restrict __attr, int *__restrict __pshared) throw()__attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_rwlockattr_setpshared(::pthread_rwlockattr_t *__attr, int __pshared) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_rwlockattr_getkind_np(const ::pthread_rwlockattr_t *__restrict __attr, int *__restrict __pref) throw()__attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_rwlockattr_setkind_np(::pthread_rwlockattr_t *__attr, int __pref) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_cond_init(::pthread_cond_t *__restrict __cond, const ::pthread_condattr_t *__restrict __cond_attr) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_cond_destroy(::pthread_cond_t *__cond) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_cond_signal(::pthread_cond_t *__cond) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_cond_broadcast(::pthread_cond_t *__cond) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_cond_wait(::pthread_cond_t *__restrict __cond, ::pthread_mutex_t *__restrict __mutex)__attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_cond_timedwait(::pthread_cond_t *__restrict __cond, ::pthread_mutex_t *__restrict __mutex, const ::timespec *__restrict __abstime)__attribute__((__nonnull__(1, 2, 3)));
}
extern "C"
{
  extern int pthread_condattr_init(::pthread_condattr_t *__attr) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_condattr_destroy(::pthread_condattr_t *__attr) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_condattr_getpshared(const ::pthread_condattr_t *__restrict __attr, int *__restrict __pshared) throw()__attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_condattr_setpshared(::pthread_condattr_t *__attr, int __pshared) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_condattr_getclock(const ::pthread_condattr_t *__restrict __attr, ::__clockid_t *__restrict __clock_id) throw()__attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_condattr_setclock(::pthread_condattr_t *__attr, ::__clockid_t __clock_id) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_spin_init(::pthread_spinlock_t *__lock, int __pshared) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_spin_destroy(::pthread_spinlock_t *__lock) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_spin_lock(::pthread_spinlock_t *__lock) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_spin_trylock(::pthread_spinlock_t *__lock) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_spin_unlock(::pthread_spinlock_t *__lock) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_barrier_init(::pthread_barrier_t *__restrict __barrier, const ::pthread_barrierattr_t *__restrict __attr, unsigned int __count) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_barrier_destroy(::pthread_barrier_t *__barrier) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_barrier_wait(::pthread_barrier_t *__barrier) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_barrierattr_init(::pthread_barrierattr_t *__attr) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_barrierattr_destroy(::pthread_barrierattr_t *__attr) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_barrierattr_getpshared(const ::pthread_barrierattr_t *__restrict __attr, int *__restrict __pshared) throw()__attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_barrierattr_setpshared(::pthread_barrierattr_t *__attr, int __pshared) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_key_create(::pthread_key_t *__key, void (*__destr_function)(void *)) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_key_delete(::pthread_key_t __key) throw();
}
extern "C"
{
  extern void *pthread_getspecific(::pthread_key_t __key) throw();
}
extern "C"
{
  extern int pthread_setspecific(::pthread_key_t __key, const void *__pointer) throw();
}
extern "C"
{
  extern int pthread_getcpuclockid(::pthread_t __thread_id, ::__clockid_t *__clock_id) throw()__attribute__((__nonnull__(2)));
}
extern "C"
{
  extern int pthread_atfork(void (*__prepare)(), void (*__parent)(), void (*__child)()) throw();
}
typedef ::pthread_t __gthread_t;
typedef ::pthread_key_t __gthread_key_t;
typedef ::pthread_once_t __gthread_once_t;
typedef ::pthread_mutex_t __gthread_mutex_t;
typedef ::pthread_mutex_t __gthread_recursive_mutex_t;
typedef ::pthread_cond_t __gthread_cond_t;
typedef ::timespec __gthread_time_t;
static int __gthrw_pthread_once(::pthread_once_t *, void (*)()) throw()__attribute__((__weakref__("pthread_once")));
static void *__gthrw_pthread_getspecific(::pthread_key_t) throw()__attribute__((__weakref__("pthread_getspecific")));
static int __gthrw_pthread_setspecific(::pthread_key_t, const void *) throw()__attribute__((__weakref__("pthread_setspecific")));
static int __gthrw_pthread_create(::pthread_t *__restrict , const ::pthread_attr_t *__restrict , void *(*)(void *), void *__restrict ) throw()__attribute__((__weakref__("pthread_create")));
static int __gthrw_pthread_join(::pthread_t, void **) throw()__attribute__((__weakref__("pthread_join")));
static int __gthrw_pthread_equal(::pthread_t, ::pthread_t) throw()__attribute__((__weakref__("pthread_equal")));
static ::pthread_t __gthrw_pthread_self() throw()__attribute__((__weakref__("pthread_self")));
static int __gthrw_pthread_detach(::pthread_t) throw()__attribute__((__weakref__("pthread_detach")));
static int __gthrw_pthread_cancel(::pthread_t) throw()__attribute__((__weakref__("pthread_cancel")));
static int __gthrw_sched_yield() throw()__attribute__((__weakref__("sched_yield")));
static int __gthrw_pthread_mutex_lock(::pthread_mutex_t *) throw()__attribute__((__weakref__("pthread_mutex_lock")));
static int __gthrw_pthread_mutex_trylock(::pthread_mutex_t *) throw()__attribute__((__weakref__("pthread_mutex_trylock")));
static int __gthrw_pthread_mutex_timedlock(::pthread_mutex_t *__restrict , const ::timespec *__restrict ) throw()__attribute__((__weakref__("pthread_mutex_timedlock")));
static int __gthrw_pthread_mutex_unlock(::pthread_mutex_t *) throw()__attribute__((__weakref__("pthread_mutex_unlock")));
static int __gthrw_pthread_mutex_init(::pthread_mutex_t *, const ::pthread_mutexattr_t *) throw()__attribute__((__weakref__("pthread_mutex_init")));
static int __gthrw_pthread_mutex_destroy(::pthread_mutex_t *) throw()__attribute__((__weakref__("pthread_mutex_destroy")));
static int __gthrw_pthread_cond_init(::pthread_cond_t *__restrict , const ::pthread_condattr_t *__restrict ) throw()__attribute__((__weakref__("pthread_cond_init")));
static int __gthrw_pthread_cond_broadcast(::pthread_cond_t *) throw()__attribute__((__weakref__("pthread_cond_broadcast")));
static int __gthrw_pthread_cond_signal(::pthread_cond_t *) throw()__attribute__((__weakref__("pthread_cond_signal")));
static int __gthrw_pthread_cond_wait(::pthread_cond_t *__restrict , ::pthread_mutex_t *__restrict ) throw()__attribute__((__weakref__("pthread_cond_wait")));
static int __gthrw_pthread_cond_timedwait(::pthread_cond_t *__restrict , ::pthread_mutex_t *__restrict , const ::timespec *__restrict ) throw()__attribute__((__weakref__("pthread_cond_timedwait")));
static int __gthrw_pthread_cond_destroy(::pthread_cond_t *) throw()__attribute__((__weakref__("pthread_cond_destroy")));
static int __gthrw_pthread_key_create(::pthread_key_t *, void (*)(void *)) throw()__attribute__((__weakref__("pthread_key_create")));
static int __gthrw_pthread_key_delete(::pthread_key_t) throw()__attribute__((__weakref__("pthread_key_delete")));
static int __gthrw_pthread_mutexattr_init(::pthread_mutexattr_t *) throw()__attribute__((__weakref__("pthread_mutexattr_init")));
static int __gthrw_pthread_mutexattr_settype(::pthread_mutexattr_t *, int) throw()__attribute__((__weakref__("pthread_mutexattr_settype")));
static int __gthrw_pthread_mutexattr_destroy(::pthread_mutexattr_t *) throw()__attribute__((__weakref__("pthread_mutexattr_destroy")));
static inline int __gthread_active_p()
{
  static void *const __gthread_active_ptr((void *)&::__gthrw_pthread_cancel);
  return __gthread_active_ptr != 0;
}
static inline int __gthread_create(::__gthread_t *__threadid, void *(*__func)(void *), void *__args)
{
  return ::__gthrw_pthread_create(__threadid, 0L, __func, __args);
}
static inline int __gthread_join(::__gthread_t __threadid, void **__value_ptr)
{
  return ::__gthrw_pthread_join(__threadid, __value_ptr);
}
static inline int __gthread_detach(::__gthread_t __threadid)
{
  return ::__gthrw_pthread_detach(__threadid);
}
static inline int __gthread_equal(::__gthread_t __t1, ::__gthread_t __t2)
{
  return ::__gthrw_pthread_equal(__t1, __t2);
}
static inline ::__gthread_t __gthread_self()
{
  return ::__gthrw_pthread_self();
}
static inline int __gthread_yield()
{
  return ::__gthrw_sched_yield();
}
static inline int __gthread_once(::__gthread_once_t *__once, void (*__func)())
{
  if (::__gthread_active_p())
    {
      return ::__gthrw_pthread_once(__once, __func);
    }
  else
    {
      return  -1;
    }
}
static inline int __gthread_key_create(::__gthread_key_t *__key, void (*__dtor)(void *))
{
  return ::__gthrw_pthread_key_create(__key, __dtor);
}
static inline int __gthread_key_delete(::__gthread_key_t __key)
{
  return ::__gthrw_pthread_key_delete(__key);
}
static inline void *__gthread_getspecific(::__gthread_key_t __key)
{
  return ::__gthrw_pthread_getspecific(__key);
}
static inline int __gthread_setspecific(::__gthread_key_t __key, const void *__ptr)
{
  return ::__gthrw_pthread_setspecific(__key, __ptr);
}
static inline int __gthread_mutex_destroy(::__gthread_mutex_t *__mutex)
{
  if (::__gthread_active_p())
    {
      return ::__gthrw_pthread_mutex_destroy(__mutex);
    }
  else
    {
      return 0;
    }
}
static inline int __gthread_mutex_lock(::__gthread_mutex_t *__mutex)
{
  if (::__gthread_active_p())
    {
      return ::__gthrw_pthread_mutex_lock(__mutex);
    }
  else
    {
      return 0;
    }
}
static inline int __gthread_mutex_trylock(::__gthread_mutex_t *__mutex)
{
  if (::__gthread_active_p())
    {
      return ::__gthrw_pthread_mutex_trylock(__mutex);
    }
  else
    {
      return 0;
    }
}
static inline int __gthread_mutex_timedlock(::__gthread_mutex_t *__mutex, const ::__gthread_time_t *__abs_timeout)
{
  if (::__gthread_active_p())
    {
      return ::__gthrw_pthread_mutex_timedlock(__mutex, __abs_timeout);
    }
  else
    {
      return 0;
    }
}
static inline int __gthread_mutex_unlock(::__gthread_mutex_t *__mutex)
{
  if (::__gthread_active_p())
    {
      return ::__gthrw_pthread_mutex_unlock(__mutex);
    }
  else
    {
      return 0;
    }
}
static inline int __gthread_recursive_mutex_lock(::__gthread_recursive_mutex_t *__mutex)
{
  return ::__gthread_mutex_lock(__mutex);
}
static inline int __gthread_recursive_mutex_trylock(::__gthread_recursive_mutex_t *__mutex)
{
  return ::__gthread_mutex_trylock(__mutex);
}
static inline int __gthread_recursive_mutex_timedlock(::__gthread_recursive_mutex_t *__mutex, const ::__gthread_time_t *__abs_timeout)
{
  return ::__gthread_mutex_timedlock(__mutex, __abs_timeout);
}
static inline int __gthread_recursive_mutex_unlock(::__gthread_recursive_mutex_t *__mutex)
{
  return ::__gthread_mutex_unlock(__mutex);
}
static inline int __gthread_cond_broadcast(::__gthread_cond_t *__cond)
{
  return ::__gthrw_pthread_cond_broadcast(__cond);
}
static inline int __gthread_cond_signal(::__gthread_cond_t *__cond)
{
  return ::__gthrw_pthread_cond_signal(__cond);
}
static inline int __gthread_cond_wait(::__gthread_cond_t *__cond, ::__gthread_mutex_t *__mutex)
{
  return ::__gthrw_pthread_cond_wait(__cond, __mutex);
}
static inline int __gthread_cond_timedwait(::__gthread_cond_t *__cond, ::__gthread_mutex_t *__mutex, const ::__gthread_time_t *__abs_timeout)
{
  return ::__gthrw_pthread_cond_timedwait(__cond, __mutex, __abs_timeout);
}
static inline int __gthread_cond_wait_recursive(::__gthread_cond_t *__cond, ::__gthread_recursive_mutex_t *__mutex)
{
  return ::__gthread_cond_wait(__cond, __mutex);
}
static inline int __gthread_cond_timedwait_recursive(::__gthread_cond_t *__cond, ::__gthread_recursive_mutex_t *__mutex, const ::__gthread_time_t *__abs_timeout)
{
  return ::__gthread_cond_timedwait(__cond, __mutex, __abs_timeout);
}
static inline int __gthread_cond_destroy(::__gthread_cond_t *__cond)
{
  return ::__gthrw_pthread_cond_destroy(__cond);
}
#pragma GCC visibility pop
typedef int _Atomic_word;
namespace __gnu_cxx __attribute__((__visibility__("default"))) {
  static inline ::_Atomic_word __exchange_and_add(volatile ::_Atomic_word *__mem, int __val)
  {
    return __atomic_fetch_add(__mem, __val, 4);
  }
  static inline void __atomic_add(volatile ::_Atomic_word *__mem, int __val)
  {
    __atomic_fetch_add(__mem, __val, 4);
  }
  static inline ::_Atomic_word __exchange_and_add_single(::_Atomic_word *__mem, int __val)
  {
    ::_Atomic_word __result(*__mem);
    *__mem += __val;
    return __result;
  }
  static inline void __atomic_add_single(::_Atomic_word *__mem, int __val)
  {
    *__mem += __val;
  }
  static inline __attribute__((__unused__)) ::_Atomic_word __exchange_and_add_dispatch(::_Atomic_word *__mem, int __val)
  {
    if (::__gthread_active_p())
      {
        return ::__gnu_cxx::__exchange_and_add(__mem, __val);
      }
    else
      {
        return ::__gnu_cxx::__exchange_and_add_single(__mem, __val);
      }
  }
  static inline __attribute__((__unused__)) void __atomic_add_dispatch(::_Atomic_word *__mem, int __val)
  {
    if (::__gthread_active_p())
      {
        ::__gnu_cxx::__atomic_add(__mem, __val);
      }
    else
      {
        ::__gnu_cxx::__atomic_add_single(__mem, __val);
      }
  }
  using ::std::size_t;
  using ::std::ptrdiff_t;
  template < typename _Tp >
  class  new_allocator
  {
    public:
      template < typename _Tp1 >
      struct rebind;
      typedef ::std::size_t size_type;
      typedef ::std::ptrdiff_t difference_type;
      typedef _Tp *pointer;
      typedef const _Tp *const_pointer;
      typedef _Tp &reference;
      typedef const _Tp &const_reference;
      typedef _Tp value_type;
      template < typename _Tp1 >
      struct  rebind
      {
          typedef ::__gnu_cxx::new_allocator<_Tp1> other;
      };
      inline new_allocator() throw()
      {
      }
      inline new_allocator(const ::__gnu_cxx::new_allocator<_Tp> &) throw()
      {
      }
      template < typename _Tp1 >
      inline new_allocator(const ::__gnu_cxx::new_allocator<_Tp1> &) throw()
      {
      }
      inline ~new_allocator() throw()
      {
      }
      inline typename ::__gnu_cxx::new_allocator<_Tp>::pointer address(typename ::__gnu_cxx::new_allocator<_Tp>::reference __x) const 
      {
        return std::__addressof(__x);
      }
      inline typename ::__gnu_cxx::new_allocator<_Tp>::const_pointer address(typename ::__gnu_cxx::new_allocator<_Tp>::const_reference __x) const 
      {
        return std::__addressof(__x);
      }
      inline typename ::__gnu_cxx::new_allocator<_Tp>::pointer allocate(typename ::__gnu_cxx::new_allocator<_Tp>::size_type __n, const void *  = 0)
      {
        if (__n > this->max_size())
          {
            ::std::__throw_bad_alloc();
          }
        return static_cast<_Tp *>(::operator new(__n * sizeof(_Tp)));
      }
      inline void deallocate(typename ::__gnu_cxx::new_allocator<_Tp>::pointer __p, typename ::__gnu_cxx::new_allocator<_Tp>::size_type)
      {
        ::operator delete(__p);
      }
      inline typename ::__gnu_cxx::new_allocator<_Tp>::size_type max_size() const  throw()
      {
        return (::std::size_t) -1 / sizeof(_Tp);
      }
      inline void construct(typename ::__gnu_cxx::new_allocator<_Tp>::pointer __p, const _Tp &__val)
      {
        ::new ((void *)__p)_Tp(__val);
      }
      inline void destroy(typename ::__gnu_cxx::new_allocator<_Tp>::pointer __p)
      {
        __p->~_Tp();
      }
  };
  template < typename _Tp >
  inline bool operator ==(const ::__gnu_cxx::new_allocator<_Tp> &, const ::__gnu_cxx::new_allocator<_Tp> &);
  template < typename _Tp >
  inline bool operator ==(const ::__gnu_cxx::new_allocator<_Tp> &, const ::__gnu_cxx::new_allocator<_Tp> &)
  {
    return true;
  }
  template < typename _Tp >
  inline bool operator !=(const ::__gnu_cxx::new_allocator<_Tp> &, const ::__gnu_cxx::new_allocator<_Tp> &);
  template < typename _Tp >
  inline bool operator !=(const ::__gnu_cxx::new_allocator<_Tp> &, const ::__gnu_cxx::new_allocator<_Tp> &)
  {
    return false;
  }
}
namespace std __attribute__((__visibility__("default"))) {
  template < typename _Tp >
  class allocator;
  template <>
  class  allocator<void>
  {
    public:
      template < typename _Tp1 >
      struct rebind;
      typedef ::std::size_t size_type;
      typedef ::std::ptrdiff_t difference_type;
      typedef void *pointer;
      typedef const void *const_pointer;
      typedef void value_type;
      template < typename _Tp1 >
      struct  rebind
      {
          typedef ::std::allocator<_Tp1> other;
      };
  };
  template < typename _Tp >
  class  allocator : public ::__gnu_cxx::new_allocator<_Tp>
  {
    public:
      template < typename _Tp1 >
      struct rebind;
      typedef ::std::size_t size_type;
      typedef ::std::ptrdiff_t difference_type;
      typedef _Tp *pointer;
      typedef const _Tp *const_pointer;
      typedef _Tp &reference;
      typedef const _Tp &const_reference;
      typedef _Tp value_type;
      template < typename _Tp1 >
      struct  rebind
      {
          typedef ::std::allocator<_Tp1> other;
      };
      inline allocator() throw()
      {
      }
      inline allocator(const ::std::allocator<_Tp> &__a) throw()
        : __gnu_cxx::new_allocator<_Tp>(__a)
      {
      }
      template < typename _Tp1 >
      inline allocator(const ::std::allocator<_Tp1> &) throw()
      {
      }
      inline ~allocator() throw()
      {
      }
  };
  template < typename _T1, typename _T2 >
  inline bool operator ==(const ::std::allocator<_T1> &, const ::std::allocator<_T2> &);
  template < typename _T1, typename _T2 >
  inline bool operator ==(const ::std::allocator<_T1> &, const ::std::allocator<_T2> &)
  {
    return true;
  }
  template < typename _Tp >
  inline bool operator ==(const ::std::allocator<_Tp> &, const ::std::allocator<_Tp> &);
  template < typename _Tp >
  inline bool operator ==(const ::std::allocator<_Tp> &, const ::std::allocator<_Tp> &)
  {
    return true;
  }
  template < typename _T1, typename _T2 >
  inline bool operator !=(const ::std::allocator<_T1> &, const ::std::allocator<_T2> &);
  template < typename _T1, typename _T2 >
  inline bool operator !=(const ::std::allocator<_T1> &, const ::std::allocator<_T2> &)
  {
    return false;
  }
  template < typename _Tp >
  inline bool operator !=(const ::std::allocator<_Tp> &, const ::std::allocator<_Tp> &);
  template < typename _Tp >
  inline bool operator !=(const ::std::allocator<_Tp> &, const ::std::allocator<_Tp> &)
  {
    return false;
  }
extern template class ::std::allocator<char>;
extern template class ::std::allocator<wchar_t>;
  template < typename _Alloc, bool __nontype_tpl_param_1_1__ = __is_empty(_Alloc) >
  struct  __alloc_swap
  {
      static inline void _S_do_it(_Alloc &, _Alloc &)
      {
      }
  };
  template < typename _Alloc >
  struct  __alloc_swap<_Alloc, false>
  {
      static inline void _S_do_it(_Alloc &__one, _Alloc &__two)
      {
        if (__one != __two)
          {
            swap(__one, __two);
          }
      }
  };
  template < typename _Alloc, bool __nontype_tpl_param_1_1__ = __is_empty(_Alloc) >
  struct  __alloc_neq
  {
      static inline bool _S_do_it(const _Alloc &, const _Alloc &)
      {
        return false;
      }
  };
  template < typename _Alloc >
  struct  __alloc_neq<_Alloc, false>
  {
      static inline bool _S_do_it(const _Alloc &__one, const _Alloc &__two)
      {
        return __one != __two;
      }
  };
}
#pragma GCC visibility push(default)
namespace __cxxabiv1 {
  class  __forced_unwind
  {
      virtual ~__forced_unwind() throw();
      virtual void __pure_dummy() = 0 ;
    public:
  };
}
#pragma GCC visibility pop
namespace std __attribute__((__visibility__("default"))) {
  template < typename _CharT, typename _Traits >
  inline void __ostream_write(::std::basic_ostream<_CharT, _Traits> &__out, const _CharT *__s, ::std::streamsize __n);
  template < typename _CharT, typename _Traits >
  inline void __ostream_write(::std::basic_ostream<_CharT, _Traits> &__out, const _CharT *__s, ::std::streamsize __n)
  {
    typedef ::std::basic_ostream<_CharT, _Traits> __ostream_type;
    typedef typename ::std::basic_ostream<_CharT, _Traits>::ios_base __ios_base;
    const ::std::streamsize __put(__out.rdbuf()->sputn(__s, __n));
    if (__put != __n)
      {
        __out.setstate(__ios_base::badbit);
      }
  }
  template < typename _CharT, typename _Traits >
  inline void __ostream_fill(::std::basic_ostream<_CharT, _Traits> &__out, ::std::streamsize __n);
  template < typename _CharT, typename _Traits >
  inline void __ostream_fill(::std::basic_ostream<_CharT, _Traits> &__out, ::std::streamsize __n)
  {
    typedef ::std::basic_ostream<_CharT, _Traits> __ostream_type;
    typedef typename ::std::basic_ostream<_CharT, _Traits>::ios_base __ios_base;
    const _CharT __c = __out.fill();
    for (; __n > 0; --__n)
      {
        const typename _Traits::int_type __put = __out.rdbuf()->sputc(__c);
        if (_Traits::eq_int_type(__put, _Traits::eof()))
          {
            __out.setstate(__ios_base::badbit);
            break;
          }
      }
  }
  template < typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &__ostream_insert(::std::basic_ostream<_CharT, _Traits> &__out, const _CharT *__s, ::std::streamsize __n);
  template < typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &__ostream_insert(::std::basic_ostream<_CharT, _Traits> &__out, const _CharT *__s, ::std::streamsize __n)
  {
    typedef ::std::basic_ostream<_CharT, _Traits> __ostream_type;
    typedef typename ::std::basic_ostream<_CharT, _Traits>::ios_base __ios_base;
    typename ::std::basic_ostream<_CharT, _Traits>::sentry __cerb(__out);
    if (__cerb)
      {
        try
        {
          const ::std::streamsize __w(__out.width());
          if (__w > __n)
            {
              const bool __left = (__out.flags() & __ios_base::adjustfield) == __ios_base::left;
              if (!__left)
                {
                  __ostream_fill(__out, __w - __n);
                }
              if (__out.good())
                {
                  __ostream_write(__out, __s, __n);
                }
              if (__left && __out.good())
                {
                  __ostream_fill(__out, __w - __n);
                }
            }
          else
            {
              __ostream_write(__out, __s, __n);
            }
          __out.width(0);
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          __out._M_setstate(__ios_base::badbit);
          throw;
        }
        catch (...)
        {
          __out._M_setstate(__ios_base::badbit);
        }
      }
    return __out;
  }
extern template ::std::basic_ostream<char, ::std::char_traits<char> > &__ostream_insert(::std::basic_ostream<char, ::std::char_traits<char> > &, const char *, long int);
extern template ::std::basic_ostream<wchar_t, ::std::char_traits<wchar_t> > &__ostream_insert(::std::basic_ostream<wchar_t, ::std::char_traits<wchar_t> > &, const wchar_t *, long int);
  template < typename _Arg, typename _Result >
  struct  unary_function
  {
      typedef _Arg argument_type;
      typedef _Result result_type;
  };
  template < typename _Arg1, typename _Arg2, typename _Result >
  struct  binary_function
  {
      typedef _Arg1 first_argument_type;
      typedef _Arg2 second_argument_type;
      typedef _Result result_type;
  };
  template < typename _Tp >
  struct  plus : ::std::binary_function<_Tp, _Tp, _Tp>
  {
      inline _Tp operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x + __y;
      }
  };
  template < typename _Tp >
  struct  minus : ::std::binary_function<_Tp, _Tp, _Tp>
  {
      inline _Tp operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x - __y;
      }
  };
  template < typename _Tp >
  struct  multiplies : ::std::binary_function<_Tp, _Tp, _Tp>
  {
      inline _Tp operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x * __y;
      }
  };
  template < typename _Tp >
  struct  divides : ::std::binary_function<_Tp, _Tp, _Tp>
  {
      inline _Tp operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x / __y;
      }
  };
  template < typename _Tp >
  struct  modulus : ::std::binary_function<_Tp, _Tp, _Tp>
  {
      inline _Tp operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x % __y;
      }
  };
  template < typename _Tp >
  struct  negate : ::std::unary_function<_Tp, _Tp>
  {
      inline _Tp operator ()(const _Tp &__x) const 
      {
        return  -__x;
      }
  };
  template < typename _Tp >
  struct  equal_to : ::std::binary_function<_Tp, _Tp, bool>
  {
      inline bool operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x == __y;
      }
  };
  template < typename _Tp >
  struct  not_equal_to : ::std::binary_function<_Tp, _Tp, bool>
  {
      inline bool operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x != __y;
      }
  };
  template < typename _Tp >
  struct  greater : ::std::binary_function<_Tp, _Tp, bool>
  {
      inline bool operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x > __y;
      }
  };
  template < typename _Tp >
  struct  less : ::std::binary_function<_Tp, _Tp, bool>
  {
      inline bool operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x < __y;
      }
  };
  template < typename _Tp >
  struct  greater_equal : ::std::binary_function<_Tp, _Tp, bool>
  {
      inline bool operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x >= __y;
      }
  };
  template < typename _Tp >
  struct  less_equal : ::std::binary_function<_Tp, _Tp, bool>
  {
      inline bool operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x <= __y;
      }
  };
  template < typename _Tp >
  struct  logical_and : ::std::binary_function<_Tp, _Tp, bool>
  {
      inline bool operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x && __y;
      }
  };
  template < typename _Tp >
  struct  logical_or : ::std::binary_function<_Tp, _Tp, bool>
  {
      inline bool operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x || __y;
      }
  };
  template < typename _Tp >
  struct  logical_not : ::std::unary_function<_Tp, bool>
  {
      inline bool operator ()(const _Tp &__x) const 
      {
        return !__x;
      }
  };
  template < typename _Tp >
  struct  bit_and : ::std::binary_function<_Tp, _Tp, _Tp>
  {
      inline _Tp operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x & __y;
      }
  };
  template < typename _Tp >
  struct  bit_or : ::std::binary_function<_Tp, _Tp, _Tp>
  {
      inline _Tp operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x | __y;
      }
  };
  template < typename _Tp >
  struct  bit_xor : ::std::binary_function<_Tp, _Tp, _Tp>
  {
      inline _Tp operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x ^ __y;
      }
  };
  template < typename _Predicate >
  class  unary_negate : public ::std::unary_function<typename _Predicate::argument_type, bool>
  {
    protected:
      _Predicate _M_pred;
    public:
      inline explicit unary_negate(const _Predicate &__x)
        : _M_pred(__x)
      {
      }
      inline bool operator ()(const typename _Predicate::argument_type &__x) const 
      {
        return !_M_pred(__x);
      }
  };
  template < typename _Predicate >
  inline ::std::unary_negate<_Predicate> not1(const _Predicate &__pred);
  template < typename _Predicate >
  inline ::std::unary_negate<_Predicate> not1(const _Predicate &__pred)
  {
    return ::std::unary_negate<_Predicate>(__pred);
  }
  template < typename _Predicate >
  class  binary_negate : public ::std::binary_function<typename _Predicate::first_argument_type, typename _Predicate::second_argument_type, bool>
  {
    protected:
      _Predicate _M_pred;
    public:
      inline explicit binary_negate(const _Predicate &__x)
        : _M_pred(__x)
      {
      }
      inline bool operator ()(const typename _Predicate::first_argument_type &__x, const typename _Predicate::second_argument_type &__y) const 
      {
        return !_M_pred(__x, __y);
      }
  };
  template < typename _Predicate >
  inline ::std::binary_negate<_Predicate> not2(const _Predicate &__pred);
  template < typename _Predicate >
  inline ::std::binary_negate<_Predicate> not2(const _Predicate &__pred)
  {
    return ::std::binary_negate<_Predicate>(__pred);
  }
  template < typename _Arg, typename _Result >
  class  pointer_to_unary_function : public ::std::unary_function<_Arg, _Result>
  {
    protected:
      _Result (*_M_ptr)(_Arg);
    public:
      inline pointer_to_unary_function()
      {
      }
      inline explicit pointer_to_unary_function(_Result (*__x)(_Arg))
        : _M_ptr(__x)
      {
      }
      inline _Result operator ()(_Arg __x) const 
      {
        return _M_ptr(__x);
      }
  };
  template < typename _Arg, typename _Result >
  inline ::std::pointer_to_unary_function<_Arg, _Result> ptr_fun(_Result (*__x)(_Arg));
  template < typename _Arg, typename _Result >
  inline ::std::pointer_to_unary_function<_Arg, _Result> ptr_fun(_Result (*__x)(_Arg))
  {
    return ::std::pointer_to_unary_function<_Arg, _Result>(__x);
  }
  template < typename _Arg1, typename _Arg2, typename _Result >
  class  pointer_to_binary_function : public ::std::binary_function<_Arg1, _Arg2, _Result>
  {
    protected:
      _Result (*_M_ptr)(_Arg1, _Arg2);
    public:
      inline pointer_to_binary_function()
      {
      }
      inline explicit pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
        : _M_ptr(__x)
      {
      }
      inline _Result operator ()(_Arg1 __x, _Arg2 __y) const 
      {
        return _M_ptr(__x, __y);
      }
  };
  template < typename _Arg1, typename _Arg2, typename _Result >
  inline ::std::pointer_to_binary_function<_Arg1, _Arg2, _Result> ptr_fun(_Result (*__x)(_Arg1, _Arg2));
  template < typename _Arg1, typename _Arg2, typename _Result >
  inline ::std::pointer_to_binary_function<_Arg1, _Arg2, _Result> ptr_fun(_Result (*__x)(_Arg1, _Arg2))
  {
    return ::std::pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x);
  }
  template < typename _Tp >
  struct  _Identity : ::std::unary_function<_Tp, _Tp>
  {
      inline _Tp &operator ()(_Tp &__x) const 
      {
        return __x;
      }
      inline const _Tp &operator ()(const _Tp &__x) const 
      {
        return __x;
      }
  };
  template < typename _Pair >
  struct  _Select1st : ::std::unary_function<_Pair, typename _Pair::first_type>
  {
      inline typename _Pair::first_type &operator ()(_Pair &__x) const 
      {
        return __x.first;
      }
      inline const typename _Pair::first_type &operator ()(const _Pair &__x) const 
      {
        return __x.first;
      }
  };
  template < typename _Pair >
  struct  _Select2nd : ::std::unary_function<_Pair, typename _Pair::second_type>
  {
      inline typename _Pair::second_type &operator ()(_Pair &__x) const 
      {
        return __x.second;
      }
      inline const typename _Pair::second_type &operator ()(const _Pair &__x) const 
      {
        return __x.second;
      }
  };
  template < typename _Ret, typename _Tp >
  class  mem_fun_t : public ::std::unary_function<_Tp *, _Ret>
  {
    public:
      inline explicit mem_fun_t(_Ret (_Tp::*__pf)())
        : _M_f(__pf)
      {
      }
      inline _Ret operator ()(_Tp *__p) const 
      {
        return (__p->*_M_f)();
      }
    private:
      _Ret (_Tp::*_M_f)();
  };
  template < typename _Ret, typename _Tp >
  class  const_mem_fun_t : public ::std::unary_function<const _Tp *, _Ret>
  {
    public:
      inline explicit const_mem_fun_t(_Ret (_Tp::*__pf)() const )
        : _M_f(__pf)
      {
      }
      inline _Ret operator ()(const _Tp *__p) const 
      {
        return (__p->*_M_f)();
      }
    private:
      _Ret (_Tp::*_M_f)() const ;
  };
  template < typename _Ret, typename _Tp >
  class  mem_fun_ref_t : public ::std::unary_function<_Tp, _Ret>
  {
    public:
      inline explicit mem_fun_ref_t(_Ret (_Tp::*__pf)())
        : _M_f(__pf)
      {
      }
      inline _Ret operator ()(_Tp &__r) const 
      {
        return (__r.*_M_f)();
      }
    private:
      _Ret (_Tp::*_M_f)();
  };
  template < typename _Ret, typename _Tp >
  class  const_mem_fun_ref_t : public ::std::unary_function<_Tp, _Ret>
  {
    public:
      inline explicit const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const )
        : _M_f(__pf)
      {
      }
      inline _Ret operator ()(const _Tp &__r) const 
      {
        return (__r.*_M_f)();
      }
    private:
      _Ret (_Tp::*_M_f)() const ;
  };
  template < typename _Ret, typename _Tp, typename _Arg >
  class  mem_fun1_t : public ::std::binary_function<_Tp *, _Arg, _Ret>
  {
    public:
      inline explicit mem_fun1_t(_Ret (_Tp::*__pf)(_Arg))
        : _M_f(__pf)
      {
      }
      inline _Ret operator ()(_Tp *__p, _Arg __x) const 
      {
        return (__p->*_M_f)(__x);
      }
    private:
      _Ret (_Tp::*_M_f)(_Arg);
  };
  template < typename _Ret, typename _Tp, typename _Arg >
  class  const_mem_fun1_t : public ::std::binary_function<const _Tp *, _Arg, _Ret>
  {
    public:
      inline explicit const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const )
        : _M_f(__pf)
      {
      }
      inline _Ret operator ()(const _Tp *__p, _Arg __x) const 
      {
        return (__p->*_M_f)(__x);
      }
    private:
      _Ret (_Tp::*_M_f)(_Arg) const ;
  };
  template < typename _Ret, typename _Tp, typename _Arg >
  class  mem_fun1_ref_t : public ::std::binary_function<_Tp, _Arg, _Ret>
  {
    public:
      inline explicit mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg))
        : _M_f(__pf)
      {
      }
      inline _Ret operator ()(_Tp &__r, _Arg __x) const 
      {
        return (__r.*_M_f)(__x);
      }
    private:
      _Ret (_Tp::*_M_f)(_Arg);
  };
  template < typename _Ret, typename _Tp, typename _Arg >
  class  const_mem_fun1_ref_t : public ::std::binary_function<_Tp, _Arg, _Ret>
  {
    public:
      inline explicit const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const )
        : _M_f(__pf)
      {
      }
      inline _Ret operator ()(const _Tp &__r, _Arg __x) const 
      {
        return (__r.*_M_f)(__x);
      }
    private:
      _Ret (_Tp::*_M_f)(_Arg) const ;
  };
  template < typename _Ret, typename _Tp >
  inline ::std::mem_fun_t<_Ret, _Tp> mem_fun(_Ret (_Tp::*__f)());
  template < typename _Ret, typename _Tp >
  inline ::std::mem_fun_t<_Ret, _Tp> mem_fun(_Ret (_Tp::*__f)())
  {
    return ::std::mem_fun_t<_Ret, _Tp>(__f);
  }
  template < typename _Ret, typename _Tp >
  inline ::std::const_mem_fun_t<_Ret, _Tp> mem_fun(_Ret (_Tp::*__f)() const );
  template < typename _Ret, typename _Tp >
  inline ::std::const_mem_fun_t<_Ret, _Tp> mem_fun(_Ret (_Tp::*__f)() const )
  {
    return ::std::const_mem_fun_t<_Ret, _Tp>(__f);
  }
  template < typename _Ret, typename _Tp >
  inline ::std::mem_fun_ref_t<_Ret, _Tp> mem_fun_ref(_Ret (_Tp::*__f)());
  template < typename _Ret, typename _Tp >
  inline ::std::mem_fun_ref_t<_Ret, _Tp> mem_fun_ref(_Ret (_Tp::*__f)())
  {
    return ::std::mem_fun_ref_t<_Ret, _Tp>(__f);
  }
  template < typename _Ret, typename _Tp >
  inline ::std::const_mem_fun_ref_t<_Ret, _Tp> mem_fun_ref(_Ret (_Tp::*__f)() const );
  template < typename _Ret, typename _Tp >
  inline ::std::const_mem_fun_ref_t<_Ret, _Tp> mem_fun_ref(_Ret (_Tp::*__f)() const )
  {
    return ::std::const_mem_fun_ref_t<_Ret, _Tp>(__f);
  }
  template < typename _Ret, typename _Tp, typename _Arg >
  inline ::std::mem_fun1_t<_Ret, _Tp, _Arg> mem_fun(_Ret (_Tp::*__f)(_Arg));
  template < typename _Ret, typename _Tp, typename _Arg >
  inline ::std::mem_fun1_t<_Ret, _Tp, _Arg> mem_fun(_Ret (_Tp::*__f)(_Arg))
  {
    return ::std::mem_fun1_t<_Ret, _Tp, _Arg>(__f);
  }
  template < typename _Ret, typename _Tp, typename _Arg >
  inline ::std::const_mem_fun1_t<_Ret, _Tp, _Arg> mem_fun(_Ret (_Tp::*__f)(_Arg) const );
  template < typename _Ret, typename _Tp, typename _Arg >
  inline ::std::const_mem_fun1_t<_Ret, _Tp, _Arg> mem_fun(_Ret (_Tp::*__f)(_Arg) const )
  {
    return ::std::const_mem_fun1_t<_Ret, _Tp, _Arg>(__f);
  }
  template < typename _Ret, typename _Tp, typename _Arg >
  inline ::std::mem_fun1_ref_t<_Ret, _Tp, _Arg> mem_fun_ref(_Ret (_Tp::*__f)(_Arg));
  template < typename _Ret, typename _Tp, typename _Arg >
  inline ::std::mem_fun1_ref_t<_Ret, _Tp, _Arg> mem_fun_ref(_Ret (_Tp::*__f)(_Arg))
  {
    return ::std::mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f);
  }
  template < typename _Ret, typename _Tp, typename _Arg >
  inline ::std::const_mem_fun1_ref_t<_Ret, _Tp, _Arg> mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const );
  template < typename _Ret, typename _Tp, typename _Arg >
  inline ::std::const_mem_fun1_ref_t<_Ret, _Tp, _Arg> mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const )
  {
    return ::std::const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f);
  }
  template < typename _Operation >
  class  binder1st : public ::std::unary_function<typename _Operation::second_argument_type, typename _Operation::result_type>
  {
    protected:
      _Operation op;
      typename _Operation::first_argument_type value;
    public:
      inline binder1st(const _Operation &__x, const typename _Operation::first_argument_type &__y)
        : op(__x), value(__y)
      {
      }
      inline typename _Operation::result_type operator ()(const typename _Operation::second_argument_type &__x) const 
      {
        return op(value, __x);
      }
      inline typename _Operation::result_type operator ()(typename _Operation::second_argument_type &__x) const 
      {
        return op(value, __x);
      }
  };
  template < typename _Operation, typename _Tp >
  inline ::std::binder1st<_Operation> bind1st(const _Operation &__fn, const _Tp &__x);
  template < typename _Operation, typename _Tp >
  inline ::std::binder1st<_Operation> bind1st(const _Operation &__fn, const _Tp &__x)
  {
    typedef typename _Operation::first_argument_type _Arg1_type;
    return ::std::binder1st<_Operation>(__fn, _Arg1_type(__x));
  }
  template < typename _Operation >
  class  binder2nd : public ::std::unary_function<typename _Operation::first_argument_type, typename _Operation::result_type>
  {
    protected:
      _Operation op;
      typename _Operation::second_argument_type value;
    public:
      inline binder2nd(const _Operation &__x, const typename _Operation::second_argument_type &__y)
        : op(__x), value(__y)
      {
      }
      inline typename _Operation::result_type operator ()(const typename _Operation::first_argument_type &__x) const 
      {
        return op(__x, value);
      }
      inline typename _Operation::result_type operator ()(typename _Operation::first_argument_type &__x) const 
      {
        return op(__x, value);
      }
  };
  template < typename _Operation, typename _Tp >
  inline ::std::binder2nd<_Operation> bind2nd(const _Operation &__fn, const _Tp &__x);
  template < typename _Operation, typename _Tp >
  inline ::std::binder2nd<_Operation> bind2nd(const _Operation &__fn, const _Tp &__x)
  {
    typedef typename _Operation::second_argument_type _Arg2_type;
    return ::std::binder2nd<_Operation>(__fn, _Arg2_type(__x));
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  class  basic_string
  {
      struct _Rep_base;
      struct _Rep;
      struct _Alloc_hider;
      typedef typename _Alloc::template rebind< _CharT>::other _CharT_alloc_type;
    public:
      typedef _Traits traits_type;
      typedef typename _Traits::char_type value_type;
      typedef _Alloc allocator_type;
      typedef typename ::std::basic_string<_CharT, _Traits, _Alloc>::_CharT_alloc_type::size_type size_type;
      typedef typename ::std::basic_string<_CharT, _Traits, _Alloc>::_CharT_alloc_type::difference_type difference_type;
      typedef typename ::std::basic_string<_CharT, _Traits, _Alloc>::_CharT_alloc_type::reference reference;
      typedef typename ::std::basic_string<_CharT, _Traits, _Alloc>::_CharT_alloc_type::const_reference const_reference;
      typedef typename ::std::basic_string<_CharT, _Traits, _Alloc>::_CharT_alloc_type::pointer pointer;
      typedef typename ::std::basic_string<_CharT, _Traits, _Alloc>::_CharT_alloc_type::const_pointer const_pointer;
      typedef ::__gnu_cxx::__normal_iterator<typename ::std::basic_string<_CharT, _Traits, _Alloc>::pointer, ::std::basic_string<_CharT, _Traits, _Alloc> > iterator;
      typedef ::__gnu_cxx::__normal_iterator<typename ::std::basic_string<_CharT, _Traits, _Alloc>::const_pointer, ::std::basic_string<_CharT, _Traits, _Alloc> > const_iterator;
      typedef ::std::reverse_iterator<typename ::std::basic_string<_CharT, _Traits, _Alloc>::const_iterator> const_reverse_iterator;
      typedef ::std::reverse_iterator<typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator> reverse_iterator;
    private:
      struct  _Rep_base
      {
          typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type _M_length;
          typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type _M_capacity;
          ::_Atomic_word _M_refcount;
      };
      struct  _Rep : ::std::basic_string<_CharT, _Traits, _Alloc>::_Rep_base
      {
          typedef typename _Alloc::template rebind< char>::other _Raw_bytes_alloc;
          static const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type _S_max_size;
          static const _CharT _S_terminal;
          static typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type _S_empty_rep_storage[];
          static inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::_Rep &_S_empty_rep()
          {
            void *__p(reinterpret_cast<void *>(&_S_empty_rep_storage));
            return *reinterpret_cast<typename ::std::basic_string<_CharT, _Traits, _Alloc>::_Rep *>(__p);
          }
          inline bool _M_is_leaked() const 
          {
            return this->_M_refcount < 0;
          }
          inline bool _M_is_shared() const 
          {
            return this->_M_refcount > 0;
          }
          inline void _M_set_leaked()
          {
            this->_M_refcount =  -1;
          }
          inline void _M_set_sharable()
          {
            this->_M_refcount = 0;
          }
          inline void _M_set_length_and_sharable(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n)
          {
            if (__builtin_expect(this != &_S_empty_rep(), false))
              {
                this->_M_set_sharable();
                this->_M_length = __n;
                traits_type::assign(this->_M_refdata()[__n], _S_terminal);
              }
          }
          inline _CharT *_M_refdata() throw()
          {
            return reinterpret_cast<_CharT *>(this + 1);
          }
          inline _CharT *_M_grab(const _Alloc &__alloc1, const _Alloc &__alloc2)
          {
            return !_M_is_leaked() && __alloc1 == __alloc2 ? _M_refcopy() : _M_clone(__alloc1);
          }
          static typename ::std::basic_string<_CharT, _Traits, _Alloc>::_Rep *_S_create(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __capacity, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __old_capacity, const _Alloc &__alloc);
          inline void _M_dispose(const _Alloc &__a)
          {
            if (__builtin_expect(this != &_S_empty_rep(), false))
              {
                ;
                if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,  -1) <= 0)
                  {
                    ;
                    _M_destroy(__a);
                  }
              }
          }
          void _M_destroy(const _Alloc &__a) throw();
          inline _CharT *_M_refcopy() throw()
          {
            if (__builtin_expect(this != &_S_empty_rep(), false))
              {
                __gnu_cxx::__atomic_add_dispatch(&this->_M_refcount, 1);
              }
            return _M_refdata();
          }
          _CharT *_M_clone(const _Alloc &__alloc, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __res  = 0);
      };
      struct  _Alloc_hider : _Alloc
      {
          inline _Alloc_hider(_CharT *__dat, const _Alloc &__a)
            : _Alloc(__a), _M_p(__dat)
          {
          }
          _CharT *_M_p;
      };
    public:
      static const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type npos = static_cast<typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type>( -1);
    private:
      mutable typename ::std::basic_string<_CharT, _Traits, _Alloc>::_Alloc_hider _M_dataplus;
      inline _CharT *_M_data() const 
      {
        return _M_dataplus._M_p;
      }
      inline _CharT *_M_data(_CharT *__p)
      {
        return _M_dataplus._M_p = __p;
      }
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::_Rep *_M_rep() const 
      {
        return &reinterpret_cast<typename ::std::basic_string<_CharT, _Traits, _Alloc>::_Rep *>(_M_data())[ -1];
      }
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator _M_ibegin() const 
      {
        return typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator(_M_data());
      }
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator _M_iend() const 
      {
        return typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator(_M_data() + this->size());
      }
      inline void _M_leak()
      {
        if (!_M_rep()->_M_is_leaked())
          {
            _M_leak_hard();
          }
      }
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type _M_check(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, const char *__s) const 
      {
        if (__pos > this->size())
          {
            ::std::__throw_out_of_range(__s);
          }
        return __pos;
      }
      inline void _M_check_length(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n1, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n2, const char *__s) const 
      {
        if (this->max_size() - (this->size() - __n1) < __n2)
          {
            ::std::__throw_length_error(__s);
          }
      }
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type _M_limit(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __off) const 
      {
        const bool __testoff = __off < this->size() - __pos;
        return __testoff ? __off : this->size() - __pos;
      }
      inline bool _M_disjunct(const _CharT *__s) const 
      {
        return ::std::less<const _CharT *>()(__s, _M_data()) || ::std::less<const _CharT *>()(_M_data() + this->size(), __s);
      }
      static inline void _M_copy(_CharT *__d, const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n)
      {
        if (__n == 1)
          {
            traits_type::assign(*__d, *__s);
          }
        else
          {
            traits_type::copy(__d, __s, __n);
          }
      }
      static inline void _M_move(_CharT *__d, const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n)
      {
        if (__n == 1)
          {
            traits_type::assign(*__d, *__s);
          }
        else
          {
            traits_type::move(__d, __s, __n);
          }
      }
      static inline void _M_assign(_CharT *__d, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n, _CharT __c)
      {
        if (__n == 1)
          {
            traits_type::assign(*__d, __c);
          }
        else
          {
            traits_type::assign(__d, __n, __c);
          }
      }
      template < typename _Iterator >
      static inline void _S_copy_chars(_CharT *__p, _Iterator __k1, _Iterator __k2)
      {
        for (; __k1 != __k2; (++__k1, ++__p))
          {
            traits_type::assign(*__p, *__k1);
          }
      }
      static inline void _S_copy_chars(_CharT *__p, typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __k1, typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __k2)
      {
        _S_copy_chars(__p, __k1.base(), __k2.base());
      }
      static inline void _S_copy_chars(_CharT *__p, typename ::std::basic_string<_CharT, _Traits, _Alloc>::const_iterator __k1, typename ::std::basic_string<_CharT, _Traits, _Alloc>::const_iterator __k2)
      {
        _S_copy_chars(__p, __k1.base(), __k2.base());
      }
      static inline void _S_copy_chars(_CharT *__p, _CharT *__k1, _CharT *__k2)
      {
        _M_copy(__p, __k1, __k2 - __k1);
      }
      static inline void _S_copy_chars(_CharT *__p, const _CharT *__k1, const _CharT *__k2)
      {
        _M_copy(__p, __k1, __k2 - __k1);
      }
      static inline int _S_compare(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n1, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n2)
      {
        const typename ::std::basic_string<_CharT, _Traits, _Alloc>::difference_type __d = typename ::std::basic_string<_CharT, _Traits, _Alloc>::difference_type(__n1 - __n2);
        if (__d > ::__gnu_cxx::__numeric_traits_integer<int>::__max)
          {
            return ::__gnu_cxx::__numeric_traits_integer<int>::__max;
          }
        else
          {
            if (__d < ::__gnu_cxx::__numeric_traits_integer<int>::__min)
              {
                return ::__gnu_cxx::__numeric_traits_integer<int>::__min;
              }
            else
              {
                return (int)__d;
              }
          }
      }
      void _M_mutate(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __len1, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __len2);
      void _M_leak_hard();
      static inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::_Rep &_S_empty_rep()
      {
        return _Rep::_S_empty_rep();
      }
    public:
      inline basic_string()
        : _M_dataplus(_S_empty_rep()._M_refdata(), _Alloc())
      {
      }
      explicit basic_string(const _Alloc &__a);
      basic_string(const ::std::basic_string<_CharT, _Traits, _Alloc> &__str);
      basic_string(const ::std::basic_string<_CharT, _Traits, _Alloc> &__str, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n  = npos);
      basic_string(const ::std::basic_string<_CharT, _Traits, _Alloc> &__str, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n, const _Alloc &__a);
      basic_string(const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n, const _Alloc &__a  = _Alloc());
      basic_string(const _CharT *__s, const _Alloc &__a  = _Alloc());
      basic_string(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n, _CharT __c, const _Alloc &__a  = _Alloc());
      template < typename _InputIterator >
      basic_string(_InputIterator __beg, _InputIterator __end, const _Alloc &__a  = _Alloc());
      inline ~basic_string()
      {
        _M_rep()->_M_dispose(this->get_allocator());
      }
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &operator =(const ::std::basic_string<_CharT, _Traits, _Alloc> &__str)
      {
        return this->assign(__str);
      }
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &operator =(const _CharT *__s)
      {
        return this->assign(__s);
      }
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &operator =(_CharT __c)
      {
        this->assign(1, __c);
        return *this;
      }
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator begin()
      {
        _M_leak();
        return typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator(_M_data());
      }
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::const_iterator begin() const 
      {
        return typename ::std::basic_string<_CharT, _Traits, _Alloc>::const_iterator(_M_data());
      }
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator end()
      {
        _M_leak();
        return typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator(_M_data() + this->size());
      }
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::const_iterator end() const 
      {
        return typename ::std::basic_string<_CharT, _Traits, _Alloc>::const_iterator(_M_data() + this->size());
      }
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::reverse_iterator rbegin()
      {
        return typename ::std::basic_string<_CharT, _Traits, _Alloc>::reverse_iterator(this->end());
      }
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::const_reverse_iterator rbegin() const 
      {
        return typename ::std::basic_string<_CharT, _Traits, _Alloc>::const_reverse_iterator(this->end());
      }
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::reverse_iterator rend()
      {
        return typename ::std::basic_string<_CharT, _Traits, _Alloc>::reverse_iterator(this->begin());
      }
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::const_reverse_iterator rend() const 
      {
        return typename ::std::basic_string<_CharT, _Traits, _Alloc>::const_reverse_iterator(this->begin());
      }
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type size() const 
      {
        return _M_rep()->_M_length;
      }
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type length() const 
      {
        return _M_rep()->_M_length;
      }
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type max_size() const 
      {
        return _Rep::_S_max_size;
      }
      void resize(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n, _CharT __c);
      inline void resize(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n)
      {
        this->resize(__n, _CharT());
      }
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type capacity() const 
      {
        return _M_rep()->_M_capacity;
      }
      void reserve(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __res  = 0);
      inline void clear()
      {
        _M_mutate(0, this->size(), 0);
      }
      inline bool empty() const 
      {
        return this->size() == 0;
      }
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::const_reference operator [](typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos) const 
      {
        ;
        return _M_data()[__pos];
      }
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::reference operator [](typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos)
      {
        ;
        ;
        _M_leak();
        return _M_data()[__pos];
      }
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::const_reference at(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n) const 
      {
        if (__n >= this->size())
          {
            ::std::__throw_out_of_range("basic_string::at");
          }
        return _M_data()[__n];
      }
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::reference at(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n)
      {
        if (__n >= size())
          {
            ::std::__throw_out_of_range("basic_string::at");
          }
        _M_leak();
        return _M_data()[__n];
      }
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &operator +=(const ::std::basic_string<_CharT, _Traits, _Alloc> &__str)
      {
        return this->append(__str);
      }
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &operator +=(const _CharT *__s)
      {
        return this->append(__s);
      }
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &operator +=(_CharT __c)
      {
        this->push_back(__c);
        return *this;
      }
      ::std::basic_string<_CharT, _Traits, _Alloc> &append(const ::std::basic_string<_CharT, _Traits, _Alloc> &__str);
      ::std::basic_string<_CharT, _Traits, _Alloc> &append(const ::std::basic_string<_CharT, _Traits, _Alloc> &__str, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n);
      ::std::basic_string<_CharT, _Traits, _Alloc> &append(const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n);
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &append(const _CharT *__s)
      {
        ;
        return this->append(__s, traits_type::length(__s));
      }
      ::std::basic_string<_CharT, _Traits, _Alloc> &append(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n, _CharT __c);
      template < typename _InputIterator >
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &append(_InputIterator __first, _InputIterator __last)
      {
        return this->replace(_M_iend(), _M_iend(), __first, __last);
      }
      inline void push_back(_CharT __c)
      {
        const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __len = 1 + this->size();
        if (__len > this->capacity() || _M_rep()->_M_is_shared())
          {
            this->reserve(__len);
          }
        traits_type::assign(_M_data()[this->size()], __c);
        _M_rep()->_M_set_length_and_sharable(__len);
      }
      ::std::basic_string<_CharT, _Traits, _Alloc> &assign(const ::std::basic_string<_CharT, _Traits, _Alloc> &__str);
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &assign(const ::std::basic_string<_CharT, _Traits, _Alloc> &__str, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n)
      {
        return this->assign(__str._M_data() + __str._M_check(__pos, "basic_string::assign"), __str._M_limit(__pos, __n));
      }
      ::std::basic_string<_CharT, _Traits, _Alloc> &assign(const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n);
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &assign(const _CharT *__s)
      {
        ;
        return this->assign(__s, traits_type::length(__s));
      }
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &assign(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n, _CharT __c)
      {
        return _M_replace_aux(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type(0), this->size(), __n, __c);
      }
      template < typename _InputIterator >
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &assign(_InputIterator __first, _InputIterator __last)
      {
        return this->replace(_M_ibegin(), _M_iend(), __first, __last);
      }
      inline void insert(typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __p, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n, _CharT __c)
      {
        this->replace(__p, __p, __n, __c);
      }
      template < typename _InputIterator >
      inline void insert(typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __p, _InputIterator __beg, _InputIterator __end)
      {
        this->replace(__p, __p, __beg, __end);
      }
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &insert(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos1, const ::std::basic_string<_CharT, _Traits, _Alloc> &__str)
      {
        return this->insert(__pos1, __str, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type(0), __str.size());
      }
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &insert(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos1, const ::std::basic_string<_CharT, _Traits, _Alloc> &__str, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos2, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n)
      {
        return this->insert(__pos1, __str._M_data() + __str._M_check(__pos2, "basic_string::insert"), __str._M_limit(__pos2, __n));
      }
      ::std::basic_string<_CharT, _Traits, _Alloc> &insert(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n);
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &insert(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, const _CharT *__s)
      {
        ;
        return this->insert(__pos, __s, traits_type::length(__s));
      }
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &insert(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n, _CharT __c)
      {
        return _M_replace_aux(_M_check(__pos, "basic_string::insert"), typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type(0), __n, __c);
      }
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator insert(typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __p, _CharT __c)
      {
        ;
        const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos = __p - _M_ibegin();
        _M_replace_aux(__pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type(0), typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type(1), __c);
        _M_rep()->_M_set_leaked();
        return typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator(_M_data() + __pos);
      }
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &erase(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = 0, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n  = npos)
      {
        _M_mutate(_M_check(__pos, "basic_string::erase"), _M_limit(__pos, __n), typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type(0));
        return *this;
      }
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator erase(typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __position)
      {
        ;
        const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos = __position - _M_ibegin();
        _M_mutate(__pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type(1), typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type(0));
        _M_rep()->_M_set_leaked();
        return typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator(_M_data() + __pos);
      }
      typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator erase(typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __first, typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __last);
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &replace(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n, const ::std::basic_string<_CharT, _Traits, _Alloc> &__str)
      {
        return this->replace(__pos, __n, __str._M_data(), __str.size());
      }
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &replace(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos1, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n1, const ::std::basic_string<_CharT, _Traits, _Alloc> &__str, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos2, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n2)
      {
        return this->replace(__pos1, __n1, __str._M_data() + __str._M_check(__pos2, "basic_string::replace"), __str._M_limit(__pos2, __n2));
      }
      ::std::basic_string<_CharT, _Traits, _Alloc> &replace(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n1, const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n2);
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &replace(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n1, const _CharT *__s)
      {
        ;
        return this->replace(__pos, __n1, __s, traits_type::length(__s));
      }
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &replace(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n1, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n2, _CharT __c)
      {
        return _M_replace_aux(_M_check(__pos, "basic_string::replace"), _M_limit(__pos, __n1), __n2, __c);
      }
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &replace(typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __i1, typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __i2, const ::std::basic_string<_CharT, _Traits, _Alloc> &__str)
      {
        return this->replace(__i1, __i2, __str._M_data(), __str.size());
      }
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &replace(typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __i1, typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __i2, const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n)
      {
        ;
        return this->replace(__i1 - _M_ibegin(), __i2 - __i1, __s, __n);
      }
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &replace(typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __i1, typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __i2, const _CharT *__s)
      {
        ;
        return this->replace(__i1, __i2, __s, traits_type::length(__s));
      }
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &replace(typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __i1, typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __i2, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n, _CharT __c)
      {
        ;
        return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __c);
      }
      template < typename _InputIterator >
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &replace(typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __i1, typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __i2, _InputIterator __k1, _InputIterator __k2)
      {
        ;
        ;
        typedef typename ::std::__is_integer<_InputIterator>::__type _Integral;
        return _M_replace_dispatch(__i1, __i2, __k1, __k2, _Integral());
      }
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &replace(typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __i1, typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __i2, _CharT *__k1, _CharT *__k2)
      {
        ;
        ;
        return this->replace(__i1 - _M_ibegin(), __i2 - __i1, __k1, __k2 - __k1);
      }
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &replace(typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __i1, typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __i2, const _CharT *__k1, const _CharT *__k2)
      {
        ;
        ;
        return this->replace(__i1 - _M_ibegin(), __i2 - __i1, __k1, __k2 - __k1);
      }
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &replace(typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __i1, typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __i2, typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __k1, typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __k2)
      {
        ;
        ;
        return this->replace(__i1 - _M_ibegin(), __i2 - __i1, __k1.base(), __k2 - __k1);
      }
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &replace(typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __i1, typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __i2, typename ::std::basic_string<_CharT, _Traits, _Alloc>::const_iterator __k1, typename ::std::basic_string<_CharT, _Traits, _Alloc>::const_iterator __k2)
      {
        ;
        ;
        return this->replace(__i1 - _M_ibegin(), __i2 - __i1, __k1.base(), __k2 - __k1);
      }
    private:
      template < typename _Integer >
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &_M_replace_dispatch(typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __i1, typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __i2, _Integer __n, _Integer __val, ::std::__true_type)
      {
        return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __val);
      }
      template < typename _InputIterator >
      ::std::basic_string<_CharT, _Traits, _Alloc> &_M_replace_dispatch(typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __i1, typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __i2, _InputIterator __k1, _InputIterator __k2, ::std::__false_type);
      ::std::basic_string<_CharT, _Traits, _Alloc> &_M_replace_aux(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos1, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n1, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n2, _CharT __c);
      ::std::basic_string<_CharT, _Traits, _Alloc> &_M_replace_safe(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos1, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n1, const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n2);
      template < typename _InIterator >
      static inline _CharT *_S_construct_aux(_InIterator __beg, _InIterator __end, const _Alloc &__a, ::std::__false_type)
      {
        typedef typename ::std::iterator_traits<_InIterator>::iterator_category _Tag;
        return _S_construct(__beg, __end, __a, _Tag());
      }
      template < typename _Integer >
      static inline _CharT *_S_construct_aux(_Integer __beg, _Integer __end, const _Alloc &__a, ::std::__true_type)
      {
        return _S_construct_aux_2(static_cast<typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type>(__beg), __end, __a);
      }
      static inline _CharT *_S_construct_aux_2(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __req, _CharT __c, const _Alloc &__a)
      {
        return _S_construct(__req, __c, __a);
      }
      template < typename _InIterator >
      static inline _CharT *_S_construct(_InIterator __beg, _InIterator __end, const _Alloc &__a)
      {
        typedef typename ::std::__is_integer<_InIterator>::__type _Integral;
        return _S_construct_aux(__beg, __end, __a, _Integral());
      }
      template < typename _InIterator >
      static _CharT *_S_construct(_InIterator __beg, _InIterator __end, const _Alloc &__a, ::std::input_iterator_tag);
      template < typename _FwdIterator >
      static _CharT *_S_construct(_FwdIterator __beg, _FwdIterator __end, const _Alloc &__a, ::std::forward_iterator_tag);
      static _CharT *_S_construct(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n, _CharT __c, const _Alloc &__a);
    public:
      typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type copy(_CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = 0) const ;
      void swap(::std::basic_string<_CharT, _Traits, _Alloc> &__s);
      inline const _CharT *c_str() const 
      {
        return _M_data();
      }
      inline const _CharT *data() const 
      {
        return _M_data();
      }
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::allocator_type get_allocator() const 
      {
        return _M_dataplus;
      }
      typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type find(const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n) const ;
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type find(const ::std::basic_string<_CharT, _Traits, _Alloc> &__str, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = 0) const 
      {
        return this->find(__str.data(), __pos, __str.size());
      }
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type find(const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = 0) const 
      {
        ;
        return this->find(__s, __pos, traits_type::length(__s));
      }
      typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type find(_CharT __c, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = 0) const ;
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type rfind(const ::std::basic_string<_CharT, _Traits, _Alloc> &__str, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = npos) const 
      {
        return this->rfind(__str.data(), __pos, __str.size());
      }
      typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type rfind(const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n) const ;
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type rfind(const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = npos) const 
      {
        ;
        return this->rfind(__s, __pos, traits_type::length(__s));
      }
      typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type rfind(_CharT __c, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = npos) const ;
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type find_first_of(const ::std::basic_string<_CharT, _Traits, _Alloc> &__str, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = 0) const 
      {
        return this->find_first_of(__str.data(), __pos, __str.size());
      }
      typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type find_first_of(const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n) const ;
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type find_first_of(const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = 0) const 
      {
        ;
        return this->find_first_of(__s, __pos, traits_type::length(__s));
      }
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type find_first_of(_CharT __c, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = 0) const 
      {
        return this->find(__c, __pos);
      }
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type find_last_of(const ::std::basic_string<_CharT, _Traits, _Alloc> &__str, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = npos) const 
      {
        return this->find_last_of(__str.data(), __pos, __str.size());
      }
      typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type find_last_of(const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n) const ;
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type find_last_of(const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = npos) const 
      {
        ;
        return this->find_last_of(__s, __pos, traits_type::length(__s));
      }
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type find_last_of(_CharT __c, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = npos) const 
      {
        return this->rfind(__c, __pos);
      }
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type find_first_not_of(const ::std::basic_string<_CharT, _Traits, _Alloc> &__str, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = 0) const 
      {
        return this->find_first_not_of(__str.data(), __pos, __str.size());
      }
      typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type find_first_not_of(const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n) const ;
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type find_first_not_of(const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = 0) const 
      {
        ;
        return this->find_first_not_of(__s, __pos, traits_type::length(__s));
      }
      typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type find_first_not_of(_CharT __c, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = 0) const ;
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type find_last_not_of(const ::std::basic_string<_CharT, _Traits, _Alloc> &__str, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = npos) const 
      {
        return this->find_last_not_of(__str.data(), __pos, __str.size());
      }
      typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type find_last_not_of(const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n) const ;
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type find_last_not_of(const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = npos) const 
      {
        ;
        return this->find_last_not_of(__s, __pos, traits_type::length(__s));
      }
      typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type find_last_not_of(_CharT __c, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = npos) const ;
      inline ::std::basic_string<_CharT, _Traits, _Alloc> substr(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = 0, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n  = npos) const 
      {
        return ::std::basic_string<_CharT, _Traits, _Alloc>(*this, _M_check(__pos, "basic_string::substr"), __n);
      }
      inline int compare(const ::std::basic_string<_CharT, _Traits, _Alloc> &__str) const 
      {
        const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __size = this->size();
        const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __osize = __str.size();
        const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __len = std::min(__size, __osize);
        int __r(traits_type::compare(_M_data(), __str.data(), __len));
        if (!__r)
          {
            __r = _S_compare(__size, __osize);
          }
        return __r;
      }
      int compare(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n, const ::std::basic_string<_CharT, _Traits, _Alloc> &__str) const ;
      int compare(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos1, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n1, const ::std::basic_string<_CharT, _Traits, _Alloc> &__str, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos2, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n2) const ;
      int compare(const _CharT *__s) const ;
      int compare(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n1, const _CharT *__s) const ;
      int compare(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n1, const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n2) const ;
  };
  template < typename _CharT, typename _Traits, typename _Alloc >
  ::std::basic_string<_CharT, _Traits, _Alloc> operator +(const ::std::basic_string<_CharT, _Traits, _Alloc> &__lhs, const ::std::basic_string<_CharT, _Traits, _Alloc> &__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  ::std::basic_string<_CharT, _Traits, _Alloc> operator +(const ::std::basic_string<_CharT, _Traits, _Alloc> &__lhs, const ::std::basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    ::std::basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
    __str.append(__rhs);
    return __str;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  ::std::basic_string<_CharT, _Traits, _Alloc> operator +(const _CharT *__lhs, const ::std::basic_string<_CharT, _Traits, _Alloc> &__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  ::std::basic_string<_CharT, _Traits, _Alloc> operator +(_CharT __lhs, const ::std::basic_string<_CharT, _Traits, _Alloc> &__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline ::std::basic_string<_CharT, _Traits, _Alloc> operator +(const ::std::basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline ::std::basic_string<_CharT, _Traits, _Alloc> operator +(const ::std::basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs)
  {
    ::std::basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
    __str.append(__rhs);
    return __str;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline ::std::basic_string<_CharT, _Traits, _Alloc> operator +(const ::std::basic_string<_CharT, _Traits, _Alloc> &__lhs, _CharT __rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline ::std::basic_string<_CharT, _Traits, _Alloc> operator +(const ::std::basic_string<_CharT, _Traits, _Alloc> &__lhs, _CharT __rhs)
  {
    typedef ::std::basic_string<_CharT, _Traits, _Alloc> __string_type;
    typedef typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __size_type;
    __string_type __str(__lhs);
    __str.append(__size_type(1), __rhs);
    return __str;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator ==(const ::std::basic_string<_CharT, _Traits, _Alloc> &__lhs, const ::std::basic_string<_CharT, _Traits, _Alloc> &__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator ==(const ::std::basic_string<_CharT, _Traits, _Alloc> &__lhs, const ::std::basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    return __lhs.compare(__rhs) == 0;
  }
  template < typename _CharT >
  inline typename ::__gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type operator ==(const ::std::basic_string<_CharT, ::std::char_traits<_CharT>, ::std::allocator<_CharT> > &__lhs, const ::std::basic_string<_CharT, ::std::char_traits<_CharT>, ::std::allocator<_CharT> > &__rhs);
  template < typename _CharT >
  inline typename ::__gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type operator ==(const ::std::basic_string<_CharT, ::std::char_traits<_CharT>, ::std::allocator<_CharT> > &__lhs, const ::std::basic_string<_CharT, ::std::char_traits<_CharT>, ::std::allocator<_CharT> > &__rhs)
  {
    return __lhs.size() == __rhs.size() && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(), __lhs.size());
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator ==(const _CharT *__lhs, const ::std::basic_string<_CharT, _Traits, _Alloc> &__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator ==(const _CharT *__lhs, const ::std::basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    return __rhs.compare(__lhs) == 0;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator ==(const ::std::basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator ==(const ::std::basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs)
  {
    return __lhs.compare(__rhs) == 0;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator !=(const ::std::basic_string<_CharT, _Traits, _Alloc> &__lhs, const ::std::basic_string<_CharT, _Traits, _Alloc> &__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator !=(const ::std::basic_string<_CharT, _Traits, _Alloc> &__lhs, const ::std::basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    return !(__lhs == __rhs);
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator !=(const _CharT *__lhs, const ::std::basic_string<_CharT, _Traits, _Alloc> &__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator !=(const _CharT *__lhs, const ::std::basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    return !(__lhs == __rhs);
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator !=(const ::std::basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator !=(const ::std::basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs)
  {
    return !(__lhs == __rhs);
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator <(const ::std::basic_string<_CharT, _Traits, _Alloc> &__lhs, const ::std::basic_string<_CharT, _Traits, _Alloc> &__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator <(const ::std::basic_string<_CharT, _Traits, _Alloc> &__lhs, const ::std::basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    return __lhs.compare(__rhs) < 0;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator <(const ::std::basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator <(const ::std::basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs)
  {
    return __lhs.compare(__rhs) < 0;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator <(const _CharT *__lhs, const ::std::basic_string<_CharT, _Traits, _Alloc> &__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator <(const _CharT *__lhs, const ::std::basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    return __rhs.compare(__lhs) > 0;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator >(const ::std::basic_string<_CharT, _Traits, _Alloc> &__lhs, const ::std::basic_string<_CharT, _Traits, _Alloc> &__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator >(const ::std::basic_string<_CharT, _Traits, _Alloc> &__lhs, const ::std::basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    return __lhs.compare(__rhs) > 0;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator >(const ::std::basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator >(const ::std::basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs)
  {
    return __lhs.compare(__rhs) > 0;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator >(const _CharT *__lhs, const ::std::basic_string<_CharT, _Traits, _Alloc> &__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator >(const _CharT *__lhs, const ::std::basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    return __rhs.compare(__lhs) < 0;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator <=(const ::std::basic_string<_CharT, _Traits, _Alloc> &__lhs, const ::std::basic_string<_CharT, _Traits, _Alloc> &__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator <=(const ::std::basic_string<_CharT, _Traits, _Alloc> &__lhs, const ::std::basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    return __lhs.compare(__rhs) <= 0;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator <=(const ::std::basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator <=(const ::std::basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs)
  {
    return __lhs.compare(__rhs) <= 0;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator <=(const _CharT *__lhs, const ::std::basic_string<_CharT, _Traits, _Alloc> &__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator <=(const _CharT *__lhs, const ::std::basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    return __rhs.compare(__lhs) >= 0;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator >=(const ::std::basic_string<_CharT, _Traits, _Alloc> &__lhs, const ::std::basic_string<_CharT, _Traits, _Alloc> &__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator >=(const ::std::basic_string<_CharT, _Traits, _Alloc> &__lhs, const ::std::basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    return __lhs.compare(__rhs) >= 0;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator >=(const ::std::basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator >=(const ::std::basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs)
  {
    return __lhs.compare(__rhs) >= 0;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator >=(const _CharT *__lhs, const ::std::basic_string<_CharT, _Traits, _Alloc> &__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator >=(const _CharT *__lhs, const ::std::basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    return __rhs.compare(__lhs) <= 0;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline void swap(::std::basic_string<_CharT, _Traits, _Alloc> &__lhs, ::std::basic_string<_CharT, _Traits, _Alloc> &__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline void swap(::std::basic_string<_CharT, _Traits, _Alloc> &__lhs, ::std::basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    __lhs.swap(__rhs);
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__in, ::std::basic_string<_CharT, _Traits, _Alloc> &__str);
  template <>
  ::std::basic_istream<char, ::std::char_traits<char> > &operator >><char, ::std::char_traits<char>, ::std::allocator<char> >(::std::basic_istream<char, ::std::char_traits<char> > &__is, ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> > &__str);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, const ::std::basic_string<_CharT, _Traits, _Alloc> &__str);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, const ::std::basic_string<_CharT, _Traits, _Alloc> &__str)
  {
    return __ostream_insert(__os, __str.data(), __str.size());
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  ::std::basic_istream<_CharT, _Traits> &getline(::std::basic_istream<_CharT, _Traits> &__in, ::std::basic_string<_CharT, _Traits, _Alloc> &__str, _CharT __delim);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline ::std::basic_istream<_CharT, _Traits> &getline(::std::basic_istream<_CharT, _Traits> &__is, ::std::basic_string<_CharT, _Traits, _Alloc> &__str);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline ::std::basic_istream<_CharT, _Traits> &getline(::std::basic_istream<_CharT, _Traits> &__is, ::std::basic_string<_CharT, _Traits, _Alloc> &__str)
  {
    return getline(__is, __str, __is.widen('\n'));
  }
  template <>
  ::std::basic_istream<char, ::std::char_traits<char> > &getline<char, ::std::char_traits<char>, ::std::allocator<char> >(::std::basic_istream<char, ::std::char_traits<char> > &__in, ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> > &__str, char __delim);
  template <>
  ::std::basic_istream<wchar_t, ::std::char_traits<wchar_t> > &getline<wchar_t, ::std::char_traits<wchar_t>, ::std::allocator<wchar_t> >(::std::basic_istream<wchar_t, ::std::char_traits<wchar_t> > &__in, ::std::basic_string<wchar_t, ::std::char_traits<wchar_t>, ::std::allocator<wchar_t> > &__str, wchar_t __delim);
  template < typename _CharT, typename _Traits, typename _Alloc >
  const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::_Rep::_S_max_size = ((npos - sizeof(typename ::std::basic_string<_CharT, _Traits, _Alloc>::_Rep_base)) / sizeof(_CharT) - 1) / 4;
  template < typename _CharT, typename _Traits, typename _Alloc >
  const _CharT basic_string<_CharT, _Traits, _Alloc>::_Rep::_S_terminal = _CharT();
  template < typename _CharT, typename _Traits, typename _Alloc >
  typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::_Rep::_S_empty_rep_storage[];
  template < typename _CharT, typename _Traits, typename _Alloc >
  template < typename _InIterator >
  _CharT *basic_string<_CharT, _Traits, _Alloc>::_S_construct(_InIterator __beg, _InIterator __end, const _Alloc &__a, ::std::input_iterator_tag)
  {
    if (__beg == __end && __a == _Alloc())
      {
        return _S_empty_rep()._M_refdata();
      }
    _CharT __buf[128];
    typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __len = 0;
    while (__beg != __end && __len < sizeof(__buf) / sizeof(_CharT))
      {
        __buf[__len++] = *__beg;
        ++__beg;
      }
    typename ::std::basic_string<_CharT, _Traits, _Alloc>::_Rep *__r = _Rep::_S_create(__len, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type(0), __a);
    _M_copy(__r->_M_refdata(), __buf, __len);
    try
    {
      while (__beg != __end)
        {
          if (__len == __r->_M_capacity)
            {
              typename ::std::basic_string<_CharT, _Traits, _Alloc>::_Rep *__another = _Rep::_S_create(__len + 1, __len, __a);
              _M_copy(__another->_M_refdata(), __r->_M_refdata(), __len);
              __r->_M_destroy(__a);
              __r = __another;
            }
          __r->_M_refdata()[__len++] = *__beg;
          ++__beg;
        }
    }
    catch (...)
    {
      __r->_M_destroy(__a);
      throw;
    }
    __r->_M_set_length_and_sharable(__len);
    return __r->_M_refdata();
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  template < typename _InIterator >
  _CharT *basic_string<_CharT, _Traits, _Alloc>::_S_construct(_InIterator __beg, _InIterator __end, const _Alloc &__a, ::std::forward_iterator_tag)
  {
    if (__beg == __end && __a == _Alloc())
      {
        return _S_empty_rep()._M_refdata();
      }
    if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
      {
        ::std::__throw_logic_error("basic_string::_S_construct null not valid");
      }
    const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __dnew = static_cast<typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type>(std::distance(__beg, __end));
    typename ::std::basic_string<_CharT, _Traits, _Alloc>::_Rep *__r = _Rep::_S_create(__dnew, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type(0), __a);
    try
    {
      _S_copy_chars(__r->_M_refdata(), __beg, __end);
    }
    catch (...)
    {
      __r->_M_destroy(__a);
      throw;
    }
    __r->_M_set_length_and_sharable(__dnew);
    return __r->_M_refdata();
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  _CharT *basic_string<_CharT, _Traits, _Alloc>::_S_construct(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n, _CharT __c, const _Alloc &__a)
  {
    if (__n == 0 && __a == _Alloc())
      {
        return _S_empty_rep()._M_refdata();
      }
    typename ::std::basic_string<_CharT, _Traits, _Alloc>::_Rep *__r = _Rep::_S_create(__n, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type(0), __a);
    if (__n)
      {
        _M_assign(__r->_M_refdata(), __n, __c);
      }
    __r->_M_set_length_and_sharable(__n);
    return __r->_M_refdata();
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  basic_string<_CharT, _Traits, _Alloc>::basic_string(const ::std::basic_string<_CharT, _Traits, _Alloc> &__str)
    : _M_dataplus(__str._M_rep()->_M_grab(_Alloc(__str.get_allocator()), __str.get_allocator()), __str.get_allocator())
  {
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  basic_string<_CharT, _Traits, _Alloc>::basic_string(const _Alloc &__a)
    : _M_dataplus(_S_construct(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type(), _CharT(), __a), __a)
  {
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  basic_string<_CharT, _Traits, _Alloc>::basic_string(const ::std::basic_string<_CharT, _Traits, _Alloc> &__str, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n)
    : _M_dataplus(_S_construct(__str._M_data() + __str._M_check(__pos, "basic_string::basic_string"), __str._M_data() + __str._M_limit(__pos, __n) + __pos, _Alloc()), _Alloc())
  {
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  basic_string<_CharT, _Traits, _Alloc>::basic_string(const ::std::basic_string<_CharT, _Traits, _Alloc> &__str, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n, const _Alloc &__a)
    : _M_dataplus(_S_construct(__str._M_data() + __str._M_check(__pos, "basic_string::basic_string"), __str._M_data() + __str._M_limit(__pos, __n) + __pos, __a), __a)
  {
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  basic_string<_CharT, _Traits, _Alloc>::basic_string(const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n, const _Alloc &__a)
    : _M_dataplus(_S_construct(__s, __s + __n, __a), __a)
  {
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  basic_string<_CharT, _Traits, _Alloc>::basic_string(const _CharT *__s, const _Alloc &__a)
    : _M_dataplus(_S_construct(__s, __s ? __s + traits_type::length(__s) : __s + npos, __a), __a)
  {
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  basic_string<_CharT, _Traits, _Alloc>::basic_string(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n, _CharT __c, const _Alloc &__a)
    : _M_dataplus(_S_construct(__n, __c, __a), __a)
  {
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  template < typename _InputIterator >
  basic_string<_CharT, _Traits, _Alloc>::basic_string(_InputIterator __beg, _InputIterator __end, const _Alloc &__a)
    : _M_dataplus(_S_construct(__beg, __end, __a), __a)
  {
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  ::std::basic_string<_CharT, _Traits, _Alloc> &basic_string<_CharT, _Traits, _Alloc>::assign(const ::std::basic_string<_CharT, _Traits, _Alloc> &__str)
  {
    if (_M_rep() != __str._M_rep())
      {
        const typename ::std::basic_string<_CharT, _Traits, _Alloc>::allocator_type __a = this->get_allocator();
        _CharT *__tmp = __str._M_rep()->_M_grab(__a, __str.get_allocator());
        _M_rep()->_M_dispose(__a);
        _M_data(__tmp);
      }
    return *this;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  ::std::basic_string<_CharT, _Traits, _Alloc> &basic_string<_CharT, _Traits, _Alloc>::assign(const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n)
  {
    ;
    _M_check_length(this->size(), __n, "basic_string::assign");
    if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
      {
        return _M_replace_safe(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type(0), this->size(), __s, __n);
      }
    else
      {
        const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos = __s - _M_data();
        if (__pos >= __n)
          {
            _M_copy(_M_data(), __s, __n);
          }
        else
          {
            if (__pos)
              {
                _M_move(_M_data(), __s, __n);
              }
          }
        _M_rep()->_M_set_length_and_sharable(__n);
        return *this;
      }
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  ::std::basic_string<_CharT, _Traits, _Alloc> &basic_string<_CharT, _Traits, _Alloc>::append(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n, _CharT __c)
  {
    if (__n)
      {
        _M_check_length(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type(0), __n, "basic_string::append");
        const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __len = __n + this->size();
        if (__len > this->capacity() || _M_rep()->_M_is_shared())
          {
            this->reserve(__len);
          }
        _M_assign(_M_data() + this->size(), __n, __c);
        _M_rep()->_M_set_length_and_sharable(__len);
      }
    return *this;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  ::std::basic_string<_CharT, _Traits, _Alloc> &basic_string<_CharT, _Traits, _Alloc>::append(const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n)
  {
    ;
    if (__n)
      {
        _M_check_length(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type(0), __n, "basic_string::append");
        const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __len = __n + this->size();
        if (__len > this->capacity() || _M_rep()->_M_is_shared())
          {
            if (_M_disjunct(__s))
              {
                this->reserve(__len);
              }
            else
              {
                const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __off = __s - _M_data();
                this->reserve(__len);
                __s = _M_data() + __off;
              }
          }
        _M_copy(_M_data() + this->size(), __s, __n);
        _M_rep()->_M_set_length_and_sharable(__len);
      }
    return *this;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  ::std::basic_string<_CharT, _Traits, _Alloc> &basic_string<_CharT, _Traits, _Alloc>::append(const ::std::basic_string<_CharT, _Traits, _Alloc> &__str)
  {
    const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __size = __str.size();
    if (__size)
      {
        const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __len = __size + this->size();
        if (__len > this->capacity() || _M_rep()->_M_is_shared())
          {
            this->reserve(__len);
          }
        _M_copy(_M_data() + this->size(), __str._M_data(), __size);
        _M_rep()->_M_set_length_and_sharable(__len);
      }
    return *this;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  ::std::basic_string<_CharT, _Traits, _Alloc> &basic_string<_CharT, _Traits, _Alloc>::append(const ::std::basic_string<_CharT, _Traits, _Alloc> &__str, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n)
  {
    __str._M_check(__pos, "basic_string::append");
    __n = __str._M_limit(__pos, __n);
    if (__n)
      {
        const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __len = __n + this->size();
        if (__len > this->capacity() || _M_rep()->_M_is_shared())
          {
            this->reserve(__len);
          }
        _M_copy(_M_data() + this->size(), __str._M_data() + __pos, __n);
        _M_rep()->_M_set_length_and_sharable(__len);
      }
    return *this;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  ::std::basic_string<_CharT, _Traits, _Alloc> &basic_string<_CharT, _Traits, _Alloc>::insert(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n)
  {
    ;
    _M_check(__pos, "basic_string::insert");
    _M_check_length(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type(0), __n, "basic_string::insert");
    if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
      {
        return _M_replace_safe(__pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type(0), __s, __n);
      }
    else
      {
        const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __off = __s - _M_data();
        _M_mutate(__pos, 0, __n);
        __s = _M_data() + __off;
        _CharT *__p = _M_data() + __pos;
        if (__s + __n <= __p)
          {
            _M_copy(__p, __s, __n);
          }
        else
          {
            if (__s >= __p)
              {
                _M_copy(__p, __s + __n, __n);
              }
            else
              {
                const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __nleft = __p - __s;
                _M_copy(__p, __s, __nleft);
                _M_copy(__p + __nleft, __p + __n, __n - __nleft);
              }
          }
        return *this;
      }
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator basic_string<_CharT, _Traits, _Alloc>::erase(typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __first, typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __last)
  {
    ;
    const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __size = __last - __first;
    if (__size)
      {
        const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos = __first - _M_ibegin();
        _M_mutate(__pos, __size, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type(0));
        _M_rep()->_M_set_leaked();
        return typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator(_M_data() + __pos);
      }
    else
      {
        return __first;
      }
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  ::std::basic_string<_CharT, _Traits, _Alloc> &basic_string<_CharT, _Traits, _Alloc>::replace(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n1, const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n2)
  {
    ;
    _M_check(__pos, "basic_string::replace");
    __n1 = _M_limit(__pos, __n1);
    _M_check_length(__n1, __n2, "basic_string::replace");
    bool __left;
    if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
      {
        return _M_replace_safe(__pos, __n1, __s, __n2);
      }
    else
      {
        if ((__left = __s + __n2 <= _M_data() + __pos) || _M_data() + __pos + __n1 <= __s)
          {
            typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __off = __s - _M_data();
            __left ? __off : __off += __n2 - __n1;
            _M_mutate(__pos, __n1, __n2);
            _M_copy(_M_data() + __pos, _M_data() + __off, __n2);
            return *this;
          }
        else
          {
            const ::std::basic_string<_CharT, _Traits, _Alloc> __tmp(__s, __n2);
            return _M_replace_safe(__pos, __n1, __tmp._M_data(), __n2);
          }
      }
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  void basic_string<_CharT, _Traits, _Alloc>::_Rep::_M_destroy(const _Alloc &__a) throw()
  {
    const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __size = sizeof(typename ::std::basic_string<_CharT, _Traits, _Alloc>::_Rep_base) + (this->_M_capacity + 1) * sizeof(_CharT);
    _Raw_bytes_alloc(__a).deallocate(reinterpret_cast<char *>(this), __size);
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  void basic_string<_CharT, _Traits, _Alloc>::_M_leak_hard()
  {
    if (_M_rep() == &_S_empty_rep())
      {
        return ;
      }
    if (_M_rep()->_M_is_shared())
      {
        _M_mutate(0, 0, 0);
      }
    _M_rep()->_M_set_leaked();
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  void basic_string<_CharT, _Traits, _Alloc>::_M_mutate(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __len1, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __len2)
  {
    const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __old_size = this->size();
    const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __new_size = __old_size + __len2 - __len1;
    const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __how_much = __old_size - __pos - __len1;
    if (__new_size > this->capacity() || _M_rep()->_M_is_shared())
      {
        const typename ::std::basic_string<_CharT, _Traits, _Alloc>::allocator_type __a = get_allocator();
        typename ::std::basic_string<_CharT, _Traits, _Alloc>::_Rep *__r = _Rep::_S_create(__new_size, this->capacity(), __a);
        if (__pos)
          {
            _M_copy(__r->_M_refdata(), _M_data(), __pos);
          }
        if (__how_much)
          {
            _M_copy(__r->_M_refdata() + __pos + __len2, _M_data() + __pos + __len1, __how_much);
          }
        _M_rep()->_M_dispose(__a);
        _M_data(__r->_M_refdata());
      }
    else
      {
        if (__how_much && __len1 != __len2)
          {
            _M_move(_M_data() + __pos + __len2, _M_data() + __pos + __len1, __how_much);
          }
      }
    _M_rep()->_M_set_length_and_sharable(__new_size);
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  void basic_string<_CharT, _Traits, _Alloc>::reserve(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __res)
  {
    if (__res != this->capacity() || _M_rep()->_M_is_shared())
      {
        if (__res < this->size())
          {
            __res = this->size();
          }
        const typename ::std::basic_string<_CharT, _Traits, _Alloc>::allocator_type __a = get_allocator();
        _CharT *__tmp = _M_rep()->_M_clone(__a, __res - this->size());
        _M_rep()->_M_dispose(__a);
        _M_data(__tmp);
      }
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  void basic_string<_CharT, _Traits, _Alloc>::swap(::std::basic_string<_CharT, _Traits, _Alloc> &__s)
  {
    if (_M_rep()->_M_is_leaked())
      {
        _M_rep()->_M_set_sharable();
      }
    if (__s._M_rep()->_M_is_leaked())
      {
        __s._M_rep()->_M_set_sharable();
      }
    if (this->get_allocator() == __s.get_allocator())
      {
        _CharT *__tmp = _M_data();
        _M_data(__s._M_data());
        __s._M_data(__tmp);
      }
    else
      {
        const ::std::basic_string<_CharT, _Traits, _Alloc> __tmp1(_M_ibegin(), _M_iend(), __s.get_allocator());
        const ::std::basic_string<_CharT, _Traits, _Alloc> __tmp2(__s._M_ibegin(), __s._M_iend(), this->get_allocator());
        *this = __tmp2;
        __s = __tmp1;
      }
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  typename ::std::basic_string<_CharT, _Traits, _Alloc>::_Rep *basic_string<_CharT, _Traits, _Alloc>::_Rep::_S_create(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __capacity, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __old_capacity, const _Alloc &__alloc)
  {
    if (__capacity > _S_max_size)
      {
        ::std::__throw_length_error("basic_string::_S_create");
      }
    const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pagesize = 4096;
    const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __malloc_header_size = 4 * sizeof(void *);
    if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)
      {
        __capacity = 2 * __old_capacity;
      }
    typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __size = (__capacity + 1) * sizeof(_CharT) + sizeof(typename ::std::basic_string<_CharT, _Traits, _Alloc>::_Rep);
    const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __adj_size = __size + __malloc_header_size;
    if (__adj_size > __pagesize && __capacity > __old_capacity)
      {
        const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __extra = __pagesize - __adj_size % __pagesize;
        __capacity += __extra / sizeof(_CharT);
        if (__capacity > _S_max_size)
          {
            __capacity = _S_max_size;
          }
        __size = (__capacity + 1) * sizeof(_CharT) + sizeof(typename ::std::basic_string<_CharT, _Traits, _Alloc>::_Rep);
      }
    void *__place(_Raw_bytes_alloc(__alloc).allocate(__size));
    typename ::std::basic_string<_CharT, _Traits, _Alloc>::_Rep *__p = new (__place)typename ::std::basic_string<_CharT, _Traits, _Alloc>::_Rep();
    __p->_M_capacity = __capacity;
    __p->_M_set_sharable();
    return __p;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  _CharT *basic_string<_CharT, _Traits, _Alloc>::_Rep::_M_clone(const _Alloc &__alloc, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __res)
  {
    const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __requested_cap = this->_M_length + __res;
    typename ::std::basic_string<_CharT, _Traits, _Alloc>::_Rep *__r = _Rep::_S_create(__requested_cap, this->_M_capacity, __alloc);
    if (this->_M_length)
      {
        _M_copy(__r->_M_refdata(), _M_refdata(), this->_M_length);
      }
    __r->_M_set_length_and_sharable(this->_M_length);
    return __r->_M_refdata();
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  void basic_string<_CharT, _Traits, _Alloc>::resize(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n, _CharT __c)
  {
    const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __size = this->size();
    _M_check_length(__size, __n, "basic_string::resize");
    if (__size < __n)
      {
        this->append(__n - __size, __c);
      }
    else
      {
        if (__n < __size)
          {
            this->erase(__n);
          }
      }
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  template < typename _InputIterator >
  ::std::basic_string<_CharT, _Traits, _Alloc> &basic_string<_CharT, _Traits, _Alloc>::_M_replace_dispatch(typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __i1, typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __i2, _InputIterator __k1, _InputIterator __k2, ::std::__false_type)
  {
    const ::std::basic_string<_CharT, _Traits, _Alloc> __s(__k1, __k2);
    const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n1 = __i2 - __i1;
    _M_check_length(__n1, __s.size(), "basic_string::_M_replace_dispatch");
    return _M_replace_safe(__i1 - _M_ibegin(), __n1, __s._M_data(), __s.size());
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  ::std::basic_string<_CharT, _Traits, _Alloc> &basic_string<_CharT, _Traits, _Alloc>::_M_replace_aux(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos1, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n1, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n2, _CharT __c)
  {
    _M_check_length(__n1, __n2, "basic_string::_M_replace_aux");
    _M_mutate(__pos1, __n1, __n2);
    if (__n2)
      {
        _M_assign(_M_data() + __pos1, __n2, __c);
      }
    return *this;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  ::std::basic_string<_CharT, _Traits, _Alloc> &basic_string<_CharT, _Traits, _Alloc>::_M_replace_safe(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos1, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n1, const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n2)
  {
    _M_mutate(__pos1, __n1, __n2);
    if (__n2)
      {
        _M_copy(_M_data() + __pos1, __s, __n2);
      }
    return *this;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  ::std::basic_string<_CharT, _Traits, _Alloc> operator +(const _CharT *__lhs, const ::std::basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    ;
    typedef ::std::basic_string<_CharT, _Traits, _Alloc> __string_type;
    typedef typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __size_type;
    const __size_type __len = _Traits::length(__lhs);
    __string_type __str;
    __str.reserve(__len + __rhs.size());
    __str.append(__lhs, __len);
    __str.append(__rhs);
    return __str;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  ::std::basic_string<_CharT, _Traits, _Alloc> operator +(_CharT __lhs, const ::std::basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    typedef ::std::basic_string<_CharT, _Traits, _Alloc> __string_type;
    typedef typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __size_type;
    __string_type __str;
    const __size_type __len = __rhs.size();
    __str.reserve(__len + 1);
    __str.append(__size_type(1), __lhs);
    __str.append(__rhs);
    return __str;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::copy(_CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos) const 
  {
    _M_check(__pos, "basic_string::copy");
    __n = _M_limit(__pos, __n);
    ;
    if (__n)
      {
        _M_copy(__s, _M_data() + __pos, __n);
      }
    return __n;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find(const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n) const 
  {
    ;
    const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __size = this->size();
    const _CharT *__data = _M_data();
    if (__n == 0)
      {
        return __pos <= __size ? __pos : npos;
      }
    if (__n <= __size)
      {
        for (; __pos <= __size - __n; ++__pos)
          {
            if (traits_type::eq(__data[__pos], __s[0]) && traits_type::compare(__data + __pos + 1, __s + 1, __n - 1) == 0)
              {
                return __pos;
              }
          }
      }
    return npos;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find(_CharT __c, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos) const 
  {
    typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __ret = npos;
    const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __size = this->size();
    if (__pos < __size)
      {
        const _CharT *__data = _M_data();
        const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n = __size - __pos;
        const _CharT *__p = traits_type::find(__data + __pos, __n, __c);
        if (__p)
          {
            __ret = __p - __data;
          }
      }
    return __ret;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::rfind(const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n) const 
  {
    ;
    const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __size = this->size();
    if (__n <= __size)
      {
        __pos = std::min(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type(__size - __n), __pos);
        const _CharT *__data = _M_data();
        do
          {
            if (traits_type::compare(__data + __pos, __s, __n) == 0)
              {
                return __pos;
              }
          }
        while (__pos-- > 0);
      }
    return npos;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::rfind(_CharT __c, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos) const 
  {
    typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __size = this->size();
    if (__size)
      {
        if (--__size > __pos)
          {
            __size = __pos;
          }
        for (++__size; __size-- > 0; )
          {
            if (traits_type::eq(_M_data()[__size], __c))
              {
                return __size;
              }
          }
      }
    return npos;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find_first_of(const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n) const 
  {
    ;
    for (; __n && __pos < this->size(); ++__pos)
      {
        const _CharT *__p = traits_type::find(__s, __n, _M_data()[__pos]);
        if (__p)
          {
            return __pos;
          }
      }
    return npos;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find_last_of(const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n) const 
  {
    ;
    typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __size = this->size();
    if (__size && __n)
      {
        if (--__size > __pos)
          {
            __size = __pos;
          }
        do
          {
            if (traits_type::find(__s, __n, _M_data()[__size]))
              {
                return __size;
              }
          }
        while (__size-- != 0);
      }
    return npos;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find_first_not_of(const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n) const 
  {
    ;
    for (; __pos < this->size(); ++__pos)
      {
        if (!traits_type::find(__s, __n, _M_data()[__pos]))
          {
            return __pos;
          }
      }
    return npos;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find_first_not_of(_CharT __c, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos) const 
  {
    for (; __pos < this->size(); ++__pos)
      {
        if (!traits_type::eq(_M_data()[__pos], __c))
          {
            return __pos;
          }
      }
    return npos;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find_last_not_of(const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n) const 
  {
    ;
    typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __size = this->size();
    if (__size)
      {
        if (--__size > __pos)
          {
            __size = __pos;
          }
        do
          {
            if (!traits_type::find(__s, __n, _M_data()[__size]))
              {
                return __size;
              }
          }
        while (__size--);
      }
    return npos;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find_last_not_of(_CharT __c, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos) const 
  {
    typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __size = this->size();
    if (__size)
      {
        if (--__size > __pos)
          {
            __size = __pos;
          }
        do
          {
            if (!traits_type::eq(_M_data()[__size], __c))
              {
                return __size;
              }
          }
        while (__size--);
      }
    return npos;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  int basic_string<_CharT, _Traits, _Alloc>::compare(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n, const ::std::basic_string<_CharT, _Traits, _Alloc> &__str) const 
  {
    _M_check(__pos, "basic_string::compare");
    __n = _M_limit(__pos, __n);
    const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __osize = __str.size();
    const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __len = std::min(__n, __osize);
    int __r(traits_type::compare(_M_data() + __pos, __str.data(), __len));
    if (!__r)
      {
        __r = _S_compare(__n, __osize);
      }
    return __r;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  int basic_string<_CharT, _Traits, _Alloc>::compare(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos1, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n1, const ::std::basic_string<_CharT, _Traits, _Alloc> &__str, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos2, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n2) const 
  {
    _M_check(__pos1, "basic_string::compare");
    __str._M_check(__pos2, "basic_string::compare");
    __n1 = _M_limit(__pos1, __n1);
    __n2 = __str._M_limit(__pos2, __n2);
    const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __len = std::min(__n1, __n2);
    int __r(traits_type::compare(_M_data() + __pos1, __str.data() + __pos2, __len));
    if (!__r)
      {
        __r = _S_compare(__n1, __n2);
      }
    return __r;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  int basic_string<_CharT, _Traits, _Alloc>::compare(const _CharT *__s) const 
  {
    ;
    const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __size = this->size();
    const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __osize = traits_type::length(__s);
    const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __len = std::min(__size, __osize);
    int __r(traits_type::compare(_M_data(), __s, __len));
    if (!__r)
      {
        __r = _S_compare(__size, __osize);
      }
    return __r;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  int basic_string<_CharT, _Traits, _Alloc>::compare(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n1, const _CharT *__s) const 
  {
    ;
    _M_check(__pos, "basic_string::compare");
    __n1 = _M_limit(__pos, __n1);
    const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __osize = traits_type::length(__s);
    const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __len = std::min(__n1, __osize);
    int __r(traits_type::compare(_M_data() + __pos, __s, __len));
    if (!__r)
      {
        __r = _S_compare(__n1, __osize);
      }
    return __r;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  int basic_string<_CharT, _Traits, _Alloc>::compare(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n1, const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n2) const 
  {
    ;
    _M_check(__pos, "basic_string::compare");
    __n1 = _M_limit(__pos, __n1);
    const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __len = std::min(__n1, __n2);
    int __r(traits_type::compare(_M_data() + __pos, __s, __len));
    if (!__r)
      {
        __r = _S_compare(__n1, __n2);
      }
    return __r;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__in, ::std::basic_string<_CharT, _Traits, _Alloc> &__str)
  {
    typedef ::std::basic_istream<_CharT, _Traits> __istream_type;
    typedef ::std::basic_string<_CharT, _Traits, _Alloc> __string_type;
    typedef typename ::std::basic_istream<_CharT, _Traits>::ios_base __ios_base;
    typedef typename ::std::basic_istream<_CharT, _Traits>::int_type __int_type;
    typedef typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __size_type;
    typedef ::std::ctype<_CharT> __ctype_type;
    typedef typename ::std::ctype<_CharT>::ctype_base __ctype_base;
    __size_type __extracted = 0;
    typename __ios_base::iostate __err = __ios_base::goodbit;
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(__in, false);
    if (__cerb)
      {
        try
        {
          __str.erase();
          _CharT __buf[128];
          __size_type __len = 0;
          const ::std::streamsize __w(__in.width());
          const __size_type __n = __w > 0 ? static_cast<__size_type>(__w) : __str.max_size();
          const __ctype_type &__ct = use_facet<__ctype_type>(__in.getloc());
          const __int_type __eof = _Traits::eof();
          __int_type __c = __in.rdbuf()->sgetc();
          while ((__extracted < __n && !_Traits::eq_int_type(__c, __eof)) && !__ct.is(__ctype_base::space, _Traits::to_char_type(__c)))
            {
              if (__len == sizeof(__buf) / sizeof(_CharT))
                {
                  __str.append(__buf, sizeof(__buf) / sizeof(_CharT));
                  __len = 0;
                }
              __buf[__len++] = _Traits::to_char_type(__c);
              ++__extracted;
              __c = __in.rdbuf()->snextc();
            }
          __str.append(__buf, __len);
          if (_Traits::eq_int_type(__c, __eof))
            {
              __err |= __ios_base::eofbit;
            }
          __in.width(0);
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          __in._M_setstate(__ios_base::badbit);
          throw;
        }
        catch (...)
        {
          __in._M_setstate(__ios_base::badbit);
        }
      }
    if (!__extracted)
      {
        __err |= __ios_base::failbit;
      }
    if (__err)
      {
        __in.setstate(__err);
      }
    return __in;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  ::std::basic_istream<_CharT, _Traits> &getline(::std::basic_istream<_CharT, _Traits> &__in, ::std::basic_string<_CharT, _Traits, _Alloc> &__str, _CharT __delim)
  {
    typedef ::std::basic_istream<_CharT, _Traits> __istream_type;
    typedef ::std::basic_string<_CharT, _Traits, _Alloc> __string_type;
    typedef typename ::std::basic_istream<_CharT, _Traits>::ios_base __ios_base;
    typedef typename ::std::basic_istream<_CharT, _Traits>::int_type __int_type;
    typedef typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __size_type;
    __size_type __extracted = 0;
    const __size_type __n = __str.max_size();
    typename __ios_base::iostate __err = __ios_base::goodbit;
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(__in, true);
    if (__cerb)
      {
        try
        {
          __str.erase();
          const __int_type __idelim = _Traits::to_int_type(__delim);
          const __int_type __eof = _Traits::eof();
          __int_type __c = __in.rdbuf()->sgetc();
          while ((__extracted < __n && !_Traits::eq_int_type(__c, __eof)) && !_Traits::eq_int_type(__c, __idelim))
            {
              __str += _Traits::to_char_type(__c);
              ++__extracted;
              __c = __in.rdbuf()->snextc();
            }
          if (_Traits::eq_int_type(__c, __eof))
            {
              __err |= __ios_base::eofbit;
            }
          else
            {
              if (_Traits::eq_int_type(__c, __idelim))
                {
                  ++__extracted;
                  __in.rdbuf()->sbumpc();
                }
              else
                {
                  __err |= __ios_base::failbit;
                }
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          __in._M_setstate(__ios_base::badbit);
          throw;
        }
        catch (...)
        {
          __in._M_setstate(__ios_base::badbit);
        }
      }
    if (!__extracted)
      {
        __err |= __ios_base::failbit;
      }
    if (__err)
      {
        __in.setstate(__err);
      }
    return __in;
  }
extern template class ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> >;
extern template ::std::basic_istream<char, ::std::char_traits<char> > &operator >>(::std::basic_istream<char, ::std::char_traits<char> > &, ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> > &);
extern template ::std::basic_ostream<char, ::std::char_traits<char> > &operator <<(::std::basic_ostream<char, ::std::char_traits<char> > &, const ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> > &);
extern template ::std::basic_istream<char, ::std::char_traits<char> > &getline(::std::basic_istream<char, ::std::char_traits<char> > &, ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> > &, char);
extern template ::std::basic_istream<char, ::std::char_traits<char> > &getline(::std::basic_istream<char, ::std::char_traits<char> > &, ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> > &);
extern template class ::std::basic_string<wchar_t, ::std::char_traits<wchar_t>, ::std::allocator<wchar_t> >;
extern template ::std::basic_istream<wchar_t, ::std::char_traits<wchar_t> > &operator >>(::std::basic_istream<wchar_t, ::std::char_traits<wchar_t> > &, ::std::basic_string<wchar_t, ::std::char_traits<wchar_t>, ::std::allocator<wchar_t> > &);
extern template ::std::basic_ostream<wchar_t, ::std::char_traits<wchar_t> > &operator <<(::std::basic_ostream<wchar_t, ::std::char_traits<wchar_t> > &, const ::std::basic_string<wchar_t, ::std::char_traits<wchar_t>, ::std::allocator<wchar_t> > &);
extern template ::std::basic_istream<wchar_t, ::std::char_traits<wchar_t> > &getline(::std::basic_istream<wchar_t, ::std::char_traits<wchar_t> > &, ::std::basic_string<wchar_t, ::std::char_traits<wchar_t>, ::std::allocator<wchar_t> > &, wchar_t);
extern template ::std::basic_istream<wchar_t, ::std::char_traits<wchar_t> > &getline(::std::basic_istream<wchar_t, ::std::char_traits<wchar_t> > &, ::std::basic_string<wchar_t, ::std::char_traits<wchar_t>, ::std::allocator<wchar_t> > &);
  class  locale
  {
    public:
      typedef int category;
      class facet;
      class id;
      class _Impl;
      static const ::std::locale::category none = 0;
      static const ::std::locale::category ctype = 1L << 0;
      static const ::std::locale::category numeric = 1L << 1;
      static const ::std::locale::category collate = 1L << 2;
      static const ::std::locale::category time = 1L << 3;
      static const ::std::locale::category monetary = 1L << 4;
      static const ::std::locale::category messages = 1L << 5;
      static const ::std::locale::category all = ((((::std::locale::ctype | ::std::locale::numeric) | ::std::locale::collate) | ::std::locale::time) | ::std::locale::monetary) | ::std::locale::messages;
      locale() throw();
      locale(const ::std::locale &__other) throw();
      explicit locale(const char *__s);
      locale(const ::std::locale &__base, const char *__s, ::std::locale::category __cat);
      locale(const ::std::locale &__base, const ::std::locale &__add, ::std::locale::category __cat);
      template < typename _Facet >
      locale(const ::std::locale &__other, _Facet *__f);
      ~locale() throw();
      const ::std::locale &operator =(const ::std::locale &__other) throw();
      template < typename _Facet >
      ::std::locale combine(const ::std::locale &__other) const ;
      ::std::string name() const ;
      bool operator ==(const ::std::locale &__other) const  throw();
      inline bool operator !=(const ::std::locale &__other) const  throw()
      {
        return !(*this).::std::locale::operator ==(__other);
      }
      template < typename _Char, typename _Traits, typename _Alloc >
      bool operator ()(const ::std::basic_string<_Char, _Traits, _Alloc> &__s1, const ::std::basic_string<_Char, _Traits, _Alloc> &__s2) const ;
      static ::std::locale global(const ::std::locale &__loc);
      static const ::std::locale &classic();
    private:
      ::std::locale::_Impl *_M_impl;
      static ::std::locale::_Impl *_S_classic;
      static ::std::locale::_Impl *_S_global;
      static const char *const *const _S_categories;
      enum mcc_enum_anon_58
      {
        _S_categories_size = 6 + 6
      };
      static ::__gthread_once_t _S_once;
      explicit locale(::std::locale::_Impl *) throw();
      static void _S_initialize();
      static void _S_initialize_once() throw();
      static ::std::locale::category _S_normalize_category(::std::locale::category);
      void _M_coalesce(const ::std::locale &__base, const ::std::locale &__add, ::std::locale::category __cat);
    friend class ::std::locale::facet;
    friend class ::std::locale::_Impl;
    template < typename _Facet >
    friend bool std::has_facet(const ::std::locale &) throw();
    template < typename _Facet >
    friend const _Facet &std::use_facet(const ::std::locale &);
    template < typename _Facet >
    friend struct __use_cache;
  };
  class  locale::facet
  {
      mutable ::_Atomic_word _M_refcount;
      static ::std::__c_locale _S_c_locale;
      static const char _S_c_name[2];
      static ::__gthread_once_t _S_once;
      static void _S_initialize_once();
    protected:
      inline explicit facet(::std::size_t __refs  = 0) throw()
        : _M_refcount(__refs ? 1 : 0)
      {
      }
      virtual ~facet();
      static void _S_create_c_locale(::std::__c_locale &__cloc, const char *__s, ::std::__c_locale __old  = 0);
      static ::std::__c_locale _S_clone_c_locale(::std::__c_locale &__cloc) throw();
      static void _S_destroy_c_locale(::std::__c_locale &__cloc);
      static ::std::__c_locale _S_lc_ctype_c_locale(::std::__c_locale __cloc, const char *__s);
      static ::std::__c_locale _S_get_c_locale();
      static const char *_S_get_c_name() throw()__attribute__((__const__));
    private:
      inline void _M_add_reference() const  throw()
      {
        ::__gnu_cxx::__atomic_add_dispatch(&(*this)._M_refcount, 1);
      }
      inline void _M_remove_reference() const  throw()
      {
        ;
        if (::__gnu_cxx::__exchange_and_add_dispatch(&(*this)._M_refcount,  -1) == 1)
          {
            ;
            try
            {
              delete this;
            }
            catch (...)
            {
            }
          }
      }
      facet(const ::std::locale::facet &);
      ::std::locale::facet &operator =(const ::std::locale::facet &);
    friend class locale;
    friend class ::std::locale::_Impl;
  };
  class  locale::id
  {
      mutable ::std::size_t _M_index;
      static ::_Atomic_word _S_refcount;
      void operator =(const ::std::locale::id &);
      id(const ::std::locale::id &);
    public:
      inline id()
      {
      }
      ::std::size_t _M_id() const  throw();
    friend class locale;
    friend class ::std::locale::_Impl;
    template < typename _Facet >
    friend const _Facet &std::use_facet(const ::std::locale &);
    template < typename _Facet >
    friend bool std::has_facet(const ::std::locale &) throw();
  };
  class  locale::_Impl
  {
      ::_Atomic_word _M_refcount;
      const ::std::locale::facet **_M_facets;
      ::std::size_t _M_facets_size;
      const ::std::locale::facet **_M_caches;
      char **_M_names;
      static const ::std::locale::id *const _S_id_ctype[];
      static const ::std::locale::id *const _S_id_numeric[];
      static const ::std::locale::id *const _S_id_collate[];
      static const ::std::locale::id *const _S_id_time[];
      static const ::std::locale::id *const _S_id_monetary[];
      static const ::std::locale::id *const _S_id_messages[];
      static const ::std::locale::id *const *const _S_facet_categories[];
      inline void _M_add_reference() throw()
      {
        ::__gnu_cxx::__atomic_add_dispatch(&(*this)._M_refcount, 1);
      }
      inline void _M_remove_reference() throw()
      {
        ;
        if (::__gnu_cxx::__exchange_and_add_dispatch(&(*this)._M_refcount,  -1) == 1)
          {
            ;
            try
            {
              delete this;
            }
            catch (...)
            {
            }
          }
      }
      _Impl(const ::std::locale::_Impl &, ::std::size_t);
      _Impl(const char *, ::std::size_t);
      _Impl(::std::size_t) throw();
      ~_Impl() throw();
      _Impl(const ::std::locale::_Impl &);
      void operator =(const ::std::locale::_Impl &);
      inline bool _M_check_same_name()
      {
        bool __ret(true);
        if ((*this)._M_names[1])
          {
            for (::std::size_t __i = 0; __ret && __i < ::std::locale::_S_categories_size - 1; ++__i)
              {
                __ret = __builtin_strcmp((*this)._M_names[__i], (*this)._M_names[__i + 1]) == 0;
              }
          }
        return __ret;
      }
      void _M_replace_categories(const ::std::locale::_Impl *, ::std::locale::category);
      void _M_replace_category(const ::std::locale::_Impl *, const ::std::locale::id *const *);
      void _M_replace_facet(const ::std::locale::_Impl *, const ::std::locale::id *);
      void _M_install_facet(const ::std::locale::id *, const ::std::locale::facet *);
      template < typename _Facet >
      inline void _M_init_facet(_Facet *__facet)
      {
        _M_install_facet(&_Facet::id, __facet);
      }
      void _M_install_cache(const ::std::locale::facet *, ::std::size_t);
    friend class locale;
    friend class ::std::locale::facet;
    template < typename _Facet >
    friend bool std::has_facet(const ::std::locale &) throw();
    template < typename _Facet >
    friend const _Facet &std::use_facet(const ::std::locale &);
    template < typename _Cache >
    friend struct __use_cache;
  };
  template < typename _CharT >
  class  collate : public ::std::locale::facet
  {
    public:
      typedef _CharT char_type;
      typedef ::std::basic_string<_CharT, ::std::char_traits<_CharT>, ::std::allocator<_CharT> > string_type;
    protected:
      ::std::__c_locale _M_c_locale_collate;
    public:
      static ::std::locale::id id;
      inline explicit collate(::std::size_t __refs  = 0)
        : facet(__refs), _M_c_locale_collate(_S_get_c_locale())
      {
      }
      inline explicit collate(::std::__c_locale __cloc, ::std::size_t __refs  = 0)
        : facet(__refs), _M_c_locale_collate(_S_clone_c_locale(__cloc))
      {
      }
      inline int compare(const _CharT *__lo1, const _CharT *__hi1, const _CharT *__lo2, const _CharT *__hi2) const 
      {
        return this->do_compare(__lo1, __hi1, __lo2, __hi2);
      }
      inline typename ::std::collate<_CharT>::string_type transform(const _CharT *__lo, const _CharT *__hi) const 
      {
        return this->do_transform(__lo, __hi);
      }
      inline long int hash(const _CharT *__lo, const _CharT *__hi) const 
      {
        return this->do_hash(__lo, __hi);
      }
      int _M_compare(const _CharT *, const _CharT *) const  throw();
      ::std::size_t _M_transform(_CharT *, const _CharT *, ::std::size_t) const  throw();
    protected:
      inline virtual ~collate()
      {
        _S_destroy_c_locale(_M_c_locale_collate);
      }
      virtual int do_compare(const _CharT *__lo1, const _CharT *__hi1, const _CharT *__lo2, const _CharT *__hi2) const ;
      virtual typename ::std::collate<_CharT>::string_type do_transform(const _CharT *__lo, const _CharT *__hi) const ;
      virtual long int do_hash(const _CharT *__lo, const _CharT *__hi) const ;
  };
  template < typename _CharT >
  ::std::locale::id collate<_CharT>::id;
  template <>
  int collate<char>::_M_compare(const char *, const char *) const  throw();
  template <>
  unsigned long int collate<char>::_M_transform(char *, const char *, unsigned long int) const  throw();
  template <>
  int collate<wchar_t>::_M_compare(const wchar_t *, const wchar_t *) const  throw();
  template <>
  unsigned long int collate<wchar_t>::_M_transform(wchar_t *, const wchar_t *, unsigned long int) const  throw();
  template < typename _CharT >
  class  collate_byname : public ::std::collate<_CharT>
  {
    public:
      typedef _CharT char_type;
      typedef ::std::basic_string<_CharT, ::std::char_traits<_CharT>, ::std::allocator<_CharT> > string_type;
      inline explicit collate_byname(const char *__s, ::std::size_t __refs  = 0)
        : collate<_CharT>(__refs)
      {
        if (__builtin_strcmp(__s, "C") != 0 && __builtin_strcmp(__s, "POSIX") != 0)
          {
            this->_S_destroy_c_locale(this->_M_c_locale_collate);
            this->_S_create_c_locale(this->_M_c_locale_collate, __s);
          }
      }
    protected:
      inline virtual ~collate_byname()
      {
      }
  };
  template < typename _Facet >
  locale::locale(const ::std::locale &__other, _Facet *__f)
  {
    (*this)._M_impl = new (::std::locale::_Impl)((*__other._M_impl), (1));
    try
    {
      (*(*this)._M_impl)._M_install_facet(&_Facet::id, __f);
    }
    catch (...)
    {
      (*(*this)._M_impl).::std::locale::_Impl::_M_remove_reference();
      throw;
    }
    delete[] (*(*this)._M_impl)._M_names[0];
    (*(*this)._M_impl)._M_names[0] = 0;
  }
  template < typename _Facet >
  ::std::locale locale::combine(const ::std::locale &__other) const 
  {
    ::std::locale::_Impl *__tmp(new (::std::locale::_Impl)((*(*this)._M_impl), (1)));
    try
    {
      (*__tmp)._M_replace_facet(__other._M_impl, &_Facet::id);
    }
    catch (...)
    {
      (*__tmp).::std::locale::_Impl::_M_remove_reference();
      throw;
    }
    return ::std::locale(__tmp);
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  bool locale::operator ()(const ::std::basic_string<_CharT, _Traits, _Alloc> &__s1, const ::std::basic_string<_CharT, _Traits, _Alloc> &__s2) const 
  {
    typedef ::std::collate<_CharT> __collate_type;
    const __collate_type &__collate = use_facet<__collate_type>(*this);
    return __collate.compare(__s1.data(), __s1.data() + __s1.length(), __s2.data(), __s2.data() + __s2.length()) < 0;
  }
  template < typename _Facet >
  bool has_facet(const ::std::locale &__loc) throw()
  {
    const ::std::size_t __i(_Facet::id._M_id());
    const ::std::locale::facet **__facets((*__loc._M_impl)._M_facets);
    return __i < (*__loc._M_impl)._M_facets_size && dynamic_cast<const _Facet *>(__facets[__i]);
  }
  template < typename _Facet >
  const _Facet &use_facet(const ::std::locale &__loc)
  {
    const ::std::size_t __i(_Facet::id._M_id());
    const ::std::locale::facet **__facets((*__loc._M_impl)._M_facets);
    if (__i >= (*__loc._M_impl)._M_facets_size || !__facets[__i])
      {
        ::std::__throw_bad_cast();
      }
    return dynamic_cast<const _Facet &>(*__facets[__i]);
  }
  template < typename _CharT >
  int collate<_CharT>::_M_compare(const _CharT *, const _CharT *) const  throw()
  {
    return 0;
  }
  template < typename _CharT >
  ::std::size_t collate<_CharT>::_M_transform(_CharT *, const _CharT *, ::std::size_t) const  throw()
  {
    return 0;
  }
  template < typename _CharT >
  int collate<_CharT>::do_compare(const _CharT *__lo1, const _CharT *__hi1, const _CharT *__lo2, const _CharT *__hi2) const 
  {
    const typename ::std::collate<_CharT>::string_type __one(__lo1, __hi1);
    const typename ::std::collate<_CharT>::string_type __two(__lo2, __hi2);
    const _CharT *__p = __one.c_str();
    const _CharT *__pend = __one.data() + __one.length();
    const _CharT *__q = __two.c_str();
    const _CharT *__qend = __two.data() + __two.length();
    for (; ; )
      {
        const int __res(_M_compare(__p, __q));
        if (__res)
          {
            return __res;
          }
        __p += char_traits<_CharT>::length(__p);
        __q += char_traits<_CharT>::length(__q);
        if (__p == __pend && __q == __qend)
          {
            return 0;
          }
        else
          {
            if (__p == __pend)
              {
                return  -1;
              }
            else
              {
                if (__q == __qend)
                  {
                    return 1;
                  }
              }
          }
        __p++;
        __q++;
      }
  }
  template < typename _CharT >
  typename ::std::collate<_CharT>::string_type collate<_CharT>::do_transform(const _CharT *__lo, const _CharT *__hi) const 
  {
    typename ::std::collate<_CharT>::string_type __ret;
    const typename ::std::collate<_CharT>::string_type __str(__lo, __hi);
    const _CharT *__p = __str.c_str();
    const _CharT *__pend = __str.data() + __str.length();
    ::std::size_t __len = (__hi - __lo) * 2;
    _CharT *__c = new _CharT [__len];
    try
    {
      for (; ; )
        {
          ::std::size_t __res(_M_transform(__c, __p, __len));
          if (__res >= __len)
            {
              __len = __res + 1;
              (delete[] __c, __c = 0);
              __c = (new _CharT [__len]);
              __res = _M_transform(__c, __p, __len);
            }
          __ret.append(__c, __res);
          __p += char_traits<_CharT>::length(__p);
          if (__p == __pend)
            {
              break;
            }
          __p++;
          __ret.push_back(_CharT());
        }
    }
    catch (...)
    {
      delete[] __c;
      throw;
    }
    delete[] __c;
    return __ret;
  }
  template < typename _CharT >
  long int collate<_CharT>::do_hash(const _CharT *__lo, const _CharT *__hi) const 
  {
    unsigned long int __val(0);
    for (; __lo < __hi; ++__lo)
      {
        __val = *__lo + (__val << 7 | __val >> (::__gnu_cxx::__numeric_traits_integer<unsigned long int>::__digits - 7));
      }
    return static_cast<long int>(__val);
  }
extern template class ::std::collate<char>;
extern template class ::std::collate_byname<char>;
extern template const ::std::collate<char> &use_facet< ::std::collate<char> >(const ::std::locale &);
extern template bool has_facet< ::std::collate<char> >(const ::std::locale &);
extern template class ::std::collate<wchar_t>;
extern template class ::std::collate_byname<wchar_t>;
extern template const ::std::collate<wchar_t> &use_facet< ::std::collate<wchar_t> >(const ::std::locale &);
extern template bool has_facet< ::std::collate<wchar_t> >(const ::std::locale &);
  enum _Ios_Fmtflags
  {
    _S_boolalpha = 1L << 0,
    _S_dec = 1L << 1,
    _S_fixed = 1L << 2,
    _S_hex = 1L << 3,
    _S_internal = 1L << 4,
    _S_left = 1L << 5,
    _S_oct = 1L << 6,
    _S_right = 1L << 7,
    _S_scientific = 1L << 8,
    _S_showbase = 1L << 9,
    _S_showpoint = 1L << 10,
    _S_showpos = 1L << 11,
    _S_skipws = 1L << 12,
    _S_unitbuf = 1L << 13,
    _S_uppercase = 1L << 14,
    _S_adjustfield = (::std::_S_left | ::std::_S_right) | ::std::_S_internal,
    _S_basefield = (::std::_S_dec | ::std::_S_oct) | ::std::_S_hex,
    _S_floatfield = ::std::_S_scientific | ::std::_S_fixed,
    _S_ios_fmtflags_end = 1L << 16
  };
  inline ::std::_Ios_Fmtflags operator &(::std::_Ios_Fmtflags __a, ::std::_Ios_Fmtflags __b)
  {
    return (::std::_Ios_Fmtflags)(static_cast<int>(__a) & static_cast<int>(__b));
  }
  inline ::std::_Ios_Fmtflags operator |(::std::_Ios_Fmtflags __a, ::std::_Ios_Fmtflags __b)
  {
    return (::std::_Ios_Fmtflags)(static_cast<int>(__a) | static_cast<int>(__b));
  }
  inline ::std::_Ios_Fmtflags operator ^(::std::_Ios_Fmtflags __a, ::std::_Ios_Fmtflags __b)
  {
    return (::std::_Ios_Fmtflags)(static_cast<int>(__a) ^ static_cast<int>(__b));
  }
  inline ::std::_Ios_Fmtflags operator ~(::std::_Ios_Fmtflags __a)
  {
    return (::std::_Ios_Fmtflags)~static_cast<int>(__a);
  }
  inline const ::std::_Ios_Fmtflags &operator |=(::std::_Ios_Fmtflags &__a, ::std::_Ios_Fmtflags __b)
  {
    return __a = __a | __b;
  }
  inline const ::std::_Ios_Fmtflags &operator &=(::std::_Ios_Fmtflags &__a, ::std::_Ios_Fmtflags __b)
  {
    return __a = __a & __b;
  }
  inline const ::std::_Ios_Fmtflags &operator ^=(::std::_Ios_Fmtflags &__a, ::std::_Ios_Fmtflags __b)
  {
    return __a = __a ^ __b;
  }
  enum _Ios_Openmode
  {
    _S_app = 1L << 0,
    _S_ate = 1L << 1,
    _S_bin = 1L << 2,
    _S_in = 1L << 3,
    _S_out = 1L << 4,
    _S_trunc = 1L << 5,
    _S_ios_openmode_end = 1L << 16
  };
  inline ::std::_Ios_Openmode operator &(::std::_Ios_Openmode __a, ::std::_Ios_Openmode __b)
  {
    return (::std::_Ios_Openmode)(static_cast<int>(__a) & static_cast<int>(__b));
  }
  inline ::std::_Ios_Openmode operator |(::std::_Ios_Openmode __a, ::std::_Ios_Openmode __b)
  {
    return (::std::_Ios_Openmode)(static_cast<int>(__a) | static_cast<int>(__b));
  }
  inline ::std::_Ios_Openmode operator ^(::std::_Ios_Openmode __a, ::std::_Ios_Openmode __b)
  {
    return (::std::_Ios_Openmode)(static_cast<int>(__a) ^ static_cast<int>(__b));
  }
  inline ::std::_Ios_Openmode operator ~(::std::_Ios_Openmode __a)
  {
    return (::std::_Ios_Openmode)~static_cast<int>(__a);
  }
  inline const ::std::_Ios_Openmode &operator |=(::std::_Ios_Openmode &__a, ::std::_Ios_Openmode __b)
  {
    return __a = __a | __b;
  }
  inline const ::std::_Ios_Openmode &operator &=(::std::_Ios_Openmode &__a, ::std::_Ios_Openmode __b)
  {
    return __a = __a & __b;
  }
  inline const ::std::_Ios_Openmode &operator ^=(::std::_Ios_Openmode &__a, ::std::_Ios_Openmode __b)
  {
    return __a = __a ^ __b;
  }
  enum _Ios_Iostate
  {
    _S_goodbit = 0,
    _S_badbit = 1L << 0,
    _S_eofbit = 1L << 1,
    _S_failbit = 1L << 2,
    _S_ios_iostate_end = 1L << 16
  };
  inline ::std::_Ios_Iostate operator &(::std::_Ios_Iostate __a, ::std::_Ios_Iostate __b)
  {
    return (::std::_Ios_Iostate)(static_cast<int>(__a) & static_cast<int>(__b));
  }
  inline ::std::_Ios_Iostate operator |(::std::_Ios_Iostate __a, ::std::_Ios_Iostate __b)
  {
    return (::std::_Ios_Iostate)(static_cast<int>(__a) | static_cast<int>(__b));
  }
  inline ::std::_Ios_Iostate operator ^(::std::_Ios_Iostate __a, ::std::_Ios_Iostate __b)
  {
    return (::std::_Ios_Iostate)(static_cast<int>(__a) ^ static_cast<int>(__b));
  }
  inline ::std::_Ios_Iostate operator ~(::std::_Ios_Iostate __a)
  {
    return (::std::_Ios_Iostate)~static_cast<int>(__a);
  }
  inline const ::std::_Ios_Iostate &operator |=(::std::_Ios_Iostate &__a, ::std::_Ios_Iostate __b)
  {
    return __a = __a | __b;
  }
  inline const ::std::_Ios_Iostate &operator &=(::std::_Ios_Iostate &__a, ::std::_Ios_Iostate __b)
  {
    return __a = __a & __b;
  }
  inline const ::std::_Ios_Iostate &operator ^=(::std::_Ios_Iostate &__a, ::std::_Ios_Iostate __b)
  {
    return __a = __a ^ __b;
  }
  enum _Ios_Seekdir
  {
    _S_beg = 0,
    _S_cur = 1,
    _S_end = 2,
    _S_ios_seekdir_end = 1L << 16
  };
  class  ios_base
  {
    public:
      class failure;
    protected:
      struct _Callback_list;
      struct _Words;
    public:
      class Init;
      class  failure : public ::std::exception
      {
        public:
          explicit failure(const ::std::string &__str) throw();
          virtual ~failure() throw();
          virtual const char *what() const  throw();
        private:
          ::std::string _M_msg;
        public:
      };
      typedef ::std::_Ios_Fmtflags fmtflags;
      static const ::std::ios_base::fmtflags boolalpha = ::std::_S_boolalpha;
      static const ::std::ios_base::fmtflags dec = ::std::_S_dec;
      static const ::std::ios_base::fmtflags fixed = ::std::_S_fixed;
      static const ::std::ios_base::fmtflags hex = ::std::_S_hex;
      static const ::std::ios_base::fmtflags internal = ::std::_S_internal;
      static const ::std::ios_base::fmtflags left = ::std::_S_left;
      static const ::std::ios_base::fmtflags oct = ::std::_S_oct;
      static const ::std::ios_base::fmtflags right = ::std::_S_right;
      static const ::std::ios_base::fmtflags scientific = ::std::_S_scientific;
      static const ::std::ios_base::fmtflags showbase = ::std::_S_showbase;
      static const ::std::ios_base::fmtflags showpoint = ::std::_S_showpoint;
      static const ::std::ios_base::fmtflags showpos = ::std::_S_showpos;
      static const ::std::ios_base::fmtflags skipws = ::std::_S_skipws;
      static const ::std::ios_base::fmtflags unitbuf = ::std::_S_unitbuf;
      static const ::std::ios_base::fmtflags uppercase = ::std::_S_uppercase;
      static const ::std::ios_base::fmtflags adjustfield = ::std::_S_adjustfield;
      static const ::std::ios_base::fmtflags basefield = ::std::_S_basefield;
      static const ::std::ios_base::fmtflags floatfield = ::std::_S_floatfield;
      typedef ::std::_Ios_Iostate iostate;
      static const ::std::ios_base::iostate badbit = ::std::_S_badbit;
      static const ::std::ios_base::iostate eofbit = ::std::_S_eofbit;
      static const ::std::ios_base::iostate failbit = ::std::_S_failbit;
      static const ::std::ios_base::iostate goodbit = ::std::_S_goodbit;
      typedef ::std::_Ios_Openmode openmode;
      static const ::std::ios_base::openmode app = ::std::_S_app;
      static const ::std::ios_base::openmode ate = ::std::_S_ate;
      static const ::std::ios_base::openmode binary = ::std::_S_bin;
      static const ::std::ios_base::openmode in = ::std::_S_in;
      static const ::std::ios_base::openmode out = ::std::_S_out;
      static const ::std::ios_base::openmode trunc = ::std::_S_trunc;
      typedef ::std::_Ios_Seekdir seekdir;
      static const ::std::ios_base::seekdir beg = ::std::_S_beg;
      static const ::std::ios_base::seekdir cur = ::std::_S_cur;
      static const ::std::ios_base::seekdir end = ::std::_S_end;
      typedef int io_state;
      typedef int open_mode;
      typedef int seek_dir;
      typedef ::std::streampos streampos;
      typedef ::std::streamoff streamoff;
      enum event
      {
        erase_event = 0,
        imbue_event = 1,
        copyfmt_event = 2
      };
      typedef void (*event_callback)(::std::ios_base::event, ::std::ios_base &, int);
      void register_callback(::std::ios_base::event_callback __fn, int __index);
    protected:
      ::std::streamsize _M_precision;
      ::std::streamsize _M_width;
      ::std::ios_base::fmtflags _M_flags;
      ::std::ios_base::iostate _M_exception;
      ::std::ios_base::iostate _M_streambuf_state;
      struct  _Callback_list
      {
          ::std::ios_base::_Callback_list *_M_next;
          ::std::ios_base::event_callback _M_fn;
          int _M_index;
          ::_Atomic_word _M_refcount;
          inline _Callback_list(::std::ios_base::event_callback __fn, int __index, ::std::ios_base::_Callback_list *__cb)
            : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0)
          {
          }
          inline void _M_add_reference()
          {
            ::__gnu_cxx::__atomic_add_dispatch(&(*this)._M_refcount, 1);
          }
          inline int _M_remove_reference()
          {
            ;
            int __res(::__gnu_cxx::__exchange_and_add_dispatch(&(*this)._M_refcount,  -1));
            if (__res == 0)
              {
                ;
              }
            return __res;
          }
      };
      ::std::ios_base::_Callback_list *_M_callbacks;
      void _M_call_callbacks(::std::ios_base::event __ev) throw();
      void _M_dispose_callbacks() throw();
      struct  _Words
      {
          void *_M_pword;
          long int _M_iword;
          inline _Words()
            : _M_pword(0), _M_iword(0)
          {
          }
      };
      ::std::ios_base::_Words _M_word_zero;
      enum mcc_enum_anon_59
      {
        _S_local_word_size = 8
      };
      ::std::ios_base::_Words _M_local_word[8];
      int _M_word_size;
      ::std::ios_base::_Words *_M_word;
      ::std::ios_base::_Words &_M_grow_words(int __index, bool __iword);
      ::std::locale _M_ios_locale;
      void _M_init() throw();
    public:
      class  Init
      {
        public:
          Init();
          ~Init();
        private:
          static ::_Atomic_word _S_refcount;
          static bool _S_synced_with_stdio;
        public:
        friend class ios_base;
      };
      inline ::std::ios_base::fmtflags flags() const 
      {
        return (*this)._M_flags;
      }
      inline ::std::ios_base::fmtflags flags(::std::ios_base::fmtflags __fmtfl)
      {
        ::std::ios_base::fmtflags __old((*this)._M_flags);
        (*this)._M_flags = __fmtfl;
        return __old;
      }
      inline ::std::ios_base::fmtflags setf(::std::ios_base::fmtflags __fmtfl)
      {
        ::std::ios_base::fmtflags __old((*this)._M_flags);
        (*this)._M_flags |= __fmtfl;
        return __old;
      }
      inline ::std::ios_base::fmtflags setf(::std::ios_base::fmtflags __fmtfl, ::std::ios_base::fmtflags __mask)
      {
        ::std::ios_base::fmtflags __old((*this)._M_flags);
        (*this)._M_flags &=  ~__mask;
        (*this)._M_flags |= __fmtfl & __mask;
        return __old;
      }
      inline void unsetf(::std::ios_base::fmtflags __mask)
      {
        (*this)._M_flags &=  ~__mask;
      }
      inline ::std::streamsize precision() const 
      {
        return (*this)._M_precision;
      }
      inline ::std::streamsize precision(::std::streamsize __prec)
      {
        ::std::streamsize __old((*this)._M_precision);
        (*this)._M_precision = __prec;
        return __old;
      }
      inline ::std::streamsize width() const 
      {
        return (*this)._M_width;
      }
      inline ::std::streamsize width(::std::streamsize __wide)
      {
        ::std::streamsize __old((*this)._M_width);
        (*this)._M_width = __wide;
        return __old;
      }
      static bool sync_with_stdio(bool __sync  = true);
      ::std::locale imbue(const ::std::locale &__loc) throw();
      inline ::std::locale getloc() const 
      {
        return (*this)._M_ios_locale;
      }
      inline const ::std::locale &_M_getloc() const 
      {
        return (*this)._M_ios_locale;
      }
      static int xalloc() throw();
      inline long int &iword(int __ix)
      {
        ::std::ios_base::_Words &__word(__ix < (*this)._M_word_size ? (*this)._M_word[__ix] : (*this).::std::ios_base::_M_grow_words(__ix, true));
        return __word._M_iword;
      }
      inline void *&pword(int __ix)
      {
        ::std::ios_base::_Words &__word(__ix < (*this)._M_word_size ? (*this)._M_word[__ix] : (*this).::std::ios_base::_M_grow_words(__ix, false));
        return __word._M_pword;
      }
      virtual ~ios_base();
    protected:
      ios_base() throw();
    private:
      ios_base(const ::std::ios_base &);
      ::std::ios_base &operator =(const ::std::ios_base &);
  };
  inline ::std::ios_base &boolalpha(::std::ios_base &__base)
  {
    __base.::std::ios_base::setf(::std::ios_base::boolalpha);
    return __base;
  }
  inline ::std::ios_base &noboolalpha(::std::ios_base &__base)
  {
    __base.::std::ios_base::unsetf(::std::ios_base::boolalpha);
    return __base;
  }
  inline ::std::ios_base &showbase(::std::ios_base &__base)
  {
    __base.::std::ios_base::setf(::std::ios_base::showbase);
    return __base;
  }
  inline ::std::ios_base &noshowbase(::std::ios_base &__base)
  {
    __base.::std::ios_base::unsetf(::std::ios_base::showbase);
    return __base;
  }
  inline ::std::ios_base &showpoint(::std::ios_base &__base)
  {
    __base.::std::ios_base::setf(::std::ios_base::showpoint);
    return __base;
  }
  inline ::std::ios_base &noshowpoint(::std::ios_base &__base)
  {
    __base.::std::ios_base::unsetf(::std::ios_base::showpoint);
    return __base;
  }
  inline ::std::ios_base &showpos(::std::ios_base &__base)
  {
    __base.::std::ios_base::setf(::std::ios_base::showpos);
    return __base;
  }
  inline ::std::ios_base &noshowpos(::std::ios_base &__base)
  {
    __base.::std::ios_base::unsetf(::std::ios_base::showpos);
    return __base;
  }
  inline ::std::ios_base &skipws(::std::ios_base &__base)
  {
    __base.::std::ios_base::setf(::std::ios_base::skipws);
    return __base;
  }
  inline ::std::ios_base &noskipws(::std::ios_base &__base)
  {
    __base.::std::ios_base::unsetf(::std::ios_base::skipws);
    return __base;
  }
  inline ::std::ios_base &uppercase(::std::ios_base &__base)
  {
    __base.::std::ios_base::setf(::std::ios_base::uppercase);
    return __base;
  }
  inline ::std::ios_base &nouppercase(::std::ios_base &__base)
  {
    __base.::std::ios_base::unsetf(::std::ios_base::uppercase);
    return __base;
  }
  inline ::std::ios_base &unitbuf(::std::ios_base &__base)
  {
    __base.::std::ios_base::setf(::std::ios_base::unitbuf);
    return __base;
  }
  inline ::std::ios_base &nounitbuf(::std::ios_base &__base)
  {
    __base.::std::ios_base::unsetf(::std::ios_base::unitbuf);
    return __base;
  }
  inline ::std::ios_base &internal(::std::ios_base &__base)
  {
    __base.::std::ios_base::setf(::std::ios_base::internal, ::std::ios_base::adjustfield);
    return __base;
  }
  inline ::std::ios_base &left(::std::ios_base &__base)
  {
    __base.::std::ios_base::setf(::std::ios_base::left, ::std::ios_base::adjustfield);
    return __base;
  }
  inline ::std::ios_base &right(::std::ios_base &__base)
  {
    __base.::std::ios_base::setf(::std::ios_base::right, ::std::ios_base::adjustfield);
    return __base;
  }
  inline ::std::ios_base &dec(::std::ios_base &__base)
  {
    __base.::std::ios_base::setf(::std::ios_base::dec, ::std::ios_base::basefield);
    return __base;
  }
  inline ::std::ios_base &hex(::std::ios_base &__base)
  {
    __base.::std::ios_base::setf(::std::ios_base::hex, ::std::ios_base::basefield);
    return __base;
  }
  inline ::std::ios_base &oct(::std::ios_base &__base)
  {
    __base.::std::ios_base::setf(::std::ios_base::oct, ::std::ios_base::basefield);
    return __base;
  }
  inline ::std::ios_base &fixed(::std::ios_base &__base)
  {
    __base.::std::ios_base::setf(::std::ios_base::fixed, ::std::ios_base::floatfield);
    return __base;
  }
  inline ::std::ios_base &scientific(::std::ios_base &__base)
  {
    __base.::std::ios_base::setf(::std::ios_base::scientific, ::std::ios_base::floatfield);
    return __base;
  }
  template < typename _CharT, typename _Traits >
  ::std::streamsize __copy_streambufs_eof(::std::basic_streambuf<_CharT, _Traits> *__sbin, ::std::basic_streambuf<_CharT, _Traits> *__sbout, bool &__ineof);
  template < typename _CharT, typename _Traits >
  class  basic_streambuf
  {
    public:
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef ::std::basic_streambuf<typename ::std::basic_streambuf<_CharT, _Traits>::char_type, typename ::std::basic_streambuf<_CharT, _Traits>::traits_type> __streambuf_type;
    protected:
      typename ::std::basic_streambuf<_CharT, _Traits>::char_type *_M_in_beg;
      typename ::std::basic_streambuf<_CharT, _Traits>::char_type *_M_in_cur;
      typename ::std::basic_streambuf<_CharT, _Traits>::char_type *_M_in_end;
      typename ::std::basic_streambuf<_CharT, _Traits>::char_type *_M_out_beg;
      typename ::std::basic_streambuf<_CharT, _Traits>::char_type *_M_out_cur;
      typename ::std::basic_streambuf<_CharT, _Traits>::char_type *_M_out_end;
      ::std::locale _M_buf_locale;
    public:
      inline virtual ~basic_streambuf()
      {
      }
      inline ::std::locale pubimbue(const ::std::locale &__loc)
      {
        ::std::locale __tmp(this->getloc());
        this->imbue(__loc);
        _M_buf_locale = __loc;
        return __tmp;
      }
      inline ::std::locale getloc() const 
      {
        return _M_buf_locale;
      }
      inline typename ::std::basic_streambuf<_CharT, _Traits>::__streambuf_type *pubsetbuf(typename ::std::basic_streambuf<_CharT, _Traits>::char_type *__s, ::std::streamsize __n)
      {
        return this->setbuf(__s, __n);
      }
      inline typename ::std::basic_streambuf<_CharT, _Traits>::pos_type pubseekoff(typename ::std::basic_streambuf<_CharT, _Traits>::off_type __off, ::std::ios_base::seekdir __way, ::std::ios_base::openmode __mode  = ::std::ios_base::in | ::std::ios_base::out)
      {
        return this->seekoff(__off, __way, __mode);
      }
      inline typename ::std::basic_streambuf<_CharT, _Traits>::pos_type pubseekpos(typename ::std::basic_streambuf<_CharT, _Traits>::pos_type __sp, ::std::ios_base::openmode __mode  = ::std::ios_base::in | ::std::ios_base::out)
      {
        return this->seekpos(__sp, __mode);
      }
      inline int pubsync()
      {
        return this->sync();
      }
      inline ::std::streamsize in_avail()
      {
        const ::std::streamsize __ret(this->egptr() - this->gptr());
        return __ret ? __ret : this->showmanyc();
      }
      inline typename ::std::basic_streambuf<_CharT, _Traits>::int_type snextc()
      {
        typename ::std::basic_streambuf<_CharT, _Traits>::int_type __ret = traits_type::eof();
        if (__builtin_expect(!traits_type::eq_int_type(this->sbumpc(), __ret), true))
          {
            __ret = this->sgetc();
          }
        return __ret;
      }
      inline typename ::std::basic_streambuf<_CharT, _Traits>::int_type sbumpc()
      {
        typename ::std::basic_streambuf<_CharT, _Traits>::int_type __ret;
        if (__builtin_expect(this->gptr() < this->egptr(), true))
          {
            __ret = traits_type::to_int_type(*this->gptr());
            this->gbump(1);
          }
        else
          {
            __ret = this->uflow();
          }
        return __ret;
      }
      inline typename ::std::basic_streambuf<_CharT, _Traits>::int_type sgetc()
      {
        typename ::std::basic_streambuf<_CharT, _Traits>::int_type __ret;
        if (__builtin_expect(this->gptr() < this->egptr(), true))
          {
            __ret = traits_type::to_int_type(*this->gptr());
          }
        else
          {
            __ret = this->underflow();
          }
        return __ret;
      }
      inline ::std::streamsize sgetn(typename ::std::basic_streambuf<_CharT, _Traits>::char_type *__s, ::std::streamsize __n)
      {
        return this->xsgetn(__s, __n);
      }
      inline typename ::std::basic_streambuf<_CharT, _Traits>::int_type sputbackc(typename ::std::basic_streambuf<_CharT, _Traits>::char_type __c)
      {
        typename ::std::basic_streambuf<_CharT, _Traits>::int_type __ret;
        const bool __testpos(this->eback() < this->gptr());
        if (__builtin_expect(!__testpos || !traits_type::eq(__c, this->gptr()[ -1]), false))
          {
            __ret = this->pbackfail(traits_type::to_int_type(__c));
          }
        else
          {
            this->gbump( -1);
            __ret = traits_type::to_int_type(*this->gptr());
          }
        return __ret;
      }
      inline typename ::std::basic_streambuf<_CharT, _Traits>::int_type sungetc()
      {
        typename ::std::basic_streambuf<_CharT, _Traits>::int_type __ret;
        if (__builtin_expect(this->eback() < this->gptr(), true))
          {
            this->gbump( -1);
            __ret = traits_type::to_int_type(*this->gptr());
          }
        else
          {
            __ret = this->pbackfail();
          }
        return __ret;
      }
      inline typename ::std::basic_streambuf<_CharT, _Traits>::int_type sputc(typename ::std::basic_streambuf<_CharT, _Traits>::char_type __c)
      {
        typename ::std::basic_streambuf<_CharT, _Traits>::int_type __ret;
        if (__builtin_expect(this->pptr() < this->epptr(), true))
          {
            *this->pptr() = __c;
            this->pbump(1);
            __ret = traits_type::to_int_type(__c);
          }
        else
          {
            __ret = this->overflow(traits_type::to_int_type(__c));
          }
        return __ret;
      }
      inline ::std::streamsize sputn(const typename ::std::basic_streambuf<_CharT, _Traits>::char_type *__s, ::std::streamsize __n)
      {
        return this->xsputn(__s, __n);
      }
    protected:
      inline basic_streambuf()
        : _M_in_beg(0), _M_in_cur(0), _M_in_end(0), _M_out_beg(0), _M_out_cur(0), _M_out_end(0), _M_buf_locale(::std::locale())
      {
      }
      inline typename ::std::basic_streambuf<_CharT, _Traits>::char_type *eback() const 
      {
        return _M_in_beg;
      }
      inline typename ::std::basic_streambuf<_CharT, _Traits>::char_type *gptr() const 
      {
        return _M_in_cur;
      }
      inline typename ::std::basic_streambuf<_CharT, _Traits>::char_type *egptr() const 
      {
        return _M_in_end;
      }
      inline void gbump(int __n)
      {
        _M_in_cur += __n;
      }
      inline void setg(typename ::std::basic_streambuf<_CharT, _Traits>::char_type *__gbeg, typename ::std::basic_streambuf<_CharT, _Traits>::char_type *__gnext, typename ::std::basic_streambuf<_CharT, _Traits>::char_type *__gend)
      {
        _M_in_beg = __gbeg;
        _M_in_cur = __gnext;
        _M_in_end = __gend;
      }
      inline typename ::std::basic_streambuf<_CharT, _Traits>::char_type *pbase() const 
      {
        return _M_out_beg;
      }
      inline typename ::std::basic_streambuf<_CharT, _Traits>::char_type *pptr() const 
      {
        return _M_out_cur;
      }
      inline typename ::std::basic_streambuf<_CharT, _Traits>::char_type *epptr() const 
      {
        return _M_out_end;
      }
      inline void pbump(int __n)
      {
        _M_out_cur += __n;
      }
      inline void setp(typename ::std::basic_streambuf<_CharT, _Traits>::char_type *__pbeg, typename ::std::basic_streambuf<_CharT, _Traits>::char_type *__pend)
      {
        _M_out_beg = _M_out_cur = __pbeg;
        _M_out_end = __pend;
      }
      inline virtual void imbue(const ::std::locale &__loc)
      {
      }
      inline virtual ::std::basic_streambuf<typename ::std::basic_streambuf<_CharT, _Traits>::char_type, _Traits> *setbuf(typename ::std::basic_streambuf<_CharT, _Traits>::char_type *, ::std::streamsize)
      {
        return this;
      }
      inline virtual typename ::std::basic_streambuf<_CharT, _Traits>::pos_type seekoff(typename ::std::basic_streambuf<_CharT, _Traits>::off_type, ::std::ios_base::seekdir, ::std::ios_base::openmode  = ::std::ios_base::in | ::std::ios_base::out)
      {
        return typename ::std::basic_streambuf<_CharT, _Traits>::pos_type(typename ::std::basic_streambuf<_CharT, _Traits>::off_type( -1));
      }
      inline virtual typename ::std::basic_streambuf<_CharT, _Traits>::pos_type seekpos(typename ::std::basic_streambuf<_CharT, _Traits>::pos_type, ::std::ios_base::openmode  = ::std::ios_base::in | ::std::ios_base::out)
      {
        return typename ::std::basic_streambuf<_CharT, _Traits>::pos_type(typename ::std::basic_streambuf<_CharT, _Traits>::off_type( -1));
      }
      inline virtual int sync()
      {
        return 0;
      }
      inline virtual ::std::streamsize showmanyc()
      {
        return 0;
      }
      virtual ::std::streamsize xsgetn(typename ::std::basic_streambuf<_CharT, _Traits>::char_type *__s, ::std::streamsize __n);
      inline virtual typename ::std::basic_streambuf<_CharT, _Traits>::int_type underflow()
      {
        return traits_type::eof();
      }
      inline virtual typename ::std::basic_streambuf<_CharT, _Traits>::int_type uflow()
      {
        typename ::std::basic_streambuf<_CharT, _Traits>::int_type __ret = traits_type::eof();
        const bool __testeof(traits_type::eq_int_type(this->underflow(), __ret));
        if (!__testeof)
          {
            __ret = traits_type::to_int_type(*this->gptr());
            this->gbump(1);
          }
        return __ret;
      }
      inline virtual typename ::std::basic_streambuf<_CharT, _Traits>::int_type pbackfail(typename ::std::basic_streambuf<_CharT, _Traits>::int_type __c  = traits_type::eof())
      {
        return traits_type::eof();
      }
      virtual ::std::streamsize xsputn(const typename ::std::basic_streambuf<_CharT, _Traits>::char_type *__s, ::std::streamsize __n);
      inline virtual typename ::std::basic_streambuf<_CharT, _Traits>::int_type overflow(typename ::std::basic_streambuf<_CharT, _Traits>::int_type __c  = traits_type::eof())
      {
        return traits_type::eof();
      }
    public:
      inline void stossc()
      {
        if (this->gptr() < this->egptr())
          {
            this->gbump(1);
          }
        else
          {
            this->uflow();
          }
      }
      inline void __safe_gbump(::std::streamsize __n)
      {
        _M_in_cur += __n;
      }
      inline void __safe_pbump(::std::streamsize __n)
      {
        _M_out_cur += __n;
      }
    private:
      inline basic_streambuf(const typename ::std::basic_streambuf<_CharT, _Traits>::__streambuf_type &__sb)
        : _M_in_beg(__sb._M_in_beg), _M_in_cur(__sb._M_in_cur), _M_in_end(__sb._M_in_end), _M_out_beg(__sb._M_out_beg), _M_out_cur(__sb._M_out_cur), _M_out_end(__sb._M_out_cur), _M_buf_locale(__sb._M_buf_locale)
      {
      }
      inline typename ::std::basic_streambuf<_CharT, _Traits>::__streambuf_type &operator =(const typename ::std::basic_streambuf<_CharT, _Traits>::__streambuf_type &)
      {
        return *this;
      }
    friend class ::std::basic_ios<typename ::std::basic_streambuf<_CharT, _Traits>::char_type, typename ::std::basic_streambuf<_CharT, _Traits>::traits_type>;
    friend class ::std::basic_istream<typename ::std::basic_streambuf<_CharT, _Traits>::char_type, typename ::std::basic_streambuf<_CharT, _Traits>::traits_type>;
    friend class ::std::basic_ostream<typename ::std::basic_streambuf<_CharT, _Traits>::char_type, typename ::std::basic_streambuf<_CharT, _Traits>::traits_type>;
    friend class ::std::istreambuf_iterator<typename ::std::basic_streambuf<_CharT, _Traits>::char_type, typename ::std::basic_streambuf<_CharT, _Traits>::traits_type>;
    friend class ::std::ostreambuf_iterator<typename ::std::basic_streambuf<_CharT, _Traits>::char_type, typename ::std::basic_streambuf<_CharT, _Traits>::traits_type>;
    friend ::std::streamsize __copy_streambufs_eof<>(typename ::std::basic_streambuf<_CharT, _Traits>::__streambuf_type *, typename ::std::basic_streambuf<_CharT, _Traits>::__streambuf_type *, bool &);
    template < bool _IsMove, typename _CharT2 >
    friend typename ::__gnu_cxx::__enable_if<__is_char<_CharT2>::__value, _CharT2 *>::__type __copy_move_a2(::std::istreambuf_iterator<_CharT2, ::std::char_traits<_CharT2> >, ::std::istreambuf_iterator<_CharT2, ::std::char_traits<_CharT2> >, _CharT2 *);
    template < typename _CharT2 >
    friend typename ::__gnu_cxx::__enable_if<__is_char<_CharT2>::__value, ::std::istreambuf_iterator<_CharT2, ::std::char_traits<_CharT2> > >::__type find(::std::istreambuf_iterator<_CharT2, ::std::char_traits<_CharT2> >, ::std::istreambuf_iterator<_CharT2, ::std::char_traits<_CharT2> >, const _CharT2 &);
    template < typename _CharT2, typename _Traits2 >
    friend ::std::basic_istream<_CharT2, _Traits2> &operator >>(::std::basic_istream<_CharT2, _Traits2> &, _CharT2 *);
    template < typename _CharT2, typename _Traits2, typename _Alloc >
    friend ::std::basic_istream<_CharT2, _Traits2> &operator >>(::std::basic_istream<_CharT2, _Traits2> &, ::std::basic_string<_CharT2, _Traits2, _Alloc> &);
    template < typename _CharT2, typename _Traits2, typename _Alloc >
    friend ::std::basic_istream<_CharT2, _Traits2> &getline(::std::basic_istream<_CharT2, _Traits2> &, ::std::basic_string<_CharT2, _Traits2, _Alloc> &, _CharT2);
  };
  template <>
  long int __copy_streambufs_eof<char, ::std::char_traits<char> >(::std::basic_streambuf<char, ::std::char_traits<char> > *__sbin, ::std::basic_streambuf<char, ::std::char_traits<char> > *__sbout, bool &__ineof);
  template <>
  long int __copy_streambufs_eof<wchar_t, ::std::char_traits<wchar_t> >(::std::basic_streambuf<wchar_t, ::std::char_traits<wchar_t> > *__sbin, ::std::basic_streambuf<wchar_t, ::std::char_traits<wchar_t> > *__sbout, bool &__ineof);
  template < typename _CharT, typename _Traits >
  ::std::streamsize basic_streambuf<_CharT, _Traits>::xsgetn(typename ::std::basic_streambuf<_CharT, _Traits>::char_type *__s, ::std::streamsize __n)
  {
    ::std::streamsize __ret(0);
    while (__ret < __n)
      {
        const ::std::streamsize __buf_len(this->egptr() - this->gptr());
        if (__buf_len)
          {
            const ::std::streamsize __remaining(__n - __ret);
            const ::std::streamsize __len(::std::min /* <long int> */ (__buf_len, __remaining));
            traits_type::copy(__s, this->gptr(), __len);
            __ret += __len;
            __s += __len;
            this->__safe_gbump(__len);
          }
        if (__ret < __n)
          {
            const typename ::std::basic_streambuf<_CharT, _Traits>::int_type __c = this->uflow();
            if (!traits_type::eq_int_type(__c, traits_type::eof()))
              {
                traits_type::assign(*__s++, traits_type::to_char_type(__c));
                ++__ret;
              }
            else
              {
                break;
              }
          }
      }
    return __ret;
  }
  template < typename _CharT, typename _Traits >
  ::std::streamsize basic_streambuf<_CharT, _Traits>::xsputn(const typename ::std::basic_streambuf<_CharT, _Traits>::char_type *__s, ::std::streamsize __n)
  {
    ::std::streamsize __ret(0);
    while (__ret < __n)
      {
        const ::std::streamsize __buf_len(this->epptr() - this->pptr());
        if (__buf_len)
          {
            const ::std::streamsize __remaining(__n - __ret);
            const ::std::streamsize __len(::std::min /* <long int> */ (__buf_len, __remaining));
            traits_type::copy(this->pptr(), __s, __len);
            __ret += __len;
            __s += __len;
            this->__safe_pbump(__len);
          }
        if (__ret < __n)
          {
            typename ::std::basic_streambuf<_CharT, _Traits>::int_type __c = this->overflow(traits_type::to_int_type(*__s));
            if (!traits_type::eq_int_type(__c, traits_type::eof()))
              {
                ++__ret;
                ++__s;
              }
            else
              {
                break;
              }
          }
      }
    return __ret;
  }
  template < typename _CharT, typename _Traits >
  ::std::streamsize __copy_streambufs_eof(::std::basic_streambuf<_CharT, _Traits> *__sbin, ::std::basic_streambuf<_CharT, _Traits> *__sbout, bool &__ineof)
  {
    ::std::streamsize __ret(0);
    __ineof = true;
    typename _Traits::int_type __c = __sbin->sgetc();
    while (!_Traits::eq_int_type(__c, _Traits::eof()))
      {
        __c = __sbout->sputc(_Traits::to_char_type(__c));
        if (_Traits::eq_int_type(__c, _Traits::eof()))
          {
            __ineof = false;
            break;
          }
        ++__ret;
        __c = __sbin->snextc();
      }
    return __ret;
  }
  template < typename _CharT, typename _Traits >
  inline ::std::streamsize __copy_streambufs(::std::basic_streambuf<_CharT, _Traits> *__sbin, ::std::basic_streambuf<_CharT, _Traits> *__sbout);
  template < typename _CharT, typename _Traits >
  inline ::std::streamsize __copy_streambufs(::std::basic_streambuf<_CharT, _Traits> *__sbin, ::std::basic_streambuf<_CharT, _Traits> *__sbout)
  {
    bool __ineof;
    return __copy_streambufs_eof(__sbin, __sbout, __ineof);
  }
extern template class ::std::basic_streambuf<char, ::std::char_traits<char> >;
extern template long int __copy_streambufs(::std::basic_streambuf<char, ::std::char_traits<char> > *, ::std::basic_streambuf<char, ::std::char_traits<char> > *);
extern template long int __copy_streambufs_eof(::std::basic_streambuf<char, ::std::char_traits<char> > *, ::std::basic_streambuf<char, ::std::char_traits<char> > *, bool &);
extern template class ::std::basic_streambuf<wchar_t, ::std::char_traits<wchar_t> >;
extern template long int __copy_streambufs(::std::basic_streambuf<wchar_t, ::std::char_traits<wchar_t> > *, ::std::basic_streambuf<wchar_t, ::std::char_traits<wchar_t> > *);
extern template long int __copy_streambufs_eof(::std::basic_streambuf<wchar_t, ::std::char_traits<wchar_t> > *, ::std::basic_streambuf<wchar_t, ::std::char_traits<wchar_t> > *, bool &);
}
typedef unsigned long int wctype_t;
enum mcc_enum_anon_60
{
  __ISwupper = 0,
  __ISwlower = 1,
  __ISwalpha = 2,
  __ISwdigit = 3,
  __ISwxdigit = 4,
  __ISwspace = 5,
  __ISwprint = 6,
  __ISwgraph = 7,
  __ISwblank = 8,
  __ISwcntrl = 9,
  __ISwpunct = 10,
  __ISwalnum = 11,
  _ISwupper = ::__ISwupper < 8 ? (int)(1LU << ::__ISwupper << 24) : ::__ISwupper < 16 ? (int)(1LU << ::__ISwupper << 8) : ::__ISwupper < 24 ? (int)(1LU << ::__ISwupper >> 8) : (int)(1LU << ::__ISwupper >> 24),
  _ISwlower = ::__ISwlower < 8 ? (int)(1LU << ::__ISwlower << 24) : ::__ISwlower < 16 ? (int)(1LU << ::__ISwlower << 8) : ::__ISwlower < 24 ? (int)(1LU << ::__ISwlower >> 8) : (int)(1LU << ::__ISwlower >> 24),
  _ISwalpha = ::__ISwalpha < 8 ? (int)(1LU << ::__ISwalpha << 24) : ::__ISwalpha < 16 ? (int)(1LU << ::__ISwalpha << 8) : ::__ISwalpha < 24 ? (int)(1LU << ::__ISwalpha >> 8) : (int)(1LU << ::__ISwalpha >> 24),
  _ISwdigit = ::__ISwdigit < 8 ? (int)(1LU << ::__ISwdigit << 24) : ::__ISwdigit < 16 ? (int)(1LU << ::__ISwdigit << 8) : ::__ISwdigit < 24 ? (int)(1LU << ::__ISwdigit >> 8) : (int)(1LU << ::__ISwdigit >> 24),
  _ISwxdigit = ::__ISwxdigit < 8 ? (int)(1LU << ::__ISwxdigit << 24) : ::__ISwxdigit < 16 ? (int)(1LU << ::__ISwxdigit << 8) : ::__ISwxdigit < 24 ? (int)(1LU << ::__ISwxdigit >> 8) : (int)(1LU << ::__ISwxdigit >> 24),
  _ISwspace = ::__ISwspace < 8 ? (int)(1LU << ::__ISwspace << 24) : ::__ISwspace < 16 ? (int)(1LU << ::__ISwspace << 8) : ::__ISwspace < 24 ? (int)(1LU << ::__ISwspace >> 8) : (int)(1LU << ::__ISwspace >> 24),
  _ISwprint = ::__ISwprint < 8 ? (int)(1LU << ::__ISwprint << 24) : ::__ISwprint < 16 ? (int)(1LU << ::__ISwprint << 8) : ::__ISwprint < 24 ? (int)(1LU << ::__ISwprint >> 8) : (int)(1LU << ::__ISwprint >> 24),
  _ISwgraph = ::__ISwgraph < 8 ? (int)(1LU << ::__ISwgraph << 24) : ::__ISwgraph < 16 ? (int)(1LU << ::__ISwgraph << 8) : ::__ISwgraph < 24 ? (int)(1LU << ::__ISwgraph >> 8) : (int)(1LU << ::__ISwgraph >> 24),
  _ISwblank = ::__ISwblank < 8 ? (int)(1LU << ::__ISwblank << 24) : ::__ISwblank < 16 ? (int)(1LU << ::__ISwblank << 8) : ::__ISwblank < 24 ? (int)(1LU << ::__ISwblank >> 8) : (int)(1LU << ::__ISwblank >> 24),
  _ISwcntrl = ::__ISwcntrl < 8 ? (int)(1LU << ::__ISwcntrl << 24) : ::__ISwcntrl < 16 ? (int)(1LU << ::__ISwcntrl << 8) : ::__ISwcntrl < 24 ? (int)(1LU << ::__ISwcntrl >> 8) : (int)(1LU << ::__ISwcntrl >> 24),
  _ISwpunct = ::__ISwpunct < 8 ? (int)(1LU << ::__ISwpunct << 24) : ::__ISwpunct < 16 ? (int)(1LU << ::__ISwpunct << 8) : ::__ISwpunct < 24 ? (int)(1LU << ::__ISwpunct >> 8) : (int)(1LU << ::__ISwpunct >> 24),
  _ISwalnum = ::__ISwalnum < 8 ? (int)(1LU << ::__ISwalnum << 24) : ::__ISwalnum < 16 ? (int)(1LU << ::__ISwalnum << 8) : ::__ISwalnum < 24 ? (int)(1LU << ::__ISwalnum >> 8) : (int)(1LU << ::__ISwalnum >> 24)
};
extern "C"
{
  extern int iswalnum(::wint_t __wc) throw();
}
extern "C"
{
  extern int iswalpha(::wint_t __wc) throw();
}
extern "C"
{
  extern int iswcntrl(::wint_t __wc) throw();
}
extern "C"
{
  extern int iswdigit(::wint_t __wc) throw();
}
extern "C"
{
  extern int iswgraph(::wint_t __wc) throw();
}
extern "C"
{
  extern int iswlower(::wint_t __wc) throw();
}
extern "C"
{
  extern int iswprint(::wint_t __wc) throw();
}
extern "C"
{
  extern int iswpunct(::wint_t __wc) throw();
}
extern "C"
{
  extern int iswspace(::wint_t __wc) throw();
}
extern "C"
{
  extern int iswupper(::wint_t __wc) throw();
}
extern "C"
{
  extern int iswxdigit(::wint_t __wc) throw();
}
extern "C"
{
  extern int iswblank(::wint_t __wc) throw();
}
extern "C"
{
  extern ::wctype_t wctype(const char *__property) throw();
}
extern "C"
{
  extern int iswctype(::wint_t __wc, ::wctype_t __desc) throw();
}
typedef const ::__int32_t *wctrans_t;
extern "C"
{
  extern ::wint_t towlower(::wint_t __wc) throw();
}
extern "C"
{
  extern ::wint_t towupper(::wint_t __wc) throw();
}
extern "C"
{
  extern ::wctrans_t wctrans(const char *__property) throw();
}
extern "C"
{
  extern ::wint_t towctrans(::wint_t __wc, ::wctrans_t __desc) throw();
}
extern "C"
{
  extern int iswalnum_l(::wint_t __wc, ::__locale_t __locale) throw();
}
extern "C"
{
  extern int iswalpha_l(::wint_t __wc, ::__locale_t __locale) throw();
}
extern "C"
{
  extern int iswcntrl_l(::wint_t __wc, ::__locale_t __locale) throw();
}
extern "C"
{
  extern int iswdigit_l(::wint_t __wc, ::__locale_t __locale) throw();
}
extern "C"
{
  extern int iswgraph_l(::wint_t __wc, ::__locale_t __locale) throw();
}
extern "C"
{
  extern int iswlower_l(::wint_t __wc, ::__locale_t __locale) throw();
}
extern "C"
{
  extern int iswprint_l(::wint_t __wc, ::__locale_t __locale) throw();
}
extern "C"
{
  extern int iswpunct_l(::wint_t __wc, ::__locale_t __locale) throw();
}
extern "C"
{
  extern int iswspace_l(::wint_t __wc, ::__locale_t __locale) throw();
}
extern "C"
{
  extern int iswupper_l(::wint_t __wc, ::__locale_t __locale) throw();
}
extern "C"
{
  extern int iswxdigit_l(::wint_t __wc, ::__locale_t __locale) throw();
}
extern "C"
{
  extern int iswblank_l(::wint_t __wc, ::__locale_t __locale) throw();
}
extern "C"
{
  extern ::wctype_t wctype_l(const char *__property, ::__locale_t __locale) throw();
}
extern "C"
{
  extern int iswctype_l(::wint_t __wc, ::wctype_t __desc, ::__locale_t __locale) throw();
}
extern "C"
{
  extern ::wint_t towlower_l(::wint_t __wc, ::__locale_t __locale) throw();
}
extern "C"
{
  extern ::wint_t towupper_l(::wint_t __wc, ::__locale_t __locale) throw();
}
extern "C"
{
  extern ::wctrans_t wctrans_l(const char *__property, ::__locale_t __locale) throw();
}
extern "C"
{
  extern ::wint_t towctrans_l(::wint_t __wc, ::wctrans_t __desc, ::__locale_t __locale) throw();
}
namespace std __attribute__((__visibility__("default"))) {
  using ::wctrans_t;
  using ::wctype_t;
  using ::wint_t;
  using ::iswalnum;
  using ::iswalpha;
  using ::iswblank;
  using ::iswcntrl;
  using ::iswctype;
  using ::iswdigit;
  using ::iswgraph;
  using ::iswlower;
  using ::iswprint;
  using ::iswpunct;
  using ::iswspace;
  using ::iswupper;
  using ::iswxdigit;
  using ::towctrans;
  using ::towlower;
  using ::towupper;
  using ::wctrans;
  using ::wctype;
  class  ctype_base
  {
    public:
      typedef const int *__to_type;
      typedef unsigned short int mask;
      static const ::std::ctype_base::mask upper = ::_ISupper;
      static const ::std::ctype_base::mask lower = ::_ISlower;
      static const ::std::ctype_base::mask alpha = ::_ISalpha;
      static const ::std::ctype_base::mask digit = ::_ISdigit;
      static const ::std::ctype_base::mask xdigit = ::_ISxdigit;
      static const ::std::ctype_base::mask space = ::_ISspace;
      static const ::std::ctype_base::mask print = ::_ISprint;
      static const ::std::ctype_base::mask graph = (::_ISalpha | ::_ISdigit) | ::_ISpunct;
      static const ::std::ctype_base::mask cntrl = ::_IScntrl;
      static const ::std::ctype_base::mask punct = ::_ISpunct;
      static const ::std::ctype_base::mask alnum = ::_ISalpha | ::_ISdigit;
  };
  template < typename _CharT, typename _Traits >
  class  istreambuf_iterator : public ::std::iterator< ::std::input_iterator_tag, _CharT, typename _Traits::off_type, _CharT *, _CharT &>
  {
    public:
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename _Traits::int_type int_type;
      typedef ::std::basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef ::std::basic_istream<_CharT, _Traits> istream_type;
    private:
      mutable typename ::std::istreambuf_iterator<_CharT, _Traits>::streambuf_type *_M_sbuf;
      mutable typename ::std::istreambuf_iterator<_CharT, _Traits>::int_type _M_c;
    public:
      inline istreambuf_iterator() throw()
        : _M_sbuf(0), _M_c(traits_type::eof())
      {
      }
      inline istreambuf_iterator(typename ::std::istreambuf_iterator<_CharT, _Traits>::istream_type &__s) throw()
        : _M_sbuf(__s.rdbuf()), _M_c(traits_type::eof())
      {
      }
      inline istreambuf_iterator(typename ::std::istreambuf_iterator<_CharT, _Traits>::streambuf_type *__s) throw()
        : _M_sbuf(__s), _M_c(traits_type::eof())
      {
      }
      inline typename ::std::istreambuf_iterator<_CharT, _Traits>::char_type operator *() const 
      {
        return traits_type::to_char_type(_M_get());
      }
      inline ::std::istreambuf_iterator<_CharT, _Traits> &operator ++()
      {
        ;
        if (_M_sbuf)
          {
            _M_sbuf->sbumpc();
            _M_c = traits_type::eof();
          }
        return *this;
      }
      inline ::std::istreambuf_iterator<_CharT, _Traits> operator ++(int)
      {
        ;
        ::std::istreambuf_iterator<_CharT, _Traits> __old = *this;
        if (_M_sbuf)
          {
            __old._M_c = _M_sbuf->sbumpc();
            _M_c = traits_type::eof();
          }
        return __old;
      }
      inline bool equal(const ::std::istreambuf_iterator<_CharT, _Traits> &__b) const 
      {
        return _M_at_eof() == __b._M_at_eof();
      }
    private:
      inline typename ::std::istreambuf_iterator<_CharT, _Traits>::int_type _M_get() const 
      {
        const typename ::std::istreambuf_iterator<_CharT, _Traits>::int_type __eof = traits_type::eof();
        typename ::std::istreambuf_iterator<_CharT, _Traits>::int_type __ret = __eof;
        if (_M_sbuf)
          {
            if (!traits_type::eq_int_type(_M_c, __eof))
              {
                __ret = _M_c;
              }
            else
              {
                if (!traits_type::eq_int_type(__ret = _M_sbuf->sgetc(), __eof))
                  {
                    _M_c = __ret;
                  }
                else
                  {
                    _M_sbuf = 0;
                  }
              }
          }
        return __ret;
      }
      inline bool _M_at_eof() const 
      {
        const typename ::std::istreambuf_iterator<_CharT, _Traits>::int_type __eof = traits_type::eof();
        return traits_type::eq_int_type(_M_get(), __eof);
      }
    template < typename _CharT2 >
    friend typename ::__gnu_cxx::__enable_if<__is_char<_CharT2>::__value, ::std::ostreambuf_iterator<_CharT2, ::std::char_traits<_CharT2> > >::__type copy(::std::istreambuf_iterator<_CharT2, ::std::char_traits<_CharT2> >, ::std::istreambuf_iterator<_CharT2, ::std::char_traits<_CharT2> >, ::std::ostreambuf_iterator<_CharT2, ::std::char_traits<_CharT2> >);
    template < bool _IsMove, typename _CharT2 >
    friend typename ::__gnu_cxx::__enable_if<__is_char<_CharT2>::__value, _CharT2 *>::__type __copy_move_a2(::std::istreambuf_iterator<_CharT2, ::std::char_traits<_CharT2> >, ::std::istreambuf_iterator<_CharT2, ::std::char_traits<_CharT2> >, _CharT2 *);
    template < typename _CharT2 >
    friend typename ::__gnu_cxx::__enable_if<__is_char<_CharT2>::__value, ::std::istreambuf_iterator<_CharT2, ::std::char_traits<_CharT2> > >::__type find(::std::istreambuf_iterator<_CharT2, ::std::char_traits<_CharT2> >, ::std::istreambuf_iterator<_CharT2, ::std::char_traits<_CharT2> >, const _CharT2 &);
  };
  template < typename _CharT, typename _Traits >
  inline bool operator ==(const ::std::istreambuf_iterator<_CharT, _Traits> &__a, const ::std::istreambuf_iterator<_CharT, _Traits> &__b);
  template < typename _CharT, typename _Traits >
  inline bool operator ==(const ::std::istreambuf_iterator<_CharT, _Traits> &__a, const ::std::istreambuf_iterator<_CharT, _Traits> &__b)
  {
    return __a.equal(__b);
  }
  template < typename _CharT, typename _Traits >
  inline bool operator !=(const ::std::istreambuf_iterator<_CharT, _Traits> &__a, const ::std::istreambuf_iterator<_CharT, _Traits> &__b);
  template < typename _CharT, typename _Traits >
  inline bool operator !=(const ::std::istreambuf_iterator<_CharT, _Traits> &__a, const ::std::istreambuf_iterator<_CharT, _Traits> &__b)
  {
    return !__a.equal(__b);
  }
  template < typename _CharT, typename _Traits >
  class  ostreambuf_iterator : public ::std::iterator< ::std::output_iterator_tag, void, void, void, void>
  {
    public:
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef ::std::basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef ::std::basic_ostream<_CharT, _Traits> ostream_type;
    private:
      typename ::std::ostreambuf_iterator<_CharT, _Traits>::streambuf_type *_M_sbuf;
      bool _M_failed;
    public:
      inline ostreambuf_iterator(typename ::std::ostreambuf_iterator<_CharT, _Traits>::ostream_type &__s) throw()
        : _M_sbuf(__s.rdbuf()), _M_failed(!_M_sbuf)
      {
      }
      inline ostreambuf_iterator(typename ::std::ostreambuf_iterator<_CharT, _Traits>::streambuf_type *__s) throw()
        : _M_sbuf(__s), _M_failed(!_M_sbuf)
      {
      }
      inline ::std::ostreambuf_iterator<_CharT, _Traits> &operator =(_CharT __c)
      {
        if (!_M_failed && _Traits::eq_int_type(_M_sbuf->sputc(__c), _Traits::eof()))
          {
            _M_failed = true;
          }
        return *this;
      }
      inline ::std::ostreambuf_iterator<_CharT, _Traits> &operator *()
      {
        return *this;
      }
      inline ::std::ostreambuf_iterator<_CharT, _Traits> &operator ++(int)
      {
        return *this;
      }
      inline ::std::ostreambuf_iterator<_CharT, _Traits> &operator ++()
      {
        return *this;
      }
      inline bool failed() const  throw()
      {
        return _M_failed;
      }
      inline ::std::ostreambuf_iterator<_CharT, _Traits> &_M_put(const _CharT *__ws, ::std::streamsize __len)
      {
        if (__builtin_expect(!_M_failed, true) && __builtin_expect(this->_M_sbuf->sputn(__ws, __len) != __len, false))
          {
            _M_failed = true;
          }
        return *this;
      }
    template < typename _CharT2 >
    friend typename ::__gnu_cxx::__enable_if<__is_char<_CharT2>::__value, ::std::ostreambuf_iterator<_CharT2, ::std::char_traits<_CharT2> > >::__type copy(::std::istreambuf_iterator<_CharT2, ::std::char_traits<_CharT2> >, ::std::istreambuf_iterator<_CharT2, ::std::char_traits<_CharT2> >, ::std::ostreambuf_iterator<_CharT2, ::std::char_traits<_CharT2> >);
  };
  template < typename _CharT >
  typename ::__gnu_cxx::__enable_if<__is_char<_CharT>::__value, ::std::ostreambuf_iterator<_CharT, ::std::char_traits<_CharT> > >::__type copy(::std::istreambuf_iterator<_CharT, ::std::char_traits<_CharT> > __first, ::std::istreambuf_iterator<_CharT, ::std::char_traits<_CharT> > __last, ::std::ostreambuf_iterator<_CharT, ::std::char_traits<_CharT> > __result);
  template < typename _CharT >
  typename ::__gnu_cxx::__enable_if<__is_char<_CharT>::__value, ::std::ostreambuf_iterator<_CharT, ::std::char_traits<_CharT> > >::__type copy(::std::istreambuf_iterator<_CharT, ::std::char_traits<_CharT> > __first, ::std::istreambuf_iterator<_CharT, ::std::char_traits<_CharT> > __last, ::std::ostreambuf_iterator<_CharT, ::std::char_traits<_CharT> > __result)
  {
    if ((__first._M_sbuf && !__last._M_sbuf) && !__result._M_failed)
      {
        bool __ineof;
        __copy_streambufs_eof(__first._M_sbuf, __result._M_sbuf, __ineof);
        if (!__ineof)
          {
            __result._M_failed = true;
          }
      }
    return __result;
  }
  template < bool _IsMove, typename _CharT >
  typename ::__gnu_cxx::__enable_if<__is_char<_CharT>::__value, ::std::ostreambuf_iterator<_CharT, ::std::char_traits<_CharT> > >::__type __copy_move_a2(_CharT *__first, _CharT *__last, ::std::ostreambuf_iterator<_CharT, ::std::char_traits<_CharT> > __result)
  {
    const ::std::streamsize __num = __last - __first;
    if (__num > 0)
      {
        __result._M_put(__first, __num);
      }
    return __result;
  }
  template < bool _IsMove, typename _CharT >
  typename ::__gnu_cxx::__enable_if<__is_char<_CharT>::__value, ::std::ostreambuf_iterator<_CharT, ::std::char_traits<_CharT> > >::__type __copy_move_a2(const _CharT *__first, const _CharT *__last, ::std::ostreambuf_iterator<_CharT, ::std::char_traits<_CharT> > __result)
  {
    const ::std::streamsize __num = __last - __first;
    if (__num > 0)
      {
        __result._M_put(__first, __num);
      }
    return __result;
  }
  template < bool _IsMove, typename _CharT >
  typename ::__gnu_cxx::__enable_if<__is_char<_CharT>::__value, _CharT *>::__type __copy_move_a2(::std::istreambuf_iterator<_CharT, ::std::char_traits<_CharT> > __first, ::std::istreambuf_iterator<_CharT, ::std::char_traits<_CharT> > __last, _CharT *__result)
  {
    typedef ::std::istreambuf_iterator<_CharT, ::std::char_traits<_CharT> > __is_iterator_type;
    typedef typename ::std::istreambuf_iterator<_CharT, ::std::char_traits<_CharT> >::traits_type traits_type;
    typedef typename ::std::istreambuf_iterator<_CharT, ::std::char_traits<_CharT> >::streambuf_type streambuf_type;
    typedef typename traits_type::int_type int_type;
    if (__first._M_sbuf && !__last._M_sbuf)
      {
        streambuf_type *__sb = __first._M_sbuf;
        int_type __c = __sb->sgetc();
        while (!traits_type::eq_int_type(__c, traits_type::eof()))
          {
            const ::std::streamsize __n(__sb->egptr() - __sb->gptr());
            if (__n > 1)
              {
                traits_type::copy(__result, __sb->gptr(), __n);
                __sb->__safe_gbump(__n);
                __result += __n;
                __c = __sb->underflow();
              }
            else
              {
                *__result++ = traits_type::to_char_type(__c);
                __c = __sb->snextc();
              }
          }
      }
    return __result;
  }
  template < typename _CharT >
  typename ::__gnu_cxx::__enable_if<__is_char<_CharT>::__value, ::std::istreambuf_iterator<_CharT, ::std::char_traits<_CharT> > >::__type find(::std::istreambuf_iterator<_CharT, ::std::char_traits<_CharT> > __first, ::std::istreambuf_iterator<_CharT, ::std::char_traits<_CharT> > __last, const _CharT &__val);
  template < typename _CharT >
  typename ::__gnu_cxx::__enable_if<__is_char<_CharT>::__value, ::std::istreambuf_iterator<_CharT, ::std::char_traits<_CharT> > >::__type find(::std::istreambuf_iterator<_CharT, ::std::char_traits<_CharT> > __first, ::std::istreambuf_iterator<_CharT, ::std::char_traits<_CharT> > __last, const _CharT &__val)
  {
    typedef ::std::istreambuf_iterator<_CharT, ::std::char_traits<_CharT> > __is_iterator_type;
    typedef typename ::std::istreambuf_iterator<_CharT, ::std::char_traits<_CharT> >::traits_type traits_type;
    typedef typename ::std::istreambuf_iterator<_CharT, ::std::char_traits<_CharT> >::streambuf_type streambuf_type;
    typedef typename traits_type::int_type int_type;
    if (__first._M_sbuf && !__last._M_sbuf)
      {
        const int_type __ival = traits_type::to_int_type(__val);
        streambuf_type *__sb = __first._M_sbuf;
        int_type __c = __sb->sgetc();
        while (!traits_type::eq_int_type(__c, traits_type::eof()) && !traits_type::eq_int_type(__c, __ival))
          {
            ::std::streamsize __n(__sb->egptr() - __sb->gptr());
            if (__n > 1)
              {
                const _CharT *__p = traits_type::find(__sb->gptr(), __n, __val);
                if (__p)
                  {
                    __n = __p - __sb->gptr();
                  }
                __sb->__safe_gbump(__n);
                __c = __sb->sgetc();
              }
            else
              {
                __c = __sb->snextc();
              }
          }
        if (!traits_type::eq_int_type(__c, traits_type::eof()))
          {
            __first._M_c = __c;
          }
        else
          {
            __first._M_sbuf = 0;
          }
      }
    return __first;
  }
  template < typename _Tp >
  void __convert_to_v(const char *, _Tp &, ::std::ios_base::iostate &, const ::std::__c_locale &) throw();
  template <>
  void __convert_to_v<float>(const char *, float &, ::std::_Ios_Iostate &, ::__locale_struct *const &) throw();
  template <>
  void __convert_to_v<double>(const char *, double &, ::std::_Ios_Iostate &, ::__locale_struct *const &) throw();
  template <>
  void __convert_to_v<long double>(const char *, long double &, ::std::_Ios_Iostate &, ::__locale_struct *const &) throw();
  template < typename _CharT, typename _Traits >
  struct  __pad
  {
      static void _S_pad(::std::ios_base &__io, _CharT __fill, _CharT *__news, const _CharT *__olds, ::std::streamsize __newlen, ::std::streamsize __oldlen);
  };
  template < typename _CharT >
  _CharT *__add_grouping(_CharT *__s, _CharT __sep, const char *__gbeg, ::std::size_t __gsize, const _CharT *__first, const _CharT *__last);
  template < typename _CharT >
  inline ::std::ostreambuf_iterator<_CharT, ::std::char_traits<_CharT> > __write(::std::ostreambuf_iterator<_CharT, ::std::char_traits<_CharT> > __s, const _CharT *__ws, int __len);
  template < typename _CharT >
  inline ::std::ostreambuf_iterator<_CharT, ::std::char_traits<_CharT> > __write(::std::ostreambuf_iterator<_CharT, ::std::char_traits<_CharT> > __s, const _CharT *__ws, int __len)
  {
    __s._M_put(__ws, __len);
    return __s;
  }
  template < typename _CharT, typename _OutIter >
  inline _OutIter __write(_OutIter __s, const _CharT *__ws, int __len);
  template < typename _CharT, typename _OutIter >
  inline _OutIter __write(_OutIter __s, const _CharT *__ws, int __len)
  {
    for (int __j = 0; __j < __len; (__j++, ++__s))
      {
        *__s = __ws[__j];
      }
    return __s;
  }
  template < typename _CharT >
  class  __ctype_abstract_base : public ::std::locale::facet, public ::std::ctype_base
  {
    public:
      typedef _CharT char_type;
      inline bool is(::std::ctype_base::mask __m, typename ::std::__ctype_abstract_base<_CharT>::char_type __c) const 
      {
        return this->do_is(__m, __c);
      }
      inline const typename ::std::__ctype_abstract_base<_CharT>::char_type *is(const typename ::std::__ctype_abstract_base<_CharT>::char_type *__lo, const typename ::std::__ctype_abstract_base<_CharT>::char_type *__hi, ::std::ctype_base::mask *__vec) const 
      {
        return this->do_is(__lo, __hi, __vec);
      }
      inline const typename ::std::__ctype_abstract_base<_CharT>::char_type *scan_is(::std::ctype_base::mask __m, const typename ::std::__ctype_abstract_base<_CharT>::char_type *__lo, const typename ::std::__ctype_abstract_base<_CharT>::char_type *__hi) const 
      {
        return this->do_scan_is(__m, __lo, __hi);
      }
      inline const typename ::std::__ctype_abstract_base<_CharT>::char_type *scan_not(::std::ctype_base::mask __m, const typename ::std::__ctype_abstract_base<_CharT>::char_type *__lo, const typename ::std::__ctype_abstract_base<_CharT>::char_type *__hi) const 
      {
        return this->do_scan_not(__m, __lo, __hi);
      }
      inline typename ::std::__ctype_abstract_base<_CharT>::char_type toupper(typename ::std::__ctype_abstract_base<_CharT>::char_type __c) const 
      {
        return this->do_toupper(__c);
      }
      inline const typename ::std::__ctype_abstract_base<_CharT>::char_type *toupper(typename ::std::__ctype_abstract_base<_CharT>::char_type *__lo, const typename ::std::__ctype_abstract_base<_CharT>::char_type *__hi) const 
      {
        return this->do_toupper(__lo, __hi);
      }
      inline typename ::std::__ctype_abstract_base<_CharT>::char_type tolower(typename ::std::__ctype_abstract_base<_CharT>::char_type __c) const 
      {
        return this->do_tolower(__c);
      }
      inline const typename ::std::__ctype_abstract_base<_CharT>::char_type *tolower(typename ::std::__ctype_abstract_base<_CharT>::char_type *__lo, const typename ::std::__ctype_abstract_base<_CharT>::char_type *__hi) const 
      {
        return this->do_tolower(__lo, __hi);
      }
      inline typename ::std::__ctype_abstract_base<_CharT>::char_type widen(char __c) const 
      {
        return this->do_widen(__c);
      }
      inline const char *widen(const char *__lo, const char *__hi, typename ::std::__ctype_abstract_base<_CharT>::char_type *__to) const 
      {
        return this->do_widen(__lo, __hi, __to);
      }
      inline char narrow(typename ::std::__ctype_abstract_base<_CharT>::char_type __c, char __dfault) const 
      {
        return this->do_narrow(__c, __dfault);
      }
      inline const typename ::std::__ctype_abstract_base<_CharT>::char_type *narrow(const typename ::std::__ctype_abstract_base<_CharT>::char_type *__lo, const typename ::std::__ctype_abstract_base<_CharT>::char_type *__hi, char __dfault, char *__to) const 
      {
        return this->do_narrow(__lo, __hi, __dfault, __to);
      }
    protected:
      inline explicit __ctype_abstract_base(::std::size_t __refs  = 0)
        : facet(__refs)
      {
      }
      inline virtual ~__ctype_abstract_base()
      {
      }
      virtual bool do_is(::std::ctype_base::mask __m, typename ::std::__ctype_abstract_base<_CharT>::char_type __c) const  = 0 ;
      virtual const typename ::std::__ctype_abstract_base<_CharT>::char_type *do_is(const typename ::std::__ctype_abstract_base<_CharT>::char_type *__lo, const typename ::std::__ctype_abstract_base<_CharT>::char_type *__hi, ::std::ctype_base::mask *__vec) const  = 0 ;
      virtual const typename ::std::__ctype_abstract_base<_CharT>::char_type *do_scan_is(::std::ctype_base::mask __m, const typename ::std::__ctype_abstract_base<_CharT>::char_type *__lo, const typename ::std::__ctype_abstract_base<_CharT>::char_type *__hi) const  = 0 ;
      virtual const typename ::std::__ctype_abstract_base<_CharT>::char_type *do_scan_not(::std::ctype_base::mask __m, const typename ::std::__ctype_abstract_base<_CharT>::char_type *__lo, const typename ::std::__ctype_abstract_base<_CharT>::char_type *__hi) const  = 0 ;
      virtual typename ::std::__ctype_abstract_base<_CharT>::char_type do_toupper(typename ::std::__ctype_abstract_base<_CharT>::char_type __c) const  = 0 ;
      virtual const typename ::std::__ctype_abstract_base<_CharT>::char_type *do_toupper(typename ::std::__ctype_abstract_base<_CharT>::char_type *__lo, const typename ::std::__ctype_abstract_base<_CharT>::char_type *__hi) const  = 0 ;
      virtual typename ::std::__ctype_abstract_base<_CharT>::char_type do_tolower(typename ::std::__ctype_abstract_base<_CharT>::char_type __c) const  = 0 ;
      virtual const typename ::std::__ctype_abstract_base<_CharT>::char_type *do_tolower(typename ::std::__ctype_abstract_base<_CharT>::char_type *__lo, const typename ::std::__ctype_abstract_base<_CharT>::char_type *__hi) const  = 0 ;
      virtual typename ::std::__ctype_abstract_base<_CharT>::char_type do_widen(char __c) const  = 0 ;
      virtual const char *do_widen(const char *__lo, const char *__hi, typename ::std::__ctype_abstract_base<_CharT>::char_type *__to) const  = 0 ;
      virtual char do_narrow(typename ::std::__ctype_abstract_base<_CharT>::char_type __c, char __dfault) const  = 0 ;
      virtual const typename ::std::__ctype_abstract_base<_CharT>::char_type *do_narrow(const typename ::std::__ctype_abstract_base<_CharT>::char_type *__lo, const typename ::std::__ctype_abstract_base<_CharT>::char_type *__hi, char __dfault, char *__to) const  = 0 ;
  };
  template < typename _CharT >
  class  ctype : public ::std::__ctype_abstract_base<_CharT>
  {
    public:
      typedef _CharT char_type;
      typedef typename ::std::__ctype_abstract_base<_CharT>::mask mask;
      static ::std::locale::id id;
      inline explicit ctype(::std::size_t __refs  = 0)
        : __ctype_abstract_base<_CharT>(__refs)
      {
      }
    protected:
      virtual ~ctype();
      virtual bool do_is(typename ::std::ctype<_CharT>::mask __m, typename ::std::ctype<_CharT>::char_type __c) const ;
      virtual const typename ::std::ctype<_CharT>::char_type *do_is(const typename ::std::ctype<_CharT>::char_type *__lo, const typename ::std::ctype<_CharT>::char_type *__hi, typename ::std::ctype<_CharT>::mask *__vec) const ;
      virtual const typename ::std::ctype<_CharT>::char_type *do_scan_is(typename ::std::ctype<_CharT>::mask __m, const typename ::std::ctype<_CharT>::char_type *__lo, const typename ::std::ctype<_CharT>::char_type *__hi) const ;
      virtual const typename ::std::ctype<_CharT>::char_type *do_scan_not(typename ::std::ctype<_CharT>::mask __m, const typename ::std::ctype<_CharT>::char_type *__lo, const typename ::std::ctype<_CharT>::char_type *__hi) const ;
      virtual typename ::std::ctype<_CharT>::char_type do_toupper(typename ::std::ctype<_CharT>::char_type __c) const ;
      virtual const typename ::std::ctype<_CharT>::char_type *do_toupper(typename ::std::ctype<_CharT>::char_type *__lo, const typename ::std::ctype<_CharT>::char_type *__hi) const ;
      virtual typename ::std::ctype<_CharT>::char_type do_tolower(typename ::std::ctype<_CharT>::char_type __c) const ;
      virtual const typename ::std::ctype<_CharT>::char_type *do_tolower(typename ::std::ctype<_CharT>::char_type *__lo, const typename ::std::ctype<_CharT>::char_type *__hi) const ;
      virtual typename ::std::ctype<_CharT>::char_type do_widen(char __c) const ;
      virtual const char *do_widen(const char *__lo, const char *__hi, typename ::std::ctype<_CharT>::char_type *__dest) const ;
      virtual char do_narrow(typename ::std::ctype<_CharT>::char_type, char __dfault) const ;
      virtual const typename ::std::ctype<_CharT>::char_type *do_narrow(const typename ::std::ctype<_CharT>::char_type *__lo, const typename ::std::ctype<_CharT>::char_type *__hi, char __dfault, char *__to) const ;
  };
  template < typename _CharT >
  ::std::locale::id ctype<_CharT>::id;
  template <>
  class  ctype<char> : public ::std::locale::facet, public ::std::ctype_base
  {
    public:
      typedef char char_type;
    protected:
      ::std::__c_locale _M_c_locale_ctype;
      bool _M_del;
      ::std::ctype_base::__to_type _M_toupper;
      ::std::ctype_base::__to_type _M_tolower;
      const ::std::ctype_base::mask *_M_table;
      mutable char _M_widen_ok;
      mutable char _M_widen[0];
      mutable char _M_narrow[0];
      mutable char _M_narrow_ok;
    public:
      static ::std::locale::id id;
      static const ::std::size_t table_size = 1 + static_cast<unsigned char>( -1);
      explicit ctype(const ::std::ctype_base::mask *__table  = 0, bool __del  = false, ::std::size_t __refs  = 0);
      explicit ctype(::std::__c_locale __cloc, const ::std::ctype_base::mask *__table  = 0, bool __del  = false, ::std::size_t __refs  = 0);
      inline bool is(::std::ctype_base::mask __m, char __c) const ;
      inline const char *is(const char *__low, const char *__high, ::std::ctype_base::mask *__vec) const ;
      inline const char *scan_is(::std::ctype_base::mask __m, const char *__low, const char *__high) const ;
      inline const char *scan_not(::std::ctype_base::mask __m, const char *__low, const char *__high) const ;
      inline ::std::ctype<char>::char_type toupper(::std::ctype<char>::char_type __c) const 
      {
        return (*this).do_toupper(__c);
      }
      inline const ::std::ctype<char>::char_type *toupper(::std::ctype<char>::char_type *__lo, const ::std::ctype<char>::char_type *__hi) const 
      {
        return (*this).do_toupper(__lo, __hi);
      }
      inline ::std::ctype<char>::char_type tolower(::std::ctype<char>::char_type __c) const 
      {
        return (*this).do_tolower(__c);
      }
      inline const ::std::ctype<char>::char_type *tolower(::std::ctype<char>::char_type *__lo, const ::std::ctype<char>::char_type *__hi) const 
      {
        return (*this).do_tolower(__lo, __hi);
      }
      inline ::std::ctype<char>::char_type widen(char __c) const 
      {
        if ((*this)._M_widen_ok)
          {
            return (*this)._M_widen[static_cast<unsigned char>(__c)];
          }
        (*this).::std::ctype<char>::_M_widen_init();
        return (*this).do_widen(__c);
      }
      inline const char *widen(const char *__lo, const char *__hi, ::std::ctype<char>::char_type *__to) const 
      {
        if ((*this)._M_widen_ok == 1)
          {
            __builtin_memcpy(__to, __lo, __hi - __lo);
            return __hi;
          }
        if (!(*this)._M_widen_ok)
          {
            (*this).::std::ctype<char>::_M_widen_init();
          }
        return (*this).do_widen(__lo, __hi, __to);
      }
      inline char narrow(::std::ctype<char>::char_type __c, char __dfault) const 
      {
        if ((*this)._M_narrow[static_cast<unsigned char>(__c)])
          {
            return (*this)._M_narrow[static_cast<unsigned char>(__c)];
          }
        const char __t((*this).do_narrow(__c, __dfault));
        if (__t != __dfault)
          {
            (*this)._M_narrow[static_cast<unsigned char>(__c)] = __t;
          }
        return __t;
      }
      inline const ::std::ctype<char>::char_type *narrow(const ::std::ctype<char>::char_type *__lo, const ::std::ctype<char>::char_type *__hi, char __dfault, char *__to) const 
      {
        if (__builtin_expect((*this)._M_narrow_ok == 1, true))
          {
            __builtin_memcpy(__to, __lo, __hi - __lo);
            return __hi;
          }
        if (!(*this)._M_narrow_ok)
          {
            (*this).::std::ctype<char>::_M_narrow_init();
          }
        return (*this).do_narrow(__lo, __hi, __dfault, __to);
      }
      inline const ::std::ctype_base::mask *table() const  throw()
      {
        return (*this)._M_table;
      }
      static const ::std::ctype_base::mask *classic_table() throw();
    protected:
      virtual ~ctype();
      virtual ::std::ctype<char>::char_type do_toupper(::std::ctype<char>::char_type __c) const ;
      virtual const ::std::ctype<char>::char_type *do_toupper(::std::ctype<char>::char_type *__lo, const ::std::ctype<char>::char_type *__hi) const ;
      virtual ::std::ctype<char>::char_type do_tolower(::std::ctype<char>::char_type __c) const ;
      virtual const ::std::ctype<char>::char_type *do_tolower(::std::ctype<char>::char_type *__lo, const ::std::ctype<char>::char_type *__hi) const ;
      virtual inline ::std::ctype<char>::char_type do_widen(char __c) const 
      {
        return __c;
      }
      virtual inline const char *do_widen(const char *__lo, const char *__hi, ::std::ctype<char>::char_type *__to) const 
      {
        __builtin_memcpy(__to, __lo, __hi - __lo);
        return __hi;
      }
      virtual inline char do_narrow(::std::ctype<char>::char_type __c, char __dfault) const 
      {
        return __c;
      }
      virtual inline const ::std::ctype<char>::char_type *do_narrow(const ::std::ctype<char>::char_type *__lo, const ::std::ctype<char>::char_type *__hi, char __dfault, char *__to) const 
      {
        __builtin_memcpy(__to, __lo, __hi - __lo);
        return __hi;
      }
    private:
      void _M_narrow_init() const ;
      void _M_widen_init() const ;
    public:
  };
  template <>
  class  ctype<wchar_t> : public ::std::__ctype_abstract_base<wchar_t>
  {
    public:
      typedef wchar_t char_type;
      typedef ::wctype_t __wmask_type;
    protected:
      ::std::__c_locale _M_c_locale_ctype;
      bool _M_narrow_ok;
      char _M_narrow[128];
      ::wint_t _M_widen[0];
      ::std::ctype_base::mask _M_bit[16];
      ::std::ctype<wchar_t>::__wmask_type _M_wmask[16];
    public:
      static ::std::locale::id id;
      explicit ctype(::std::size_t __refs  = 0);
      explicit ctype(::std::__c_locale __cloc, ::std::size_t __refs  = 0);
    protected:
      ::std::ctype<wchar_t>::__wmask_type _M_convert_to_wmask(const ::std::ctype_base::mask __m) const  throw();
      virtual ~ctype();
      virtual bool do_is(::std::ctype_base::mask __m, ::std::ctype<wchar_t>::char_type __c) const ;
      virtual const ::std::ctype<wchar_t>::char_type *do_is(const ::std::ctype<wchar_t>::char_type *__lo, const ::std::ctype<wchar_t>::char_type *__hi, ::std::ctype_base::mask *__vec) const ;
      virtual const ::std::ctype<wchar_t>::char_type *do_scan_is(::std::ctype_base::mask __m, const ::std::ctype<wchar_t>::char_type *__lo, const ::std::ctype<wchar_t>::char_type *__hi) const ;
      virtual const ::std::ctype<wchar_t>::char_type *do_scan_not(::std::ctype_base::mask __m, const ::std::ctype<wchar_t>::char_type *__lo, const ::std::ctype<wchar_t>::char_type *__hi) const ;
      virtual ::std::ctype<wchar_t>::char_type do_toupper(::std::ctype<wchar_t>::char_type __c) const ;
      virtual const ::std::ctype<wchar_t>::char_type *do_toupper(::std::ctype<wchar_t>::char_type *__lo, const ::std::ctype<wchar_t>::char_type *__hi) const ;
      virtual ::std::ctype<wchar_t>::char_type do_tolower(::std::ctype<wchar_t>::char_type __c) const ;
      virtual const ::std::ctype<wchar_t>::char_type *do_tolower(::std::ctype<wchar_t>::char_type *__lo, const ::std::ctype<wchar_t>::char_type *__hi) const ;
      virtual ::std::ctype<wchar_t>::char_type do_widen(char __c) const ;
      virtual const char *do_widen(const char *__lo, const char *__hi, ::std::ctype<wchar_t>::char_type *__to) const ;
      virtual char do_narrow(::std::ctype<wchar_t>::char_type __c, char __dfault) const ;
      virtual const ::std::ctype<wchar_t>::char_type *do_narrow(const ::std::ctype<wchar_t>::char_type *__lo, const ::std::ctype<wchar_t>::char_type *__hi, char __dfault, char *__to) const ;
      void _M_initialize_ctype() throw();
    public:
  };
  template < typename _CharT >
  class  ctype_byname : public ::std::ctype<_CharT>
  {
    public:
      typedef typename ::std::ctype<_CharT>::mask mask;
      explicit ctype_byname(const char *__s, ::std::size_t __refs  = 0);
    protected:
      inline virtual ~ctype_byname()
      {
      }
  };
  template <>
  class  ctype_byname<char> : public ::std::ctype<char>
  {
    public:
      explicit ctype_byname(const char *__s, ::std::size_t __refs  = 0);
    protected:
      virtual ~ctype_byname();
    public:
  };
  template <>
  class  ctype_byname<wchar_t> : public ::std::ctype<wchar_t>
  {
    public:
      explicit ctype_byname(const char *__s, ::std::size_t __refs  = 0);
    protected:
      virtual ~ctype_byname();
    public:
  };
  inline bool ctype<char>::is(::std::ctype_base::mask __m, char __c) const 
  {
    return (*this)._M_table[static_cast<unsigned char>(__c)] & __m;
  }
  inline const char *ctype<char>::is(const char *__low, const char *__high, ::std::ctype_base::mask *__vec) const 
  {
    while (__low < __high)
      {
        *__vec++ = (*this)._M_table[static_cast<unsigned char>(*__low++)];
      }
    return __high;
  }
  inline const char *ctype<char>::scan_is(::std::ctype_base::mask __m, const char *__low, const char *__high) const 
  {
    while (__low < __high && !((*this)._M_table[static_cast<unsigned char>(*__low)] & __m))
      {
        ++__low;
      }
    return __low;
  }
  inline const char *ctype<char>::scan_not(::std::ctype_base::mask __m, const char *__low, const char *__high) const 
  {
    while (__low < __high && ((*this)._M_table[static_cast<unsigned char>(*__low)] & __m) != 0)
      {
        ++__low;
      }
    return __low;
  }
  class  __num_base
  {
    public:
      enum mcc_enum_anon_61
      {
        _S_ominus = 0,
        _S_oplus = 1,
        _S_ox = 2,
        _S_oX = 3,
        _S_odigits = 4,
        _S_odigits_end = ::std::__num_base::_S_odigits + 16,
        _S_oudigits = ::std::__num_base::_S_odigits_end,
        _S_oudigits_end = ::std::__num_base::_S_oudigits + 16,
        _S_oe = ::std::__num_base::_S_odigits + 14,
        _S_oE = ::std::__num_base::_S_oudigits + 14,
        _S_oend = ::std::__num_base::_S_oudigits_end
      };
      static const char *_S_atoms_out;
      static const char *_S_atoms_in;
      enum mcc_enum_anon_62
      {
        _S_iminus = 0,
        _S_iplus = 1,
        _S_ix = 2,
        _S_iX = 3,
        _S_izero = 4,
        _S_ie = ::std::__num_base::_S_izero + 14,
        _S_iE = ::std::__num_base::_S_izero + 20,
        _S_iend = 26
      };
      static void _S_format_float(const ::std::ios_base &__io, char *__fptr, char __mod) throw();
  };
  template < typename _CharT >
  struct  __numpunct_cache : ::std::locale::facet
  {
      const char *_M_grouping;
      ::std::size_t _M_grouping_size;
      bool _M_use_grouping;
      const _CharT *_M_truename;
      ::std::size_t _M_truename_size;
      const _CharT *_M_falsename;
      ::std::size_t _M_falsename_size;
      _CharT _M_decimal_point;
      _CharT _M_thousands_sep;
      _CharT _M_atoms_out[36];
      _CharT _M_atoms_in[26];
      bool _M_allocated;
      inline __numpunct_cache(::std::size_t __refs  = 0)
        : facet(__refs), _M_grouping(0), _M_grouping_size(0), _M_use_grouping(false), _M_truename(0), _M_truename_size(0), _M_falsename(0), _M_falsename_size(0), _M_decimal_point(_CharT()), _M_thousands_sep(_CharT()), _M_allocated(false)
      {
      }
      virtual ~__numpunct_cache();
      void _M_cache(const ::std::locale &__loc);
    private:
      ::std::__numpunct_cache<_CharT> &operator =(const ::std::__numpunct_cache<_CharT> &);
      explicit __numpunct_cache(const ::std::__numpunct_cache<_CharT> &);
  };
  template < typename _CharT >
  __numpunct_cache<_CharT>::~__numpunct_cache()
  {
    if (_M_allocated)
      {
        delete[] _M_grouping;
        delete[] _M_truename;
        delete[] _M_falsename;
      }
  }
  template < typename _CharT >
  class  numpunct : public ::std::locale::facet
  {
    public:
      typedef _CharT char_type;
      typedef ::std::basic_string<_CharT, ::std::char_traits<_CharT>, ::std::allocator<_CharT> > string_type;
      typedef ::std::__numpunct_cache<_CharT> __cache_type;
    protected:
      typename ::std::numpunct<_CharT>::__cache_type *_M_data;
    public:
      static ::std::locale::id id;
      inline explicit numpunct(::std::size_t __refs  = 0)
        : facet(__refs), _M_data(0)
      {
        _M_initialize_numpunct();
      }
      inline explicit numpunct(typename ::std::numpunct<_CharT>::__cache_type *__cache, ::std::size_t __refs  = 0)
        : facet(__refs), _M_data(__cache)
      {
        _M_initialize_numpunct();
      }
      inline explicit numpunct(::std::__c_locale __cloc, ::std::size_t __refs  = 0)
        : facet(__refs), _M_data(0)
      {
        _M_initialize_numpunct(__cloc);
      }
      inline typename ::std::numpunct<_CharT>::char_type decimal_point() const 
      {
        return this->do_decimal_point();
      }
      inline typename ::std::numpunct<_CharT>::char_type thousands_sep() const 
      {
        return this->do_thousands_sep();
      }
      inline ::std::string grouping() const 
      {
        return this->do_grouping();
      }
      inline typename ::std::numpunct<_CharT>::string_type truename() const 
      {
        return this->do_truename();
      }
      inline typename ::std::numpunct<_CharT>::string_type falsename() const 
      {
        return this->do_falsename();
      }
    protected:
      virtual ~numpunct();
      inline virtual typename ::std::numpunct<_CharT>::char_type do_decimal_point() const 
      {
        return _M_data->_M_decimal_point;
      }
      inline virtual typename ::std::numpunct<_CharT>::char_type do_thousands_sep() const 
      {
        return _M_data->_M_thousands_sep;
      }
      inline virtual ::std::string do_grouping() const 
      {
        return _M_data->_M_grouping;
      }
      inline virtual typename ::std::numpunct<_CharT>::string_type do_truename() const 
      {
        return _M_data->_M_truename;
      }
      inline virtual typename ::std::numpunct<_CharT>::string_type do_falsename() const 
      {
        return _M_data->_M_falsename;
      }
      void _M_initialize_numpunct(::std::__c_locale __cloc  = 0);
  };
  template < typename _CharT >
  ::std::locale::id numpunct<_CharT>::id;
  template <>
  numpunct<char>::~numpunct();
  template <>
  void numpunct<char>::_M_initialize_numpunct(::__locale_struct *__cloc);
  template <>
  numpunct<wchar_t>::~numpunct();
  template <>
  void numpunct<wchar_t>::_M_initialize_numpunct(::__locale_struct *__cloc);
  template < typename _CharT >
  class  numpunct_byname : public ::std::numpunct<_CharT>
  {
    public:
      typedef _CharT char_type;
      typedef ::std::basic_string<_CharT, ::std::char_traits<_CharT>, ::std::allocator<_CharT> > string_type;
      inline explicit numpunct_byname(const char *__s, ::std::size_t __refs  = 0)
        : numpunct<_CharT>(__refs)
      {
        if (__builtin_strcmp(__s, "C") != 0 && __builtin_strcmp(__s, "POSIX") != 0)
          {
            ::std::__c_locale __tmp;
            this->_S_create_c_locale(__tmp, __s);
            this->_M_initialize_numpunct(__tmp);
            this->_S_destroy_c_locale(__tmp);
          }
      }
    protected:
      inline virtual ~numpunct_byname()
      {
      }
  };
  template < typename _CharT, typename _InIter >
  class  num_get : public ::std::locale::facet
  {
    public:
      typedef _CharT char_type;
      typedef _InIter iter_type;
      static ::std::locale::id id;
      inline explicit num_get(::std::size_t __refs  = 0)
        : facet(__refs)
      {
      }
      inline typename ::std::num_get<_CharT, _InIter>::iter_type get(typename ::std::num_get<_CharT, _InIter>::iter_type __in, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, bool &__v) const 
      {
        return this->do_get(__in, __end, __io, __err, __v);
      }
      inline typename ::std::num_get<_CharT, _InIter>::iter_type get(typename ::std::num_get<_CharT, _InIter>::iter_type __in, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, long int &__v) const 
      {
        return this->do_get(__in, __end, __io, __err, __v);
      }
      inline typename ::std::num_get<_CharT, _InIter>::iter_type get(typename ::std::num_get<_CharT, _InIter>::iter_type __in, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, unsigned short int &__v) const 
      {
        return this->do_get(__in, __end, __io, __err, __v);
      }
      inline typename ::std::num_get<_CharT, _InIter>::iter_type get(typename ::std::num_get<_CharT, _InIter>::iter_type __in, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, unsigned int &__v) const 
      {
        return this->do_get(__in, __end, __io, __err, __v);
      }
      inline typename ::std::num_get<_CharT, _InIter>::iter_type get(typename ::std::num_get<_CharT, _InIter>::iter_type __in, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, unsigned long int &__v) const 
      {
        return this->do_get(__in, __end, __io, __err, __v);
      }
      inline typename ::std::num_get<_CharT, _InIter>::iter_type get(typename ::std::num_get<_CharT, _InIter>::iter_type __in, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, long long int &__v) const 
      {
        return this->do_get(__in, __end, __io, __err, __v);
      }
      inline typename ::std::num_get<_CharT, _InIter>::iter_type get(typename ::std::num_get<_CharT, _InIter>::iter_type __in, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, unsigned long long int &__v) const 
      {
        return this->do_get(__in, __end, __io, __err, __v);
      }
      inline typename ::std::num_get<_CharT, _InIter>::iter_type get(typename ::std::num_get<_CharT, _InIter>::iter_type __in, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, float &__v) const 
      {
        return this->do_get(__in, __end, __io, __err, __v);
      }
      inline typename ::std::num_get<_CharT, _InIter>::iter_type get(typename ::std::num_get<_CharT, _InIter>::iter_type __in, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, double &__v) const 
      {
        return this->do_get(__in, __end, __io, __err, __v);
      }
      inline typename ::std::num_get<_CharT, _InIter>::iter_type get(typename ::std::num_get<_CharT, _InIter>::iter_type __in, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, long double &__v) const 
      {
        return this->do_get(__in, __end, __io, __err, __v);
      }
      inline typename ::std::num_get<_CharT, _InIter>::iter_type get(typename ::std::num_get<_CharT, _InIter>::iter_type __in, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, void *&__v) const 
      {
        return this->do_get(__in, __end, __io, __err, __v);
      }
    protected:
      inline virtual ~num_get()
      {
      }
      typename ::std::num_get<_CharT, _InIter>::iter_type _M_extract_float(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, ::std::string &__xtrc) const ;
      template < typename _ValueT >
      typename ::std::num_get<_CharT, _InIter>::iter_type _M_extract_int(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, _ValueT &__v) const ;
      template < typename _CharT2 >
      inline typename ::__gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type _M_find(const _CharT2 *, ::std::size_t __len, _CharT2 __c) const 
      {
        int __ret( -1);
        if (__len <= 10)
          {
            if (__c >= _CharT2('0') && __c < _CharT2(_CharT2('0') + __len))
              {
                __ret = __c - _CharT2('0');
              }
          }
        else
          {
            if (__c >= _CharT2('0') && __c <= _CharT2('9'))
              {
                __ret = __c - _CharT2('0');
              }
            else
              {
                if (__c >= _CharT2('a') && __c <= _CharT2('f'))
                  {
                    __ret = 10 + (__c - _CharT2('a'));
                  }
                else
                  {
                    if (__c >= _CharT2('A') && __c <= _CharT2('F'))
                      {
                        __ret = 10 + (__c - _CharT2('A'));
                      }
                  }
              }
          }
        return __ret;
      }
      template < typename _CharT2 >
      inline typename ::__gnu_cxx::__enable_if<!__is_char<_CharT2>::__value, int>::__type _M_find(const _CharT2 *__zero, ::std::size_t __len, _CharT2 __c) const 
      {
        int __ret( -1);
        const typename ::std::num_get<_CharT, _InIter>::char_type *__q = char_traits<_CharT2>::find(__zero, __len, __c);
        if (__q)
          {
            __ret = __q - __zero;
            if (__ret > 15)
              {
                __ret -= 6;
              }
          }
        return __ret;
      }
      virtual typename ::std::num_get<_CharT, _InIter>::iter_type do_get(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, bool &__v) const ;
      inline virtual typename ::std::num_get<_CharT, _InIter>::iter_type do_get(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, long int &__v) const 
      {
        return _M_extract_int(__beg, __end, __io, __err, __v);
      }
      inline virtual typename ::std::num_get<_CharT, _InIter>::iter_type do_get(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, unsigned short int &__v) const 
      {
        return _M_extract_int(__beg, __end, __io, __err, __v);
      }
      inline virtual typename ::std::num_get<_CharT, _InIter>::iter_type do_get(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, unsigned int &__v) const 
      {
        return _M_extract_int(__beg, __end, __io, __err, __v);
      }
      inline virtual typename ::std::num_get<_CharT, _InIter>::iter_type do_get(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, unsigned long int &__v) const 
      {
        return _M_extract_int(__beg, __end, __io, __err, __v);
      }
      inline virtual typename ::std::num_get<_CharT, _InIter>::iter_type do_get(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, long long int &__v) const 
      {
        return _M_extract_int(__beg, __end, __io, __err, __v);
      }
      inline virtual typename ::std::num_get<_CharT, _InIter>::iter_type do_get(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, unsigned long long int &__v) const 
      {
        return _M_extract_int(__beg, __end, __io, __err, __v);
      }
      virtual typename ::std::num_get<_CharT, _InIter>::iter_type do_get(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, float &__v) const ;
      virtual typename ::std::num_get<_CharT, _InIter>::iter_type do_get(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, double &__v) const ;
      virtual typename ::std::num_get<_CharT, _InIter>::iter_type do_get(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, long double &__v) const ;
      virtual typename ::std::num_get<_CharT, _InIter>::iter_type do_get(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, void *&__v) const ;
  };
  template < typename _CharT, typename _InIter >
  ::std::locale::id num_get<_CharT, _InIter>::id;
  template < typename _CharT, typename _OutIter >
  class  num_put : public ::std::locale::facet
  {
    public:
      typedef _CharT char_type;
      typedef _OutIter iter_type;
      static ::std::locale::id id;
      inline explicit num_put(::std::size_t __refs  = 0)
        : facet(__refs)
      {
      }
      inline typename ::std::num_put<_CharT, _OutIter>::iter_type put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, bool __v) const 
      {
        return this->do_put(__s, __io, __fill, __v);
      }
      inline typename ::std::num_put<_CharT, _OutIter>::iter_type put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, long int __v) const 
      {
        return this->do_put(__s, __io, __fill, __v);
      }
      inline typename ::std::num_put<_CharT, _OutIter>::iter_type put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, unsigned long int __v) const 
      {
        return this->do_put(__s, __io, __fill, __v);
      }
      inline typename ::std::num_put<_CharT, _OutIter>::iter_type put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, long long int __v) const 
      {
        return this->do_put(__s, __io, __fill, __v);
      }
      inline typename ::std::num_put<_CharT, _OutIter>::iter_type put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, unsigned long long int __v) const 
      {
        return this->do_put(__s, __io, __fill, __v);
      }
      inline typename ::std::num_put<_CharT, _OutIter>::iter_type put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, double __v) const 
      {
        return this->do_put(__s, __io, __fill, __v);
      }
      inline typename ::std::num_put<_CharT, _OutIter>::iter_type put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, long double __v) const 
      {
        return this->do_put(__s, __io, __fill, __v);
      }
      inline typename ::std::num_put<_CharT, _OutIter>::iter_type put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, const void *__v) const 
      {
        return this->do_put(__s, __io, __fill, __v);
      }
    protected:
      template < typename _ValueT >
      typename ::std::num_put<_CharT, _OutIter>::iter_type _M_insert_float(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, char __mod, _ValueT __v) const ;
      void _M_group_float(const char *__grouping, ::std::size_t __grouping_size, typename ::std::num_put<_CharT, _OutIter>::char_type __sep, const typename ::std::num_put<_CharT, _OutIter>::char_type *__p, typename ::std::num_put<_CharT, _OutIter>::char_type *__new, typename ::std::num_put<_CharT, _OutIter>::char_type *__cs, int &__len) const ;
      template < typename _ValueT >
      typename ::std::num_put<_CharT, _OutIter>::iter_type _M_insert_int(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, _ValueT __v) const ;
      void _M_group_int(const char *__grouping, ::std::size_t __grouping_size, typename ::std::num_put<_CharT, _OutIter>::char_type __sep, ::std::ios_base &, typename ::std::num_put<_CharT, _OutIter>::char_type *__new, typename ::std::num_put<_CharT, _OutIter>::char_type *__cs, int &__len) const ;
      void _M_pad(typename ::std::num_put<_CharT, _OutIter>::char_type __fill, ::std::streamsize __w, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type *__new, const typename ::std::num_put<_CharT, _OutIter>::char_type *__cs, int &__len) const ;
      inline virtual ~num_put()
      {
      }
      virtual typename ::std::num_put<_CharT, _OutIter>::iter_type do_put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, bool __v) const ;
      inline virtual typename ::std::num_put<_CharT, _OutIter>::iter_type do_put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, long int __v) const 
      {
        return _M_insert_int(__s, __io, __fill, __v);
      }
      inline virtual typename ::std::num_put<_CharT, _OutIter>::iter_type do_put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, unsigned long int __v) const 
      {
        return _M_insert_int(__s, __io, __fill, __v);
      }
      inline virtual typename ::std::num_put<_CharT, _OutIter>::iter_type do_put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, long long int __v) const 
      {
        return _M_insert_int(__s, __io, __fill, __v);
      }
      inline virtual typename ::std::num_put<_CharT, _OutIter>::iter_type do_put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, unsigned long long int __v) const 
      {
        return _M_insert_int(__s, __io, __fill, __v);
      }
      virtual typename ::std::num_put<_CharT, _OutIter>::iter_type do_put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, double __v) const ;
      virtual typename ::std::num_put<_CharT, _OutIter>::iter_type do_put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, long double __v) const ;
      virtual typename ::std::num_put<_CharT, _OutIter>::iter_type do_put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, const void *__v) const ;
  };
  template < typename _CharT, typename _OutIter >
  ::std::locale::id num_put<_CharT, _OutIter>::id;
  template < typename _CharT >
  inline bool isspace(_CharT __c, const ::std::locale &__loc)
  {
    return use_facet< ::std::ctype<_CharT> >(__loc).is(::std::ctype_base::space, __c);
  }
  template < typename _CharT >
  inline bool isprint(_CharT __c, const ::std::locale &__loc)
  {
    return use_facet< ::std::ctype<_CharT> >(__loc).is(::std::ctype_base::print, __c);
  }
  template < typename _CharT >
  inline bool iscntrl(_CharT __c, const ::std::locale &__loc)
  {
    return use_facet< ::std::ctype<_CharT> >(__loc).is(::std::ctype_base::cntrl, __c);
  }
  template < typename _CharT >
  inline bool isupper(_CharT __c, const ::std::locale &__loc)
  {
    return use_facet< ::std::ctype<_CharT> >(__loc).is(::std::ctype_base::upper, __c);
  }
  template < typename _CharT >
  inline bool islower(_CharT __c, const ::std::locale &__loc)
  {
    return use_facet< ::std::ctype<_CharT> >(__loc).is(::std::ctype_base::lower, __c);
  }
  template < typename _CharT >
  inline bool isalpha(_CharT __c, const ::std::locale &__loc)
  {
    return use_facet< ::std::ctype<_CharT> >(__loc).is(::std::ctype_base::alpha, __c);
  }
  template < typename _CharT >
  inline bool isdigit(_CharT __c, const ::std::locale &__loc)
  {
    return use_facet< ::std::ctype<_CharT> >(__loc).is(::std::ctype_base::digit, __c);
  }
  template < typename _CharT >
  inline bool ispunct(_CharT __c, const ::std::locale &__loc)
  {
    return use_facet< ::std::ctype<_CharT> >(__loc).is(::std::ctype_base::punct, __c);
  }
  template < typename _CharT >
  inline bool isxdigit(_CharT __c, const ::std::locale &__loc)
  {
    return use_facet< ::std::ctype<_CharT> >(__loc).is(::std::ctype_base::xdigit, __c);
  }
  template < typename _CharT >
  inline bool isalnum(_CharT __c, const ::std::locale &__loc)
  {
    return use_facet< ::std::ctype<_CharT> >(__loc).is(::std::ctype_base::alnum, __c);
  }
  template < typename _CharT >
  inline bool isgraph(_CharT __c, const ::std::locale &__loc)
  {
    return use_facet< ::std::ctype<_CharT> >(__loc).is(::std::ctype_base::graph, __c);
  }
  template < typename _CharT >
  inline _CharT toupper(_CharT __c, const ::std::locale &__loc)
  {
    return use_facet< ::std::ctype<_CharT> >(__loc).toupper(__c);
  }
  template < typename _CharT >
  inline _CharT tolower(_CharT __c, const ::std::locale &__loc)
  {
    return use_facet< ::std::ctype<_CharT> >(__loc).tolower(__c);
  }
  template < typename _Facet >
  struct  __use_cache
  {
      const _Facet *operator ()(const ::std::locale &__loc) const ;
  };
  template < typename _CharT >
  struct  __use_cache< ::std::__numpunct_cache<_CharT> >
  {
      inline const ::std::__numpunct_cache<_CharT> *operator ()(const ::std::locale &__loc) const 
      {
        const ::std::size_t __i(numpunct<_CharT>::id._M_id());
        const ::std::locale::facet **__caches((*__loc._M_impl)._M_caches);
        if (!__caches[__i])
          {
            ::std::__numpunct_cache<_CharT> *__tmp = 0;
            try
            {
              __tmp = (new ::std::__numpunct_cache<_CharT>());
              __tmp->_M_cache(__loc);
            }
            catch (...)
            {
              delete __tmp;
              throw;
            }
            (*__loc._M_impl)._M_install_cache(__tmp, __i);
          }
        return static_cast<const ::std::__numpunct_cache<_CharT> *>(__caches[__i]);
      }
  };
  template < typename _CharT >
  void __numpunct_cache<_CharT>::_M_cache(const ::std::locale &__loc)
  {
    _M_allocated = true;
    const ::std::numpunct<_CharT> &__np = use_facet< ::std::numpunct<_CharT> >(__loc);
    char *__grouping(0);
    _CharT *__truename = 0;
    _CharT *__falsename = 0;
    try
    {
      _M_grouping_size = __np.grouping().size();
      __grouping = (new char [_M_grouping_size]);
      __np.grouping().copy(__grouping, _M_grouping_size);
      _M_grouping = __grouping;
      _M_use_grouping = (_M_grouping_size && static_cast<signed char>(_M_grouping[0]) > 0) && _M_grouping[0] != ::__gnu_cxx::__numeric_traits_integer<char>::__max;
      _M_truename_size = __np.truename().size();
      __truename = (new _CharT [_M_truename_size]);
      __np.truename().copy(__truename, _M_truename_size);
      _M_truename = __truename;
      _M_falsename_size = __np.falsename().size();
      __falsename = (new _CharT [_M_falsename_size]);
      __np.falsename().copy(__falsename, _M_falsename_size);
      _M_falsename = __falsename;
      _M_decimal_point = __np.decimal_point();
      _M_thousands_sep = __np.thousands_sep();
      const ::std::ctype<_CharT> &__ct = use_facet< ::std::ctype<_CharT> >(__loc);
      __ct.widen(::std::__num_base::_S_atoms_out, ::std::__num_base::_S_atoms_out + ::std::__num_base::_S_oend, _M_atoms_out);
      __ct.widen(::std::__num_base::_S_atoms_in, ::std::__num_base::_S_atoms_in + ::std::__num_base::_S_iend, _M_atoms_in);
    }
    catch (...)
    {
      delete[] __grouping;
      delete[] __truename;
      delete[] __falsename;
      throw;
    }
  }
  bool __verify_grouping(const char *__grouping, ::std::size_t __grouping_size, const ::std::string &__grouping_tmp) throw()__attribute__((__pure__));
  template < typename _CharT, typename _InIter >
  typename ::std::num_get<_CharT, _InIter>::iter_type num_get<_CharT, _InIter>::_M_extract_float(_InIter __beg, _InIter __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, ::std::string &__xtrc) const 
  {
    typedef ::std::char_traits<_CharT> __traits_type;
    typedef ::std::__numpunct_cache<_CharT> __cache_type;
    ::std::__use_cache<__cache_type> __uc;
    const ::std::locale &__loc(__io._M_getloc());
    const __cache_type *__lc = __uc(__loc);
    const _CharT *__lit = __lc->_M_atoms_in;
    typename ::std::num_get<_CharT, _InIter>::char_type __c = typename ::std::num_get<_CharT, _InIter>::char_type();
    bool __testeof = __beg == __end;
    if (!__testeof)
      {
        __c = *__beg;
        const bool __plus = __c == __lit[::std::__num_base::_S_iplus];
        if (((__plus || __c == __lit[::std::__num_base::_S_iminus]) && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)) && !(__c == __lc->_M_decimal_point))
          {
            __xtrc += __plus ? '+' : '-';
            if (++__beg != __end)
              {
                __c = *__beg;
              }
            else
              {
                __testeof = true;
              }
          }
      }
    bool __found_mantissa(false);
    int __sep_pos(0);
    while (!__testeof)
      {
        if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep) || __c == __lc->_M_decimal_point)
          {
            break;
          }
        else
          {
            if (__c == __lit[::std::__num_base::_S_izero])
              {
                if (!__found_mantissa)
                  {
                    __xtrc += '0';
                    __found_mantissa = true;
                  }
                ++__sep_pos;
                if (++__beg != __end)
                  {
                    __c = *__beg;
                  }
                else
                  {
                    __testeof = true;
                  }
              }
            else
              {
                break;
              }
          }
      }
    bool __found_dec(false);
    bool __found_sci(false);
    ::std::string __found_grouping;
    if (__lc->_M_use_grouping)
      {
        __found_grouping.reserve(32);
      }
    const typename ::std::num_get<_CharT, _InIter>::char_type *__lit_zero = __lit + ::std::__num_base::_S_izero;
    if (!__lc->_M_allocated)
      {
        while (!__testeof)
          {
            const int __digit(_M_find(__lit_zero, 10, __c));
            if (__digit !=  -1)
              {
                __xtrc += '0' + __digit;
                __found_mantissa = true;
              }
            else
              {
                if ((__c == __lc->_M_decimal_point && !__found_dec) && !__found_sci)
                  {
                    __xtrc += '.';
                    __found_dec = true;
                  }
                else
                  {
                    if (((__c == __lit[::std::__num_base::_S_ie] || __c == __lit[::std::__num_base::_S_iE]) && !__found_sci) && __found_mantissa)
                      {
                        __xtrc += 'e';
                        __found_sci = true;
                        if (++__beg != __end)
                          {
                            __c = *__beg;
                            const bool __plus = __c == __lit[::std::__num_base::_S_iplus];
                            if (__plus || __c == __lit[::std::__num_base::_S_iminus])
                              {
                                __xtrc += __plus ? '+' : '-';
                              }
                            else
                              {
                                continue;
                              }
                          }
                        else
                          {
                            __testeof = true;
                            break;
                          }
                      }
                    else
                      {
                        break;
                      }
                  }
              }
            if (++__beg != __end)
              {
                __c = *__beg;
              }
            else
              {
                __testeof = true;
              }
          }
      }
    else
      {
        while (!__testeof)
          {
            if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
              {
                if (!__found_dec && !__found_sci)
                  {
                    if (__sep_pos)
                      {
                        __found_grouping += static_cast<char>(__sep_pos);
                        __sep_pos = 0;
                      }
                    else
                      {
                        __xtrc.clear();
                        break;
                      }
                  }
                else
                  {
                    break;
                  }
              }
            else
              {
                if (__c == __lc->_M_decimal_point)
                  {
                    if (!__found_dec && !__found_sci)
                      {
                        if (__found_grouping.size())
                          {
                            __found_grouping += static_cast<char>(__sep_pos);
                          }
                        __xtrc += '.';
                        __found_dec = true;
                      }
                    else
                      {
                        break;
                      }
                  }
                else
                  {
                    const typename ::std::num_get<_CharT, _InIter>::char_type *__q = __traits_type::find(__lit_zero, 10, __c);
                    if (__q)
                      {
                        __xtrc += '0' + (__q - __lit_zero);
                        __found_mantissa = true;
                        ++__sep_pos;
                      }
                    else
                      {
                        if (((__c == __lit[::std::__num_base::_S_ie] || __c == __lit[::std::__num_base::_S_iE]) && !__found_sci) && __found_mantissa)
                          {
                            if (__found_grouping.size() && !__found_dec)
                              {
                                __found_grouping += static_cast<char>(__sep_pos);
                              }
                            __xtrc += 'e';
                            __found_sci = true;
                            if (++__beg != __end)
                              {
                                __c = *__beg;
                                const bool __plus = __c == __lit[::std::__num_base::_S_iplus];
                                if (((__plus || __c == __lit[::std::__num_base::_S_iminus]) && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)) && !(__c == __lc->_M_decimal_point))
                                  {
                                    __xtrc += __plus ? '+' : '-';
                                  }
                                else
                                  {
                                    continue;
                                  }
                              }
                            else
                              {
                                __testeof = true;
                                break;
                              }
                          }
                        else
                          {
                            break;
                          }
                      }
                  }
              }
            if (++__beg != __end)
              {
                __c = *__beg;
              }
            else
              {
                __testeof = true;
              }
          }
      }
    if (__found_grouping.size())
      {
        if (!__found_dec && !__found_sci)
          {
            __found_grouping += static_cast<char>(__sep_pos);
          }
        if (!std::__verify_grouping(__lc->_M_grouping, __lc->_M_grouping_size, __found_grouping))
          {
            __err = ::std::ios_base::failbit;
          }
      }
    return __beg;
  }
  template < typename _CharT, typename _InIter >
  template < typename _ValueT >
  typename ::std::num_get<_CharT, _InIter>::iter_type num_get<_CharT, _InIter>::_M_extract_int(_InIter __beg, _InIter __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, _ValueT &__v) const 
  {
    typedef ::std::char_traits<_CharT> __traits_type;
    using ::__gnu_cxx::__add_unsigned;
    typedef typename ::__gnu_cxx::__add_unsigned<_ValueT>::__type __unsigned_type;
    typedef ::std::__numpunct_cache<_CharT> __cache_type;
    ::std::__use_cache<__cache_type> __uc;
    const ::std::locale &__loc(__io._M_getloc());
    const __cache_type *__lc = __uc(__loc);
    const _CharT *__lit = __lc->_M_atoms_in;
    typename ::std::num_get<_CharT, _InIter>::char_type __c = typename ::std::num_get<_CharT, _InIter>::char_type();
    const ::std::ios_base::fmtflags __basefield(__io.flags() & ::std::ios_base::basefield);
    const bool __oct(__basefield == ::std::ios_base::oct);
    int __base(__oct ? 8 : __basefield == ::std::ios_base::hex ? 16 : 10);
    bool __testeof = __beg == __end;
    bool __negative(false);
    if (!__testeof)
      {
        __c = *__beg;
        __negative = __c == __lit[::std::__num_base::_S_iminus];
        if (((__negative || __c == __lit[::std::__num_base::_S_iplus]) && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)) && !(__c == __lc->_M_decimal_point))
          {
            if (++__beg != __end)
              {
                __c = *__beg;
              }
            else
              {
                __testeof = true;
              }
          }
      }
    bool __found_zero(false);
    int __sep_pos(0);
    while (!__testeof)
      {
        if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep) || __c == __lc->_M_decimal_point)
          {
            break;
          }
        else
          {
            if (__c == __lit[::std::__num_base::_S_izero] && (!__found_zero || __base == 10))
              {
                __found_zero = true;
                ++__sep_pos;
                if (__basefield == 0)
                  {
                    __base = 8;
                  }
                if (__base == 8)
                  {
                    __sep_pos = 0;
                  }
              }
            else
              {
                if (__found_zero && (__c == __lit[::std::__num_base::_S_ix] || __c == __lit[::std::__num_base::_S_iX]))
                  {
                    if (__basefield == 0)
                      {
                        __base = 16;
                      }
                    if (__base == 16)
                      {
                        __found_zero = false;
                        __sep_pos = 0;
                      }
                    else
                      {
                        break;
                      }
                  }
                else
                  {
                    break;
                  }
              }
          }
        if (++__beg != __end)
          {
            __c = *__beg;
            if (!__found_zero)
              {
                break;
              }
          }
        else
          {
            __testeof = true;
          }
      }
    const ::std::size_t __len(__base == 16 ? ::std::__num_base::_S_iend - ::std::__num_base::_S_izero : __base);
    ::std::string __found_grouping;
    if (__lc->_M_use_grouping)
      {
        __found_grouping.reserve(32);
      }
    bool __testfail(false);
    bool __testoverflow(false);
    const __unsigned_type __max = __negative && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed ?  -__gnu_cxx::__numeric_traits<_ValueT>::__min : __gnu_cxx::__numeric_traits<_ValueT>::__max;
    const __unsigned_type __smax = __max / __base;
    __unsigned_type __result = 0;
    int __digit(0);
    const typename ::std::num_get<_CharT, _InIter>::char_type *__lit_zero = __lit + ::std::__num_base::_S_izero;
    if (!__lc->_M_allocated)
      {
        while (!__testeof)
          {
            __digit = _M_find(__lit_zero, __len, __c);
            if (__digit ==  -1)
              {
                break;
              }
            if (__result > __smax)
              {
                __testoverflow = true;
              }
            else
              {
                __result *= __base;
                __testoverflow |= __result > __max - __digit;
                __result += __digit;
                ++__sep_pos;
              }
            if (++__beg != __end)
              {
                __c = *__beg;
              }
            else
              {
                __testeof = true;
              }
          }
      }
    else
      {
        while (!__testeof)
          {
            if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
              {
                if (__sep_pos)
                  {
                    __found_grouping += static_cast<char>(__sep_pos);
                    __sep_pos = 0;
                  }
                else
                  {
                    __testfail = true;
                    break;
                  }
              }
            else
              {
                if (__c == __lc->_M_decimal_point)
                  {
                    break;
                  }
                else
                  {
                    const typename ::std::num_get<_CharT, _InIter>::char_type *__q = __traits_type::find(__lit_zero, __len, __c);
                    if (!__q)
                      {
                        break;
                      }
                    __digit = __q - __lit_zero;
                    if (__digit > 15)
                      {
                        __digit -= 6;
                      }
                    if (__result > __smax)
                      {
                        __testoverflow = true;
                      }
                    else
                      {
                        __result *= __base;
                        __testoverflow |= __result > __max - __digit;
                        __result += __digit;
                        ++__sep_pos;
                      }
                  }
              }
            if (++__beg != __end)
              {
                __c = *__beg;
              }
            else
              {
                __testeof = true;
              }
          }
      }
    if (__found_grouping.size())
      {
        __found_grouping += static_cast<char>(__sep_pos);
        if (!std::__verify_grouping(__lc->_M_grouping, __lc->_M_grouping_size, __found_grouping))
          {
            __err = ::std::ios_base::failbit;
          }
      }
    if (((!__sep_pos && !__found_zero) && !__found_grouping.size()) || __testfail)
      {
        __v = 0;
        __err = ::std::ios_base::failbit;
      }
    else
      {
        if (__testoverflow)
          {
            if (__negative && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
              {
                __v = __gnu_cxx::__numeric_traits<_ValueT>::__min;
              }
            else
              {
                __v = __gnu_cxx::__numeric_traits<_ValueT>::__max;
              }
            __err = ::std::ios_base::failbit;
          }
        else
          {
            __v = __negative ?  -__result : __result;
          }
      }
    if (__testeof)
      {
        __err |= ::std::ios_base::eofbit;
      }
    return __beg;
  }
  template < typename _CharT, typename _InIter >
  typename ::std::num_get<_CharT, _InIter>::iter_type num_get<_CharT, _InIter>::do_get(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, bool &__v) const 
  {
    if (!(__io.flags() & ::std::ios_base::boolalpha))
      {
        long int __l( -1);
        __beg = _M_extract_int(__beg, __end, __io, __err, __l);
        if (__l == 0 || __l == 1)
          {
            __v = (bool)__l;
          }
        else
          {
            __v = true;
            __err = ::std::ios_base::failbit;
            if (__beg == __end)
              {
                __err |= ::std::ios_base::eofbit;
              }
          }
      }
    else
      {
        typedef ::std::__numpunct_cache<_CharT> __cache_type;
        ::std::__use_cache<__cache_type> __uc;
        const ::std::locale &__loc(__io._M_getloc());
        const __cache_type *__lc = __uc(__loc);
        bool __testf(true);
        bool __testt(true);
        bool __donef(__lc->_M_falsename_size == 0);
        bool __donet(__lc->_M_truename_size == 0);
        bool __testeof(false);
        ::std::size_t __n(0);
        while (!__donef || !__donet)
          {
            if (__beg == __end)
              {
                __testeof = true;
                break;
              }
            const typename ::std::num_get<_CharT, _InIter>::char_type __c = *__beg;
            if (!__donef)
              {
                __testf = __c == __lc->_M_falsename[__n];
              }
            if (!__testf && __donet)
              {
                break;
              }
            if (!__donet)
              {
                __testt = __c == __lc->_M_truename[__n];
              }
            if (!__testt && __donef)
              {
                break;
              }
            if (!__testt && !__testf)
              {
                break;
              }
            ++__n;
            ++__beg;
            __donef = !__testf || __n >= __lc->_M_falsename_size;
            __donet = !__testt || __n >= __lc->_M_truename_size;
          }
        if ((__testf && __n == __lc->_M_falsename_size) && __n)
          {
            __v = false;
            if (__testt && __n == __lc->_M_truename_size)
              {
                __err = ::std::ios_base::failbit;
              }
            else
              {
                __err = __testeof ? ::std::ios_base::eofbit : ::std::ios_base::goodbit;
              }
          }
        else
          {
            if ((__testt && __n == __lc->_M_truename_size) && __n)
              {
                __v = true;
                __err = __testeof ? ::std::ios_base::eofbit : ::std::ios_base::goodbit;
              }
            else
              {
                __v = false;
                __err = ::std::ios_base::failbit;
                if (__testeof)
                  {
                    __err |= ::std::ios_base::eofbit;
                  }
              }
          }
      }
    return __beg;
  }
  template < typename _CharT, typename _InIter >
  typename ::std::num_get<_CharT, _InIter>::iter_type num_get<_CharT, _InIter>::do_get(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, float &__v) const 
  {
    ::std::string __xtrc;
    __xtrc.reserve(32);
    __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
    std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
    if (__beg == __end)
      {
        __err |= ::std::ios_base::eofbit;
      }
    return __beg;
  }
  template < typename _CharT, typename _InIter >
  typename ::std::num_get<_CharT, _InIter>::iter_type num_get<_CharT, _InIter>::do_get(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, double &__v) const 
  {
    ::std::string __xtrc;
    __xtrc.reserve(32);
    __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
    std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
    if (__beg == __end)
      {
        __err |= ::std::ios_base::eofbit;
      }
    return __beg;
  }
  template < typename _CharT, typename _InIter >
  typename ::std::num_get<_CharT, _InIter>::iter_type num_get<_CharT, _InIter>::do_get(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, long double &__v) const 
  {
    ::std::string __xtrc;
    __xtrc.reserve(32);
    __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
    std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
    if (__beg == __end)
      {
        __err |= ::std::ios_base::eofbit;
      }
    return __beg;
  }
  template < typename _CharT, typename _InIter >
  typename ::std::num_get<_CharT, _InIter>::iter_type num_get<_CharT, _InIter>::do_get(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, void *&__v) const 
  {
    typedef ::std::ios_base::fmtflags fmtflags;
    const fmtflags __fmt = __io.flags();
    __io.flags((__fmt &  ~::std::ios_base::basefield) | ::std::ios_base::hex);
    typedef ::__gnu_cxx::__conditional_type<true, unsigned long int, unsigned long long int>::__type _UIntPtrType;
    _UIntPtrType __ul;
    __beg = _M_extract_int(__beg, __end, __io, __err, __ul);
    __io.flags(__fmt);
    __v = reinterpret_cast<void *>(__ul);
    return __beg;
  }
  template < typename _CharT, typename _OutIter >
  void num_put<_CharT, _OutIter>::_M_pad(_CharT __fill, ::std::streamsize __w, ::std::ios_base &__io, _CharT *__new, const _CharT *__cs, int &__len) const 
  {
    __pad<_CharT, ::std::char_traits<_CharT> >::_S_pad(__io, __fill, __new, __cs, __w, __len);
    __len = static_cast<int>(__w);
  }
  template < typename _CharT, typename _ValueT >
  int __int_to_char(_CharT *__bufend, _ValueT __v, const _CharT *__lit, ::std::ios_base::fmtflags __flags, bool __dec);
  template < typename _CharT, typename _ValueT >
  int __int_to_char(_CharT *__bufend, _ValueT __v, const _CharT *__lit, ::std::ios_base::fmtflags __flags, bool __dec)
  {
    _CharT *__buf = __bufend;
    if (__builtin_expect(__dec, true))
      {
        do
          {
            *--__buf = __lit[__v % 10 + ::std::__num_base::_S_odigits];
            __v /= 10;
          }
        while (__v != 0);
      }
    else
      {
        if ((__flags & ::std::ios_base::basefield) == ::std::ios_base::oct)
          {
            do
              {
                *--__buf = __lit[(__v & 7) + ::std::__num_base::_S_odigits];
                __v >>= 3;
              }
            while (__v != 0);
          }
        else
          {
            const bool __uppercase(__flags & ::std::ios_base::uppercase);
            const int __case_offset(__uppercase ? ::std::__num_base::_S_oudigits : ::std::__num_base::_S_odigits);
            do
              {
                *--__buf = __lit[(__v & 15) + __case_offset];
                __v >>= 4;
              }
            while (__v != 0);
          }
      }
    return __bufend - __buf;
  }
  template < typename _CharT, typename _OutIter >
  void num_put<_CharT, _OutIter>::_M_group_int(const char *__grouping, ::std::size_t __grouping_size, _CharT __sep, ::std::ios_base &, _CharT *__new, _CharT *__cs, int &__len) const 
  {
    _CharT *__p = std::__add_grouping(__new, __sep, __grouping, __grouping_size, __cs, __cs + __len);
    __len = __p - __new;
  }
  template < typename _CharT, typename _OutIter >
  template < typename _ValueT >
  typename ::std::num_put<_CharT, _OutIter>::iter_type num_put<_CharT, _OutIter>::_M_insert_int(_OutIter __s, ::std::ios_base &__io, _CharT __fill, _ValueT __v) const 
  {
    using ::__gnu_cxx::__add_unsigned;
    typedef typename ::__gnu_cxx::__add_unsigned<_ValueT>::__type __unsigned_type;
    typedef ::std::__numpunct_cache<_CharT> __cache_type;
    ::std::__use_cache<__cache_type> __uc;
    const ::std::locale &__loc(__io._M_getloc());
    const __cache_type *__lc = __uc(__loc);
    const _CharT *__lit = __lc->_M_atoms_out;
    const ::std::ios_base::fmtflags __flags(__io.flags());
    const int __ilen = 5 * sizeof(_ValueT);
    _CharT *__cs = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __ilen));
    const ::std::ios_base::fmtflags __basefield(__flags & ::std::ios_base::basefield);
    const bool __dec(__basefield != ::std::ios_base::oct && __basefield != ::std::ios_base::hex);
    const __unsigned_type __u = __v > 0 || !__dec ? __unsigned_type(__v) :  -__unsigned_type(__v);
    int __len(__int_to_char(__cs + __ilen, __u, __lit, __flags, __dec));
    __cs += __ilen - __len;
    if (__lc->_M_use_grouping)
      {
        _CharT *__cs2 = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * (__len + 1) * 2));
        _M_group_int(__lc->_M_grouping, __lc->_M_grouping_size, __lc->_M_thousands_sep, __io, __cs2 + 2, __cs, __len);
        __cs = __cs2 + 2;
      }
    if (__builtin_expect(__dec, true))
      {
        if (__v >= 0)
          {
            if ((bool)(__flags & ::std::ios_base::showpos) && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
              {
                (*--__cs = __lit[::std::__num_base::_S_oplus], ++__len);
              }
          }
        else
          {
            (*--__cs = __lit[::std::__num_base::_S_ominus], ++__len);
          }
      }
    else
      {
        if ((bool)(__flags & ::std::ios_base::showbase) && __v)
          {
            if (__basefield == ::std::ios_base::oct)
              {
                (*--__cs = __lit[::std::__num_base::_S_odigits], ++__len);
              }
            else
              {
                const bool __uppercase(__flags & ::std::ios_base::uppercase);
                *--__cs = __lit[::std::__num_base::_S_ox + __uppercase];
                *--__cs = __lit[::std::__num_base::_S_odigits];
                __len += 2;
              }
          }
      }
    const ::std::streamsize __w(__io.width());
    if (__w > static_cast< ::std::streamsize>(__len))
      {
        _CharT *__cs3 = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __w));
        _M_pad(__fill, __w, __io, __cs3, __cs, __len);
        __cs = __cs3;
      }
    __io.width(0);
    return std::__write(__s, __cs, __len);
  }
  template < typename _CharT, typename _OutIter >
  void num_put<_CharT, _OutIter>::_M_group_float(const char *__grouping, ::std::size_t __grouping_size, _CharT __sep, const _CharT *__p, _CharT *__new, _CharT *__cs, int &__len) const 
  {
    const int __declen = __p ? __p - __cs : __len;
    _CharT *__p2 = std::__add_grouping(__new, __sep, __grouping, __grouping_size, __cs, __cs + __declen);
    int __newlen = __p2 - __new;
    if (__p)
      {
        char_traits<_CharT>::copy(__p2, __p, __len - __declen);
        __newlen += __len - __declen;
      }
    __len = __newlen;
  }
  template < typename _CharT, typename _OutIter >
  template < typename _ValueT >
  typename ::std::num_put<_CharT, _OutIter>::iter_type num_put<_CharT, _OutIter>::_M_insert_float(_OutIter __s, ::std::ios_base &__io, _CharT __fill, char __mod, _ValueT __v) const 
  {
    typedef ::std::__numpunct_cache<_CharT> __cache_type;
    ::std::__use_cache<__cache_type> __uc;
    const ::std::locale &__loc(__io._M_getloc());
    const __cache_type *__lc = __uc(__loc);
    const ::std::streamsize __prec(__io.precision() < 0 ? 6 : __io.precision());
    const int __max_digits = __gnu_cxx::__numeric_traits<_ValueT>::__digits10;
    int __len;
    char __fbuf[16];
    __num_base::_S_format_float(__io, __fbuf, __mod);
    int __cs_size = __max_digits * 3;
    char *__cs(static_cast<char *>(__builtin_alloca(__cs_size)));
    __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size, __fbuf, __prec, __v);
    if (__len >= __cs_size)
      {
        __cs_size = __len + 1;
        __cs = static_cast<char *>(__builtin_alloca(__cs_size));
        __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size, __fbuf, __prec, __v);
      }
    const ::std::ctype<_CharT> &__ctype = use_facet< ::std::ctype<_CharT> >(__loc);
    _CharT *__ws = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __len));
    __ctype.widen(__cs, __cs + __len, __ws);
    _CharT *__wp = 0;
    const char *__p(char_traits<char>::find(__cs, __len, '.'));
    if (__p)
      {
        __wp = __ws + (__p - __cs);
        *__wp = __lc->_M_decimal_point;
      }
    if (__lc->_M_use_grouping && ((__wp || __len < 3) || (((__cs[1] <= '9' && __cs[2] <= '9') && __cs[1] >= '0') && __cs[2] >= '0')))
      {
        _CharT *__ws2 = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __len * 2));
        ::std::streamsize __off(0);
        if (__cs[0] == '-' || __cs[0] == '+')
          {
            __off = 1;
            __ws2[0] = __ws[0];
            __len -= 1;
          }
        _M_group_float(__lc->_M_grouping, __lc->_M_grouping_size, __lc->_M_thousands_sep, __wp, __ws2 + __off, __ws + __off, __len);
        __len += __off;
        __ws = __ws2;
      }
    const ::std::streamsize __w(__io.width());
    if (__w > static_cast< ::std::streamsize>(__len))
      {
        _CharT *__ws3 = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __w));
        _M_pad(__fill, __w, __io, __ws3, __ws, __len);
        __ws = __ws3;
      }
    __io.width(0);
    return std::__write(__s, __ws, __len);
  }
  template < typename _CharT, typename _OutIter >
  typename ::std::num_put<_CharT, _OutIter>::iter_type num_put<_CharT, _OutIter>::do_put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, bool __v) const 
  {
    const ::std::ios_base::fmtflags __flags(__io.flags());
    if ((__flags & ::std::ios_base::boolalpha) == 0)
      {
        const long int __l(__v);
        __s = _M_insert_int(__s, __io, __fill, __l);
      }
    else
      {
        typedef ::std::__numpunct_cache<_CharT> __cache_type;
        ::std::__use_cache<__cache_type> __uc;
        const ::std::locale &__loc(__io._M_getloc());
        const __cache_type *__lc = __uc(__loc);
        const _CharT *__name = __v ? __lc->_M_truename : __lc->_M_falsename;
        int __len(__v ? __lc->_M_truename_size : __lc->_M_falsename_size);
        const ::std::streamsize __w(__io.width());
        if (__w > static_cast< ::std::streamsize>(__len))
          {
            const ::std::streamsize __plen(__w - __len);
            _CharT *__ps = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __plen));
            char_traits<_CharT>::assign(__ps, __plen, __fill);
            __io.width(0);
            if ((__flags & ::std::ios_base::adjustfield) == ::std::ios_base::left)
              {
                __s = std::__write(__s, __name, __len);
                __s = std::__write(__s, __ps, __plen);
              }
            else
              {
                __s = std::__write(__s, __ps, __plen);
                __s = std::__write(__s, __name, __len);
              }
            return __s;
          }
        __io.width(0);
        __s = std::__write(__s, __name, __len);
      }
    return __s;
  }
  template < typename _CharT, typename _OutIter >
  typename ::std::num_put<_CharT, _OutIter>::iter_type num_put<_CharT, _OutIter>::do_put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, double __v) const 
  {
    return _M_insert_float(__s, __io, __fill, char(), __v);
  }
  template < typename _CharT, typename _OutIter >
  typename ::std::num_put<_CharT, _OutIter>::iter_type num_put<_CharT, _OutIter>::do_put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, long double __v) const 
  {
    return _M_insert_float(__s, __io, __fill, 'L', __v);
  }
  template < typename _CharT, typename _OutIter >
  typename ::std::num_put<_CharT, _OutIter>::iter_type num_put<_CharT, _OutIter>::do_put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, const void *__v) const 
  {
    const ::std::ios_base::fmtflags __flags(__io.flags());
    const ::std::ios_base::fmtflags __fmt( ~(::std::ios_base::basefield | ::std::ios_base::uppercase));
    __io.flags(__flags & __fmt | ::std::ios_base::hex | ::std::ios_base::showbase);
    typedef ::__gnu_cxx::__conditional_type<true, unsigned long int, unsigned long long int>::__type _UIntPtrType;
    __s = _M_insert_int(__s, __io, __fill, reinterpret_cast<_UIntPtrType>(__v));
    __io.flags(__flags);
    return __s;
  }
  template < typename _CharT, typename _Traits >
  void __pad<_CharT, _Traits>::_S_pad(::std::ios_base &__io, _CharT __fill, _CharT *__news, const _CharT *__olds, ::std::streamsize __newlen, ::std::streamsize __oldlen)
  {
    const ::std::size_t __plen(static_cast< ::std::size_t>(__newlen - __oldlen));
    const ::std::ios_base::fmtflags __adjust(__io.::std::ios_base::flags() & ::std::ios_base::adjustfield);
    if (__adjust == ::std::ios_base::left)
      {
        _Traits::copy(__news, __olds, __oldlen);
        _Traits::assign(__news + __oldlen, __plen, __fill);
        return ;
      }
    ::std::size_t __mod(0);
    if (__adjust == ::std::ios_base::internal)
      {
        const ::std::locale &__loc(__io.::std::ios_base::_M_getloc());
        const ::std::ctype<_CharT> &__ctype = use_facet< ::std::ctype<_CharT> >(__loc);
        if (__ctype.widen('-') == __olds[0] || __ctype.widen('+') == __olds[0])
          {
            __news[0] = __olds[0];
            __mod = 1;
            ++__news;
          }
        else
          {
            if ((__ctype.widen('0') == __olds[0] && __oldlen > 1) && (__ctype.widen('x') == __olds[1] || __ctype.widen('X') == __olds[1]))
              {
                __news[0] = __olds[0];
                __news[1] = __olds[1];
                __mod = 2;
                __news += 2;
              }
          }
      }
    _Traits::assign(__news, __plen, __fill);
    _Traits::copy(__news + __plen, __olds + __mod, __oldlen - __mod);
  }
  template < typename _CharT >
  _CharT *__add_grouping(_CharT *__s, _CharT __sep, const char *__gbeg, ::std::size_t __gsize, const _CharT *__first, const _CharT *__last)
  {
    ::std::size_t __idx(0);
    ::std::size_t __ctr(0);
    while ((__last - __first > __gbeg[__idx] && static_cast<signed char>(__gbeg[__idx]) > 0) && __gbeg[__idx] != ::__gnu_cxx::__numeric_traits_integer<char>::__max)
      {
        __last -= __gbeg[__idx];
        __idx < __gsize - 1 ? ++__idx : ++__ctr;
      }
    while (__first != __last)
      {
        *__s++ = *__first++;
      }
    while (__ctr--)
      {
        *__s++ = __sep;
        for (char __i = __gbeg[__idx]; __i > 0; --__i)
          {
            *__s++ = *__first++;
          }
      }
    while (__idx--)
      {
        *__s++ = __sep;
        for (char __i = __gbeg[__idx]; __i > 0; --__i)
          {
            *__s++ = *__first++;
          }
      }
    return __s;
  }
extern template class ::std::numpunct<char>;
extern template class ::std::numpunct_byname<char>;
extern template class ::std::num_get<char, ::std::istreambuf_iterator<char, ::std::char_traits<char> > >;
extern template class ::std::num_put<char, ::std::ostreambuf_iterator<char, ::std::char_traits<char> > >;
extern template class ::std::ctype_byname<char>;
extern template const ::std::ctype<char> &use_facet< ::std::ctype<char> >(const ::std::locale &);
extern template const ::std::numpunct<char> &use_facet< ::std::numpunct<char> >(const ::std::locale &);
extern template const ::std::num_put<char, ::std::ostreambuf_iterator<char, ::std::char_traits<char> > > &use_facet< ::std::num_put<char, ::std::ostreambuf_iterator<char, ::std::char_traits<char> > > >(const ::std::locale &);
extern template const ::std::num_get<char, ::std::istreambuf_iterator<char, ::std::char_traits<char> > > &use_facet< ::std::num_get<char, ::std::istreambuf_iterator<char, ::std::char_traits<char> > > >(const ::std::locale &);
extern template bool has_facet< ::std::ctype<char> >(const ::std::locale &);
extern template bool has_facet< ::std::numpunct<char> >(const ::std::locale &);
extern template bool has_facet< ::std::num_put<char, ::std::ostreambuf_iterator<char, ::std::char_traits<char> > > >(const ::std::locale &);
extern template bool has_facet< ::std::num_get<char, ::std::istreambuf_iterator<char, ::std::char_traits<char> > > >(const ::std::locale &);
extern template class ::std::numpunct<wchar_t>;
extern template class ::std::numpunct_byname<wchar_t>;
extern template class ::std::num_get<wchar_t, ::std::istreambuf_iterator<wchar_t, ::std::char_traits<wchar_t> > >;
extern template class ::std::num_put<wchar_t, ::std::ostreambuf_iterator<wchar_t, ::std::char_traits<wchar_t> > >;
extern template class ::std::ctype_byname<wchar_t>;
extern template const ::std::ctype<wchar_t> &use_facet< ::std::ctype<wchar_t> >(const ::std::locale &);
extern template const ::std::numpunct<wchar_t> &use_facet< ::std::numpunct<wchar_t> >(const ::std::locale &);
extern template const ::std::num_put<wchar_t, ::std::ostreambuf_iterator<wchar_t, ::std::char_traits<wchar_t> > > &use_facet< ::std::num_put<wchar_t, ::std::ostreambuf_iterator<wchar_t, ::std::char_traits<wchar_t> > > >(const ::std::locale &);
extern template const ::std::num_get<wchar_t, ::std::istreambuf_iterator<wchar_t, ::std::char_traits<wchar_t> > > &use_facet< ::std::num_get<wchar_t, ::std::istreambuf_iterator<wchar_t, ::std::char_traits<wchar_t> > > >(const ::std::locale &);
extern template bool has_facet< ::std::ctype<wchar_t> >(const ::std::locale &);
extern template bool has_facet< ::std::numpunct<wchar_t> >(const ::std::locale &);
extern template bool has_facet< ::std::num_put<wchar_t, ::std::ostreambuf_iterator<wchar_t, ::std::char_traits<wchar_t> > > >(const ::std::locale &);
extern template bool has_facet< ::std::num_get<wchar_t, ::std::istreambuf_iterator<wchar_t, ::std::char_traits<wchar_t> > > >(const ::std::locale &);
  template < typename _Facet >
  inline const _Facet &__check_facet(const _Facet *__f);
  template < typename _Facet >
  inline const _Facet &__check_facet(const _Facet *__f)
  {
    if (!__f)
      {
        ::std::__throw_bad_cast();
      }
    return *__f;
  }
  template < typename _CharT, typename _Traits >
  class  basic_ios : public ::std::ios_base
  {
    public:
      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;
      typedef ::std::ctype<_CharT> __ctype_type;
      typedef ::std::num_put<_CharT, ::std::ostreambuf_iterator<_CharT, _Traits> > __num_put_type;
      typedef ::std::num_get<_CharT, ::std::istreambuf_iterator<_CharT, _Traits> > __num_get_type;
    protected:
      ::std::basic_ostream<_CharT, _Traits> *_M_tie;
      mutable typename ::std::basic_ios<_CharT, _Traits>::char_type _M_fill;
      mutable bool _M_fill_init;
      ::std::basic_streambuf<_CharT, _Traits> *_M_streambuf;
      const typename ::std::basic_ios<_CharT, _Traits>::__ctype_type *_M_ctype;
      const typename ::std::basic_ios<_CharT, _Traits>::__num_put_type *_M_num_put;
      const typename ::std::basic_ios<_CharT, _Traits>::__num_get_type *_M_num_get;
    public:
      inline operator void *() const 
      {
        return this->fail() ? 0 : const_cast< ::std::basic_ios<_CharT, _Traits> *>(this);
      }
      inline bool operator !() const 
      {
        return this->fail();
      }
      inline ::std::ios_base::iostate rdstate() const 
      {
        return (*this)._M_streambuf_state;
      }
      void clear(::std::ios_base::iostate __state  = ::std::ios_base::goodbit);
      inline void setstate(::std::ios_base::iostate __state)
      {
        this->clear(this->rdstate() | __state);
      }
      inline void _M_setstate(::std::ios_base::iostate __state)
      {
        (*this)._M_streambuf_state |= __state;
        if (this->exceptions() & __state)
          {
            throw;
          }
      }
      inline bool good() const 
      {
        return this->rdstate() == 0;
      }
      inline bool eof() const 
      {
        return (this->rdstate() & ::std::ios_base::eofbit) != 0;
      }
      inline bool fail() const 
      {
        return (this->rdstate() & (::std::ios_base::badbit | ::std::ios_base::failbit)) != 0;
      }
      inline bool bad() const 
      {
        return (this->rdstate() & ::std::ios_base::badbit) != 0;
      }
      inline ::std::ios_base::iostate exceptions() const 
      {
        return (*this)._M_exception;
      }
      inline void exceptions(::std::ios_base::iostate __except)
      {
        (*this)._M_exception = __except;
        this->clear((*this)._M_streambuf_state);
      }
      inline explicit basic_ios(::std::basic_streambuf<_CharT, _Traits> *__sb)
        : ios_base(), _M_tie(0), _M_fill(), _M_fill_init(false), _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)
      {
        this->init(__sb);
      }
      inline virtual ~basic_ios()
      {
      }
      inline ::std::basic_ostream<_CharT, _Traits> *tie() const 
      {
        return _M_tie;
      }
      inline ::std::basic_ostream<_CharT, _Traits> *tie(::std::basic_ostream<_CharT, _Traits> *__tiestr)
      {
        ::std::basic_ostream<_CharT, _Traits> *__old = _M_tie;
        _M_tie = __tiestr;
        return __old;
      }
      inline ::std::basic_streambuf<_CharT, _Traits> *rdbuf() const 
      {
        return _M_streambuf;
      }
      ::std::basic_streambuf<_CharT, _Traits> *rdbuf(::std::basic_streambuf<_CharT, _Traits> *__sb);
      ::std::basic_ios<_CharT, _Traits> &copyfmt(const ::std::basic_ios<_CharT, _Traits> &__rhs);
      inline typename ::std::basic_ios<_CharT, _Traits>::char_type fill() const 
      {
        if (!_M_fill_init)
          {
            _M_fill = this->widen(' ');
            _M_fill_init = true;
          }
        return _M_fill;
      }
      inline typename ::std::basic_ios<_CharT, _Traits>::char_type fill(typename ::std::basic_ios<_CharT, _Traits>::char_type __ch)
      {
        typename ::std::basic_ios<_CharT, _Traits>::char_type __old = this->fill();
        _M_fill = __ch;
        return __old;
      }
      ::std::locale imbue(const ::std::locale &__loc);
      inline char narrow(typename ::std::basic_ios<_CharT, _Traits>::char_type __c, char __dfault) const 
      {
        return __check_facet(_M_ctype).narrow(__c, __dfault);
      }
      inline typename ::std::basic_ios<_CharT, _Traits>::char_type widen(char __c) const 
      {
        return __check_facet(_M_ctype).widen(__c);
      }
    protected:
      inline basic_ios()
        : ios_base(), _M_tie(0), _M_fill(typename ::std::basic_ios<_CharT, _Traits>::char_type()), _M_fill_init(false), _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)
      {
      }
      void init(::std::basic_streambuf<_CharT, _Traits> *__sb);
      void _M_cache_locale(const ::std::locale &__loc);
  };
  template < typename _CharT, typename _Traits >
  void basic_ios<_CharT, _Traits>::clear(::std::ios_base::iostate __state)
  {
    if (this->rdbuf())
      {
        (*this)._M_streambuf_state = __state;
      }
    else
      {
        (*this)._M_streambuf_state = __state | ::std::ios_base::badbit;
      }
    if (this->exceptions() & this->rdstate())
      {
        ::std::__throw_ios_failure("basic_ios::clear");
      }
  }
  template < typename _CharT, typename _Traits >
  ::std::basic_streambuf<_CharT, _Traits> *basic_ios<_CharT, _Traits>::rdbuf(::std::basic_streambuf<_CharT, _Traits> *__sb)
  {
    ::std::basic_streambuf<_CharT, _Traits> *__old = _M_streambuf;
    _M_streambuf = __sb;
    this->clear();
    return __old;
  }
  template < typename _CharT, typename _Traits >
  ::std::basic_ios<_CharT, _Traits> &basic_ios<_CharT, _Traits>::copyfmt(const ::std::basic_ios<_CharT, _Traits> &__rhs)
  {
    if (this != &__rhs)
      {
        ::std::ios_base::_Words *__words(__rhs._M_word_size <= ::std::ios_base::_S_local_word_size ? (*this)._M_local_word : new ::std::ios_base::_Words [__rhs._M_word_size]);
        ::std::ios_base::_Callback_list *__cb(__rhs._M_callbacks);
        if (__cb)
          {
            (*__cb)._M_add_reference();
          }
        _M_call_callbacks(::std::ios_base::erase_event);
        if ((*this)._M_word != (*this)._M_local_word)
          {
            delete[] (*this)._M_word;
            (*this)._M_word = 0;
          }
        _M_dispose_callbacks();
        (*this)._M_callbacks = __cb;
        for (int __i = 0; __i < __rhs._M_word_size; ++__i)
          {
            __words[__i] = __rhs._M_word[__i];
          }
        (*this)._M_word = __words;
        (*this)._M_word_size = __rhs._M_word_size;
        this->flags(__rhs.flags());
        this->width(__rhs.width());
        this->precision(__rhs.precision());
        this->tie(__rhs.tie());
        this->fill(__rhs.fill());
        (*this)._M_ios_locale = __rhs.getloc();
        _M_cache_locale((*this)._M_ios_locale);
        _M_call_callbacks(::std::ios_base::copyfmt_event);
        this->exceptions(__rhs.exceptions());
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  ::std::locale basic_ios<_CharT, _Traits>::imbue(const ::std::locale &__loc)
  {
    ::std::locale __old(this->getloc());
    ios_base::imbue(__loc);
    _M_cache_locale(__loc);
    if (this->rdbuf() != 0)
      {
        this->rdbuf()->pubimbue(__loc);
      }
    return __old;
  }
  template < typename _CharT, typename _Traits >
  void basic_ios<_CharT, _Traits>::init(::std::basic_streambuf<_CharT, _Traits> *__sb)
  {
    ios_base::_M_init();
    _M_cache_locale((*this)._M_ios_locale);
    _M_fill = _CharT();
    _M_fill_init = false;
    _M_tie = 0;
    (*this)._M_exception = ::std::ios_base::goodbit;
    _M_streambuf = __sb;
    (*this)._M_streambuf_state = __sb ? ::std::ios_base::goodbit : ::std::ios_base::badbit;
  }
  template < typename _CharT, typename _Traits >
  void basic_ios<_CharT, _Traits>::_M_cache_locale(const ::std::locale &__loc)
  {
    if (__builtin_expect(has_facet<typename ::std::basic_ios<_CharT, _Traits>::__ctype_type>(__loc), true))
      {
        _M_ctype = &use_facet<typename ::std::basic_ios<_CharT, _Traits>::__ctype_type>(__loc);
      }
    else
      {
        _M_ctype = 0;
      }
    if (__builtin_expect(has_facet<typename ::std::basic_ios<_CharT, _Traits>::__num_put_type>(__loc), true))
      {
        _M_num_put = &use_facet<typename ::std::basic_ios<_CharT, _Traits>::__num_put_type>(__loc);
      }
    else
      {
        _M_num_put = 0;
      }
    if (__builtin_expect(has_facet<typename ::std::basic_ios<_CharT, _Traits>::__num_get_type>(__loc), true))
      {
        _M_num_get = &use_facet<typename ::std::basic_ios<_CharT, _Traits>::__num_get_type>(__loc);
      }
    else
      {
        _M_num_get = 0;
      }
  }
extern template class ::std::basic_ios<char, ::std::char_traits<char> >;
extern template class ::std::basic_ios<wchar_t, ::std::char_traits<wchar_t> >;
  template < typename _CharT, typename _Traits >
  class  basic_ostream : virtual public ::std::basic_ios<_CharT, _Traits>
  {
    public:
      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;
      typedef ::std::basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef ::std::basic_ios<_CharT, _Traits> __ios_type;
      typedef ::std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef ::std::num_put<_CharT, ::std::ostreambuf_iterator<_CharT, _Traits> > __num_put_type;
      typedef ::std::ctype<_CharT> __ctype_type;
      inline explicit basic_ostream(typename ::std::basic_ostream<_CharT, _Traits>::__streambuf_type *__sb)
      {
        this->init(__sb);
      }
      inline virtual ~basic_ostream()
      {
      }
      class sentry;
      inline typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &(*__pf)(typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &))
      {
        return __pf(*this);
      }
      inline typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(typename ::std::basic_ostream<_CharT, _Traits>::__ios_type &(*__pf)(typename ::std::basic_ostream<_CharT, _Traits>::__ios_type &))
      {
        __pf(*this);
        return *this;
      }
      inline typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(::std::ios_base &(*__pf)(::std::ios_base &))
      {
        __pf(*this);
        return *this;
      }
      inline typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(long int __n)
      {
        return _M_insert(__n);
      }
      inline typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(unsigned long int __n)
      {
        return _M_insert(__n);
      }
      inline typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(bool __n)
      {
        return _M_insert(__n);
      }
      typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(short int __n);
      inline typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(unsigned short int __n)
      {
        return _M_insert(static_cast<unsigned long int>(__n));
      }
      typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(int __n);
      inline typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(unsigned int __n)
      {
        return _M_insert(static_cast<unsigned long int>(__n));
      }
      inline typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(long long int __n)
      {
        return _M_insert(__n);
      }
      inline typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(unsigned long long int __n)
      {
        return _M_insert(__n);
      }
      inline typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(double __f)
      {
        return _M_insert(__f);
      }
      inline typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(float __f)
      {
        return _M_insert(static_cast<double>(__f));
      }
      inline typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(long double __f)
      {
        return _M_insert(__f);
      }
      inline typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(const void *__p)
      {
        return _M_insert(__p);
      }
      typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(typename ::std::basic_ostream<_CharT, _Traits>::__streambuf_type *__sbin);
      typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &put(typename ::std::basic_ostream<_CharT, _Traits>::char_type __c);
      inline void _M_write(const typename ::std::basic_ostream<_CharT, _Traits>::char_type *__s, ::std::streamsize __n)
      {
        const ::std::streamsize __put(this->rdbuf()->sputn(__s, __n));
        if (__put != __n)
          {
            this->setstate(::std::ios_base::badbit);
          }
      }
      typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &write(const typename ::std::basic_ostream<_CharT, _Traits>::char_type *__s, ::std::streamsize __n);
      typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &flush();
      typename ::std::basic_ostream<_CharT, _Traits>::pos_type tellp();
      typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &seekp(typename ::std::basic_ostream<_CharT, _Traits>::pos_type __pos);
      typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &seekp(typename ::std::basic_ostream<_CharT, _Traits>::off_type __off, ::std::ios_base::seekdir __dir);
    protected:
      inline basic_ostream()
      {
        this->init(0);
      }
      template < typename _ValueT >
      typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &_M_insert(_ValueT __v);
    friend class ::std::basic_ostream<_CharT, _Traits>::sentry;
  };
  template < typename _CharT, typename _Traits >
  class  basic_ostream<_CharT, _Traits>::sentry
  {
      bool _M_ok;
      ::std::basic_ostream<_CharT, _Traits> &_M_os;
    public:
      explicit sentry(::std::basic_ostream<_CharT, _Traits> &__os);
      inline ~sentry()
      {
        if ((bool)(_M_os.flags() & ::std::ios_base::unitbuf) && !::std::uncaught_exception())
          {
            if (_M_os.rdbuf() && _M_os.rdbuf()->pubsync() ==  -1)
              {
                _M_os.setstate(::std::ios_base::badbit);
              }
          }
      }
      inline operator bool() const 
      {
        return _M_ok;
      }
  };
  template < typename _CharT, typename _Traits >
  inline ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__out, _CharT __c);
  template < typename _CharT, typename _Traits >
  inline ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__out, _CharT __c)
  {
    return __ostream_insert(__out, &__c, 1);
  }
  template < typename _CharT, typename _Traits >
  inline ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__out, char __c);
  template < typename _CharT, typename _Traits >
  inline ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__out, char __c)
  {
    return __out << __out.widen(__c);
  }
  template < typename _Traits >
  inline ::std::basic_ostream<char, _Traits> &operator <<(::std::basic_ostream<char, _Traits> &__out, char __c);
  template < typename _Traits >
  inline ::std::basic_ostream<char, _Traits> &operator <<(::std::basic_ostream<char, _Traits> &__out, char __c)
  {
    return __ostream_insert(__out, &__c, 1);
  }
  template < typename _Traits >
  inline ::std::basic_ostream<char, _Traits> &operator <<(::std::basic_ostream<char, _Traits> &__out, signed char __c);
  template < typename _Traits >
  inline ::std::basic_ostream<char, _Traits> &operator <<(::std::basic_ostream<char, _Traits> &__out, signed char __c)
  {
    return __out << static_cast<char>(__c);
  }
  template < typename _Traits >
  inline ::std::basic_ostream<char, _Traits> &operator <<(::std::basic_ostream<char, _Traits> &__out, unsigned char __c);
  template < typename _Traits >
  inline ::std::basic_ostream<char, _Traits> &operator <<(::std::basic_ostream<char, _Traits> &__out, unsigned char __c)
  {
    return __out << static_cast<char>(__c);
  }
  template < typename _CharT, typename _Traits >
  inline ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__out, const _CharT *__s);
  template < typename _CharT, typename _Traits >
  inline ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__out, const _CharT *__s)
  {
    if (!__s)
      {
        __out.setstate(::std::ios_base::badbit);
      }
    else
      {
        __ostream_insert(__out, __s, static_cast< ::std::streamsize>(_Traits::length(__s)));
      }
    return __out;
  }
  template < typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__out, const char *__s);
  template < typename _Traits >
  inline ::std::basic_ostream<char, _Traits> &operator <<(::std::basic_ostream<char, _Traits> &__out, const char *__s);
  template < typename _Traits >
  inline ::std::basic_ostream<char, _Traits> &operator <<(::std::basic_ostream<char, _Traits> &__out, const char *__s)
  {
    if (!__s)
      {
        __out.setstate(::std::ios_base::badbit);
      }
    else
      {
        __ostream_insert(__out, __s, static_cast< ::std::streamsize>(_Traits::length(__s)));
      }
    return __out;
  }
  template < typename _Traits >
  inline ::std::basic_ostream<char, _Traits> &operator <<(::std::basic_ostream<char, _Traits> &__out, const signed char *__s);
  template < typename _Traits >
  inline ::std::basic_ostream<char, _Traits> &operator <<(::std::basic_ostream<char, _Traits> &__out, const signed char *__s)
  {
    return __out << reinterpret_cast<const char *>(__s);
  }
  template < typename _Traits >
  inline ::std::basic_ostream<char, _Traits> &operator <<(::std::basic_ostream<char, _Traits> &__out, const unsigned char *__s);
  template < typename _Traits >
  inline ::std::basic_ostream<char, _Traits> &operator <<(::std::basic_ostream<char, _Traits> &__out, const unsigned char *__s)
  {
    return __out << reinterpret_cast<const char *>(__s);
  }
  template < typename _CharT, typename _Traits >
  inline ::std::basic_ostream<_CharT, _Traits> &endl(::std::basic_ostream<_CharT, _Traits> &__os);
  template < typename _CharT, typename _Traits >
  inline ::std::basic_ostream<_CharT, _Traits> &endl(::std::basic_ostream<_CharT, _Traits> &__os)
  {
    return flush(__os.put(__os.widen('\n')));
  }
  template < typename _CharT, typename _Traits >
  inline ::std::basic_ostream<_CharT, _Traits> &ends(::std::basic_ostream<_CharT, _Traits> &__os);
  template < typename _CharT, typename _Traits >
  inline ::std::basic_ostream<_CharT, _Traits> &ends(::std::basic_ostream<_CharT, _Traits> &__os)
  {
    return __os.put(_CharT());
  }
  template < typename _CharT, typename _Traits >
  inline ::std::basic_ostream<_CharT, _Traits> &flush(::std::basic_ostream<_CharT, _Traits> &__os);
  template < typename _CharT, typename _Traits >
  inline ::std::basic_ostream<_CharT, _Traits> &flush(::std::basic_ostream<_CharT, _Traits> &__os)
  {
    return __os.flush();
  }
  template < typename _CharT, typename _Traits >
  basic_ostream<_CharT, _Traits>::sentry::sentry(::std::basic_ostream<_CharT, _Traits> &__os)
    : _M_ok(false), _M_os(__os)
  {
    if (__os.tie() && __os.good())
      {
        __os.tie()->flush();
      }
    if (__os.good())
      {
        _M_ok = true;
      }
    else
      {
        __os.setstate(::std::ios_base::failbit);
      }
  }
  template < typename _CharT, typename _Traits >
  template < typename _ValueT >
  typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &basic_ostream<_CharT, _Traits>::_M_insert(_ValueT __v)
  {
    typename ::std::basic_ostream<_CharT, _Traits>::sentry __cerb(*this);
    if (__cerb)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          const typename ::std::basic_ostream<_CharT, _Traits>::__num_put_type &__np = __check_facet(this->_M_num_put);
          if (__np.put(*this, *this, this->fill(), __v).failed())
            {
              __err |= ::std::ios_base::badbit;
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            this->setstate(__err);
          }
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &basic_ostream<_CharT, _Traits>::operator <<(short int __n)
  {
    const ::std::ios_base::fmtflags __fmt(this->flags() & ::std::ios_base::basefield);
    if (__fmt == ::std::ios_base::oct || __fmt == ::std::ios_base::hex)
      {
        return _M_insert(static_cast<long int>(static_cast<unsigned short int>(__n)));
      }
    else
      {
        return _M_insert(static_cast<long int>(__n));
      }
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &basic_ostream<_CharT, _Traits>::operator <<(int __n)
  {
    const ::std::ios_base::fmtflags __fmt(this->flags() & ::std::ios_base::basefield);
    if (__fmt == ::std::ios_base::oct || __fmt == ::std::ios_base::hex)
      {
        return _M_insert(static_cast<long int>(static_cast<unsigned int>(__n)));
      }
    else
      {
        return _M_insert(static_cast<long int>(__n));
      }
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &basic_ostream<_CharT, _Traits>::operator <<(typename ::std::basic_ostream<_CharT, _Traits>::__streambuf_type *__sbin)
  {
    ::std::ios_base::iostate __err(::std::ios_base::goodbit);
    typename ::std::basic_ostream<_CharT, _Traits>::sentry __cerb(*this);
    if (__cerb && __sbin)
      {
        try
        {
          if (!__copy_streambufs(__sbin, this->rdbuf()))
            {
              __err |= ::std::ios_base::failbit;
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::failbit);
        }
      }
    else
      {
        if (!__sbin)
          {
            __err |= ::std::ios_base::badbit;
          }
      }
    if (__err)
      {
        this->setstate(__err);
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &basic_ostream<_CharT, _Traits>::put(typename ::std::basic_ostream<_CharT, _Traits>::char_type __c)
  {
    typename ::std::basic_ostream<_CharT, _Traits>::sentry __cerb(*this);
    if (__cerb)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          const typename ::std::basic_ostream<_CharT, _Traits>::int_type __put = this->rdbuf()->sputc(__c);
          if (traits_type::eq_int_type(__put, traits_type::eof()))
            {
              __err |= ::std::ios_base::badbit;
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            this->setstate(__err);
          }
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &basic_ostream<_CharT, _Traits>::write(const _CharT *__s, ::std::streamsize __n)
  {
    typename ::std::basic_ostream<_CharT, _Traits>::sentry __cerb(*this);
    if (__cerb)
      {
        try
        {
          _M_write(__s, __n);
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &basic_ostream<_CharT, _Traits>::flush()
  {
    ::std::ios_base::iostate __err(::std::ios_base::goodbit);
    try
    {
      if (this->rdbuf() && this->rdbuf()->pubsync() ==  -1)
        {
          __err |= ::std::ios_base::badbit;
        }
    }
    catch (::__cxxabiv1::__forced_unwind &)
    {
      this->_M_setstate(::std::ios_base::badbit);
      throw;
    }
    catch (...)
    {
      this->_M_setstate(::std::ios_base::badbit);
    }
    if (__err)
      {
        this->setstate(__err);
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_ostream<_CharT, _Traits>::pos_type basic_ostream<_CharT, _Traits>::tellp()
  {
    typename ::std::basic_ostream<_CharT, _Traits>::pos_type __ret = typename ::std::basic_ostream<_CharT, _Traits>::pos_type( -1);
    try
    {
      if (!this->fail())
        {
          __ret = this->rdbuf()->pubseekoff(0, ::std::ios_base::cur, ::std::ios_base::out);
        }
    }
    catch (::__cxxabiv1::__forced_unwind &)
    {
      this->_M_setstate(::std::ios_base::badbit);
      throw;
    }
    catch (...)
    {
      this->_M_setstate(::std::ios_base::badbit);
    }
    return __ret;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &basic_ostream<_CharT, _Traits>::seekp(typename ::std::basic_ostream<_CharT, _Traits>::pos_type __pos)
  {
    ::std::ios_base::iostate __err(::std::ios_base::goodbit);
    try
    {
      if (!this->fail())
        {
          const typename ::std::basic_ostream<_CharT, _Traits>::pos_type __p = this->rdbuf()->pubseekpos(__pos, ::std::ios_base::out);
          if (__p == pos_type(typename ::std::basic_ostream<_CharT, _Traits>::off_type( -1)))
            {
              __err |= ::std::ios_base::failbit;
            }
        }
    }
    catch (::__cxxabiv1::__forced_unwind &)
    {
      this->_M_setstate(::std::ios_base::badbit);
      throw;
    }
    catch (...)
    {
      this->_M_setstate(::std::ios_base::badbit);
    }
    if (__err)
      {
        this->setstate(__err);
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &basic_ostream<_CharT, _Traits>::seekp(typename ::std::basic_ostream<_CharT, _Traits>::off_type __off, ::std::ios_base::seekdir __dir)
  {
    ::std::ios_base::iostate __err(::std::ios_base::goodbit);
    try
    {
      if (!this->fail())
        {
          const typename ::std::basic_ostream<_CharT, _Traits>::pos_type __p = this->rdbuf()->pubseekoff(__off, __dir, ::std::ios_base::out);
          if (__p == pos_type(typename ::std::basic_ostream<_CharT, _Traits>::off_type( -1)))
            {
              __err |= ::std::ios_base::failbit;
            }
        }
    }
    catch (::__cxxabiv1::__forced_unwind &)
    {
      this->_M_setstate(::std::ios_base::badbit);
      throw;
    }
    catch (...)
    {
      this->_M_setstate(::std::ios_base::badbit);
    }
    if (__err)
      {
        this->setstate(__err);
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__out, const char *__s)
  {
    if (!__s)
      {
        __out.setstate(::std::ios_base::badbit);
      }
    else
      {
        const ::std::size_t __clen(::std::char_traits<char>::length(__s));
        try
        {
          struct  __ptr_guard
          {
              _CharT *__p;
              inline __ptr_guard(_CharT *__ip)
                : __p(__ip)
              {
              }
              inline ~__ptr_guard()
              {
                delete[] __p;
              }
              inline _CharT *__get()
              {
                return __p;
              }
          };
          __ptr_guard __pg(new _CharT [__clen]);
          _CharT *__ws = __pg.__get();
          for (::std::size_t __i = 0; __i < __clen; ++__i)
            {
              __ws[__i] = __out.widen(__s[__i]);
            }
          __ostream_insert(__out, __ws, __clen);
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          __out._M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          __out._M_setstate(::std::ios_base::badbit);
        }
      }
    return __out;
  }
extern template class ::std::basic_ostream<char, ::std::char_traits<char> >;
extern template ::std::basic_ostream<char, ::std::char_traits<char> > &endl(::std::basic_ostream<char, ::std::char_traits<char> > &);
extern template ::std::basic_ostream<char, ::std::char_traits<char> > &ends(::std::basic_ostream<char, ::std::char_traits<char> > &);
extern template ::std::basic_ostream<char, ::std::char_traits<char> > &flush(::std::basic_ostream<char, ::std::char_traits<char> > &);
extern template ::std::basic_ostream<char, ::std::char_traits<char> > &operator <<(::std::basic_ostream<char, ::std::char_traits<char> > &, char);
extern template ::std::basic_ostream<char, ::std::char_traits<char> > &operator <<(::std::basic_ostream<char, ::std::char_traits<char> > &, unsigned char);
extern template ::std::basic_ostream<char, ::std::char_traits<char> > &operator <<(::std::basic_ostream<char, ::std::char_traits<char> > &, signed char);
extern template ::std::basic_ostream<char, ::std::char_traits<char> > &operator <<(::std::basic_ostream<char, ::std::char_traits<char> > &, const char *);
extern template ::std::basic_ostream<char, ::std::char_traits<char> > &operator <<(::std::basic_ostream<char, ::std::char_traits<char> > &, const unsigned char *);
extern template ::std::basic_ostream<char, ::std::char_traits<char> > &operator <<(::std::basic_ostream<char, ::std::char_traits<char> > &, const signed char *);
extern template ::std::basic_ostream<char, ::std::char_traits<char> > &ostream::_M_insert(long int);
extern template ::std::basic_ostream<char, ::std::char_traits<char> > &ostream::_M_insert(unsigned long int);
extern template ::std::basic_ostream<char, ::std::char_traits<char> > &ostream::_M_insert(bool);
extern template ::std::basic_ostream<char, ::std::char_traits<char> > &ostream::_M_insert(long long int);
extern template ::std::basic_ostream<char, ::std::char_traits<char> > &ostream::_M_insert(unsigned long long int);
extern template ::std::basic_ostream<char, ::std::char_traits<char> > &ostream::_M_insert(double);
extern template ::std::basic_ostream<char, ::std::char_traits<char> > &ostream::_M_insert(long double);
extern template ::std::basic_ostream<char, ::std::char_traits<char> > &ostream::_M_insert(const void *);
extern template class ::std::basic_ostream<wchar_t, ::std::char_traits<wchar_t> >;
extern template ::std::basic_ostream<wchar_t, ::std::char_traits<wchar_t> > &endl(::std::basic_ostream<wchar_t, ::std::char_traits<wchar_t> > &);
extern template ::std::basic_ostream<wchar_t, ::std::char_traits<wchar_t> > &ends(::std::basic_ostream<wchar_t, ::std::char_traits<wchar_t> > &);
extern template ::std::basic_ostream<wchar_t, ::std::char_traits<wchar_t> > &flush(::std::basic_ostream<wchar_t, ::std::char_traits<wchar_t> > &);
extern template ::std::basic_ostream<wchar_t, ::std::char_traits<wchar_t> > &operator <<(::std::basic_ostream<wchar_t, ::std::char_traits<wchar_t> > &, wchar_t);
extern template ::std::basic_ostream<wchar_t, ::std::char_traits<wchar_t> > &operator <<(::std::basic_ostream<wchar_t, ::std::char_traits<wchar_t> > &, char);
extern template ::std::basic_ostream<wchar_t, ::std::char_traits<wchar_t> > &operator <<(::std::basic_ostream<wchar_t, ::std::char_traits<wchar_t> > &, const wchar_t *);
extern template ::std::basic_ostream<wchar_t, ::std::char_traits<wchar_t> > &operator <<(::std::basic_ostream<wchar_t, ::std::char_traits<wchar_t> > &, const char *);
extern template ::std::basic_ostream<wchar_t, ::std::char_traits<wchar_t> > &wostream::_M_insert(long int);
extern template ::std::basic_ostream<wchar_t, ::std::char_traits<wchar_t> > &wostream::_M_insert(unsigned long int);
extern template ::std::basic_ostream<wchar_t, ::std::char_traits<wchar_t> > &wostream::_M_insert(bool);
extern template ::std::basic_ostream<wchar_t, ::std::char_traits<wchar_t> > &wostream::_M_insert(long long int);
extern template ::std::basic_ostream<wchar_t, ::std::char_traits<wchar_t> > &wostream::_M_insert(unsigned long long int);
extern template ::std::basic_ostream<wchar_t, ::std::char_traits<wchar_t> > &wostream::_M_insert(double);
extern template ::std::basic_ostream<wchar_t, ::std::char_traits<wchar_t> > &wostream::_M_insert(long double);
extern template ::std::basic_ostream<wchar_t, ::std::char_traits<wchar_t> > &wostream::_M_insert(const void *);
  template < typename _CharT, typename _Traits >
  class  basic_istream : virtual public ::std::basic_ios<_CharT, _Traits>
  {
    public:
      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;
      typedef ::std::basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef ::std::basic_ios<_CharT, _Traits> __ios_type;
      typedef ::std::basic_istream<_CharT, _Traits> __istream_type;
      typedef ::std::num_get<_CharT, ::std::istreambuf_iterator<_CharT, _Traits> > __num_get_type;
      typedef ::std::ctype<_CharT> __ctype_type;
    protected:
      ::std::streamsize _M_gcount;
    public:
      inline explicit basic_istream(typename ::std::basic_istream<_CharT, _Traits>::__streambuf_type *__sb)
        : _M_gcount((long int)0)
      {
        this->init(__sb);
      }
      inline virtual ~basic_istream()
      {
        _M_gcount = (long int)0;
      }
      class sentry;
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(typename ::std::basic_istream<_CharT, _Traits>::__istream_type &(*__pf)(typename ::std::basic_istream<_CharT, _Traits>::__istream_type &))
      {
        return __pf(*this);
      }
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(typename ::std::basic_istream<_CharT, _Traits>::__ios_type &(*__pf)(typename ::std::basic_istream<_CharT, _Traits>::__ios_type &))
      {
        __pf(*this);
        return *this;
      }
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(::std::ios_base &(*__pf)(::std::ios_base &))
      {
        __pf(*this);
        return *this;
      }
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(bool &__n)
      {
        return _M_extract(__n);
      }
      typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(short int &__n);
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(unsigned short int &__n)
      {
        return _M_extract(__n);
      }
      typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(int &__n);
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(unsigned int &__n)
      {
        return _M_extract(__n);
      }
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(long int &__n)
      {
        return _M_extract(__n);
      }
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(unsigned long int &__n)
      {
        return _M_extract(__n);
      }
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(long long int &__n)
      {
        return _M_extract(__n);
      }
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(unsigned long long int &__n)
      {
        return _M_extract(__n);
      }
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(float &__f)
      {
        return _M_extract(__f);
      }
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(double &__f)
      {
        return _M_extract(__f);
      }
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(long double &__f)
      {
        return _M_extract(__f);
      }
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(void *&__p)
      {
        return _M_extract(__p);
      }
      typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(typename ::std::basic_istream<_CharT, _Traits>::__streambuf_type *__sbout);
      inline ::std::streamsize gcount() const 
      {
        return _M_gcount;
      }
      typename ::std::basic_istream<_CharT, _Traits>::int_type get();
      typename ::std::basic_istream<_CharT, _Traits>::__istream_type &get(typename ::std::basic_istream<_CharT, _Traits>::char_type &__c);
      typename ::std::basic_istream<_CharT, _Traits>::__istream_type &get(typename ::std::basic_istream<_CharT, _Traits>::char_type *__s, ::std::streamsize __n, typename ::std::basic_istream<_CharT, _Traits>::char_type __delim);
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &get(typename ::std::basic_istream<_CharT, _Traits>::char_type *__s, ::std::streamsize __n)
      {
        return this->get(__s, __n, this->widen('\n'));
      }
      typename ::std::basic_istream<_CharT, _Traits>::__istream_type &get(typename ::std::basic_istream<_CharT, _Traits>::__streambuf_type &__sb, typename ::std::basic_istream<_CharT, _Traits>::char_type __delim);
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &get(typename ::std::basic_istream<_CharT, _Traits>::__streambuf_type &__sb)
      {
        return this->get(__sb, this->widen('\n'));
      }
      typename ::std::basic_istream<_CharT, _Traits>::__istream_type &getline(typename ::std::basic_istream<_CharT, _Traits>::char_type *__s, ::std::streamsize __n, typename ::std::basic_istream<_CharT, _Traits>::char_type __delim);
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &getline(typename ::std::basic_istream<_CharT, _Traits>::char_type *__s, ::std::streamsize __n)
      {
        return this->getline(__s, __n, this->widen('\n'));
      }
      typename ::std::basic_istream<_CharT, _Traits>::__istream_type &ignore(::std::streamsize __n, typename ::std::basic_istream<_CharT, _Traits>::int_type __delim);
      typename ::std::basic_istream<_CharT, _Traits>::__istream_type &ignore(::std::streamsize __n);
      typename ::std::basic_istream<_CharT, _Traits>::__istream_type &ignore();
      typename ::std::basic_istream<_CharT, _Traits>::int_type peek();
      typename ::std::basic_istream<_CharT, _Traits>::__istream_type &read(typename ::std::basic_istream<_CharT, _Traits>::char_type *__s, ::std::streamsize __n);
      ::std::streamsize readsome(typename ::std::basic_istream<_CharT, _Traits>::char_type *__s, ::std::streamsize __n);
      typename ::std::basic_istream<_CharT, _Traits>::__istream_type &putback(typename ::std::basic_istream<_CharT, _Traits>::char_type __c);
      typename ::std::basic_istream<_CharT, _Traits>::__istream_type &unget();
      int sync();
      typename ::std::basic_istream<_CharT, _Traits>::pos_type tellg();
      typename ::std::basic_istream<_CharT, _Traits>::__istream_type &seekg(typename ::std::basic_istream<_CharT, _Traits>::pos_type __pos);
      typename ::std::basic_istream<_CharT, _Traits>::__istream_type &seekg(typename ::std::basic_istream<_CharT, _Traits>::off_type __off, ::std::ios_base::seekdir __dir);
    protected:
      inline basic_istream()
        : _M_gcount((long int)0)
      {
        this->init(0);
      }
      template < typename _ValueT >
      typename ::std::basic_istream<_CharT, _Traits>::__istream_type &_M_extract(_ValueT &__v);
    friend class ::std::basic_istream<_CharT, _Traits>::sentry;
  };
  template <>
  ::std::basic_istream<char, ::std::char_traits<char> >::__istream_type &basic_istream<char, ::std::char_traits<char> >::getline(::std::basic_istream<char, ::std::char_traits<char> >::char_type *__s, long int __n, ::std::basic_istream<char, ::std::char_traits<char> >::char_type __delim);
  template <>
  ::std::basic_istream<char, ::std::char_traits<char> >::__istream_type &basic_istream<char, ::std::char_traits<char> >::ignore(long int __n);
  template <>
  ::std::basic_istream<char, ::std::char_traits<char> >::__istream_type &basic_istream<char, ::std::char_traits<char> >::ignore(long int __n, ::std::basic_istream<char, ::std::char_traits<char> >::int_type __delim);
  template <>
  ::std::basic_istream<wchar_t, ::std::char_traits<wchar_t> >::__istream_type &basic_istream<wchar_t, ::std::char_traits<wchar_t> >::getline(::std::basic_istream<wchar_t, ::std::char_traits<wchar_t> >::char_type *__s, long int __n, ::std::basic_istream<wchar_t, ::std::char_traits<wchar_t> >::char_type __delim);
  template <>
  ::std::basic_istream<wchar_t, ::std::char_traits<wchar_t> >::__istream_type &basic_istream<wchar_t, ::std::char_traits<wchar_t> >::ignore(long int __n);
  template <>
  ::std::basic_istream<wchar_t, ::std::char_traits<wchar_t> >::__istream_type &basic_istream<wchar_t, ::std::char_traits<wchar_t> >::ignore(long int __n, ::std::basic_istream<wchar_t, ::std::char_traits<wchar_t> >::int_type __delim);
  template < typename _CharT, typename _Traits >
  class  basic_istream<_CharT, _Traits>::sentry
  {
      bool _M_ok;
    public:
      typedef _Traits traits_type;
      typedef ::std::basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef ::std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename ::std::basic_istream<_CharT, _Traits>::__ctype_type __ctype_type;
      typedef typename _Traits::int_type __int_type;
      explicit sentry(::std::basic_istream<_CharT, _Traits> &__in, bool __noskip  = false);
      inline operator bool() const 
      {
        return _M_ok;
      }
  };
  template < typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__in, _CharT &__c);
  template < typename _Traits >
  inline ::std::basic_istream<char, _Traits> &operator >>(::std::basic_istream<char, _Traits> &__in, unsigned char &__c);
  template < typename _Traits >
  inline ::std::basic_istream<char, _Traits> &operator >>(::std::basic_istream<char, _Traits> &__in, unsigned char &__c)
  {
    return __in >> reinterpret_cast<char &>(__c);
  }
  template < typename _Traits >
  inline ::std::basic_istream<char, _Traits> &operator >>(::std::basic_istream<char, _Traits> &__in, signed char &__c);
  template < typename _Traits >
  inline ::std::basic_istream<char, _Traits> &operator >>(::std::basic_istream<char, _Traits> &__in, signed char &__c)
  {
    return __in >> reinterpret_cast<char &>(__c);
  }
  template < typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__in, _CharT *__s);
  template <>
  ::std::basic_istream<char, ::std::char_traits<char> > &operator >><char, ::std::char_traits<char> >(::std::basic_istream<char, ::std::char_traits<char> > &__in, char *__s);
  template < typename _Traits >
  inline ::std::basic_istream<char, _Traits> &operator >>(::std::basic_istream<char, _Traits> &__in, unsigned char *__s);
  template < typename _Traits >
  inline ::std::basic_istream<char, _Traits> &operator >>(::std::basic_istream<char, _Traits> &__in, unsigned char *__s)
  {
    return __in >> reinterpret_cast<char *>(__s);
  }
  template < typename _Traits >
  inline ::std::basic_istream<char, _Traits> &operator >>(::std::basic_istream<char, _Traits> &__in, signed char *__s);
  template < typename _Traits >
  inline ::std::basic_istream<char, _Traits> &operator >>(::std::basic_istream<char, _Traits> &__in, signed char *__s)
  {
    return __in >> reinterpret_cast<char *>(__s);
  }
  template < typename _CharT, typename _Traits >
  class  basic_iostream : public ::std::basic_istream<_CharT, _Traits>, public ::std::basic_ostream<_CharT, _Traits>
  {
    public:
      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;
      typedef ::std::basic_istream<_CharT, _Traits> __istream_type;
      typedef ::std::basic_ostream<_CharT, _Traits> __ostream_type;
      inline explicit basic_iostream(::std::basic_streambuf<_CharT, _Traits> *__sb)
        : __istream_type(__sb), __ostream_type(__sb)
      {
      }
      inline virtual ~basic_iostream()
      {
      }
    protected:
      inline basic_iostream()
        : __istream_type(), __ostream_type()
      {
      }
  };
  template < typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &ws(::std::basic_istream<_CharT, _Traits> &__in);
  template < typename _CharT, typename _Traits >
  basic_istream<_CharT, _Traits>::sentry::sentry(::std::basic_istream<_CharT, _Traits> &__in, bool __noskip)
    : _M_ok(false)
  {
    ::std::ios_base::iostate __err(::std::ios_base::goodbit);
    if (__in.good())
      {
        if (__in.tie())
          {
            __in.tie()->flush();
          }
        if (!__noskip && (bool)(__in.flags() & ::std::ios_base::skipws))
          {
            const typename ::std::basic_istream<_CharT, _Traits>::sentry::__int_type __eof = traits_type::eof();
            typename ::std::basic_istream<_CharT, _Traits>::sentry::__streambuf_type *__sb = __in.rdbuf();
            typename ::std::basic_istream<_CharT, _Traits>::sentry::__int_type __c = __sb->sgetc();
            const typename ::std::basic_istream<_CharT, _Traits>::sentry::__ctype_type &__ct = __check_facet(__in._M_ctype);
            while (!traits_type::eq_int_type(__c, __eof) && __ct.is(::std::ctype_base::space, traits_type::to_char_type(__c)))
              {
                __c = __sb->snextc();
              }
            if (traits_type::eq_int_type(__c, __eof))
              {
                __err |= ::std::ios_base::eofbit;
              }
          }
      }
    if (__in.good() && __err == ::std::ios_base::goodbit)
      {
        _M_ok = true;
      }
    else
      {
        __err |= ::std::ios_base::failbit;
        __in.setstate(__err);
      }
  }
  template < typename _CharT, typename _Traits >
  template < typename _ValueT >
  typename ::std::basic_istream<_CharT, _Traits>::__istream_type &basic_istream<_CharT, _Traits>::_M_extract(_ValueT &__v)
  {
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, false);
    if (__cerb)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          const typename ::std::basic_istream<_CharT, _Traits>::__num_get_type &__ng = __check_facet(this->_M_num_get);
          __ng.get(*this, 0, *this, __err, __v);
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            this->setstate(__err);
          }
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::__istream_type &basic_istream<_CharT, _Traits>::operator >>(short int &__n)
  {
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, false);
    if (__cerb)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          long int __l;
          const typename ::std::basic_istream<_CharT, _Traits>::__num_get_type &__ng = __check_facet(this->_M_num_get);
          __ng.get(*this, 0, *this, __err, __l);
          if (__l < ::__gnu_cxx::__numeric_traits_integer<short int>::__min)
            {
              __err |= ::std::ios_base::failbit;
              __n = ::__gnu_cxx::__numeric_traits_integer<short int>::__min;
            }
          else
            {
              if (__l > ::__gnu_cxx::__numeric_traits_integer<short int>::__max)
                {
                  __err |= ::std::ios_base::failbit;
                  __n = ::__gnu_cxx::__numeric_traits_integer<short int>::__max;
                }
              else
                {
                  __n = (short int)__l;
                }
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            this->setstate(__err);
          }
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::__istream_type &basic_istream<_CharT, _Traits>::operator >>(int &__n)
  {
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, false);
    if (__cerb)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          long int __l;
          const typename ::std::basic_istream<_CharT, _Traits>::__num_get_type &__ng = __check_facet(this->_M_num_get);
          __ng.get(*this, 0, *this, __err, __l);
          if (__l < ::__gnu_cxx::__numeric_traits_integer<int>::__min)
            {
              __err |= ::std::ios_base::failbit;
              __n = ::__gnu_cxx::__numeric_traits_integer<int>::__min;
            }
          else
            {
              if (__l > ::__gnu_cxx::__numeric_traits_integer<int>::__max)
                {
                  __err |= ::std::ios_base::failbit;
                  __n = ::__gnu_cxx::__numeric_traits_integer<int>::__max;
                }
              else
                {
                  __n = (int)__l;
                }
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            this->setstate(__err);
          }
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::__istream_type &basic_istream<_CharT, _Traits>::operator >>(typename ::std::basic_istream<_CharT, _Traits>::__streambuf_type *__sbout)
  {
    ::std::ios_base::iostate __err(::std::ios_base::goodbit);
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, false);
    if (__cerb && __sbout)
      {
        try
        {
          bool __ineof;
          if (!__copy_streambufs_eof(this->rdbuf(), __sbout, __ineof))
            {
              __err |= ::std::ios_base::failbit;
            }
          if (__ineof)
            {
              __err |= ::std::ios_base::eofbit;
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::failbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::failbit);
        }
      }
    else
      {
        if (!__sbout)
          {
            __err |= ::std::ios_base::failbit;
          }
      }
    if (__err)
      {
        this->setstate(__err);
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::int_type basic_istream<_CharT, _Traits>::get()
  {
    const typename ::std::basic_istream<_CharT, _Traits>::int_type __eof = traits_type::eof();
    typename ::std::basic_istream<_CharT, _Traits>::int_type __c = __eof;
    _M_gcount = 0;
    ::std::ios_base::iostate __err(::std::ios_base::goodbit);
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb)
      {
        try
        {
          __c = this->rdbuf()->sbumpc();
          if (!traits_type::eq_int_type(__c, __eof))
            {
              _M_gcount = 1;
            }
          else
            {
              __err |= ::std::ios_base::eofbit;
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
      }
    if (!_M_gcount)
      {
        __err |= ::std::ios_base::failbit;
      }
    if (__err)
      {
        this->setstate(__err);
      }
    return __c;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::__istream_type &basic_istream<_CharT, _Traits>::get(typename ::std::basic_istream<_CharT, _Traits>::char_type &__c)
  {
    _M_gcount = 0;
    ::std::ios_base::iostate __err(::std::ios_base::goodbit);
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb)
      {
        try
        {
          const typename ::std::basic_istream<_CharT, _Traits>::int_type __cb = this->rdbuf()->sbumpc();
          if (!traits_type::eq_int_type(__cb, traits_type::eof()))
            {
              _M_gcount = 1;
              __c = traits_type::to_char_type(__cb);
            }
          else
            {
              __err |= ::std::ios_base::eofbit;
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
      }
    if (!_M_gcount)
      {
        __err |= ::std::ios_base::failbit;
      }
    if (__err)
      {
        this->setstate(__err);
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::__istream_type &basic_istream<_CharT, _Traits>::get(typename ::std::basic_istream<_CharT, _Traits>::char_type *__s, ::std::streamsize __n, typename ::std::basic_istream<_CharT, _Traits>::char_type __delim)
  {
    _M_gcount = 0;
    ::std::ios_base::iostate __err(::std::ios_base::goodbit);
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb)
      {
        try
        {
          const typename ::std::basic_istream<_CharT, _Traits>::int_type __idelim = traits_type::to_int_type(__delim);
          const typename ::std::basic_istream<_CharT, _Traits>::int_type __eof = traits_type::eof();
          typename ::std::basic_istream<_CharT, _Traits>::__streambuf_type *__sb = this->rdbuf();
          typename ::std::basic_istream<_CharT, _Traits>::int_type __c = __sb->sgetc();
          while ((_M_gcount + 1 < __n && !traits_type::eq_int_type(__c, __eof)) && !traits_type::eq_int_type(__c, __idelim))
            {
              *__s++ = traits_type::to_char_type(__c);
              ++_M_gcount;
              __c = __sb->snextc();
            }
          if (traits_type::eq_int_type(__c, __eof))
            {
              __err |= ::std::ios_base::eofbit;
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
      }
    if (__n > 0)
      {
        *__s = typename ::std::basic_istream<_CharT, _Traits>::char_type();
      }
    if (!_M_gcount)
      {
        __err |= ::std::ios_base::failbit;
      }
    if (__err)
      {
        this->setstate(__err);
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::__istream_type &basic_istream<_CharT, _Traits>::get(typename ::std::basic_istream<_CharT, _Traits>::__streambuf_type &__sb, typename ::std::basic_istream<_CharT, _Traits>::char_type __delim)
  {
    _M_gcount = 0;
    ::std::ios_base::iostate __err(::std::ios_base::goodbit);
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb)
      {
        try
        {
          const typename ::std::basic_istream<_CharT, _Traits>::int_type __idelim = traits_type::to_int_type(__delim);
          const typename ::std::basic_istream<_CharT, _Traits>::int_type __eof = traits_type::eof();
          typename ::std::basic_istream<_CharT, _Traits>::__streambuf_type *__this_sb = this->rdbuf();
          typename ::std::basic_istream<_CharT, _Traits>::int_type __c = __this_sb->sgetc();
          typename ::std::basic_istream<_CharT, _Traits>::char_type __c2 = traits_type::to_char_type(__c);
          while ((!traits_type::eq_int_type(__c, __eof) && !traits_type::eq_int_type(__c, __idelim)) && !traits_type::eq_int_type(__sb.sputc(__c2), __eof))
            {
              ++_M_gcount;
              __c = __this_sb->snextc();
              __c2 = traits_type::to_char_type(__c);
            }
          if (traits_type::eq_int_type(__c, __eof))
            {
              __err |= ::std::ios_base::eofbit;
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
      }
    if (!_M_gcount)
      {
        __err |= ::std::ios_base::failbit;
      }
    if (__err)
      {
        this->setstate(__err);
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::__istream_type &basic_istream<_CharT, _Traits>::getline(typename ::std::basic_istream<_CharT, _Traits>::char_type *__s, ::std::streamsize __n, typename ::std::basic_istream<_CharT, _Traits>::char_type __delim)
  {
    _M_gcount = 0;
    ::std::ios_base::iostate __err(::std::ios_base::goodbit);
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb)
      {
        try
        {
          const typename ::std::basic_istream<_CharT, _Traits>::int_type __idelim = traits_type::to_int_type(__delim);
          const typename ::std::basic_istream<_CharT, _Traits>::int_type __eof = traits_type::eof();
          typename ::std::basic_istream<_CharT, _Traits>::__streambuf_type *__sb = this->rdbuf();
          typename ::std::basic_istream<_CharT, _Traits>::int_type __c = __sb->sgetc();
          while ((_M_gcount + 1 < __n && !traits_type::eq_int_type(__c, __eof)) && !traits_type::eq_int_type(__c, __idelim))
            {
              *__s++ = traits_type::to_char_type(__c);
              __c = __sb->snextc();
              ++_M_gcount;
            }
          if (traits_type::eq_int_type(__c, __eof))
            {
              __err |= ::std::ios_base::eofbit;
            }
          else
            {
              if (traits_type::eq_int_type(__c, __idelim))
                {
                  __sb->sbumpc();
                  ++_M_gcount;
                }
              else
                {
                  __err |= ::std::ios_base::failbit;
                }
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
      }
    if (__n > 0)
      {
        *__s = typename ::std::basic_istream<_CharT, _Traits>::char_type();
      }
    if (!_M_gcount)
      {
        __err |= ::std::ios_base::failbit;
      }
    if (__err)
      {
        this->setstate(__err);
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::__istream_type &basic_istream<_CharT, _Traits>::ignore()
  {
    _M_gcount = 0;
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          const typename ::std::basic_istream<_CharT, _Traits>::int_type __eof = traits_type::eof();
          typename ::std::basic_istream<_CharT, _Traits>::__streambuf_type *__sb = this->rdbuf();
          if (traits_type::eq_int_type(__sb->sbumpc(), __eof))
            {
              __err |= ::std::ios_base::eofbit;
            }
          else
            {
              _M_gcount = 1;
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            this->setstate(__err);
          }
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::__istream_type &basic_istream<_CharT, _Traits>::ignore(::std::streamsize __n)
  {
    _M_gcount = 0;
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb && __n > 0)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          const typename ::std::basic_istream<_CharT, _Traits>::int_type __eof = traits_type::eof();
          typename ::std::basic_istream<_CharT, _Traits>::__streambuf_type *__sb = this->rdbuf();
          typename ::std::basic_istream<_CharT, _Traits>::int_type __c = __sb->sgetc();
          bool __large_ignore(false);
          while (true)
            {
              while (_M_gcount < __n && !traits_type::eq_int_type(__c, __eof))
                {
                  ++_M_gcount;
                  __c = __sb->snextc();
                }
              if (__n == ::__gnu_cxx::__numeric_traits_integer<long int>::__max && !traits_type::eq_int_type(__c, __eof))
                {
                  _M_gcount = ::__gnu_cxx::__numeric_traits_integer<long int>::__min;
                  __large_ignore = true;
                }
              else
                {
                  break;
                }
            }
          if (__large_ignore)
            {
              _M_gcount = ::__gnu_cxx::__numeric_traits_integer<long int>::__max;
            }
          if (traits_type::eq_int_type(__c, __eof))
            {
              __err |= ::std::ios_base::eofbit;
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            this->setstate(__err);
          }
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::__istream_type &basic_istream<_CharT, _Traits>::ignore(::std::streamsize __n, typename ::std::basic_istream<_CharT, _Traits>::int_type __delim)
  {
    _M_gcount = 0;
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb && __n > 0)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          const typename ::std::basic_istream<_CharT, _Traits>::int_type __eof = traits_type::eof();
          typename ::std::basic_istream<_CharT, _Traits>::__streambuf_type *__sb = this->rdbuf();
          typename ::std::basic_istream<_CharT, _Traits>::int_type __c = __sb->sgetc();
          bool __large_ignore(false);
          while (true)
            {
              while ((_M_gcount < __n && !traits_type::eq_int_type(__c, __eof)) && !traits_type::eq_int_type(__c, __delim))
                {
                  ++_M_gcount;
                  __c = __sb->snextc();
                }
              if ((__n == ::__gnu_cxx::__numeric_traits_integer<long int>::__max && !traits_type::eq_int_type(__c, __eof)) && !traits_type::eq_int_type(__c, __delim))
                {
                  _M_gcount = ::__gnu_cxx::__numeric_traits_integer<long int>::__min;
                  __large_ignore = true;
                }
              else
                {
                  break;
                }
            }
          if (__large_ignore)
            {
              _M_gcount = ::__gnu_cxx::__numeric_traits_integer<long int>::__max;
            }
          if (traits_type::eq_int_type(__c, __eof))
            {
              __err |= ::std::ios_base::eofbit;
            }
          else
            {
              if (traits_type::eq_int_type(__c, __delim))
                {
                  if (_M_gcount < ::__gnu_cxx::__numeric_traits_integer<long int>::__max)
                    {
                      ++_M_gcount;
                    }
                  __sb->sbumpc();
                }
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            this->setstate(__err);
          }
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::int_type basic_istream<_CharT, _Traits>::peek()
  {
    typename ::std::basic_istream<_CharT, _Traits>::int_type __c = traits_type::eof();
    _M_gcount = 0;
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          __c = this->rdbuf()->sgetc();
          if (traits_type::eq_int_type(__c, traits_type::eof()))
            {
              __err |= ::std::ios_base::eofbit;
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            this->setstate(__err);
          }
      }
    return __c;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::__istream_type &basic_istream<_CharT, _Traits>::read(typename ::std::basic_istream<_CharT, _Traits>::char_type *__s, ::std::streamsize __n)
  {
    _M_gcount = 0;
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          _M_gcount = this->rdbuf()->sgetn(__s, __n);
          if (_M_gcount != __n)
            {
              __err |= ::std::ios_base::eofbit | ::std::ios_base::failbit;
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            this->setstate(__err);
          }
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  ::std::streamsize basic_istream<_CharT, _Traits>::readsome(typename ::std::basic_istream<_CharT, _Traits>::char_type *__s, ::std::streamsize __n)
  {
    _M_gcount = 0;
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          const ::std::streamsize __num(this->rdbuf()->in_avail());
          if (__num > 0)
            {
              _M_gcount = this->rdbuf()->sgetn(__s, ::std::min /* <long int> */ (__num, __n));
            }
          else
            {
              if (__num ==  -1)
                {
                  __err |= ::std::ios_base::eofbit;
                }
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            this->setstate(__err);
          }
      }
    return _M_gcount;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::__istream_type &basic_istream<_CharT, _Traits>::putback(typename ::std::basic_istream<_CharT, _Traits>::char_type __c)
  {
    _M_gcount = 0;
    this->clear(this->rdstate() &  ~::std::ios_base::eofbit);
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          const typename ::std::basic_istream<_CharT, _Traits>::int_type __eof = traits_type::eof();
          typename ::std::basic_istream<_CharT, _Traits>::__streambuf_type *__sb = this->rdbuf();
          if (!__sb || traits_type::eq_int_type(__sb->sputbackc(__c), __eof))
            {
              __err |= ::std::ios_base::badbit;
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            this->setstate(__err);
          }
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::__istream_type &basic_istream<_CharT, _Traits>::unget()
  {
    _M_gcount = 0;
    this->clear(this->rdstate() &  ~::std::ios_base::eofbit);
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          const typename ::std::basic_istream<_CharT, _Traits>::int_type __eof = traits_type::eof();
          typename ::std::basic_istream<_CharT, _Traits>::__streambuf_type *__sb = this->rdbuf();
          if (!__sb || traits_type::eq_int_type(__sb->sungetc(), __eof))
            {
              __err |= ::std::ios_base::badbit;
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            this->setstate(__err);
          }
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  int basic_istream<_CharT, _Traits>::sync()
  {
    int __ret( -1);
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          typename ::std::basic_istream<_CharT, _Traits>::__streambuf_type *__sb = this->rdbuf();
          if (__sb)
            {
              if (__sb->pubsync() ==  -1)
                {
                  __err |= ::std::ios_base::badbit;
                }
              else
                {
                  __ret = 0;
                }
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            this->setstate(__err);
          }
      }
    return __ret;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::pos_type basic_istream<_CharT, _Traits>::tellg()
  {
    typename ::std::basic_istream<_CharT, _Traits>::pos_type __ret = typename ::std::basic_istream<_CharT, _Traits>::pos_type( -1);
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb)
      {
        try
        {
          if (!this->fail())
            {
              __ret = this->rdbuf()->pubseekoff(0, ::std::ios_base::cur, ::std::ios_base::in);
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
      }
    return __ret;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::__istream_type &basic_istream<_CharT, _Traits>::seekg(typename ::std::basic_istream<_CharT, _Traits>::pos_type __pos)
  {
    this->clear(this->rdstate() &  ~::std::ios_base::eofbit);
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          if (!this->fail())
            {
              const typename ::std::basic_istream<_CharT, _Traits>::pos_type __p = this->rdbuf()->pubseekpos(__pos, ::std::ios_base::in);
              if (__p == pos_type(typename ::std::basic_istream<_CharT, _Traits>::off_type( -1)))
                {
                  __err |= ::std::ios_base::failbit;
                }
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            this->setstate(__err);
          }
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::__istream_type &basic_istream<_CharT, _Traits>::seekg(typename ::std::basic_istream<_CharT, _Traits>::off_type __off, ::std::ios_base::seekdir __dir)
  {
    this->clear(this->rdstate() &  ~::std::ios_base::eofbit);
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          if (!this->fail())
            {
              const typename ::std::basic_istream<_CharT, _Traits>::pos_type __p = this->rdbuf()->pubseekoff(__off, __dir, ::std::ios_base::in);
              if (__p == pos_type(typename ::std::basic_istream<_CharT, _Traits>::off_type( -1)))
                {
                  __err |= ::std::ios_base::failbit;
                }
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            this->setstate(__err);
          }
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__in, _CharT &__c)
  {
    typedef ::std::basic_istream<_CharT, _Traits> __istream_type;
    typedef typename ::std::basic_istream<_CharT, _Traits>::int_type __int_type;
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(__in, false);
    if (__cerb)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          const __int_type __cb = __in.rdbuf()->sbumpc();
          if (!_Traits::eq_int_type(__cb, _Traits::eof()))
            {
              __c = _Traits::to_char_type(__cb);
            }
          else
            {
              __err |= ::std::ios_base::eofbit | ::std::ios_base::failbit;
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          __in._M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          __in._M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            __in.setstate(__err);
          }
      }
    return __in;
  }
  template < typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__in, _CharT *__s)
  {
    typedef ::std::basic_istream<_CharT, _Traits> __istream_type;
    typedef ::std::basic_streambuf<_CharT, _Traits> __streambuf_type;
    typedef typename _Traits::int_type int_type;
    typedef _CharT char_type;
    typedef ::std::ctype<_CharT> __ctype_type;
    ::std::streamsize __extracted(0);
    ::std::ios_base::iostate __err(::std::ios_base::goodbit);
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(__in, false);
    if (__cerb)
      {
        try
        {
          ::std::streamsize __num(__in.width());
          if (__num <= 0)
            {
              __num = ::__gnu_cxx::__numeric_traits_integer<long int>::__max;
            }
          const __ctype_type &__ct = use_facet<__ctype_type>(__in.getloc());
          const int_type __eof = _Traits::eof();
          __streambuf_type *__sb = __in.rdbuf();
          int_type __c = __sb->sgetc();
          while ((__extracted < __num - 1 && !_Traits::eq_int_type(__c, __eof)) && !__ct.is(::std::ctype_base::space, _Traits::to_char_type(__c)))
            {
              *__s++ = _Traits::to_char_type(__c);
              ++__extracted;
              __c = __sb->snextc();
            }
          if (_Traits::eq_int_type(__c, __eof))
            {
              __err |= ::std::ios_base::eofbit;
            }
          *__s = char_type();
          __in.width(0);
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          __in._M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          __in._M_setstate(::std::ios_base::badbit);
        }
      }
    if (!__extracted)
      {
        __err |= ::std::ios_base::failbit;
      }
    if (__err)
      {
        __in.setstate(__err);
      }
    return __in;
  }
  template < typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &ws(::std::basic_istream<_CharT, _Traits> &__in)
  {
    typedef ::std::basic_istream<_CharT, _Traits> __istream_type;
    typedef ::std::basic_streambuf<_CharT, _Traits> __streambuf_type;
    typedef typename ::std::basic_istream<_CharT, _Traits>::int_type __int_type;
    typedef ::std::ctype<_CharT> __ctype_type;
    const __ctype_type &__ct = use_facet<__ctype_type>(__in.getloc());
    const __int_type __eof = _Traits::eof();
    __streambuf_type *__sb = __in.rdbuf();
    __int_type __c = __sb->sgetc();
    while (!_Traits::eq_int_type(__c, __eof) && __ct.is(::std::ctype_base::space, _Traits::to_char_type(__c)))
      {
        __c = __sb->snextc();
      }
    if (_Traits::eq_int_type(__c, __eof))
      {
        __in.setstate(::std::ios_base::eofbit);
      }
    return __in;
  }
extern template class ::std::basic_istream<char, ::std::char_traits<char> >;
extern template ::std::basic_istream<char, ::std::char_traits<char> > &ws(::std::basic_istream<char, ::std::char_traits<char> > &);
extern template ::std::basic_istream<char, ::std::char_traits<char> > &operator >>(::std::basic_istream<char, ::std::char_traits<char> > &, char &);
extern template ::std::basic_istream<char, ::std::char_traits<char> > &operator >>(::std::basic_istream<char, ::std::char_traits<char> > &, char *);
extern template ::std::basic_istream<char, ::std::char_traits<char> > &operator >>(::std::basic_istream<char, ::std::char_traits<char> > &, unsigned char &);
extern template ::std::basic_istream<char, ::std::char_traits<char> > &operator >>(::std::basic_istream<char, ::std::char_traits<char> > &, signed char &);
extern template ::std::basic_istream<char, ::std::char_traits<char> > &operator >>(::std::basic_istream<char, ::std::char_traits<char> > &, unsigned char *);
extern template ::std::basic_istream<char, ::std::char_traits<char> > &operator >>(::std::basic_istream<char, ::std::char_traits<char> > &, signed char *);
extern template ::std::basic_istream<char, ::std::char_traits<char> > &istream::_M_extract(unsigned short int &);
extern template ::std::basic_istream<char, ::std::char_traits<char> > &istream::_M_extract(unsigned int &);
extern template ::std::basic_istream<char, ::std::char_traits<char> > &istream::_M_extract(long int &);
extern template ::std::basic_istream<char, ::std::char_traits<char> > &istream::_M_extract(unsigned long int &);
extern template ::std::basic_istream<char, ::std::char_traits<char> > &istream::_M_extract(bool &);
extern template ::std::basic_istream<char, ::std::char_traits<char> > &istream::_M_extract(long long int &);
extern template ::std::basic_istream<char, ::std::char_traits<char> > &istream::_M_extract(unsigned long long int &);
extern template ::std::basic_istream<char, ::std::char_traits<char> > &istream::_M_extract(float &);
extern template ::std::basic_istream<char, ::std::char_traits<char> > &istream::_M_extract(double &);
extern template ::std::basic_istream<char, ::std::char_traits<char> > &istream::_M_extract(long double &);
extern template ::std::basic_istream<char, ::std::char_traits<char> > &istream::_M_extract(void *&);
extern template class ::std::basic_iostream<char, ::std::char_traits<char> >;
extern template class ::std::basic_istream<wchar_t, ::std::char_traits<wchar_t> >;
extern template ::std::basic_istream<wchar_t, ::std::char_traits<wchar_t> > &ws(::std::basic_istream<wchar_t, ::std::char_traits<wchar_t> > &);
extern template ::std::basic_istream<wchar_t, ::std::char_traits<wchar_t> > &operator >>(::std::basic_istream<wchar_t, ::std::char_traits<wchar_t> > &, wchar_t &);
extern template ::std::basic_istream<wchar_t, ::std::char_traits<wchar_t> > &operator >>(::std::basic_istream<wchar_t, ::std::char_traits<wchar_t> > &, wchar_t *);
extern template ::std::basic_istream<wchar_t, ::std::char_traits<wchar_t> > &wistream::_M_extract(unsigned short int &);
extern template ::std::basic_istream<wchar_t, ::std::char_traits<wchar_t> > &wistream::_M_extract(unsigned int &);
extern template ::std::basic_istream<wchar_t, ::std::char_traits<wchar_t> > &wistream::_M_extract(long int &);
extern template ::std::basic_istream<wchar_t, ::std::char_traits<wchar_t> > &wistream::_M_extract(unsigned long int &);
extern template ::std::basic_istream<wchar_t, ::std::char_traits<wchar_t> > &wistream::_M_extract(bool &);
extern template ::std::basic_istream<wchar_t, ::std::char_traits<wchar_t> > &wistream::_M_extract(long long int &);
extern template ::std::basic_istream<wchar_t, ::std::char_traits<wchar_t> > &wistream::_M_extract(unsigned long long int &);
extern template ::std::basic_istream<wchar_t, ::std::char_traits<wchar_t> > &wistream::_M_extract(float &);
extern template ::std::basic_istream<wchar_t, ::std::char_traits<wchar_t> > &wistream::_M_extract(double &);
extern template ::std::basic_istream<wchar_t, ::std::char_traits<wchar_t> > &wistream::_M_extract(long double &);
extern template ::std::basic_istream<wchar_t, ::std::char_traits<wchar_t> > &wistream::_M_extract(void *&);
extern template class ::std::basic_iostream<wchar_t, ::std::char_traits<wchar_t> >;
  extern ::std::istream cin;
  extern ::std::ostream cout;
  extern ::std::ostream cerr;
  extern ::std::ostream clog;
  extern ::std::wistream wcin;
  extern ::std::wostream wcout;
  extern ::std::wostream wcerr;
  extern ::std::wostream wclog;
  static ::std::ios_base::Init __ioinit;
  namespace rel_ops {
    template < typename _Tp >
    inline bool operator !=(const _Tp &__x, const _Tp &__y);
    template < typename _Tp >
    inline bool operator !=(const _Tp &__x, const _Tp &__y)
    {
      return !(__x == __y);
    }
    template < typename _Tp >
    inline bool operator >(const _Tp &__x, const _Tp &__y);
    template < typename _Tp >
    inline bool operator >(const _Tp &__x, const _Tp &__y)
    {
      return __y < __x;
    }
    template < typename _Tp >
    inline bool operator <=(const _Tp &__x, const _Tp &__y);
    template < typename _Tp >
    inline bool operator <=(const _Tp &__x, const _Tp &__y)
    {
      return !(__y < __x);
    }
    template < typename _Tp >
    inline bool operator >=(const _Tp &__x, const _Tp &__y);
    template < typename _Tp >
    inline bool operator >=(const _Tp &__x, const _Tp &__y)
    {
      return !(__x < __y);
    }
  }
  using ::div_t;
  using ::ldiv_t;
  using ::abort;
  using ::abs;
  using ::atexit;
  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;
  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;
  using ::qsort;
  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;
  using ::wcstombs;
  using ::wctomb;
  inline long int abs(long int __i)
  {
    return ::std::labs(__i);
  }
  inline ::ldiv_t div(long int __i, long int __j)
  {
    return ::std::ldiv(__i, __j);
  }
}
namespace __gnu_cxx __attribute__((__visibility__("default"))) {
  using ::lldiv_t;
  using ::_Exit;
  inline long long int abs(long long int __x)
  {
    return __x >= 0 ? __x :  -__x;
  }
  using ::llabs;
  inline ::lldiv_t div(long long int __n, long long int __d)
  {
    ::lldiv_t __q;
    __q.quot = __n / __d;
    __q.rem = __n % __d;
    return __q;
  }
  using ::lldiv;
  using ::atoll;
  using ::strtoll;
  using ::strtoull;
  using ::strtof;
  using ::strtold;
}
namespace std __attribute__((__visibility__("default"))) {
  using ::__gnu_cxx::lldiv_t;
  using ::__gnu_cxx::_Exit;
  using ::__gnu_cxx::abs;
  using ::__gnu_cxx::llabs;
  using ::__gnu_cxx::div;
  using ::__gnu_cxx::lldiv;
  using ::__gnu_cxx::atoll;
  using ::__gnu_cxx::strtof;
  using ::__gnu_cxx::strtoll;
  using ::__gnu_cxx::strtoull;
  using ::__gnu_cxx::strtold;
  template < typename _FIter, typename _Tp >
  bool binary_search(_FIter __first, _FIter __last, const _Tp &__val);
  template < typename _FIter, typename _Tp, typename _Compare >
  bool binary_search(_FIter __first, _FIter __last, const _Tp &__val, _Compare __comp);
  template < typename _FIter, typename _Tp >
  ::std::pair<_FIter, _FIter> equal_range(_FIter __first, _FIter __last, const _Tp &__val);
  template < typename _FIter, typename _Tp, typename _Compare >
  ::std::pair<_FIter, _FIter> equal_range(_FIter __first, _FIter __last, const _Tp &__val, _Compare __comp);
  template < typename _FIter1, typename _FIter2 >
  inline _FIter1 find_end(_FIter1 __first1, _FIter1 __last1, _FIter2 __first2, _FIter2 __last2);
  template < typename _FIter1, typename _FIter2, typename _BinaryPredicate >
  inline _FIter1 find_end(_FIter1 __first1, _FIter1 __last1, _FIter2 __first2, _FIter2 __last2, _BinaryPredicate __comp);
  template < typename _IIter1, typename _IIter2 >
  bool includes(_IIter1 __first1, _IIter1 __last1, _IIter2 __first2, _IIter2 __last2);
  template < typename _IIter1, typename _IIter2, typename _Compare >
  bool includes(_IIter1 __first1, _IIter1 __last1, _IIter2 __first2, _IIter2 __last2, _Compare __comp);
  template < typename _BIter >
  void inplace_merge(_BIter __first, _BIter __middle, _BIter __last);
  template < typename _BIter, typename _Compare >
  void inplace_merge(_BIter __first, _BIter __middle, _BIter __last, _Compare __comp);
  template < typename _FIter, typename _Tp, typename _Compare >
  _FIter lower_bound(_FIter __first, _FIter __last, const _Tp &__val, _Compare __comp);
  template < typename _RAIter >
  void make_heap(_RAIter __first, _RAIter __last);
  template < typename _RAIter, typename _Compare >
  void make_heap(_RAIter __first, _RAIter __last, _Compare __comp);
  template < typename _BIter >
  bool next_permutation(_BIter __first, _BIter __last);
  template < typename _BIter, typename _Compare >
  bool next_permutation(_BIter __first, _BIter __last, _Compare __comp);
  template < typename _IIter, typename _RAIter >
  _RAIter partial_sort_copy(_IIter __first, _IIter __last, _RAIter __result_first, _RAIter __result_last);
  template < typename _IIter, typename _RAIter, typename _Compare >
  _RAIter partial_sort_copy(_IIter __first, _IIter __last, _RAIter __result_first, _RAIter __result_last, _Compare __comp);
  template < typename _RAIter >
  inline void pop_heap(_RAIter __first, _RAIter __last);
  template < typename _RAIter, typename _Compare >
  inline void pop_heap(_RAIter __first, _RAIter __last, _Compare __comp);
  template < typename _BIter >
  bool prev_permutation(_BIter __first, _BIter __last);
  template < typename _BIter, typename _Compare >
  bool prev_permutation(_BIter __first, _BIter __last, _Compare __comp);
  template < typename _RAIter >
  inline void push_heap(_RAIter __first, _RAIter __last);
  template < typename _RAIter, typename _Compare >
  inline void push_heap(_RAIter __first, _RAIter __last, _Compare __comp);
  template < typename _FIter, typename _Tp >
  _FIter remove(_FIter __first, _FIter __last, const _Tp &__value);
  template < typename _FIter, typename _Predicate >
  _FIter remove_if(_FIter __first, _FIter __last, _Predicate __pred);
  template < typename _IIter, typename _OIter, typename _Tp >
  _OIter remove_copy(_IIter __first, _IIter __last, _OIter __result, const _Tp &__value);
  template < typename _IIter, typename _OIter, typename _Predicate >
  _OIter remove_copy_if(_IIter __first, _IIter __last, _OIter __result, _Predicate __pred);
  template < typename _IIter, typename _OIter, typename _Tp >
  _OIter replace_copy(_IIter __first, _IIter __last, _OIter __result, const _Tp &__old_value, const _Tp &__new_value);
  template < typename _Iter, typename _OIter, typename _Predicate, typename _Tp >
  _OIter replace_copy_if(_Iter __first, _Iter __last, _OIter __result, _Predicate __pred, const _Tp &__new_value);
  template < typename _BIter >
  inline void reverse(_BIter __first, _BIter __last);
  template < typename _BIter, typename _OIter >
  _OIter reverse_copy(_BIter __first, _BIter __last, _OIter __result);
  template < typename _FIter >
  inline void rotate(_FIter __first, _FIter __middle, _FIter __last);
  template < typename _FIter, typename _OIter >
  _OIter rotate_copy(_FIter __first, _FIter __middle, _FIter __last, _OIter __result);
  template < typename _RAIter >
  void sort_heap(_RAIter __first, _RAIter __last);
  template < typename _RAIter, typename _Compare >
  void sort_heap(_RAIter __first, _RAIter __last, _Compare __comp);
  template < typename _BIter, typename _Predicate >
  _BIter stable_partition(_BIter __first, _BIter __last, _Predicate __pred);
  template < typename _FIter >
  _FIter unique(_FIter __first, _FIter __last);
  template < typename _FIter, typename _BinaryPredicate >
  _FIter unique(_FIter __first, _FIter __last, _BinaryPredicate __binary_pred);
  template < typename _FIter, typename _Tp >
  _FIter upper_bound(_FIter __first, _FIter __last, const _Tp &__val);
  template < typename _FIter, typename _Tp, typename _Compare >
  _FIter upper_bound(_FIter __first, _FIter __last, const _Tp &__val, _Compare __comp);
  template < typename _FIter >
  _FIter adjacent_find(_FIter __first, _FIter __last);
  template < typename _FIter, typename _BinaryPredicate >
  _FIter adjacent_find(_FIter __first, _FIter __last, _BinaryPredicate __binary_pred);
  template < typename _IIter, typename _Tp >
  typename ::std::iterator_traits<_IIter>::difference_type count(_IIter __first, _IIter __last, const _Tp &__value);
  template < typename _IIter, typename _Predicate >
  typename ::std::iterator_traits<_IIter>::difference_type count_if(_IIter __first, _IIter __last, _Predicate __pred);
  template < typename _IIter, typename _Tp >
  inline _IIter find(_IIter __first, _IIter __last, const _Tp &__val);
  template < typename _FIter1, typename _FIter2 >
  _FIter1 find_first_of(_FIter1 __first1, _FIter1 __last1, _FIter2 __first2, _FIter2 __last2);
  template < typename _FIter1, typename _FIter2, typename _BinaryPredicate >
  _FIter1 find_first_of(_FIter1 __first1, _FIter1 __last1, _FIter2 __first2, _FIter2 __last2, _BinaryPredicate __comp);
  template < typename _IIter, typename _Predicate >
  inline _IIter find_if(_IIter __first, _IIter __last, _Predicate __pred);
  template < typename _IIter, typename _Funct >
  _Funct for_each(_IIter __first, _IIter __last, _Funct __f);
  template < typename _FIter, typename _Generator >
  void generate(_FIter __first, _FIter __last, _Generator __gen);
  template < typename _OIter, typename _Size, typename _Generator >
  _OIter generate_n(_OIter __first, _Size __n, _Generator __gen);
  template < typename _FIter >
  _FIter max_element(_FIter __first, _FIter __last);
  template < typename _FIter, typename _Compare >
  _FIter max_element(_FIter __first, _FIter __last, _Compare __comp);
  template < typename _IIter1, typename _IIter2, typename _OIter >
  _OIter merge(_IIter1 __first1, _IIter1 __last1, _IIter2 __first2, _IIter2 __last2, _OIter __result);
  template < typename _IIter1, typename _IIter2, typename _OIter, typename _Compare >
  _OIter merge(_IIter1 __first1, _IIter1 __last1, _IIter2 __first2, _IIter2 __last2, _OIter __result, _Compare __comp);
  template < typename _FIter >
  _FIter min_element(_FIter __first, _FIter __last);
  template < typename _FIter, typename _Compare >
  _FIter min_element(_FIter __first, _FIter __last, _Compare __comp);
  template < typename _RAIter >
  inline void nth_element(_RAIter __first, _RAIter __nth, _RAIter __last);
  template < typename _RAIter, typename _Compare >
  inline void nth_element(_RAIter __first, _RAIter __nth, _RAIter __last, _Compare __comp);
  template < typename _RAIter >
  inline void partial_sort(_RAIter __first, _RAIter __middle, _RAIter __last);
  template < typename _RAIter, typename _Compare >
  inline void partial_sort(_RAIter __first, _RAIter __middle, _RAIter __last, _Compare __comp);
  template < typename _BIter, typename _Predicate >
  inline _BIter partition(_BIter __first, _BIter __last, _Predicate __pred);
  template < typename _RAIter >
  inline void random_shuffle(_RAIter __first, _RAIter __last);
  template < typename _RAIter, typename _Generator >
  void random_shuffle(_RAIter __first, _RAIter __last, _Generator &__rand);
  template < typename _FIter, typename _Tp >
  void replace(_FIter __first, _FIter __last, const _Tp &__old_value, const _Tp &__new_value);
  template < typename _FIter, typename _Predicate, typename _Tp >
  void replace_if(_FIter __first, _FIter __last, _Predicate __pred, const _Tp &__new_value);
  template < typename _FIter1, typename _FIter2 >
  _FIter1 search(_FIter1 __first1, _FIter1 __last1, _FIter2 __first2, _FIter2 __last2);
  template < typename _FIter1, typename _FIter2, typename _BinaryPredicate >
  _FIter1 search(_FIter1 __first1, _FIter1 __last1, _FIter2 __first2, _FIter2 __last2, _BinaryPredicate __predicate);
  template < typename _FIter, typename _Size, typename _Tp >
  _FIter search_n(_FIter __first, _FIter __last, _Size __count, const _Tp &__val);
  template < typename _FIter, typename _Size, typename _Tp, typename _BinaryPredicate >
  _FIter search_n(_FIter __first, _FIter __last, _Size __count, const _Tp &__val, _BinaryPredicate __binary_pred);
  template < typename _IIter1, typename _IIter2, typename _OIter >
  _OIter set_difference(_IIter1 __first1, _IIter1 __last1, _IIter2 __first2, _IIter2 __last2, _OIter __result);
  template < typename _IIter1, typename _IIter2, typename _OIter, typename _Compare >
  _OIter set_difference(_IIter1 __first1, _IIter1 __last1, _IIter2 __first2, _IIter2 __last2, _OIter __result, _Compare __comp);
  template < typename _IIter1, typename _IIter2, typename _OIter >
  _OIter set_intersection(_IIter1 __first1, _IIter1 __last1, _IIter2 __first2, _IIter2 __last2, _OIter __result);
  template < typename _IIter1, typename _IIter2, typename _OIter, typename _Compare >
  _OIter set_intersection(_IIter1 __first1, _IIter1 __last1, _IIter2 __first2, _IIter2 __last2, _OIter __result, _Compare __comp);
  template < typename _IIter1, typename _IIter2, typename _OIter >
  _OIter set_symmetric_difference(_IIter1 __first1, _IIter1 __last1, _IIter2 __first2, _IIter2 __last2, _OIter __result);
  template < typename _IIter1, typename _IIter2, typename _OIter, typename _Compare >
  _OIter set_symmetric_difference(_IIter1 __first1, _IIter1 __last1, _IIter2 __first2, _IIter2 __last2, _OIter __result, _Compare __comp);
  template < typename _IIter1, typename _IIter2, typename _OIter >
  _OIter set_union(_IIter1 __first1, _IIter1 __last1, _IIter2 __first2, _IIter2 __last2, _OIter __result);
  template < typename _IIter1, typename _IIter2, typename _OIter, typename _Compare >
  _OIter set_union(_IIter1 __first1, _IIter1 __last1, _IIter2 __first2, _IIter2 __last2, _OIter __result, _Compare __comp);
  template < typename _RAIter >
  inline void sort(_RAIter __first, _RAIter __last);
  template < typename _RAIter, typename _Compare >
  inline void sort(_RAIter __first, _RAIter __last, _Compare __comp);
  template < typename _RAIter >
  inline void stable_sort(_RAIter __first, _RAIter __last);
  template < typename _RAIter, typename _Compare >
  inline void stable_sort(_RAIter __first, _RAIter __last, _Compare __comp);
  template < typename _IIter, typename _OIter, typename _UnaryOperation >
  _OIter transform(_IIter __first, _IIter __last, _OIter __result, _UnaryOperation __unary_op);
  template < typename _IIter1, typename _IIter2, typename _OIter, typename _BinaryOperation >
  _OIter transform(_IIter1 __first1, _IIter1 __last1, _IIter2 __first2, _OIter __result, _BinaryOperation __binary_op);
  template < typename _IIter, typename _OIter >
  inline _OIter unique_copy(_IIter __first, _IIter __last, _OIter __result);
  template < typename _IIter, typename _OIter, typename _BinaryPredicate >
  inline _OIter unique_copy(_IIter __first, _IIter __last, _OIter __result, _BinaryPredicate __binary_pred);
  template < typename _RandomAccessIterator, typename _Distance >
  _Distance __is_heap_until(_RandomAccessIterator __first, _Distance __n);
  template < typename _RandomAccessIterator, typename _Distance >
  _Distance __is_heap_until(_RandomAccessIterator __first, _Distance __n)
  {
    _Distance __parent = 0;
    for (_Distance __child = 1; __child < __n; ++__child)
      {
        if (__first[__parent] < __first[__child])
          {
            return __child;
          }
        if ((__child & 1) == 0)
          {
            ++__parent;
          }
      }
    return __n;
  }
  template < typename _RandomAccessIterator, typename _Distance, typename _Compare >
  _Distance __is_heap_until(_RandomAccessIterator __first, _Distance __n, _Compare __comp);
  template < typename _RandomAccessIterator, typename _Distance, typename _Compare >
  _Distance __is_heap_until(_RandomAccessIterator __first, _Distance __n, _Compare __comp)
  {
    _Distance __parent = 0;
    for (_Distance __child = 1; __child < __n; ++__child)
      {
        if (__comp(__first[__parent], __first[__child]))
          {
            return __child;
          }
        if ((__child & 1) == 0)
          {
            ++__parent;
          }
      }
    return __n;
  }
  template < typename _RandomAccessIterator, typename _Distance >
  inline bool __is_heap(_RandomAccessIterator __first, _Distance __n);
  template < typename _RandomAccessIterator, typename _Distance >
  inline bool __is_heap(_RandomAccessIterator __first, _Distance __n)
  {
    return std::__is_heap_until(__first, __n) == __n;
  }
  template < typename _RandomAccessIterator, typename _Compare, typename _Distance >
  inline bool __is_heap(_RandomAccessIterator __first, _Compare __comp, _Distance __n);
  template < typename _RandomAccessIterator, typename _Compare, typename _Distance >
  inline bool __is_heap(_RandomAccessIterator __first, _Compare __comp, _Distance __n)
  {
    return std::__is_heap_until(__first, __n, __comp) == __n;
  }
  template < typename _RandomAccessIterator >
  inline bool __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last);
  template < typename _RandomAccessIterator >
  inline bool __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
  {
    return std::__is_heap(__first, std::distance(__first, __last));
  }
  template < typename _RandomAccessIterator, typename _Compare >
  inline bool __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp);
  template < typename _RandomAccessIterator, typename _Compare >
  inline bool __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
  {
    return std::__is_heap(__first, __comp, std::distance(__first, __last));
  }
  template < typename _RandomAccessIterator, typename _Distance, typename _Tp >
  void __push_heap(_RandomAccessIterator __first, _Distance __holeIndex, _Distance __topIndex, _Tp __value);
  template < typename _RandomAccessIterator, typename _Distance, typename _Tp >
  void __push_heap(_RandomAccessIterator __first, _Distance __holeIndex, _Distance __topIndex, _Tp __value)
  {
    _Distance __parent = (__holeIndex - 1) / 2;
    while (__holeIndex > __topIndex && *(__first + __parent) < __value)
      {
        *(__first + __holeIndex) = *(__first + __parent);
        __holeIndex = __parent;
        __parent = (__holeIndex - 1) / 2;
      }
    *(__first + __holeIndex) = __value;
  }
  template < typename _RandomAccessIterator >
  inline void push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
  {
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::value_type _ValueType;
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::difference_type _DistanceType;
    ;
    ;
    _ValueType __value = *(__last - 1);
    std::__push_heap(__first, _DistanceType(__last - __first - 1), _DistanceType(0), __value);
  }
  template < typename _RandomAccessIterator, typename _Distance, typename _Tp, typename _Compare >
  void __push_heap(_RandomAccessIterator __first, _Distance __holeIndex, _Distance __topIndex, _Tp __value, _Compare __comp);
  template < typename _RandomAccessIterator, typename _Distance, typename _Tp, typename _Compare >
  void __push_heap(_RandomAccessIterator __first, _Distance __holeIndex, _Distance __topIndex, _Tp __value, _Compare __comp)
  {
    _Distance __parent = (__holeIndex - 1) / 2;
    while (__holeIndex > __topIndex && __comp(*(__first + __parent), __value))
      {
        *(__first + __holeIndex) = *(__first + __parent);
        __holeIndex = __parent;
        __parent = (__holeIndex - 1) / 2;
      }
    *(__first + __holeIndex) = __value;
  }
  template < typename _RandomAccessIterator, typename _Compare >
  inline void push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
  {
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::value_type _ValueType;
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::difference_type _DistanceType;
    ;
    ;
    _ValueType __value = *(__last - 1);
    std::__push_heap(__first, _DistanceType(__last - __first - 1), _DistanceType(0), __value, __comp);
  }
  template < typename _RandomAccessIterator, typename _Distance, typename _Tp >
  void __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex, _Distance __len, _Tp __value);
  template < typename _RandomAccessIterator, typename _Distance, typename _Tp >
  void __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex, _Distance __len, _Tp __value)
  {
    const _Distance __topIndex = __holeIndex;
    _Distance __secondChild = __holeIndex;
    while (__secondChild < (__len - 1) / 2)
      {
        __secondChild = 2 * (__secondChild + 1);
        if (*(__first + __secondChild) < *(__first + (__secondChild - 1)))
          {
            __secondChild--;
          }
        *(__first + __holeIndex) = *(__first + __secondChild);
        __holeIndex = __secondChild;
      }
    if ((__len & 1) == 0 && __secondChild == (__len - 2) / 2)
      {
        __secondChild = 2 * (__secondChild + 1);
        *(__first + __holeIndex) = *(__first + (__secondChild - 1));
        __holeIndex = __secondChild - 1;
      }
    std::__push_heap(__first, __holeIndex, __topIndex, __value);
  }
  template < typename _RandomAccessIterator >
  inline void __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _RandomAccessIterator __result);
  template < typename _RandomAccessIterator >
  inline void __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _RandomAccessIterator __result)
  {
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::value_type _ValueType;
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::difference_type _DistanceType;
    _ValueType __value = *__result;
    *__result = *__first;
    std::__adjust_heap(__first, _DistanceType(0), _DistanceType(__last - __first), __value);
  }
  template < typename _RandomAccessIterator >
  inline void pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
  {
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::value_type _ValueType;
    ;
    ;
    ;
    --__last;
    std::__pop_heap(__first, __last, __last);
  }
  template < typename _RandomAccessIterator, typename _Distance, typename _Tp, typename _Compare >
  void __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex, _Distance __len, _Tp __value, _Compare __comp);
  template < typename _RandomAccessIterator, typename _Distance, typename _Tp, typename _Compare >
  void __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex, _Distance __len, _Tp __value, _Compare __comp)
  {
    const _Distance __topIndex = __holeIndex;
    _Distance __secondChild = __holeIndex;
    while (__secondChild < (__len - 1) / 2)
      {
        __secondChild = 2 * (__secondChild + 1);
        if (__comp(*(__first + __secondChild), *(__first + (__secondChild - 1))))
          {
            __secondChild--;
          }
        *(__first + __holeIndex) = *(__first + __secondChild);
        __holeIndex = __secondChild;
      }
    if ((__len & 1) == 0 && __secondChild == (__len - 2) / 2)
      {
        __secondChild = 2 * (__secondChild + 1);
        *(__first + __holeIndex) = *(__first + (__secondChild - 1));
        __holeIndex = __secondChild - 1;
      }
    std::__push_heap(__first, __holeIndex, __topIndex, __value, __comp);
  }
  template < typename _RandomAccessIterator, typename _Compare >
  inline void __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _RandomAccessIterator __result, _Compare __comp);
  template < typename _RandomAccessIterator, typename _Compare >
  inline void __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _RandomAccessIterator __result, _Compare __comp)
  {
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::value_type _ValueType;
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::difference_type _DistanceType;
    _ValueType __value = *__result;
    *__result = *__first;
    std::__adjust_heap(__first, _DistanceType(0), _DistanceType(__last - __first), __value, __comp);
  }
  template < typename _RandomAccessIterator, typename _Compare >
  inline void pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
  {
    ;
    ;
    ;
    --__last;
    std::__pop_heap(__first, __last, __last, __comp);
  }
  template < typename _RandomAccessIterator >
  void make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
  {
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::value_type _ValueType;
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::difference_type _DistanceType;
    ;
    if (__last - __first < 2)
      {
        return ;
      }
    const _DistanceType __len = __last - __first;
    _DistanceType __parent = (__len - 2) / 2;
    while (true)
      {
        _ValueType __value = *(__first + __parent);
        std::__adjust_heap(__first, __parent, __len, __value);
        if (__parent == 0)
          {
            return ;
          }
        __parent--;
      }
  }
  template < typename _RandomAccessIterator, typename _Compare >
  void make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
  {
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::value_type _ValueType;
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::difference_type _DistanceType;
    ;
    if (__last - __first < 2)
      {
        return ;
      }
    const _DistanceType __len = __last - __first;
    _DistanceType __parent = (__len - 2) / 2;
    while (true)
      {
        _ValueType __value = *(__first + __parent);
        std::__adjust_heap(__first, __parent, __len, __value, __comp);
        if (__parent == 0)
          {
            return ;
          }
        __parent--;
      }
  }
  template < typename _RandomAccessIterator >
  void sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
  {
    ;
    ;
    while (__last - __first > 1)
      {
        --__last;
        std::__pop_heap(__first, __last, __last);
      }
  }
  template < typename _RandomAccessIterator, typename _Compare >
  void sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
  {
    ;
    ;
    while (__last - __first > 1)
      {
        --__last;
        std::__pop_heap(__first, __last, __last, __comp);
      }
  }
  template < typename __type_tpl__param_1_0__ >
  class allocator;
}
namespace __gnu_cxx __attribute__((__visibility__("default"))) {
  template < typename _Alloc >
  struct  __alloc_traits
  {
      template < typename _Tp >
      struct rebind;
      typedef _Alloc allocator_type;
      typedef typename _Alloc::pointer pointer;
      typedef typename _Alloc::const_pointer const_pointer;
      typedef typename _Alloc::value_type value_type;
      typedef typename _Alloc::reference reference;
      typedef typename _Alloc::const_reference const_reference;
      typedef typename _Alloc::size_type size_type;
      static inline typename ::__gnu_cxx::__alloc_traits<_Alloc>::pointer allocate(_Alloc &__a, typename ::__gnu_cxx::__alloc_traits<_Alloc>::size_type __n)
      {
        return __a.allocate(__n);
      }
      static inline void deallocate(_Alloc &__a, typename ::__gnu_cxx::__alloc_traits<_Alloc>::pointer __p, typename ::__gnu_cxx::__alloc_traits<_Alloc>::size_type __n)
      {
        __a.deallocate(__p, __n);
      }
      template < typename _Tp >
      static inline void construct(_Alloc &__a, typename ::__gnu_cxx::__alloc_traits<_Alloc>::pointer __p, const _Tp &__arg)
      {
        __a.construct(__p, __arg);
      }
      static inline void destroy(_Alloc &__a, typename ::__gnu_cxx::__alloc_traits<_Alloc>::pointer __p)
      {
        __a.destroy(__p);
      }
      static inline typename ::__gnu_cxx::__alloc_traits<_Alloc>::size_type max_size(const _Alloc &__a)
      {
        return __a.max_size();
      }
      static inline const _Alloc &_S_select_on_copy(const _Alloc &__a)
      {
        return __a;
      }
      static inline void _S_on_swap(_Alloc &__a, _Alloc &__b)
      {
        std::__alloc_swap<_Alloc>::_S_do_it(__a, __b);
      }
      template < typename _Tp >
      struct  rebind
      {
          typedef typename _Alloc::template rebind< _Tp>::other other;
      };
  };
}
namespace std __attribute__((__visibility__("default"))) {
  template < typename _T1, typename _T2 >
  inline void _Construct(_T1 *__p, const _T2 &__value);
  template < typename _T1, typename _T2 >
  inline void _Construct(_T1 *__p, const _T2 &__value)
  {
    ::new (static_cast<void *>(__p))_T1(__value);
  }
  template < typename _Tp >
  inline void _Destroy(_Tp *__pointer);
  template < typename _Tp >
  inline void _Destroy(_Tp *__pointer)
  {
    __pointer->~_Tp();
  }
  template < bool __nontype_tpl_param_1_0__ >
  struct  _Destroy_aux
  {
      template < typename _ForwardIterator >
      static inline void __destroy(_ForwardIterator __first, _ForwardIterator __last)
      {
        for (; __first != __last; ++__first)
          {
            std::_Destroy(std::__addressof(*__first));
          }
      }
  };
  template <>
  struct  _Destroy_aux<true>
  {
      template < typename _ForwardIterator >
      static inline void __destroy(_ForwardIterator, _ForwardIterator)
      {
      }
  };
  template < typename _ForwardIterator >
  inline void _Destroy(_ForwardIterator __first, _ForwardIterator __last);
  template < typename _ForwardIterator >
  inline void _Destroy(_ForwardIterator __first, _ForwardIterator __last)
  {
    typedef typename ::std::iterator_traits<_ForwardIterator>::value_type _Value_type;
    std::_Destroy_aux<__has_trivial_destructor(_Value_type)>::__destroy(__first, __last);
  }
  template < typename _Tp >
  class allocator;
  template < typename _ForwardIterator, typename _Allocator >
  void _Destroy(_ForwardIterator __first, _ForwardIterator __last, _Allocator &__alloc);
  template < typename _ForwardIterator, typename _Allocator >
  void _Destroy(_ForwardIterator __first, _ForwardIterator __last, _Allocator &__alloc)
  {
    typedef ::__gnu_cxx::__alloc_traits<_Allocator> __traits;
    for (; __first != __last; ++__first)
      {
        __traits::destroy(__alloc, std::__addressof(*__first));
      }
  }
  template < typename _ForwardIterator, typename _Tp >
  inline void _Destroy(_ForwardIterator __first, _ForwardIterator __last, ::std::allocator<_Tp> &);
  template < typename _ForwardIterator, typename _Tp >
  inline void _Destroy(_ForwardIterator __first, _ForwardIterator __last, ::std::allocator<_Tp> &)
  {
    _Destroy(__first, __last);
  }
  template < typename _Tp >
  ::std::pair<_Tp *, ::std::ptrdiff_t> get_temporary_buffer(::std::ptrdiff_t __len);
  template < typename _Tp >
  ::std::pair<_Tp *, ::std::ptrdiff_t> get_temporary_buffer(::std::ptrdiff_t __len)
  {
    const ::std::ptrdiff_t __max = ::__gnu_cxx::__numeric_traits_integer<long int>::__max / sizeof(_Tp);
    if (__len > __max)
      {
        __len = __max;
      }
    while (__len > 0)
      {
        _Tp *__tmp = static_cast<_Tp *>(::operator new(__len * sizeof(_Tp), ::std::nothrow));
        if (__tmp != 0)
          {
            return ::std::pair<_Tp *, ::std::ptrdiff_t>(__tmp, __len);
          }
        __len /= 2;
      }
    return ::std::pair<_Tp *, ::std::ptrdiff_t>(static_cast<_Tp *>(0), 0);
  }
  template < typename _Tp >
  inline void return_temporary_buffer(_Tp *__p);
  template < typename _Tp >
  inline void return_temporary_buffer(_Tp *__p)
  {
    ::operator delete(__p, ::std::nothrow);
  }
  template < typename _ForwardIterator, typename _Tp >
  class  _Temporary_buffer
  {
    public:
      typedef _Tp value_type;
      typedef typename ::std::_Temporary_buffer<_ForwardIterator, _Tp>::value_type *pointer;
      typedef typename ::std::_Temporary_buffer<_ForwardIterator, _Tp>::pointer iterator;
      typedef ::std::ptrdiff_t size_type;
    protected:
      typename ::std::_Temporary_buffer<_ForwardIterator, _Tp>::size_type _M_original_len;
      typename ::std::_Temporary_buffer<_ForwardIterator, _Tp>::size_type _M_len;
      typename ::std::_Temporary_buffer<_ForwardIterator, _Tp>::pointer _M_buffer;
    public:
      inline typename ::std::_Temporary_buffer<_ForwardIterator, _Tp>::size_type size() const 
      {
        return _M_len;
      }
      inline typename ::std::_Temporary_buffer<_ForwardIterator, _Tp>::size_type requested_size() const 
      {
        return _M_original_len;
      }
      inline typename ::std::_Temporary_buffer<_ForwardIterator, _Tp>::iterator begin()
      {
        return _M_buffer;
      }
      inline typename ::std::_Temporary_buffer<_ForwardIterator, _Tp>::iterator end()
      {
        return _M_buffer + _M_len;
      }
      _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last);
      inline ~_Temporary_buffer()
      {
        std::_Destroy(_M_buffer, _M_buffer + _M_len);
        std::return_temporary_buffer(_M_buffer);
      }
    private:
      _Temporary_buffer(const ::std::_Temporary_buffer<_ForwardIterator, _Tp> &);
      void operator =(const ::std::_Temporary_buffer<_ForwardIterator, _Tp> &);
  };
  template < bool __nontype_tpl_param_1_0__ >
  struct  __uninitialized_construct_buf_dispatch
  {
      template < typename _ForwardIterator, typename _Tp >
      static inline void __ucr(_ForwardIterator __first, _ForwardIterator __last, _Tp &__value)
      {
        if (__first == __last)
          {
            return ;
          }
        _ForwardIterator __cur = __first;
        try
        {
          std::_Construct(std::__addressof(*__first), __value);
          _ForwardIterator __prev = __cur;
          ++__cur;
          for (; __cur != __last; (++__cur, ++__prev))
            {
              std::_Construct(std::__addressof(*__cur), *__prev);
            }
          __value = *__prev;
        }
        catch (...)
        {
          std::_Destroy(__first, __cur);
          throw;
        }
      }
  };
  template <>
  struct  __uninitialized_construct_buf_dispatch<true>
  {
      template < typename _ForwardIterator, typename _Tp >
      static inline void __ucr(_ForwardIterator, _ForwardIterator, _Tp &)
      {
      }
  };
  template < typename _ForwardIterator, typename _Tp >
  inline void __uninitialized_construct_buf(_ForwardIterator __first, _ForwardIterator __last, _Tp &__value);
  template < typename _ForwardIterator, typename _Tp >
  inline void __uninitialized_construct_buf(_ForwardIterator __first, _ForwardIterator __last, _Tp &__value)
  {
    typedef typename ::std::iterator_traits<_ForwardIterator>::value_type _ValueType;
    std::__uninitialized_construct_buf_dispatch<__has_trivial_constructor(_ValueType)>::__ucr(__first, __last, __value);
  }
  template < typename _ForwardIterator, typename _Tp >
  _Temporary_buffer<_ForwardIterator, _Tp>::_Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last)
    : _M_original_len(std::distance(__first, __last)), _M_len(0), _M_buffer(0)
  {
    try
    {
      ::std::pair<typename ::std::_Temporary_buffer<_ForwardIterator, _Tp>::pointer, typename ::std::_Temporary_buffer<_ForwardIterator, _Tp>::size_type> __p(std::get_temporary_buffer<typename ::std::_Temporary_buffer<_ForwardIterator, _Tp>::value_type>(_M_original_len));
      _M_buffer = __p.first;
      _M_len = __p.second;
      if (_M_buffer)
        {
          std::__uninitialized_construct_buf(_M_buffer, _M_buffer + _M_len, *__first);
        }
    }
    catch (...)
    {
      std::return_temporary_buffer(_M_buffer);
      _M_buffer = 0;
      _M_len = 0;
      throw;
    }
  }
  template < typename _Iterator >
  void __move_median_first(_Iterator __a, _Iterator __b, _Iterator __c);
  template < typename _Iterator >
  void __move_median_first(_Iterator __a, _Iterator __b, _Iterator __c)
  {
    if (*__a < *__b)
      {
        if (*__b < *__c)
          {
            std::iter_swap(__a, __b);
          }
        else
          {
            if (*__a < *__c)
              {
                std::iter_swap(__a, __c);
              }
          }
      }
    else
      {
        if (*__a < *__c)
          {
            return ;
          }
        else
          {
            if (*__b < *__c)
              {
                std::iter_swap(__a, __c);
              }
            else
              {
                std::iter_swap(__a, __b);
              }
          }
      }
  }
  template < typename _Iterator, typename _Compare >
  void __move_median_first(_Iterator __a, _Iterator __b, _Iterator __c, _Compare __comp);
  template < typename _Iterator, typename _Compare >
  void __move_median_first(_Iterator __a, _Iterator __b, _Iterator __c, _Compare __comp)
  {
    if (__comp(*__a, *__b))
      {
        if (__comp(*__b, *__c))
          {
            std::iter_swap(__a, __b);
          }
        else
          {
            if (__comp(*__a, *__c))
              {
                std::iter_swap(__a, __c);
              }
          }
      }
    else
      {
        if (__comp(*__a, *__c))
          {
            return ;
          }
        else
          {
            if (__comp(*__b, *__c))
              {
                std::iter_swap(__a, __c);
              }
            else
              {
                std::iter_swap(__a, __b);
              }
          }
      }
  }
  template < typename _InputIterator, typename _Tp >
  inline _InputIterator __find(_InputIterator __first, _InputIterator __last, const _Tp &__val, ::std::input_iterator_tag);
  template < typename _InputIterator, typename _Tp >
  inline _InputIterator __find(_InputIterator __first, _InputIterator __last, const _Tp &__val, ::std::input_iterator_tag)
  {
    while (__first != __last && !(*__first == __val))
      {
        ++__first;
      }
    return __first;
  }
  template < typename _InputIterator, typename _Predicate >
  inline _InputIterator __find_if(_InputIterator __first, _InputIterator __last, _Predicate __pred, ::std::input_iterator_tag);
  template < typename _InputIterator, typename _Predicate >
  inline _InputIterator __find_if(_InputIterator __first, _InputIterator __last, _Predicate __pred, ::std::input_iterator_tag)
  {
    while (__first != __last && !((bool)__pred(*__first)))
      {
        ++__first;
      }
    return __first;
  }
  template < typename _RandomAccessIterator, typename _Tp >
  _RandomAccessIterator __find(_RandomAccessIterator __first, _RandomAccessIterator __last, const _Tp &__val, ::std::random_access_iterator_tag);
  template < typename _RandomAccessIterator, typename _Tp >
  _RandomAccessIterator __find(_RandomAccessIterator __first, _RandomAccessIterator __last, const _Tp &__val, ::std::random_access_iterator_tag)
  {
    typename ::std::iterator_traits<_RandomAccessIterator>::difference_type __trip_count = (__last - __first) >> 2;
    for (; __trip_count > 0; --__trip_count)
      {
        if (*__first == __val)
          {
            return __first;
          }
        ++__first;
        if (*__first == __val)
          {
            return __first;
          }
        ++__first;
        if (*__first == __val)
          {
            return __first;
          }
        ++__first;
        if (*__first == __val)
          {
            return __first;
          }
        ++__first;
      }
    switch (__last - __first)
        {
          case 3 :
          if (*__first == __val)
            {
              return __first;
            }
          ++__first;
          case 2 :
          if (*__first == __val)
            {
              return __first;
            }
          ++__first;
          case 1 :
          if (*__first == __val)
            {
              return __first;
            }
          ++__first;
          case 0 :
          default :
          return __last;
        }
  }
  template < typename _RandomAccessIterator, typename _Predicate >
  _RandomAccessIterator __find_if(_RandomAccessIterator __first, _RandomAccessIterator __last, _Predicate __pred, ::std::random_access_iterator_tag);
  template < typename _RandomAccessIterator, typename _Predicate >
  _RandomAccessIterator __find_if(_RandomAccessIterator __first, _RandomAccessIterator __last, _Predicate __pred, ::std::random_access_iterator_tag)
  {
    typename ::std::iterator_traits<_RandomAccessIterator>::difference_type __trip_count = (__last - __first) >> 2;
    for (; __trip_count > 0; --__trip_count)
      {
        if (__pred(*__first))
          {
            return __first;
          }
        ++__first;
        if (__pred(*__first))
          {
            return __first;
          }
        ++__first;
        if (__pred(*__first))
          {
            return __first;
          }
        ++__first;
        if (__pred(*__first))
          {
            return __first;
          }
        ++__first;
      }
    switch (__last - __first)
        {
          case 3 :
          if (__pred(*__first))
            {
              return __first;
            }
          ++__first;
          case 2 :
          if (__pred(*__first))
            {
              return __first;
            }
          ++__first;
          case 1 :
          if (__pred(*__first))
            {
              return __first;
            }
          ++__first;
          case 0 :
          default :
          return __last;
        }
  }
  template < typename _InputIterator, typename _Predicate >
  inline _InputIterator __find_if_not(_InputIterator __first, _InputIterator __last, _Predicate __pred, ::std::input_iterator_tag);
  template < typename _InputIterator, typename _Predicate >
  inline _InputIterator __find_if_not(_InputIterator __first, _InputIterator __last, _Predicate __pred, ::std::input_iterator_tag)
  {
    while (__first != __last && (bool)__pred(*__first))
      {
        ++__first;
      }
    return __first;
  }
  template < typename _RandomAccessIterator, typename _Predicate >
  _RandomAccessIterator __find_if_not(_RandomAccessIterator __first, _RandomAccessIterator __last, _Predicate __pred, ::std::random_access_iterator_tag);
  template < typename _RandomAccessIterator, typename _Predicate >
  _RandomAccessIterator __find_if_not(_RandomAccessIterator __first, _RandomAccessIterator __last, _Predicate __pred, ::std::random_access_iterator_tag)
  {
    typename ::std::iterator_traits<_RandomAccessIterator>::difference_type __trip_count = (__last - __first) >> 2;
    for (; __trip_count > 0; --__trip_count)
      {
        if (!((bool)__pred(*__first)))
          {
            return __first;
          }
        ++__first;
        if (!((bool)__pred(*__first)))
          {
            return __first;
          }
        ++__first;
        if (!((bool)__pred(*__first)))
          {
            return __first;
          }
        ++__first;
        if (!((bool)__pred(*__first)))
          {
            return __first;
          }
        ++__first;
      }
    switch (__last - __first)
        {
          case 3 :
          if (!((bool)__pred(*__first)))
            {
              return __first;
            }
          ++__first;
          case 2 :
          if (!((bool)__pred(*__first)))
            {
              return __first;
            }
          ++__first;
          case 1 :
          if (!((bool)__pred(*__first)))
            {
              return __first;
            }
          ++__first;
          case 0 :
          default :
          return __last;
        }
  }
  template < typename _InputIterator, typename _Predicate >
  inline _InputIterator __find_if_not(_InputIterator __first, _InputIterator __last, _Predicate __pred);
  template < typename _InputIterator, typename _Predicate >
  inline _InputIterator __find_if_not(_InputIterator __first, _InputIterator __last, _Predicate __pred)
  {
    return std::__find_if_not(__first, __last, __pred, std::__iterator_category(__first));
  }
  template < typename _InputIterator, typename _Predicate, typename _Distance >
  _InputIterator __find_if_not_n(_InputIterator __first, _Distance &__len, _Predicate __pred);
  template < typename _InputIterator, typename _Predicate, typename _Distance >
  _InputIterator __find_if_not_n(_InputIterator __first, _Distance &__len, _Predicate __pred)
  {
    for (; __len; (--__len, ++__first))
      {
        if (!((bool)__pred(*__first)))
          {
            break;
          }
      }
    return __first;
  }
  template < typename _ForwardIterator, typename _Integer, typename _Tp >
  _ForwardIterator __search_n(_ForwardIterator __first, _ForwardIterator __last, _Integer __count, const _Tp &__val, ::std::forward_iterator_tag);
  template < typename _ForwardIterator, typename _Integer, typename _Tp >
  _ForwardIterator __search_n(_ForwardIterator __first, _ForwardIterator __last, _Integer __count, const _Tp &__val, ::std::forward_iterator_tag)
  {
    __first = std::find(__first, __last, __val);
    while (__first != __last)
      {
        typename ::std::iterator_traits<_ForwardIterator>::difference_type __n = __count;
        _ForwardIterator __i = __first;
        ++__i;
        while ((__i != __last && __n != 1) && *__i == __val)
          {
            ++__i;
            --__n;
          }
        if (__n == 1)
          {
            return __first;
          }
        if (__i == __last)
          {
            return __last;
          }
        __first = std::find(++__i, __last, __val);
      }
    return __last;
  }
  template < typename _RandomAccessIter, typename _Integer, typename _Tp >
  _RandomAccessIter __search_n(_RandomAccessIter __first, _RandomAccessIter __last, _Integer __count, const _Tp &__val, ::std::random_access_iterator_tag);
  template < typename _RandomAccessIter, typename _Integer, typename _Tp >
  _RandomAccessIter __search_n(_RandomAccessIter __first, _RandomAccessIter __last, _Integer __count, const _Tp &__val, ::std::random_access_iterator_tag)
  {
    typedef typename ::std::iterator_traits<_RandomAccessIter>::difference_type _DistanceType;
    _DistanceType __tailSize = __last - __first;
    const _DistanceType __pattSize = __count;
    if (__tailSize < __pattSize)
      {
        return __last;
      }
    const _DistanceType __skipOffset = __pattSize - 1;
    _RandomAccessIter __lookAhead = __first + __skipOffset;
    __tailSize -= __pattSize;
    while (1)
      {
        while (!(*__lookAhead == __val))
          {
            if (__tailSize < __pattSize)
              {
                return __last;
              }
            __lookAhead += __pattSize;
            __tailSize -= __pattSize;
          }
        _DistanceType __remainder = __skipOffset;
        for (_RandomAccessIter __backTrack = __lookAhead - 1; *__backTrack == __val; --__backTrack)
          {
            if (--__remainder == 0)
              {
                return __lookAhead - __skipOffset;
              }
          }
        if (__remainder > __tailSize)
          {
            return __last;
          }
        __lookAhead += __remainder;
        __tailSize -= __remainder;
      }
  }
  template < typename _ForwardIterator, typename _Integer, typename _Tp, typename _BinaryPredicate >
  _ForwardIterator __search_n(_ForwardIterator __first, _ForwardIterator __last, _Integer __count, const _Tp &__val, _BinaryPredicate __binary_pred, ::std::forward_iterator_tag);
  template < typename _ForwardIterator, typename _Integer, typename _Tp, typename _BinaryPredicate >
  _ForwardIterator __search_n(_ForwardIterator __first, _ForwardIterator __last, _Integer __count, const _Tp &__val, _BinaryPredicate __binary_pred, ::std::forward_iterator_tag)
  {
    while (__first != __last && !((bool)__binary_pred(*__first, __val)))
      {
        ++__first;
      }
    while (__first != __last)
      {
        typename ::std::iterator_traits<_ForwardIterator>::difference_type __n = __count;
        _ForwardIterator __i = __first;
        ++__i;
        while ((__i != __last && __n != 1) && (bool)__binary_pred(*__i, __val))
          {
            ++__i;
            --__n;
          }
        if (__n == 1)
          {
            return __first;
          }
        if (__i == __last)
          {
            return __last;
          }
        __first = ++__i;
        while (__first != __last && !((bool)__binary_pred(*__first, __val)))
          {
            ++__first;
          }
      }
    return __last;
  }
  template < typename _RandomAccessIter, typename _Integer, typename _Tp, typename _BinaryPredicate >
  _RandomAccessIter __search_n(_RandomAccessIter __first, _RandomAccessIter __last, _Integer __count, const _Tp &__val, _BinaryPredicate __binary_pred, ::std::random_access_iterator_tag);
  template < typename _RandomAccessIter, typename _Integer, typename _Tp, typename _BinaryPredicate >
  _RandomAccessIter __search_n(_RandomAccessIter __first, _RandomAccessIter __last, _Integer __count, const _Tp &__val, _BinaryPredicate __binary_pred, ::std::random_access_iterator_tag)
  {
    typedef typename ::std::iterator_traits<_RandomAccessIter>::difference_type _DistanceType;
    _DistanceType __tailSize = __last - __first;
    const _DistanceType __pattSize = __count;
    if (__tailSize < __pattSize)
      {
        return __last;
      }
    const _DistanceType __skipOffset = __pattSize - 1;
    _RandomAccessIter __lookAhead = __first + __skipOffset;
    __tailSize -= __pattSize;
    while (1)
      {
        while (!((bool)__binary_pred(*__lookAhead, __val)))
          {
            if (__tailSize < __pattSize)
              {
                return __last;
              }
            __lookAhead += __pattSize;
            __tailSize -= __pattSize;
          }
        _DistanceType __remainder = __skipOffset;
        for (_RandomAccessIter __backTrack = __lookAhead - 1; __binary_pred(*__backTrack, __val); --__backTrack)
          {
            if (--__remainder == 0)
              {
                return __lookAhead - __skipOffset;
              }
          }
        if (__remainder > __tailSize)
          {
            return __last;
          }
        __lookAhead += __remainder;
        __tailSize -= __remainder;
      }
  }
  template < typename _ForwardIterator1, typename _ForwardIterator2 >
  _ForwardIterator1 __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2, ::std::forward_iterator_tag, ::std::forward_iterator_tag);
  template < typename _ForwardIterator1, typename _ForwardIterator2 >
  _ForwardIterator1 __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2, ::std::forward_iterator_tag, ::std::forward_iterator_tag)
  {
    if (__first2 == __last2)
      {
        return __last1;
      }
    else
      {
        _ForwardIterator1 __result = __last1;
        while (1)
          {
            _ForwardIterator1 __new_result = std::search(__first1, __last1, __first2, __last2);
            if (__new_result == __last1)
              {
                return __result;
              }
            else
              {
                __result = __new_result;
                __first1 = __new_result;
                ++__first1;
              }
          }
      }
  }
  template < typename _ForwardIterator1, typename _ForwardIterator2, typename _BinaryPredicate >
  _ForwardIterator1 __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2, ::std::forward_iterator_tag, ::std::forward_iterator_tag, _BinaryPredicate __comp);
  template < typename _ForwardIterator1, typename _ForwardIterator2, typename _BinaryPredicate >
  _ForwardIterator1 __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2, ::std::forward_iterator_tag, ::std::forward_iterator_tag, _BinaryPredicate __comp)
  {
    if (__first2 == __last2)
      {
        return __last1;
      }
    else
      {
        _ForwardIterator1 __result = __last1;
        while (1)
          {
            _ForwardIterator1 __new_result = std::search(__first1, __last1, __first2, __last2, __comp);
            if (__new_result == __last1)
              {
                return __result;
              }
            else
              {
                __result = __new_result;
                __first1 = __new_result;
                ++__first1;
              }
          }
      }
  }
  template < typename _BidirectionalIterator1, typename _BidirectionalIterator2 >
  _BidirectionalIterator1 __find_end(_BidirectionalIterator1 __first1, _BidirectionalIterator1 __last1, _BidirectionalIterator2 __first2, _BidirectionalIterator2 __last2, ::std::bidirectional_iterator_tag, ::std::bidirectional_iterator_tag);
  template < typename _BidirectionalIterator1, typename _BidirectionalIterator2 >
  _BidirectionalIterator1 __find_end(_BidirectionalIterator1 __first1, _BidirectionalIterator1 __last1, _BidirectionalIterator2 __first2, _BidirectionalIterator2 __last2, ::std::bidirectional_iterator_tag, ::std::bidirectional_iterator_tag)
  {
    typedef ::std::reverse_iterator<_BidirectionalIterator1> _RevIterator1;
    typedef ::std::reverse_iterator<_BidirectionalIterator2> _RevIterator2;
    _RevIterator1 __rlast1(__first1);
    _RevIterator2 __rlast2(__first2);
    _RevIterator1 __rresult = std::search(_RevIterator1(__last1), __rlast1, _RevIterator2(__last2), __rlast2);
    if (__rresult == __rlast1)
      {
        return __last1;
      }
    else
      {
        _BidirectionalIterator1 __result = __rresult.base();
        std::advance(__result,  -std::distance(__first2, __last2));
        return __result;
      }
  }
  template < typename _BidirectionalIterator1, typename _BidirectionalIterator2, typename _BinaryPredicate >
  _BidirectionalIterator1 __find_end(_BidirectionalIterator1 __first1, _BidirectionalIterator1 __last1, _BidirectionalIterator2 __first2, _BidirectionalIterator2 __last2, ::std::bidirectional_iterator_tag, ::std::bidirectional_iterator_tag, _BinaryPredicate __comp);
  template < typename _BidirectionalIterator1, typename _BidirectionalIterator2, typename _BinaryPredicate >
  _BidirectionalIterator1 __find_end(_BidirectionalIterator1 __first1, _BidirectionalIterator1 __last1, _BidirectionalIterator2 __first2, _BidirectionalIterator2 __last2, ::std::bidirectional_iterator_tag, ::std::bidirectional_iterator_tag, _BinaryPredicate __comp)
  {
    typedef ::std::reverse_iterator<_BidirectionalIterator1> _RevIterator1;
    typedef ::std::reverse_iterator<_BidirectionalIterator2> _RevIterator2;
    _RevIterator1 __rlast1(__first1);
    _RevIterator2 __rlast2(__first2);
    _RevIterator1 __rresult = std::search(_RevIterator1(__last1), __rlast1, _RevIterator2(__last2), __rlast2, __comp);
    if (__rresult == __rlast1)
      {
        return __last1;
      }
    else
      {
        _BidirectionalIterator1 __result = __rresult.base();
        std::advance(__result,  -std::distance(__first2, __last2));
        return __result;
      }
  }
  template < typename _ForwardIterator1, typename _ForwardIterator2 >
  inline _ForwardIterator1 find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2)
  {
    ;
    ;
    return std::__find_end(__first1, __last1, __first2, __last2, std::__iterator_category(__first1), std::__iterator_category(__first2));
  }
  template < typename _ForwardIterator1, typename _ForwardIterator2, typename _BinaryPredicate >
  inline _ForwardIterator1 find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __comp)
  {
    ;
    ;
    return std::__find_end(__first1, __last1, __first2, __last2, std::__iterator_category(__first1), std::__iterator_category(__first2), __comp);
  }
  template < typename _InputIterator, typename _OutputIterator, typename _Tp >
  _OutputIterator remove_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, const _Tp &__value)
  {
    ;
    for (; __first != __last; ++__first)
      {
        if (!(*__first == __value))
          {
            *__result = *__first;
            ++__result;
          }
      }
    return __result;
  }
  template < typename _InputIterator, typename _OutputIterator, typename _Predicate >
  _OutputIterator remove_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _Predicate __pred)
  {
    ;
    for (; __first != __last; ++__first)
      {
        if (!((bool)__pred(*__first)))
          {
            *__result = *__first;
            ++__result;
          }
      }
    return __result;
  }
  template < typename _ForwardIterator, typename _Tp >
  _ForwardIterator remove(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value)
  {
    ;
    __first = std::find(__first, __last, __value);
    if (__first == __last)
      {
        return __first;
      }
    _ForwardIterator __result = __first;
    ++__first;
    for (; __first != __last; ++__first)
      {
        if (!(*__first == __value))
          {
            *__result = *__first;
            ++__result;
          }
      }
    return __result;
  }
  template < typename _ForwardIterator, typename _Predicate >
  _ForwardIterator remove_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
  {
    ;
    __first = std::find_if(__first, __last, __pred);
    if (__first == __last)
      {
        return __first;
      }
    _ForwardIterator __result = __first;
    ++__first;
    for (; __first != __last; ++__first)
      {
        if (!((bool)__pred(*__first)))
          {
            *__result = *__first;
            ++__result;
          }
      }
    return __result;
  }
  template < typename _ForwardIterator >
  _ForwardIterator unique(_ForwardIterator __first, _ForwardIterator __last)
  {
    ;
    __first = std::adjacent_find(__first, __last);
    if (__first == __last)
      {
        return __last;
      }
    _ForwardIterator __dest = __first;
    ++__first;
    while (++__first != __last)
      {
        if (!(*__dest == *__first))
          {
            *++__dest = *__first;
          }
      }
    return ++__dest;
  }
  template < typename _ForwardIterator, typename _BinaryPredicate >
  _ForwardIterator unique(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __binary_pred)
  {
    ;
    __first = std::adjacent_find(__first, __last, __binary_pred);
    if (__first == __last)
      {
        return __last;
      }
    _ForwardIterator __dest = __first;
    ++__first;
    while (++__first != __last)
      {
        if (!((bool)__binary_pred(*__dest, *__first)))
          {
            *++__dest = *__first;
          }
      }
    return ++__dest;
  }
  template < typename _ForwardIterator, typename _OutputIterator >
  _OutputIterator __unique_copy(_ForwardIterator __first, _ForwardIterator __last, _OutputIterator __result, ::std::forward_iterator_tag, ::std::output_iterator_tag);
  template < typename _ForwardIterator, typename _OutputIterator >
  _OutputIterator __unique_copy(_ForwardIterator __first, _ForwardIterator __last, _OutputIterator __result, ::std::forward_iterator_tag, ::std::output_iterator_tag)
  {
    _ForwardIterator __next = __first;
    *__result = *__first;
    while (++__next != __last)
      {
        if (!(*__first == *__next))
          {
            __first = __next;
            *++__result = *__first;
          }
      }
    return ++__result;
  }
  template < typename _InputIterator, typename _OutputIterator >
  _OutputIterator __unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, ::std::input_iterator_tag, ::std::output_iterator_tag);
  template < typename _InputIterator, typename _OutputIterator >
  _OutputIterator __unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, ::std::input_iterator_tag, ::std::output_iterator_tag)
  {
    typename ::std::iterator_traits<_InputIterator>::value_type __value = *__first;
    *__result = __value;
    while (++__first != __last)
      {
        if (!(__value == *__first))
          {
            __value = *__first;
            *++__result = __value;
          }
      }
    return ++__result;
  }
  template < typename _InputIterator, typename _ForwardIterator >
  _ForwardIterator __unique_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, ::std::input_iterator_tag, ::std::forward_iterator_tag);
  template < typename _InputIterator, typename _ForwardIterator >
  _ForwardIterator __unique_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, ::std::input_iterator_tag, ::std::forward_iterator_tag)
  {
    *__result = *__first;
    while (++__first != __last)
      {
        if (!(*__result == *__first))
          {
            *++__result = *__first;
          }
      }
    return ++__result;
  }
  template < typename _ForwardIterator, typename _OutputIterator, typename _BinaryPredicate >
  _OutputIterator __unique_copy(_ForwardIterator __first, _ForwardIterator __last, _OutputIterator __result, _BinaryPredicate __binary_pred, ::std::forward_iterator_tag, ::std::output_iterator_tag);
  template < typename _ForwardIterator, typename _OutputIterator, typename _BinaryPredicate >
  _OutputIterator __unique_copy(_ForwardIterator __first, _ForwardIterator __last, _OutputIterator __result, _BinaryPredicate __binary_pred, ::std::forward_iterator_tag, ::std::output_iterator_tag)
  {
    _ForwardIterator __next = __first;
    *__result = *__first;
    while (++__next != __last)
      {
        if (!((bool)__binary_pred(*__first, *__next)))
          {
            __first = __next;
            *++__result = *__first;
          }
      }
    return ++__result;
  }
  template < typename _InputIterator, typename _OutputIterator, typename _BinaryPredicate >
  _OutputIterator __unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __binary_pred, ::std::input_iterator_tag, ::std::output_iterator_tag);
  template < typename _InputIterator, typename _OutputIterator, typename _BinaryPredicate >
  _OutputIterator __unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __binary_pred, ::std::input_iterator_tag, ::std::output_iterator_tag)
  {
    typename ::std::iterator_traits<_InputIterator>::value_type __value = *__first;
    *__result = __value;
    while (++__first != __last)
      {
        if (!((bool)__binary_pred(__value, *__first)))
          {
            __value = *__first;
            *++__result = __value;
          }
      }
    return ++__result;
  }
  template < typename _InputIterator, typename _ForwardIterator, typename _BinaryPredicate >
  _ForwardIterator __unique_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _BinaryPredicate __binary_pred, ::std::input_iterator_tag, ::std::forward_iterator_tag);
  template < typename _InputIterator, typename _ForwardIterator, typename _BinaryPredicate >
  _ForwardIterator __unique_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _BinaryPredicate __binary_pred, ::std::input_iterator_tag, ::std::forward_iterator_tag)
  {
    *__result = *__first;
    while (++__first != __last)
      {
        if (!((bool)__binary_pred(*__result, *__first)))
          {
            *++__result = *__first;
          }
      }
    return ++__result;
  }
  template < typename _BidirectionalIterator >
  void __reverse(_BidirectionalIterator __first, _BidirectionalIterator __last, ::std::bidirectional_iterator_tag);
  template < typename _BidirectionalIterator >
  void __reverse(_BidirectionalIterator __first, _BidirectionalIterator __last, ::std::bidirectional_iterator_tag)
  {
    while (true)
      {
        if (__first == __last || __first == --__last)
          {
            return ;
          }
        else
          {
            std::iter_swap(__first, __last);
            ++__first;
          }
      }
  }
  template < typename _RandomAccessIterator >
  void __reverse(_RandomAccessIterator __first, _RandomAccessIterator __last, ::std::random_access_iterator_tag);
  template < typename _RandomAccessIterator >
  void __reverse(_RandomAccessIterator __first, _RandomAccessIterator __last, ::std::random_access_iterator_tag)
  {
    if (__first == __last)
      {
        return ;
      }
    --__last;
    while (__first < __last)
      {
        std::iter_swap(__first, __last);
        ++__first;
        --__last;
      }
  }
  template < typename _BidirectionalIterator >
  inline void reverse(_BidirectionalIterator __first, _BidirectionalIterator __last)
  {
    ;
    std::__reverse(__first, __last, std::__iterator_category(__first));
  }
  template < typename _BidirectionalIterator, typename _OutputIterator >
  _OutputIterator reverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)
  {
    ;
    while (__first != __last)
      {
        --__last;
        *__result = *__last;
        ++__result;
      }
    return __result;
  }
  template < typename _EuclideanRingElement >
  _EuclideanRingElement __gcd(_EuclideanRingElement __m, _EuclideanRingElement __n);
  template < typename _EuclideanRingElement >
  _EuclideanRingElement __gcd(_EuclideanRingElement __m, _EuclideanRingElement __n)
  {
    while (__n != 0)
      {
        _EuclideanRingElement __t = __m % __n;
        __m = __n;
        __n = __t;
      }
    return __m;
  }
  template < typename _ForwardIterator >
  void __rotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last, ::std::forward_iterator_tag);
  template < typename _ForwardIterator >
  void __rotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last, ::std::forward_iterator_tag)
  {
    if (__first == __middle || __last == __middle)
      {
        return ;
      }
    _ForwardIterator __first2 = __middle;
    do
      {
        std::iter_swap(__first, __first2);
        ++__first;
        ++__first2;
        if (__first == __middle)
          {
            __middle = __first2;
          }
      }
    while (__first2 != __last);
    __first2 = __middle;
    while (__first2 != __last)
      {
        std::iter_swap(__first, __first2);
        ++__first;
        ++__first2;
        if (__first == __middle)
          {
            __middle = __first2;
          }
        else
          {
            if (__first2 == __last)
              {
                __first2 = __middle;
              }
          }
      }
  }
  template < typename _BidirectionalIterator >
  void __rotate(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last, ::std::bidirectional_iterator_tag);
  template < typename _BidirectionalIterator >
  void __rotate(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last, ::std::bidirectional_iterator_tag)
  {
    if (__first == __middle || __last == __middle)
      {
        return ;
      }
    std::__reverse(__first, __middle, ::std::bidirectional_iterator_tag());
    std::__reverse(__middle, __last, ::std::bidirectional_iterator_tag());
    while (__first != __middle && __middle != __last)
      {
        std::iter_swap(__first, --__last);
        ++__first;
      }
    if (__first == __middle)
      {
        std::__reverse(__middle, __last, ::std::bidirectional_iterator_tag());
      }
    else
      {
        std::__reverse(__first, __middle, ::std::bidirectional_iterator_tag());
      }
  }
  template < typename _RandomAccessIterator >
  void __rotate(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last, ::std::random_access_iterator_tag);
  template < typename _RandomAccessIterator >
  void __rotate(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last, ::std::random_access_iterator_tag)
  {
    if (__first == __middle || __last == __middle)
      {
        return ;
      }
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::difference_type _Distance;
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::value_type _ValueType;
    _Distance __n = __last - __first;
    _Distance __k = __middle - __first;
    if (__k == __n - __k)
      {
        std::swap_ranges(__first, __middle, __middle);
        return ;
      }
    _RandomAccessIterator __p = __first;
    for (; ; )
      {
        if (__k < __n - __k)
          {
            if ((__is_pod(_ValueType)) && __k == 1)
              {
                _ValueType __t = *__p;
                std::copy(__p + 1, __p + __n, __p);
                *(__p + __n - 1) = __t;
                return ;
              }
            _RandomAccessIterator __q = __p + __k;
            for (_Distance __i = 0; __i < __n - __k; ++__i)
              {
                std::iter_swap(__p, __q);
                ++__p;
                ++__q;
              }
            __n %= __k;
            if (__n == 0)
              {
                return ;
              }
            std::swap(__n, __k);
            __k = __n - __k;
          }
        else
          {
            __k = __n - __k;
            if ((__is_pod(_ValueType)) && __k == 1)
              {
                _ValueType __t = *(__p + __n - 1);
                std::copy_backward(__p, __p + __n - 1, __p + __n);
                *__p = __t;
                return ;
              }
            _RandomAccessIterator __q = __p + __n;
            __p = __q - __k;
            for (_Distance __i = 0; __i < __n - __k; ++__i)
              {
                --__p;
                --__q;
                std::iter_swap(__p, __q);
              }
            __n %= __k;
            if (__n == 0)
              {
                return ;
              }
            std::swap(__n, __k);
          }
      }
  }
  template < typename _ForwardIterator >
  inline void rotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)
  {
    ;
    ;
    typedef typename ::std::iterator_traits<_ForwardIterator>::iterator_category _IterType;
    std::__rotate(__first, __middle, __last, _IterType());
  }
  template < typename _ForwardIterator, typename _OutputIterator >
  _OutputIterator rotate_copy(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last, _OutputIterator __result)
  {
    ;
    ;
    return std::copy(__first, __middle, std::copy(__middle, __last, __result));
  }
  template < typename _ForwardIterator, typename _Predicate >
  _ForwardIterator __partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, ::std::forward_iterator_tag);
  template < typename _ForwardIterator, typename _Predicate >
  _ForwardIterator __partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, ::std::forward_iterator_tag)
  {
    if (__first == __last)
      {
        return __first;
      }
    while (__pred(*__first))
      {
        if (++__first == __last)
          {
            return __first;
          }
      }
    _ForwardIterator __next = __first;
    while (++__next != __last)
      {
        if (__pred(*__next))
          {
            std::iter_swap(__first, __next);
            ++__first;
          }
      }
    return __first;
  }
  template < typename _BidirectionalIterator, typename _Predicate >
  _BidirectionalIterator __partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred, ::std::bidirectional_iterator_tag);
  template < typename _BidirectionalIterator, typename _Predicate >
  _BidirectionalIterator __partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred, ::std::bidirectional_iterator_tag)
  {
    while (true)
      {
        while (true)
          {
            if (__first == __last)
              {
                return __first;
              }
            else
              {
                if (__pred(*__first))
                  {
                    ++__first;
                  }
                else
                  {
                    break;
                  }
              }
          }
        --__last;
        while (true)
          {
            if (__first == __last)
              {
                return __first;
              }
            else
              {
                if (!((bool)__pred(*__last)))
                  {
                    --__last;
                  }
                else
                  {
                    break;
                  }
              }
          }
        std::iter_swap(__first, __last);
        ++__first;
      }
  }
  template < typename _ForwardIterator, typename _Predicate, typename _Distance >
  _ForwardIterator __inplace_stable_partition(_ForwardIterator __first, _Predicate __pred, _Distance __len);
  template < typename _ForwardIterator, typename _Predicate, typename _Distance >
  _ForwardIterator __inplace_stable_partition(_ForwardIterator __first, _Predicate __pred, _Distance __len)
  {
    if (__len == 1)
      {
        return __first;
      }
    _ForwardIterator __middle = __first;
    std::advance(__middle, __len / 2);
    _ForwardIterator __left_split = std::__inplace_stable_partition(__first, __pred, __len / 2);
    _Distance __right_len = __len - __len / 2;
    _ForwardIterator __right_split = std::__find_if_not_n(__middle, __right_len, __pred);
    if (__right_len)
      {
        __right_split = std::__inplace_stable_partition(__middle, __pred, __right_len);
      }
    std::rotate(__left_split, __middle, __right_split);
    std::advance(__left_split, std::distance(__middle, __right_split));
    return __left_split;
  }
  template < typename _ForwardIterator, typename _Pointer, typename _Predicate, typename _Distance >
  _ForwardIterator __stable_partition_adaptive(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, _Distance __len, _Pointer __buffer, _Distance __buffer_size);
  template < typename _ForwardIterator, typename _Pointer, typename _Predicate, typename _Distance >
  _ForwardIterator __stable_partition_adaptive(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, _Distance __len, _Pointer __buffer, _Distance __buffer_size)
  {
    if (__len <= __buffer_size)
      {
        _ForwardIterator __result1 = __first;
        _Pointer __result2 = __buffer;
        *__result2 = *__first;
        ++__result2;
        ++__first;
        for (; __first != __last; ++__first)
          {
            if (__pred(*__first))
              {
                *__result1 = *__first;
                ++__result1;
              }
            else
              {
                *__result2 = *__first;
                ++__result2;
              }
          }
        std::copy(__buffer, __result2, __result1);
        return __result1;
      }
    else
      {
        _ForwardIterator __middle = __first;
        std::advance(__middle, __len / 2);
        _ForwardIterator __left_split = std::__stable_partition_adaptive(__first, __middle, __pred, __len / 2, __buffer, __buffer_size);
        _Distance __right_len = __len - __len / 2;
        _ForwardIterator __right_split = std::__find_if_not_n(__middle, __right_len, __pred);
        if (__right_len)
          {
            __right_split = std::__stable_partition_adaptive(__right_split, __last, __pred, __right_len, __buffer, __buffer_size);
          }
        std::rotate(__left_split, __middle, __right_split);
        std::advance(__left_split, std::distance(__middle, __right_split));
        return __left_split;
      }
  }
  template < typename _ForwardIterator, typename _Predicate >
  _ForwardIterator stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
  {
    ;
    __first = std::__find_if_not(__first, __last, __pred);
    if (__first == __last)
      {
        return __first;
      }
    else
      {
        typedef typename ::std::iterator_traits<_ForwardIterator>::value_type _ValueType;
        typedef typename ::std::iterator_traits<_ForwardIterator>::difference_type _DistanceType;
        ::std::_Temporary_buffer<_ForwardIterator, _ValueType> __buf(__first, __last);
        if (__buf.size() > 0)
          {
            return std::__stable_partition_adaptive(__first, __last, __pred, _DistanceType(__buf.requested_size()), __buf.begin(), _DistanceType(__buf.size()));
          }
        else
          {
            return std::__inplace_stable_partition(__first, __pred, _DistanceType(__buf.requested_size()));
          }
      }
  }
  template < typename _RandomAccessIterator >
  void __heap_select(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last);
  template < typename _RandomAccessIterator >
  void __heap_select(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)
  {
    std::make_heap(__first, __middle);
    for (_RandomAccessIterator __i = __middle; __i < __last; ++__i)
      {
        if (*__i < *__first)
          {
            std::__pop_heap(__first, __middle, __i);
          }
      }
  }
  template < typename _RandomAccessIterator, typename _Compare >
  void __heap_select(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last, _Compare __comp);
  template < typename _RandomAccessIterator, typename _Compare >
  void __heap_select(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last, _Compare __comp)
  {
    std::make_heap(__first, __middle, __comp);
    for (_RandomAccessIterator __i = __middle; __i < __last; ++__i)
      {
        if (__comp(*__i, *__first))
          {
            std::__pop_heap(__first, __middle, __i, __comp);
          }
      }
  }
  template < typename _InputIterator, typename _RandomAccessIterator >
  _RandomAccessIterator partial_sort_copy(_InputIterator __first, _InputIterator __last, _RandomAccessIterator __result_first, _RandomAccessIterator __result_last)
  {
    typedef typename ::std::iterator_traits<_InputIterator>::value_type _InputValueType;
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::value_type _OutputValueType;
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::difference_type _DistanceType;
    ;
    ;
    if (__result_first == __result_last)
      {
        return __result_last;
      }
    _RandomAccessIterator __result_real_last = __result_first;
    while (__first != __last && __result_real_last != __result_last)
      {
        *__result_real_last = *__first;
        ++__result_real_last;
        ++__first;
      }
    std::make_heap(__result_first, __result_real_last);
    while (__first != __last)
      {
        if (*__first < *__result_first)
          {
            std::__adjust_heap(__result_first, _DistanceType(0), _DistanceType(__result_real_last - __result_first), _InputValueType(*__first));
          }
        ++__first;
      }
    std::sort_heap(__result_first, __result_real_last);
    return __result_real_last;
  }
  template < typename _InputIterator, typename _RandomAccessIterator, typename _Compare >
  _RandomAccessIterator partial_sort_copy(_InputIterator __first, _InputIterator __last, _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)
  {
    typedef typename ::std::iterator_traits<_InputIterator>::value_type _InputValueType;
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::value_type _OutputValueType;
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::difference_type _DistanceType;
    ;
    ;
    if (__result_first == __result_last)
      {
        return __result_last;
      }
    _RandomAccessIterator __result_real_last = __result_first;
    while (__first != __last && __result_real_last != __result_last)
      {
        *__result_real_last = *__first;
        ++__result_real_last;
        ++__first;
      }
    std::make_heap(__result_first, __result_real_last, __comp);
    while (__first != __last)
      {
        if (__comp(*__first, *__result_first))
          {
            std::__adjust_heap(__result_first, _DistanceType(0), _DistanceType(__result_real_last - __result_first), _InputValueType(*__first), __comp);
          }
        ++__first;
      }
    std::sort_heap(__result_first, __result_real_last, __comp);
    return __result_real_last;
  }
  template < typename _RandomAccessIterator >
  void __unguarded_linear_insert(_RandomAccessIterator __last);
  template < typename _RandomAccessIterator >
  void __unguarded_linear_insert(_RandomAccessIterator __last)
  {
    typename ::std::iterator_traits<_RandomAccessIterator>::value_type __val = *__last;
    _RandomAccessIterator __next = __last;
    --__next;
    while (__val < *__next)
      {
        *__last = *__next;
        __last = __next;
        --__next;
      }
    *__last = __val;
  }
  template < typename _RandomAccessIterator, typename _Compare >
  void __unguarded_linear_insert(_RandomAccessIterator __last, _Compare __comp);
  template < typename _RandomAccessIterator, typename _Compare >
  void __unguarded_linear_insert(_RandomAccessIterator __last, _Compare __comp)
  {
    typename ::std::iterator_traits<_RandomAccessIterator>::value_type __val = *__last;
    _RandomAccessIterator __next = __last;
    --__next;
    while (__comp(__val, *__next))
      {
        *__last = *__next;
        __last = __next;
        --__next;
      }
    *__last = __val;
  }
  template < typename _RandomAccessIterator >
  void __insertion_sort(_RandomAccessIterator __first, _RandomAccessIterator __last);
  template < typename _RandomAccessIterator >
  void __insertion_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
  {
    if (__first == __last)
      {
        return ;
      }
    for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
      {
        if (*__i < *__first)
          {
            typename ::std::iterator_traits<_RandomAccessIterator>::value_type __val = *__i;
            std::copy_backward(__first, __i, __i + 1);
            *__first = __val;
          }
        else
          {
            std::__unguarded_linear_insert(__i);
          }
      }
  }
  template < typename _RandomAccessIterator, typename _Compare >
  void __insertion_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp);
  template < typename _RandomAccessIterator, typename _Compare >
  void __insertion_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
  {
    if (__first == __last)
      {
        return ;
      }
    for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
      {
        if (__comp(*__i, *__first))
          {
            typename ::std::iterator_traits<_RandomAccessIterator>::value_type __val = *__i;
            std::copy_backward(__first, __i, __i + 1);
            *__first = __val;
          }
        else
          {
            std::__unguarded_linear_insert(__i, __comp);
          }
      }
  }
  template < typename _RandomAccessIterator >
  inline void __unguarded_insertion_sort(_RandomAccessIterator __first, _RandomAccessIterator __last);
  template < typename _RandomAccessIterator >
  inline void __unguarded_insertion_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
  {
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::value_type _ValueType;
    for (_RandomAccessIterator __i = __first; __i != __last; ++__i)
      {
        std::__unguarded_linear_insert(__i);
      }
  }
  template < typename _RandomAccessIterator, typename _Compare >
  inline void __unguarded_insertion_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp);
  template < typename _RandomAccessIterator, typename _Compare >
  inline void __unguarded_insertion_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
  {
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::value_type _ValueType;
    for (_RandomAccessIterator __i = __first; __i != __last; ++__i)
      {
        std::__unguarded_linear_insert(__i, __comp);
      }
  }
  enum mcc_enum_anon_63
  {
    _S_threshold = 16
  };
  template < typename _RandomAccessIterator >
  void __final_insertion_sort(_RandomAccessIterator __first, _RandomAccessIterator __last);
  template < typename _RandomAccessIterator >
  void __final_insertion_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
  {
    if (__last - __first > (int)::std::_S_threshold)
      {
        std::__insertion_sort(__first, __first + (int)::std::_S_threshold);
        std::__unguarded_insertion_sort(__first + (int)::std::_S_threshold, __last);
      }
    else
      {
        std::__insertion_sort(__first, __last);
      }
  }
  template < typename _RandomAccessIterator, typename _Compare >
  void __final_insertion_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp);
  template < typename _RandomAccessIterator, typename _Compare >
  void __final_insertion_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
  {
    if (__last - __first > (int)::std::_S_threshold)
      {
        std::__insertion_sort(__first, __first + (int)::std::_S_threshold, __comp);
        std::__unguarded_insertion_sort(__first + (int)::std::_S_threshold, __last, __comp);
      }
    else
      {
        std::__insertion_sort(__first, __last, __comp);
      }
  }
  template < typename _RandomAccessIterator, typename _Tp >
  _RandomAccessIterator __unguarded_partition(_RandomAccessIterator __first, _RandomAccessIterator __last, const _Tp &__pivot);
  template < typename _RandomAccessIterator, typename _Tp >
  _RandomAccessIterator __unguarded_partition(_RandomAccessIterator __first, _RandomAccessIterator __last, const _Tp &__pivot)
  {
    while (true)
      {
        while (*__first < __pivot)
          {
            ++__first;
          }
        --__last;
        while (__pivot < *__last)
          {
            --__last;
          }
        if (!(__first < __last))
          {
            return __first;
          }
        std::iter_swap(__first, __last);
        ++__first;
      }
  }
  template < typename _RandomAccessIterator, typename _Tp, typename _Compare >
  _RandomAccessIterator __unguarded_partition(_RandomAccessIterator __first, _RandomAccessIterator __last, const _Tp &__pivot, _Compare __comp);
  template < typename _RandomAccessIterator, typename _Tp, typename _Compare >
  _RandomAccessIterator __unguarded_partition(_RandomAccessIterator __first, _RandomAccessIterator __last, const _Tp &__pivot, _Compare __comp)
  {
    while (true)
      {
        while (__comp(*__first, __pivot))
          {
            ++__first;
          }
        --__last;
        while (__comp(__pivot, *__last))
          {
            --__last;
          }
        if (!(__first < __last))
          {
            return __first;
          }
        std::iter_swap(__first, __last);
        ++__first;
      }
  }
  template < typename _RandomAccessIterator >
  inline _RandomAccessIterator __unguarded_partition_pivot(_RandomAccessIterator __first, _RandomAccessIterator __last);
  template < typename _RandomAccessIterator >
  inline _RandomAccessIterator __unguarded_partition_pivot(_RandomAccessIterator __first, _RandomAccessIterator __last)
  {
    _RandomAccessIterator __mid = __first + (__last - __first) / 2;
    std::__move_median_first(__first, __mid, __last - 1);
    return std::__unguarded_partition(__first + 1, __last, *__first);
  }
  template < typename _RandomAccessIterator, typename _Compare >
  inline _RandomAccessIterator __unguarded_partition_pivot(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp);
  template < typename _RandomAccessIterator, typename _Compare >
  inline _RandomAccessIterator __unguarded_partition_pivot(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
  {
    _RandomAccessIterator __mid = __first + (__last - __first) / 2;
    std::__move_median_first(__first, __mid, __last - 1, __comp);
    return std::__unguarded_partition(__first + 1, __last, *__first, __comp);
  }
  template < typename _RandomAccessIterator, typename _Size >
  void __introsort_loop(_RandomAccessIterator __first, _RandomAccessIterator __last, _Size __depth_limit);
  template < typename _RandomAccessIterator, typename _Size >
  void __introsort_loop(_RandomAccessIterator __first, _RandomAccessIterator __last, _Size __depth_limit)
  {
    while (__last - __first > (int)::std::_S_threshold)
      {
        if (__depth_limit == 0)
          {
            std::partial_sort(__first, __last, __last);
            return ;
          }
        --__depth_limit;
        _RandomAccessIterator __cut = std::__unguarded_partition_pivot(__first, __last);
        std::__introsort_loop(__cut, __last, __depth_limit);
        __last = __cut;
      }
  }
  template < typename _RandomAccessIterator, typename _Size, typename _Compare >
  void __introsort_loop(_RandomAccessIterator __first, _RandomAccessIterator __last, _Size __depth_limit, _Compare __comp);
  template < typename _RandomAccessIterator, typename _Size, typename _Compare >
  void __introsort_loop(_RandomAccessIterator __first, _RandomAccessIterator __last, _Size __depth_limit, _Compare __comp)
  {
    while (__last - __first > (int)::std::_S_threshold)
      {
        if (__depth_limit == 0)
          {
            std::partial_sort(__first, __last, __last, __comp);
            return ;
          }
        --__depth_limit;
        _RandomAccessIterator __cut = std::__unguarded_partition_pivot(__first, __last, __comp);
        std::__introsort_loop(__cut, __last, __depth_limit, __comp);
        __last = __cut;
      }
  }
  template < typename _RandomAccessIterator, typename _Size >
  void __introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Size __depth_limit);
  template < typename _RandomAccessIterator, typename _Size >
  void __introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Size __depth_limit)
  {
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::value_type _ValueType;
    while (__last - __first > 3)
      {
        if (__depth_limit == 0)
          {
            std::__heap_select(__first, __nth + 1, __last);
            std::iter_swap(__first, __nth);
            return ;
          }
        --__depth_limit;
        _RandomAccessIterator __cut = std::__unguarded_partition_pivot(__first, __last);
        if (__cut <= __nth)
          {
            __first = __cut;
          }
        else
          {
            __last = __cut;
          }
      }
    std::__insertion_sort(__first, __last);
  }
  template < typename _RandomAccessIterator, typename _Size, typename _Compare >
  void __introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Size __depth_limit, _Compare __comp);
  template < typename _RandomAccessIterator, typename _Size, typename _Compare >
  void __introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Size __depth_limit, _Compare __comp)
  {
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::value_type _ValueType;
    while (__last - __first > 3)
      {
        if (__depth_limit == 0)
          {
            std::__heap_select(__first, __nth + 1, __last, __comp);
            std::iter_swap(__first, __nth);
            return ;
          }
        --__depth_limit;
        _RandomAccessIterator __cut = std::__unguarded_partition_pivot(__first, __last, __comp);
        if (__cut <= __nth)
          {
            __first = __cut;
          }
        else
          {
            __last = __cut;
          }
      }
    std::__insertion_sort(__first, __last, __comp);
  }
  template < typename _ForwardIterator, typename _Tp, typename _Compare >
  _ForwardIterator lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val, _Compare __comp)
  {
    typedef typename ::std::iterator_traits<_ForwardIterator>::value_type _ValueType;
    typedef typename ::std::iterator_traits<_ForwardIterator>::difference_type _DistanceType;
    ;
    _DistanceType __len = std::distance(__first, __last);
    while (__len > 0)
      {
        _DistanceType __half = __len >> 1;
        _ForwardIterator __middle = __first;
        std::advance(__middle, __half);
        if (__comp(*__middle, __val))
          {
            __first = __middle;
            ++__first;
            __len = __len - __half - 1;
          }
        else
          {
            __len = __half;
          }
      }
    return __first;
  }
  template < typename _ForwardIterator, typename _Tp >
  _ForwardIterator upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val)
  {
    typedef typename ::std::iterator_traits<_ForwardIterator>::value_type _ValueType;
    typedef typename ::std::iterator_traits<_ForwardIterator>::difference_type _DistanceType;
    ;
    _DistanceType __len = std::distance(__first, __last);
    while (__len > 0)
      {
        _DistanceType __half = __len >> 1;
        _ForwardIterator __middle = __first;
        std::advance(__middle, __half);
        if (__val < *__middle)
          {
            __len = __half;
          }
        else
          {
            __first = __middle;
            ++__first;
            __len = __len - __half - 1;
          }
      }
    return __first;
  }
  template < typename _ForwardIterator, typename _Tp, typename _Compare >
  _ForwardIterator upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val, _Compare __comp)
  {
    typedef typename ::std::iterator_traits<_ForwardIterator>::value_type _ValueType;
    typedef typename ::std::iterator_traits<_ForwardIterator>::difference_type _DistanceType;
    ;
    _DistanceType __len = std::distance(__first, __last);
    while (__len > 0)
      {
        _DistanceType __half = __len >> 1;
        _ForwardIterator __middle = __first;
        std::advance(__middle, __half);
        if (__comp(__val, *__middle))
          {
            __len = __half;
          }
        else
          {
            __first = __middle;
            ++__first;
            __len = __len - __half - 1;
          }
      }
    return __first;
  }
  template < typename _ForwardIterator, typename _Tp >
  ::std::pair<_ForwardIterator, _ForwardIterator> equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val)
  {
    typedef typename ::std::iterator_traits<_ForwardIterator>::value_type _ValueType;
    typedef typename ::std::iterator_traits<_ForwardIterator>::difference_type _DistanceType;
    ;
    ;
    _DistanceType __len = std::distance(__first, __last);
    while (__len > 0)
      {
        _DistanceType __half = __len >> 1;
        _ForwardIterator __middle = __first;
        std::advance(__middle, __half);
        if (*__middle < __val)
          {
            __first = __middle;
            ++__first;
            __len = __len - __half - 1;
          }
        else
          {
            if (__val < *__middle)
              {
                __len = __half;
              }
            else
              {
                _ForwardIterator __left = std::lower_bound(__first, __middle, __val);
                std::advance(__first, __len);
                _ForwardIterator __right = std::upper_bound(++__middle, __first, __val);
                return ::std::pair<_ForwardIterator, _ForwardIterator>(__left, __right);
              }
          }
      }
    return ::std::pair<_ForwardIterator, _ForwardIterator>(__first, __first);
  }
  template < typename _ForwardIterator, typename _Tp, typename _Compare >
  ::std::pair<_ForwardIterator, _ForwardIterator> equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val, _Compare __comp)
  {
    typedef typename ::std::iterator_traits<_ForwardIterator>::value_type _ValueType;
    typedef typename ::std::iterator_traits<_ForwardIterator>::difference_type _DistanceType;
    ;
    ;
    _DistanceType __len = std::distance(__first, __last);
    while (__len > 0)
      {
        _DistanceType __half = __len >> 1;
        _ForwardIterator __middle = __first;
        std::advance(__middle, __half);
        if (__comp(*__middle, __val))
          {
            __first = __middle;
            ++__first;
            __len = __len - __half - 1;
          }
        else
          {
            if (__comp(__val, *__middle))
              {
                __len = __half;
              }
            else
              {
                _ForwardIterator __left = std::lower_bound(__first, __middle, __val, __comp);
                std::advance(__first, __len);
                _ForwardIterator __right = std::upper_bound(++__middle, __first, __val, __comp);
                return ::std::pair<_ForwardIterator, _ForwardIterator>(__left, __right);
              }
          }
      }
    return ::std::pair<_ForwardIterator, _ForwardIterator>(__first, __first);
  }
  template < typename _ForwardIterator, typename _Tp >
  bool binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val)
  {
    typedef typename ::std::iterator_traits<_ForwardIterator>::value_type _ValueType;
    ;
    ;
    _ForwardIterator __i = std::lower_bound(__first, __last, __val);
    return __i != __last && !(__val < *__i);
  }
  template < typename _ForwardIterator, typename _Tp, typename _Compare >
  bool binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val, _Compare __comp)
  {
    typedef typename ::std::iterator_traits<_ForwardIterator>::value_type _ValueType;
    ;
    ;
    _ForwardIterator __i = std::lower_bound(__first, __last, __val, __comp);
    return __i != __last && !((bool)__comp(__val, *__i));
  }
  template < typename _InputIterator1, typename _InputIterator2, typename _OutputIterator >
  void __move_merge_adaptive(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result);
  template < typename _InputIterator1, typename _InputIterator2, typename _OutputIterator >
  void __move_merge_adaptive(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
  {
    while (__first1 != __last1 && __first2 != __last2)
      {
        if (*__first2 < *__first1)
          {
            *__result = *__first2;
            ++__first2;
          }
        else
          {
            *__result = *__first1;
            ++__first1;
          }
        ++__result;
      }
    if (__first1 != __last1)
      {
        std::copy(__first1, __last1, __result);
      }
  }
  template < typename _InputIterator1, typename _InputIterator2, typename _OutputIterator, typename _Compare >
  void __move_merge_adaptive(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp);
  template < typename _InputIterator1, typename _InputIterator2, typename _OutputIterator, typename _Compare >
  void __move_merge_adaptive(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
  {
    while (__first1 != __last1 && __first2 != __last2)
      {
        if (__comp(*__first2, *__first1))
          {
            *__result = *__first2;
            ++__first2;
          }
        else
          {
            *__result = *__first1;
            ++__first1;
          }
        ++__result;
      }
    if (__first1 != __last1)
      {
        std::copy(__first1, __last1, __result);
      }
  }
  template < typename _BidirectionalIterator1, typename _BidirectionalIterator2, typename _BidirectionalIterator3 >
  void __move_merge_adaptive_backward(_BidirectionalIterator1 __first1, _BidirectionalIterator1 __last1, _BidirectionalIterator2 __first2, _BidirectionalIterator2 __last2, _BidirectionalIterator3 __result);
  template < typename _BidirectionalIterator1, typename _BidirectionalIterator2, typename _BidirectionalIterator3 >
  void __move_merge_adaptive_backward(_BidirectionalIterator1 __first1, _BidirectionalIterator1 __last1, _BidirectionalIterator2 __first2, _BidirectionalIterator2 __last2, _BidirectionalIterator3 __result)
  {
    if (__first1 == __last1)
      {
        std::copy_backward(__first2, __last2, __result);
        return ;
      }
    else
      {
        if (__first2 == __last2)
          {
            return ;
          }
      }
    --__last1;
    --__last2;
    while (true)
      {
        if (*__last2 < *__last1)
          {
            *--__result = *__last1;
            if (__first1 == __last1)
              {
                std::copy_backward(__first2, ++__last2, __result);
                return ;
              }
            --__last1;
          }
        else
          {
            *--__result = *__last2;
            if (__first2 == __last2)
              {
                return ;
              }
            --__last2;
          }
      }
  }
  template < typename _BidirectionalIterator1, typename _BidirectionalIterator2, typename _BidirectionalIterator3, typename _Compare >
  void __move_merge_adaptive_backward(_BidirectionalIterator1 __first1, _BidirectionalIterator1 __last1, _BidirectionalIterator2 __first2, _BidirectionalIterator2 __last2, _BidirectionalIterator3 __result, _Compare __comp);
  template < typename _BidirectionalIterator1, typename _BidirectionalIterator2, typename _BidirectionalIterator3, typename _Compare >
  void __move_merge_adaptive_backward(_BidirectionalIterator1 __first1, _BidirectionalIterator1 __last1, _BidirectionalIterator2 __first2, _BidirectionalIterator2 __last2, _BidirectionalIterator3 __result, _Compare __comp)
  {
    if (__first1 == __last1)
      {
        std::copy_backward(__first2, __last2, __result);
        return ;
      }
    else
      {
        if (__first2 == __last2)
          {
            return ;
          }
      }
    --__last1;
    --__last2;
    while (true)
      {
        if (__comp(*__last2, *__last1))
          {
            *--__result = *__last1;
            if (__first1 == __last1)
              {
                std::copy_backward(__first2, ++__last2, __result);
                return ;
              }
            --__last1;
          }
        else
          {
            *--__result = *__last2;
            if (__first2 == __last2)
              {
                return ;
              }
            --__last2;
          }
      }
  }
  template < typename _BidirectionalIterator1, typename _BidirectionalIterator2, typename _Distance >
  _BidirectionalIterator1 __rotate_adaptive(_BidirectionalIterator1 __first, _BidirectionalIterator1 __middle, _BidirectionalIterator1 __last, _Distance __len1, _Distance __len2, _BidirectionalIterator2 __buffer, _Distance __buffer_size);
  template < typename _BidirectionalIterator1, typename _BidirectionalIterator2, typename _Distance >
  _BidirectionalIterator1 __rotate_adaptive(_BidirectionalIterator1 __first, _BidirectionalIterator1 __middle, _BidirectionalIterator1 __last, _Distance __len1, _Distance __len2, _BidirectionalIterator2 __buffer, _Distance __buffer_size)
  {
    _BidirectionalIterator2 __buffer_end;
    if (__len1 > __len2 && __len2 <= __buffer_size)
      {
        if (__len2)
          {
            __buffer_end = std::copy(__middle, __last, __buffer);
            std::copy_backward(__first, __middle, __last);
            return std::copy(__buffer, __buffer_end, __first);
          }
        else
          {
            return __first;
          }
      }
    else
      {
        if (__len1 <= __buffer_size)
          {
            if (__len1)
              {
                __buffer_end = std::copy(__first, __middle, __buffer);
                std::copy(__middle, __last, __first);
                return std::copy_backward(__buffer, __buffer_end, __last);
              }
            else
              {
                return __last;
              }
          }
        else
          {
            std::rotate(__first, __middle, __last);
            std::advance(__first, std::distance(__middle, __last));
            return __first;
          }
      }
  }
  template < typename _BidirectionalIterator, typename _Distance, typename _Pointer >
  void __merge_adaptive(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last, _Distance __len1, _Distance __len2, _Pointer __buffer, _Distance __buffer_size);
  template < typename _BidirectionalIterator, typename _Distance, typename _Pointer >
  void __merge_adaptive(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last, _Distance __len1, _Distance __len2, _Pointer __buffer, _Distance __buffer_size)
  {
    if (__len1 <= __len2 && __len1 <= __buffer_size)
      {
        _Pointer __buffer_end = std::copy(__first, __middle, __buffer);
        std::__move_merge_adaptive(__buffer, __buffer_end, __middle, __last, __first);
      }
    else
      {
        if (__len2 <= __buffer_size)
          {
            _Pointer __buffer_end = std::copy(__middle, __last, __buffer);
            std::__move_merge_adaptive_backward(__first, __middle, __buffer, __buffer_end, __last);
          }
        else
          {
            _BidirectionalIterator __first_cut = __first;
            _BidirectionalIterator __second_cut = __middle;
            _Distance __len11 = 0;
            _Distance __len22 = 0;
            if (__len1 > __len2)
              {
                __len11 = __len1 / 2;
                std::advance(__first_cut, __len11);
                __second_cut = std::lower_bound(__middle, __last, *__first_cut);
                __len22 = std::distance(__middle, __second_cut);
              }
            else
              {
                __len22 = __len2 / 2;
                std::advance(__second_cut, __len22);
                __first_cut = std::upper_bound(__first, __middle, *__second_cut);
                __len11 = std::distance(__first, __first_cut);
              }
            _BidirectionalIterator __new_middle = std::__rotate_adaptive(__first_cut, __middle, __second_cut, __len1 - __len11, __len22, __buffer, __buffer_size);
            std::__merge_adaptive(__first, __first_cut, __new_middle, __len11, __len22, __buffer, __buffer_size);
            std::__merge_adaptive(__new_middle, __second_cut, __last, __len1 - __len11, __len2 - __len22, __buffer, __buffer_size);
          }
      }
  }
  template < typename _BidirectionalIterator, typename _Distance, typename _Pointer, typename _Compare >
  void __merge_adaptive(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last, _Distance __len1, _Distance __len2, _Pointer __buffer, _Distance __buffer_size, _Compare __comp);
  template < typename _BidirectionalIterator, typename _Distance, typename _Pointer, typename _Compare >
  void __merge_adaptive(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last, _Distance __len1, _Distance __len2, _Pointer __buffer, _Distance __buffer_size, _Compare __comp)
  {
    if (__len1 <= __len2 && __len1 <= __buffer_size)
      {
        _Pointer __buffer_end = std::copy(__first, __middle, __buffer);
        std::__move_merge_adaptive(__buffer, __buffer_end, __middle, __last, __first, __comp);
      }
    else
      {
        if (__len2 <= __buffer_size)
          {
            _Pointer __buffer_end = std::copy(__middle, __last, __buffer);
            std::__move_merge_adaptive_backward(__first, __middle, __buffer, __buffer_end, __last, __comp);
          }
        else
          {
            _BidirectionalIterator __first_cut = __first;
            _BidirectionalIterator __second_cut = __middle;
            _Distance __len11 = 0;
            _Distance __len22 = 0;
            if (__len1 > __len2)
              {
                __len11 = __len1 / 2;
                std::advance(__first_cut, __len11);
                __second_cut = std::lower_bound(__middle, __last, *__first_cut, __comp);
                __len22 = std::distance(__middle, __second_cut);
              }
            else
              {
                __len22 = __len2 / 2;
                std::advance(__second_cut, __len22);
                __first_cut = std::upper_bound(__first, __middle, *__second_cut, __comp);
                __len11 = std::distance(__first, __first_cut);
              }
            _BidirectionalIterator __new_middle = std::__rotate_adaptive(__first_cut, __middle, __second_cut, __len1 - __len11, __len22, __buffer, __buffer_size);
            std::__merge_adaptive(__first, __first_cut, __new_middle, __len11, __len22, __buffer, __buffer_size, __comp);
            std::__merge_adaptive(__new_middle, __second_cut, __last, __len1 - __len11, __len2 - __len22, __buffer, __buffer_size, __comp);
          }
      }
  }
  template < typename _BidirectionalIterator, typename _Distance >
  void __merge_without_buffer(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last, _Distance __len1, _Distance __len2);
  template < typename _BidirectionalIterator, typename _Distance >
  void __merge_without_buffer(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last, _Distance __len1, _Distance __len2)
  {
    if (__len1 == 0 || __len2 == 0)
      {
        return ;
      }
    if (__len1 + __len2 == 2)
      {
        if (*__middle < *__first)
          {
            std::iter_swap(__first, __middle);
          }
        return ;
      }
    _BidirectionalIterator __first_cut = __first;
    _BidirectionalIterator __second_cut = __middle;
    _Distance __len11 = 0;
    _Distance __len22 = 0;
    if (__len1 > __len2)
      {
        __len11 = __len1 / 2;
        std::advance(__first_cut, __len11);
        __second_cut = std::lower_bound(__middle, __last, *__first_cut);
        __len22 = std::distance(__middle, __second_cut);
      }
    else
      {
        __len22 = __len2 / 2;
        std::advance(__second_cut, __len22);
        __first_cut = std::upper_bound(__first, __middle, *__second_cut);
        __len11 = std::distance(__first, __first_cut);
      }
    std::rotate(__first_cut, __middle, __second_cut);
    _BidirectionalIterator __new_middle = __first_cut;
    std::advance(__new_middle, std::distance(__middle, __second_cut));
    std::__merge_without_buffer(__first, __first_cut, __new_middle, __len11, __len22);
    std::__merge_without_buffer(__new_middle, __second_cut, __last, __len1 - __len11, __len2 - __len22);
  }
  template < typename _BidirectionalIterator, typename _Distance, typename _Compare >
  void __merge_without_buffer(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last, _Distance __len1, _Distance __len2, _Compare __comp);
  template < typename _BidirectionalIterator, typename _Distance, typename _Compare >
  void __merge_without_buffer(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last, _Distance __len1, _Distance __len2, _Compare __comp)
  {
    if (__len1 == 0 || __len2 == 0)
      {
        return ;
      }
    if (__len1 + __len2 == 2)
      {
        if (__comp(*__middle, *__first))
          {
            std::iter_swap(__first, __middle);
          }
        return ;
      }
    _BidirectionalIterator __first_cut = __first;
    _BidirectionalIterator __second_cut = __middle;
    _Distance __len11 = 0;
    _Distance __len22 = 0;
    if (__len1 > __len2)
      {
        __len11 = __len1 / 2;
        std::advance(__first_cut, __len11);
        __second_cut = std::lower_bound(__middle, __last, *__first_cut, __comp);
        __len22 = std::distance(__middle, __second_cut);
      }
    else
      {
        __len22 = __len2 / 2;
        std::advance(__second_cut, __len22);
        __first_cut = std::upper_bound(__first, __middle, *__second_cut, __comp);
        __len11 = std::distance(__first, __first_cut);
      }
    std::rotate(__first_cut, __middle, __second_cut);
    _BidirectionalIterator __new_middle = __first_cut;
    std::advance(__new_middle, std::distance(__middle, __second_cut));
    std::__merge_without_buffer(__first, __first_cut, __new_middle, __len11, __len22, __comp);
    std::__merge_without_buffer(__new_middle, __second_cut, __last, __len1 - __len11, __len2 - __len22, __comp);
  }
  template < typename _BidirectionalIterator >
  void inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last)
  {
    typedef typename ::std::iterator_traits<_BidirectionalIterator>::value_type _ValueType;
    typedef typename ::std::iterator_traits<_BidirectionalIterator>::difference_type _DistanceType;
    ;
    ;
    if (__first == __middle || __middle == __last)
      {
        return ;
      }
    _DistanceType __len1 = std::distance(__first, __middle);
    _DistanceType __len2 = std::distance(__middle, __last);
    ::std::_Temporary_buffer<_BidirectionalIterator, _ValueType> __buf(__first, __last);
    if (__buf.begin() == 0)
      {
        std::__merge_without_buffer(__first, __middle, __last, __len1, __len2);
      }
    else
      {
        std::__merge_adaptive(__first, __middle, __last, __len1, __len2, __buf.begin(), _DistanceType(__buf.size()));
      }
  }
  template < typename _BidirectionalIterator, typename _Compare >
  void inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last, _Compare __comp)
  {
    typedef typename ::std::iterator_traits<_BidirectionalIterator>::value_type _ValueType;
    typedef typename ::std::iterator_traits<_BidirectionalIterator>::difference_type _DistanceType;
    ;
    ;
    if (__first == __middle || __middle == __last)
      {
        return ;
      }
    const _DistanceType __len1 = std::distance(__first, __middle);
    const _DistanceType __len2 = std::distance(__middle, __last);
    ::std::_Temporary_buffer<_BidirectionalIterator, _ValueType> __buf(__first, __last);
    if (__buf.begin() == 0)
      {
        std::__merge_without_buffer(__first, __middle, __last, __len1, __len2, __comp);
      }
    else
      {
        std::__merge_adaptive(__first, __middle, __last, __len1, __len2, __buf.begin(), _DistanceType(__buf.size()), __comp);
      }
  }
  template < typename _InputIterator1, typename _InputIterator2, typename _OutputIterator >
  _OutputIterator __move_merge(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result);
  template < typename _InputIterator1, typename _InputIterator2, typename _OutputIterator >
  _OutputIterator __move_merge(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
  {
    while (__first1 != __last1 && __first2 != __last2)
      {
        if (*__first2 < *__first1)
          {
            *__result = *__first2;
            ++__first2;
          }
        else
          {
            *__result = *__first1;
            ++__first1;
          }
        ++__result;
      }
    return std::copy(__first2, __last2, std::copy(__first1, __last1, __result));
  }
  template < typename _InputIterator1, typename _InputIterator2, typename _OutputIterator, typename _Compare >
  _OutputIterator __move_merge(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp);
  template < typename _InputIterator1, typename _InputIterator2, typename _OutputIterator, typename _Compare >
  _OutputIterator __move_merge(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
  {
    while (__first1 != __last1 && __first2 != __last2)
      {
        if (__comp(*__first2, *__first1))
          {
            *__result = *__first2;
            ++__first2;
          }
        else
          {
            *__result = *__first1;
            ++__first1;
          }
        ++__result;
      }
    return std::copy(__first2, __last2, std::copy(__first1, __last1, __result));
  }
  template < typename _RandomAccessIterator1, typename _RandomAccessIterator2, typename _Distance >
  void __merge_sort_loop(_RandomAccessIterator1 __first, _RandomAccessIterator1 __last, _RandomAccessIterator2 __result, _Distance __step_size);
  template < typename _RandomAccessIterator1, typename _RandomAccessIterator2, typename _Distance >
  void __merge_sort_loop(_RandomAccessIterator1 __first, _RandomAccessIterator1 __last, _RandomAccessIterator2 __result, _Distance __step_size)
  {
    const _Distance __two_step = 2 * __step_size;
    while (__last - __first >= __two_step)
      {
        __result = std::__move_merge(__first, __first + __step_size, __first + __step_size, __first + __two_step, __result);
        __first += __two_step;
      }
    __step_size = std::min(_Distance(__last - __first), __step_size);
    std::__move_merge(__first, __first + __step_size, __first + __step_size, __last, __result);
  }
  template < typename _RandomAccessIterator1, typename _RandomAccessIterator2, typename _Distance, typename _Compare >
  void __merge_sort_loop(_RandomAccessIterator1 __first, _RandomAccessIterator1 __last, _RandomAccessIterator2 __result, _Distance __step_size, _Compare __comp);
  template < typename _RandomAccessIterator1, typename _RandomAccessIterator2, typename _Distance, typename _Compare >
  void __merge_sort_loop(_RandomAccessIterator1 __first, _RandomAccessIterator1 __last, _RandomAccessIterator2 __result, _Distance __step_size, _Compare __comp)
  {
    const _Distance __two_step = 2 * __step_size;
    while (__last - __first >= __two_step)
      {
        __result = std::__move_merge(__first, __first + __step_size, __first + __step_size, __first + __two_step, __result, __comp);
        __first += __two_step;
      }
    __step_size = std::min(_Distance(__last - __first), __step_size);
    std::__move_merge(__first, __first + __step_size, __first + __step_size, __last, __result, __comp);
  }
  template < typename _RandomAccessIterator, typename _Distance >
  void __chunk_insertion_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Distance __chunk_size);
  template < typename _RandomAccessIterator, typename _Distance >
  void __chunk_insertion_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Distance __chunk_size)
  {
    while (__last - __first >= __chunk_size)
      {
        std::__insertion_sort(__first, __first + __chunk_size);
        __first += __chunk_size;
      }
    std::__insertion_sort(__first, __last);
  }
  template < typename _RandomAccessIterator, typename _Distance, typename _Compare >
  void __chunk_insertion_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Distance __chunk_size, _Compare __comp);
  template < typename _RandomAccessIterator, typename _Distance, typename _Compare >
  void __chunk_insertion_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Distance __chunk_size, _Compare __comp)
  {
    while (__last - __first >= __chunk_size)
      {
        std::__insertion_sort(__first, __first + __chunk_size, __comp);
        __first += __chunk_size;
      }
    std::__insertion_sort(__first, __last, __comp);
  }
  enum mcc_enum_anon_64
  {
    _S_chunk_size = 7
  };
  template < typename _RandomAccessIterator, typename _Pointer >
  void __merge_sort_with_buffer(_RandomAccessIterator __first, _RandomAccessIterator __last, _Pointer __buffer);
  template < typename _RandomAccessIterator, typename _Pointer >
  void __merge_sort_with_buffer(_RandomAccessIterator __first, _RandomAccessIterator __last, _Pointer __buffer)
  {
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::difference_type _Distance;
    const _Distance __len = __last - __first;
    const _Pointer __buffer_last = __buffer + __len;
    _Distance __step_size = ::std::_S_chunk_size;
    std::__chunk_insertion_sort(__first, __last, __step_size);
    while (__step_size < __len)
      {
        std::__merge_sort_loop(__first, __last, __buffer, __step_size);
        __step_size *= 2;
        std::__merge_sort_loop(__buffer, __buffer_last, __first, __step_size);
        __step_size *= 2;
      }
  }
  template < typename _RandomAccessIterator, typename _Pointer, typename _Compare >
  void __merge_sort_with_buffer(_RandomAccessIterator __first, _RandomAccessIterator __last, _Pointer __buffer, _Compare __comp);
  template < typename _RandomAccessIterator, typename _Pointer, typename _Compare >
  void __merge_sort_with_buffer(_RandomAccessIterator __first, _RandomAccessIterator __last, _Pointer __buffer, _Compare __comp)
  {
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::difference_type _Distance;
    const _Distance __len = __last - __first;
    const _Pointer __buffer_last = __buffer + __len;
    _Distance __step_size = ::std::_S_chunk_size;
    std::__chunk_insertion_sort(__first, __last, __step_size, __comp);
    while (__step_size < __len)
      {
        std::__merge_sort_loop(__first, __last, __buffer, __step_size, __comp);
        __step_size *= 2;
        std::__merge_sort_loop(__buffer, __buffer_last, __first, __step_size, __comp);
        __step_size *= 2;
      }
  }
  template < typename _RandomAccessIterator, typename _Pointer, typename _Distance >
  void __stable_sort_adaptive(_RandomAccessIterator __first, _RandomAccessIterator __last, _Pointer __buffer, _Distance __buffer_size);
  template < typename _RandomAccessIterator, typename _Pointer, typename _Distance >
  void __stable_sort_adaptive(_RandomAccessIterator __first, _RandomAccessIterator __last, _Pointer __buffer, _Distance __buffer_size)
  {
    const _Distance __len = (__last - __first + 1) / 2;
    const _RandomAccessIterator __middle = __first + __len;
    if (__len > __buffer_size)
      {
        std::__stable_sort_adaptive(__first, __middle, __buffer, __buffer_size);
        std::__stable_sort_adaptive(__middle, __last, __buffer, __buffer_size);
      }
    else
      {
        std::__merge_sort_with_buffer(__first, __middle, __buffer);
        std::__merge_sort_with_buffer(__middle, __last, __buffer);
      }
    std::__merge_adaptive(__first, __middle, __last, _Distance(__middle - __first), _Distance(__last - __middle), __buffer, __buffer_size);
  }
  template < typename _RandomAccessIterator, typename _Pointer, typename _Distance, typename _Compare >
  void __stable_sort_adaptive(_RandomAccessIterator __first, _RandomAccessIterator __last, _Pointer __buffer, _Distance __buffer_size, _Compare __comp);
  template < typename _RandomAccessIterator, typename _Pointer, typename _Distance, typename _Compare >
  void __stable_sort_adaptive(_RandomAccessIterator __first, _RandomAccessIterator __last, _Pointer __buffer, _Distance __buffer_size, _Compare __comp)
  {
    const _Distance __len = (__last - __first + 1) / 2;
    const _RandomAccessIterator __middle = __first + __len;
    if (__len > __buffer_size)
      {
        std::__stable_sort_adaptive(__first, __middle, __buffer, __buffer_size, __comp);
        std::__stable_sort_adaptive(__middle, __last, __buffer, __buffer_size, __comp);
      }
    else
      {
        std::__merge_sort_with_buffer(__first, __middle, __buffer, __comp);
        std::__merge_sort_with_buffer(__middle, __last, __buffer, __comp);
      }
    std::__merge_adaptive(__first, __middle, __last, _Distance(__middle - __first), _Distance(__last - __middle), __buffer, __buffer_size, __comp);
  }
  template < typename _RandomAccessIterator >
  void __inplace_stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last);
  template < typename _RandomAccessIterator >
  void __inplace_stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
  {
    if (__last - __first < 15)
      {
        std::__insertion_sort(__first, __last);
        return ;
      }
    _RandomAccessIterator __middle = __first + (__last - __first) / 2;
    std::__inplace_stable_sort(__first, __middle);
    std::__inplace_stable_sort(__middle, __last);
    std::__merge_without_buffer(__first, __middle, __last, __middle - __first, __last - __middle);
  }
  template < typename _RandomAccessIterator, typename _Compare >
  void __inplace_stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp);
  template < typename _RandomAccessIterator, typename _Compare >
  void __inplace_stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
  {
    if (__last - __first < 15)
      {
        std::__insertion_sort(__first, __last, __comp);
        return ;
      }
    _RandomAccessIterator __middle = __first + (__last - __first) / 2;
    std::__inplace_stable_sort(__first, __middle, __comp);
    std::__inplace_stable_sort(__middle, __last, __comp);
    std::__merge_without_buffer(__first, __middle, __last, __middle - __first, __last - __middle, __comp);
  }
  template < typename _InputIterator1, typename _InputIterator2 >
  bool includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2)
  {
    typedef typename ::std::iterator_traits<_InputIterator1>::value_type _ValueType1;
    typedef typename ::std::iterator_traits<_InputIterator2>::value_type _ValueType2;
    ;
    ;
    while (__first1 != __last1 && __first2 != __last2)
      {
        if (*__first2 < *__first1)
          {
            return false;
          }
        else
          {
            if (*__first1 < *__first2)
              {
                ++__first1;
              }
            else
              {
                (++__first1, ++__first2);
              }
          }
      }
    return __first2 == __last2;
  }
  template < typename _InputIterator1, typename _InputIterator2, typename _Compare >
  bool includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)
  {
    typedef typename ::std::iterator_traits<_InputIterator1>::value_type _ValueType1;
    typedef typename ::std::iterator_traits<_InputIterator2>::value_type _ValueType2;
    ;
    ;
    while (__first1 != __last1 && __first2 != __last2)
      {
        if (__comp(*__first2, *__first1))
          {
            return false;
          }
        else
          {
            if (__comp(*__first1, *__first2))
              {
                ++__first1;
              }
            else
              {
                (++__first1, ++__first2);
              }
          }
      }
    return __first2 == __last2;
  }
  template < typename _BidirectionalIterator >
  bool next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)
  {
    ;
    if (__first == __last)
      {
        return false;
      }
    _BidirectionalIterator __i = __first;
    ++__i;
    if (__i == __last)
      {
        return false;
      }
    __i = __last;
    --__i;
    for (; ; )
      {
        _BidirectionalIterator __ii = __i;
        --__i;
        if (*__i < *__ii)
          {
            _BidirectionalIterator __j = __last;
            while (!(*__i < *--__j))
              {
              }
            std::iter_swap(__i, __j);
            std::reverse(__ii, __last);
            return true;
          }
        if (__i == __first)
          {
            std::reverse(__first, __last);
            return false;
          }
      }
  }
  template < typename _BidirectionalIterator, typename _Compare >
  bool next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)
  {
    ;
    if (__first == __last)
      {
        return false;
      }
    _BidirectionalIterator __i = __first;
    ++__i;
    if (__i == __last)
      {
        return false;
      }
    __i = __last;
    --__i;
    for (; ; )
      {
        _BidirectionalIterator __ii = __i;
        --__i;
        if (__comp(*__i, *__ii))
          {
            _BidirectionalIterator __j = __last;
            while (!((bool)__comp(*__i, *--__j)))
              {
              }
            std::iter_swap(__i, __j);
            std::reverse(__ii, __last);
            return true;
          }
        if (__i == __first)
          {
            std::reverse(__first, __last);
            return false;
          }
      }
  }
  template < typename _BidirectionalIterator >
  bool prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)
  {
    ;
    if (__first == __last)
      {
        return false;
      }
    _BidirectionalIterator __i = __first;
    ++__i;
    if (__i == __last)
      {
        return false;
      }
    __i = __last;
    --__i;
    for (; ; )
      {
        _BidirectionalIterator __ii = __i;
        --__i;
        if (*__ii < *__i)
          {
            _BidirectionalIterator __j = __last;
            while (!(*--__j < *__i))
              {
              }
            std::iter_swap(__i, __j);
            std::reverse(__ii, __last);
            return true;
          }
        if (__i == __first)
          {
            std::reverse(__first, __last);
            return false;
          }
      }
  }
  template < typename _BidirectionalIterator, typename _Compare >
  bool prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)
  {
    ;
    if (__first == __last)
      {
        return false;
      }
    _BidirectionalIterator __i = __first;
    ++__i;
    if (__i == __last)
      {
        return false;
      }
    __i = __last;
    --__i;
    for (; ; )
      {
        _BidirectionalIterator __ii = __i;
        --__i;
        if (__comp(*__ii, *__i))
          {
            _BidirectionalIterator __j = __last;
            while (!((bool)__comp(*--__j, *__i)))
              {
              }
            std::iter_swap(__i, __j);
            std::reverse(__ii, __last);
            return true;
          }
        if (__i == __first)
          {
            std::reverse(__first, __last);
            return false;
          }
      }
  }
  template < typename _InputIterator, typename _OutputIterator, typename _Tp >
  _OutputIterator replace_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, const _Tp &__old_value, const _Tp &__new_value)
  {
    ;
    for (; __first != __last; (++__first, ++__result))
      {
        if (*__first == __old_value)
          {
            *__result = __new_value;
          }
        else
          {
            *__result = *__first;
          }
      }
    return __result;
  }
  template < typename _InputIterator, typename _OutputIterator, typename _Predicate, typename _Tp >
  _OutputIterator replace_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _Predicate __pred, const _Tp &__new_value)
  {
    ;
    for (; __first != __last; (++__first, ++__result))
      {
        if (__pred(*__first))
          {
            *__result = __new_value;
          }
        else
          {
            *__result = *__first;
          }
      }
    return __result;
  }
  template < typename _InputIterator, typename _Function >
  _Function for_each(_InputIterator __first, _InputIterator __last, _Function __f)
  {
    ;
    for (; __first != __last; ++__first)
      {
        __f(*__first);
      }
    return __f;
  }
  template < typename _InputIterator, typename _Tp >
  inline _InputIterator find(_InputIterator __first, _InputIterator __last, const _Tp &__val)
  {
    ;
    return std::__find(__first, __last, __val, std::__iterator_category(__first));
  }
  template < typename _InputIterator, typename _Predicate >
  inline _InputIterator find_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
  {
    ;
    return std::__find_if(__first, __last, __pred, std::__iterator_category(__first));
  }
  template < typename _InputIterator, typename _ForwardIterator >
  _InputIterator find_first_of(_InputIterator __first1, _InputIterator __last1, _ForwardIterator __first2, _ForwardIterator __last2)
  {
    ;
    ;
    for (; __first1 != __last1; ++__first1)
      {
        for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
          {
            if (*__first1 == *__iter)
              {
                return __first1;
              }
          }
      }
    return __last1;
  }
  template < typename _InputIterator, typename _ForwardIterator, typename _BinaryPredicate >
  _InputIterator find_first_of(_InputIterator __first1, _InputIterator __last1, _ForwardIterator __first2, _ForwardIterator __last2, _BinaryPredicate __comp)
  {
    ;
    ;
    for (; __first1 != __last1; ++__first1)
      {
        for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
          {
            if (__comp(*__first1, *__iter))
              {
                return __first1;
              }
          }
      }
    return __last1;
  }
  template < typename _ForwardIterator >
  _ForwardIterator adjacent_find(_ForwardIterator __first, _ForwardIterator __last)
  {
    ;
    if (__first == __last)
      {
        return __last;
      }
    _ForwardIterator __next = __first;
    while (++__next != __last)
      {
        if (*__first == *__next)
          {
            return __first;
          }
        __first = __next;
      }
    return __last;
  }
  template < typename _ForwardIterator, typename _BinaryPredicate >
  _ForwardIterator adjacent_find(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __binary_pred)
  {
    ;
    if (__first == __last)
      {
        return __last;
      }
    _ForwardIterator __next = __first;
    while (++__next != __last)
      {
        if (__binary_pred(*__first, *__next))
          {
            return __first;
          }
        __first = __next;
      }
    return __last;
  }
  template < typename _InputIterator, typename _Tp >
  typename ::std::iterator_traits<_InputIterator>::difference_type count(_InputIterator __first, _InputIterator __last, const _Tp &__value)
  {
    ;
    typename ::std::iterator_traits<_InputIterator>::difference_type __n = 0;
    for (; __first != __last; ++__first)
      {
        if (*__first == __value)
          {
            ++__n;
          }
      }
    return __n;
  }
  template < typename _InputIterator, typename _Predicate >
  typename ::std::iterator_traits<_InputIterator>::difference_type count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
  {
    ;
    typename ::std::iterator_traits<_InputIterator>::difference_type __n = 0;
    for (; __first != __last; ++__first)
      {
        if (__pred(*__first))
          {
            ++__n;
          }
      }
    return __n;
  }
  template < typename _ForwardIterator1, typename _ForwardIterator2 >
  _ForwardIterator1 search(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2)
  {
    ;
    ;
    if (__first1 == __last1 || __first2 == __last2)
      {
        return __first1;
      }
    _ForwardIterator2 __p1(__first2);
    if (++__p1 == __last2)
      {
        return std::find(__first1, __last1, *__first2);
      }
    _ForwardIterator2 __p;
    _ForwardIterator1 __current = __first1;
    for (; ; )
      {
        __first1 = std::find(__first1, __last1, *__first2);
        if (__first1 == __last1)
          {
            return __last1;
          }
        __p = __p1;
        __current = __first1;
        if (++__current == __last1)
          {
            return __last1;
          }
        while (*__current == *__p)
          {
            if (++__p == __last2)
              {
                return __first1;
              }
            if (++__current == __last1)
              {
                return __last1;
              }
          }
        ++__first1;
      }
    return __first1;
  }
  template < typename _ForwardIterator1, typename _ForwardIterator2, typename _BinaryPredicate >
  _ForwardIterator1 search(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __predicate)
  {
    ;
    ;
    if (__first1 == __last1 || __first2 == __last2)
      {
        return __first1;
      }
    _ForwardIterator2 __p1(__first2);
    if (++__p1 == __last2)
      {
        while (__first1 != __last1 && !((bool)__predicate(*__first1, *__first2)))
          {
            ++__first1;
          }
        return __first1;
      }
    _ForwardIterator2 __p;
    _ForwardIterator1 __current = __first1;
    for (; ; )
      {
        while (__first1 != __last1 && !((bool)__predicate(*__first1, *__first2)))
          {
            ++__first1;
          }
        if (__first1 == __last1)
          {
            return __last1;
          }
        __p = __p1;
        __current = __first1;
        if (++__current == __last1)
          {
            return __last1;
          }
        while (__predicate(*__current, *__p))
          {
            if (++__p == __last2)
              {
                return __first1;
              }
            if (++__current == __last1)
              {
                return __last1;
              }
          }
        ++__first1;
      }
    return __first1;
  }
  template < typename _ForwardIterator, typename _Integer, typename _Tp >
  _ForwardIterator search_n(_ForwardIterator __first, _ForwardIterator __last, _Integer __count, const _Tp &__val)
  {
    ;
    if (__count <= 0)
      {
        return __first;
      }
    if (__count == 1)
      {
        return std::find(__first, __last, __val);
      }
    return std::__search_n(__first, __last, __count, __val, std::__iterator_category(__first));
  }
  template < typename _ForwardIterator, typename _Integer, typename _Tp, typename _BinaryPredicate >
  _ForwardIterator search_n(_ForwardIterator __first, _ForwardIterator __last, _Integer __count, const _Tp &__val, _BinaryPredicate __binary_pred)
  {
    ;
    if (__count <= 0)
      {
        return __first;
      }
    if (__count == 1)
      {
        while (__first != __last && !((bool)__binary_pred(*__first, __val)))
          {
            ++__first;
          }
        return __first;
      }
    return std::__search_n(__first, __last, __count, __val, __binary_pred, std::__iterator_category(__first));
  }
  template < typename _InputIterator, typename _OutputIterator, typename _UnaryOperation >
  _OutputIterator transform(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _UnaryOperation __unary_op)
  {
    ;
    for (; __first != __last; (++__first, ++__result))
      {
        *__result = __unary_op(*__first);
      }
    return __result;
  }
  template < typename _InputIterator1, typename _InputIterator2, typename _OutputIterator, typename _BinaryOperation >
  _OutputIterator transform(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _OutputIterator __result, _BinaryOperation __binary_op)
  {
    ;
    for (; __first1 != __last1; (((++__first1, ++__first2)), ++__result))
      {
        *__result = __binary_op(*__first1, *__first2);
      }
    return __result;
  }
  template < typename _ForwardIterator, typename _Tp >
  void replace(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__old_value, const _Tp &__new_value)
  {
    ;
    for (; __first != __last; ++__first)
      {
        if (*__first == __old_value)
          {
            *__first = __new_value;
          }
      }
  }
  template < typename _ForwardIterator, typename _Predicate, typename _Tp >
  void replace_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, const _Tp &__new_value)
  {
    ;
    for (; __first != __last; ++__first)
      {
        if (__pred(*__first))
          {
            *__first = __new_value;
          }
      }
  }
  template < typename _ForwardIterator, typename _Generator >
  void generate(_ForwardIterator __first, _ForwardIterator __last, _Generator __gen)
  {
    ;
    for (; __first != __last; ++__first)
      {
        *__first = __gen();
      }
  }
  template < typename _OutputIterator, typename _Size, typename _Generator >
  _OutputIterator generate_n(_OutputIterator __first, _Size __n, _Generator __gen)
  {
    for (__decltype(__n + 0) __niter = __n; __niter > 0; (--__niter, ++__first))
      {
        *__first = __gen();
      }
    return __first;
  }
  template < typename _InputIterator, typename _OutputIterator >
  inline _OutputIterator unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
  {
    ;
    if (__first == __last)
      {
        return __result;
      }
    return std::__unique_copy(__first, __last, __result, std::__iterator_category(__first), std::__iterator_category(__result));
  }
  template < typename _InputIterator, typename _OutputIterator, typename _BinaryPredicate >
  inline _OutputIterator unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __binary_pred)
  {
    ;
    if (__first == __last)
      {
        return __result;
      }
    return std::__unique_copy(__first, __last, __result, __binary_pred, std::__iterator_category(__first), std::__iterator_category(__result));
  }
  template < typename _RandomAccessIterator >
  inline void random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)
  {
    ;
    if (__first != __last)
      {
        for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
          {
            std::iter_swap(__i, __first + ::std::rand() % (__i - __first + 1));
          }
      }
  }
  template < typename _RandomAccessIterator, typename _RandomNumberGenerator >
  void random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last, _RandomNumberGenerator &__rand)
  {
    ;
    if (__first == __last)
      {
        return ;
      }
    for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
      {
        std::iter_swap(__i, __first + __rand(__i - __first + 1));
      }
  }
  template < typename _ForwardIterator, typename _Predicate >
  inline _ForwardIterator partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
  {
    ;
    return std::__partition(__first, __last, __pred, std::__iterator_category(__first));
  }
  template < typename _RandomAccessIterator >
  inline void partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)
  {
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::value_type _ValueType;
    ;
    ;
    std::__heap_select(__first, __middle, __last);
    std::sort_heap(__first, __middle);
  }
  template < typename _RandomAccessIterator, typename _Compare >
  inline void partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last, _Compare __comp)
  {
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::value_type _ValueType;
    ;
    ;
    std::__heap_select(__first, __middle, __last, __comp);
    std::sort_heap(__first, __middle, __comp);
  }
  template < typename _RandomAccessIterator >
  inline void nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last)
  {
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::value_type _ValueType;
    ;
    ;
    if (__first == __last || __nth == __last)
      {
        return ;
      }
    std::__introselect(__first, __nth, __last, std::__lg(__last - __first) * 2);
  }
  template < typename _RandomAccessIterator, typename _Compare >
  inline void nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)
  {
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::value_type _ValueType;
    ;
    ;
    if (__first == __last || __nth == __last)
      {
        return ;
      }
    std::__introselect(__first, __nth, __last, std::__lg(__last - __first) * 2, __comp);
  }
  template < typename _RandomAccessIterator >
  inline void sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
  {
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::value_type _ValueType;
    ;
    if (__first != __last)
      {
        std::__introsort_loop(__first, __last, std::__lg(__last - __first) * 2);
        std::__final_insertion_sort(__first, __last);
      }
  }
  template < typename _RandomAccessIterator, typename _Compare >
  inline void sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
  {
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::value_type _ValueType;
    ;
    if (__first != __last)
      {
        std::__introsort_loop(__first, __last, std::__lg(__last - __first) * 2, __comp);
        std::__final_insertion_sort(__first, __last, __comp);
      }
  }
  template < typename _InputIterator1, typename _InputIterator2, typename _OutputIterator >
  _OutputIterator merge(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
  {
    typedef typename ::std::iterator_traits<_InputIterator1>::value_type _ValueType1;
    typedef typename ::std::iterator_traits<_InputIterator2>::value_type _ValueType2;
    ;
    ;
    while (__first1 != __last1 && __first2 != __last2)
      {
        if (*__first2 < *__first1)
          {
            *__result = *__first2;
            ++__first2;
          }
        else
          {
            *__result = *__first1;
            ++__first1;
          }
        ++__result;
      }
    return std::copy(__first2, __last2, std::copy(__first1, __last1, __result));
  }
  template < typename _InputIterator1, typename _InputIterator2, typename _OutputIterator, typename _Compare >
  _OutputIterator merge(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
  {
    typedef typename ::std::iterator_traits<_InputIterator1>::value_type _ValueType1;
    typedef typename ::std::iterator_traits<_InputIterator2>::value_type _ValueType2;
    ;
    ;
    while (__first1 != __last1 && __first2 != __last2)
      {
        if (__comp(*__first2, *__first1))
          {
            *__result = *__first2;
            ++__first2;
          }
        else
          {
            *__result = *__first1;
            ++__first1;
          }
        ++__result;
      }
    return std::copy(__first2, __last2, std::copy(__first1, __last1, __result));
  }
  template < typename _RandomAccessIterator >
  inline void stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
  {
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::value_type _ValueType;
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::difference_type _DistanceType;
    ;
    ::std::_Temporary_buffer<_RandomAccessIterator, _ValueType> __buf(__first, __last);
    if (__buf.begin() == 0)
      {
        std::__inplace_stable_sort(__first, __last);
      }
    else
      {
        std::__stable_sort_adaptive(__first, __last, __buf.begin(), _DistanceType(__buf.size()));
      }
  }
  template < typename _RandomAccessIterator, typename _Compare >
  inline void stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
  {
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::value_type _ValueType;
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::difference_type _DistanceType;
    ;
    ::std::_Temporary_buffer<_RandomAccessIterator, _ValueType> __buf(__first, __last);
    if (__buf.begin() == 0)
      {
        std::__inplace_stable_sort(__first, __last, __comp);
      }
    else
      {
        std::__stable_sort_adaptive(__first, __last, __buf.begin(), _DistanceType(__buf.size()), __comp);
      }
  }
  template < typename _InputIterator1, typename _InputIterator2, typename _OutputIterator >
  _OutputIterator set_union(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
  {
    typedef typename ::std::iterator_traits<_InputIterator1>::value_type _ValueType1;
    typedef typename ::std::iterator_traits<_InputIterator2>::value_type _ValueType2;
    ;
    ;
    while (__first1 != __last1 && __first2 != __last2)
      {
        if (*__first1 < *__first2)
          {
            *__result = *__first1;
            ++__first1;
          }
        else
          {
            if (*__first2 < *__first1)
              {
                *__result = *__first2;
                ++__first2;
              }
            else
              {
                *__result = *__first1;
                ++__first1;
                ++__first2;
              }
          }
        ++__result;
      }
    return std::copy(__first2, __last2, std::copy(__first1, __last1, __result));
  }
  template < typename _InputIterator1, typename _InputIterator2, typename _OutputIterator, typename _Compare >
  _OutputIterator set_union(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
  {
    typedef typename ::std::iterator_traits<_InputIterator1>::value_type _ValueType1;
    typedef typename ::std::iterator_traits<_InputIterator2>::value_type _ValueType2;
    ;
    ;
    while (__first1 != __last1 && __first2 != __last2)
      {
        if (__comp(*__first1, *__first2))
          {
            *__result = *__first1;
            ++__first1;
          }
        else
          {
            if (__comp(*__first2, *__first1))
              {
                *__result = *__first2;
                ++__first2;
              }
            else
              {
                *__result = *__first1;
                ++__first1;
                ++__first2;
              }
          }
        ++__result;
      }
    return std::copy(__first2, __last2, std::copy(__first1, __last1, __result));
  }
  template < typename _InputIterator1, typename _InputIterator2, typename _OutputIterator >
  _OutputIterator set_intersection(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
  {
    typedef typename ::std::iterator_traits<_InputIterator1>::value_type _ValueType1;
    typedef typename ::std::iterator_traits<_InputIterator2>::value_type _ValueType2;
    ;
    ;
    while (__first1 != __last1 && __first2 != __last2)
      {
        if (*__first1 < *__first2)
          {
            ++__first1;
          }
        else
          {
            if (*__first2 < *__first1)
              {
                ++__first2;
              }
            else
              {
                *__result = *__first1;
                ++__first1;
                ++__first2;
                ++__result;
              }
          }
      }
    return __result;
  }
  template < typename _InputIterator1, typename _InputIterator2, typename _OutputIterator, typename _Compare >
  _OutputIterator set_intersection(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
  {
    typedef typename ::std::iterator_traits<_InputIterator1>::value_type _ValueType1;
    typedef typename ::std::iterator_traits<_InputIterator2>::value_type _ValueType2;
    ;
    ;
    while (__first1 != __last1 && __first2 != __last2)
      {
        if (__comp(*__first1, *__first2))
          {
            ++__first1;
          }
        else
          {
            if (__comp(*__first2, *__first1))
              {
                ++__first2;
              }
            else
              {
                *__result = *__first1;
                ++__first1;
                ++__first2;
                ++__result;
              }
          }
      }
    return __result;
  }
  template < typename _InputIterator1, typename _InputIterator2, typename _OutputIterator >
  _OutputIterator set_difference(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
  {
    typedef typename ::std::iterator_traits<_InputIterator1>::value_type _ValueType1;
    typedef typename ::std::iterator_traits<_InputIterator2>::value_type _ValueType2;
    ;
    ;
    while (__first1 != __last1 && __first2 != __last2)
      {
        if (*__first1 < *__first2)
          {
            *__result = *__first1;
            ++__first1;
            ++__result;
          }
        else
          {
            if (*__first2 < *__first1)
              {
                ++__first2;
              }
            else
              {
                ++__first1;
                ++__first2;
              }
          }
      }
    return std::copy(__first1, __last1, __result);
  }
  template < typename _InputIterator1, typename _InputIterator2, typename _OutputIterator, typename _Compare >
  _OutputIterator set_difference(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
  {
    typedef typename ::std::iterator_traits<_InputIterator1>::value_type _ValueType1;
    typedef typename ::std::iterator_traits<_InputIterator2>::value_type _ValueType2;
    ;
    ;
    while (__first1 != __last1 && __first2 != __last2)
      {
        if (__comp(*__first1, *__first2))
          {
            *__result = *__first1;
            ++__first1;
            ++__result;
          }
        else
          {
            if (__comp(*__first2, *__first1))
              {
                ++__first2;
              }
            else
              {
                ++__first1;
                ++__first2;
              }
          }
      }
    return std::copy(__first1, __last1, __result);
  }
  template < typename _InputIterator1, typename _InputIterator2, typename _OutputIterator >
  _OutputIterator set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
  {
    typedef typename ::std::iterator_traits<_InputIterator1>::value_type _ValueType1;
    typedef typename ::std::iterator_traits<_InputIterator2>::value_type _ValueType2;
    ;
    ;
    while (__first1 != __last1 && __first2 != __last2)
      {
        if (*__first1 < *__first2)
          {
            *__result = *__first1;
            ++__first1;
            ++__result;
          }
        else
          {
            if (*__first2 < *__first1)
              {
                *__result = *__first2;
                ++__first2;
                ++__result;
              }
            else
              {
                ++__first1;
                ++__first2;
              }
          }
      }
    return std::copy(__first2, __last2, std::copy(__first1, __last1, __result));
  }
  template < typename _InputIterator1, typename _InputIterator2, typename _OutputIterator, typename _Compare >
  _OutputIterator set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
  {
    typedef typename ::std::iterator_traits<_InputIterator1>::value_type _ValueType1;
    typedef typename ::std::iterator_traits<_InputIterator2>::value_type _ValueType2;
    ;
    ;
    while (__first1 != __last1 && __first2 != __last2)
      {
        if (__comp(*__first1, *__first2))
          {
            *__result = *__first1;
            ++__first1;
            ++__result;
          }
        else
          {
            if (__comp(*__first2, *__first1))
              {
                *__result = *__first2;
                ++__first2;
                ++__result;
              }
            else
              {
                ++__first1;
                ++__first2;
              }
          }
      }
    return std::copy(__first2, __last2, std::copy(__first1, __last1, __result));
  }
  template < typename _ForwardIterator >
  _ForwardIterator min_element(_ForwardIterator __first, _ForwardIterator __last)
  {
    ;
    if (__first == __last)
      {
        return __first;
      }
    _ForwardIterator __result = __first;
    while (++__first != __last)
      {
        if (*__first < *__result)
          {
            __result = __first;
          }
      }
    return __result;
  }
  template < typename _ForwardIterator, typename _Compare >
  _ForwardIterator min_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
  {
    ;
    if (__first == __last)
      {
        return __first;
      }
    _ForwardIterator __result = __first;
    while (++__first != __last)
      {
        if (__comp(*__first, *__result))
          {
            __result = __first;
          }
      }
    return __result;
  }
  template < typename _ForwardIterator >
  _ForwardIterator max_element(_ForwardIterator __first, _ForwardIterator __last)
  {
    ;
    if (__first == __last)
      {
        return __first;
      }
    _ForwardIterator __result = __first;
    while (++__first != __last)
      {
        if (*__result < *__first)
          {
            __result = __first;
          }
      }
    return __result;
  }
  template < typename _ForwardIterator, typename _Compare >
  _ForwardIterator max_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
  {
    ;
    if (__first == __last)
      {
        return __first;
      }
    _ForwardIterator __result = __first;
    while (++__first != __last)
      {
        if (__comp(*__result, *__first))
          {
            __result = __first;
          }
      }
    return __result;
  }
  enum float_round_style
  {
    round_indeterminate =  -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
  };
  enum float_denorm_style
  {
    denorm_indeterminate =  -1,
    denorm_absent = 0,
    denorm_present = 1
  };
  struct  __numeric_limits_base
  {
      static const bool is_specialized = false;
      static const int digits = 0;
      static const int digits10 = 0;
      static const bool is_signed = false;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 0;
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const ::std::float_denorm_style has_denorm = ::std::denorm_absent;
      static const bool has_denorm_loss = false;
      static const bool is_iec559 = false;
      static const bool is_bounded = false;
      static const bool is_modulo = false;
      static const bool traps = false;
      static const bool tinyness_before = false;
      static const ::std::float_round_style round_style = ::std::round_toward_zero;
  };
  template < typename _Tp >
  struct  numeric_limits : ::std::__numeric_limits_base
  {
      static inline _Tp min() throw()
      {
        return static_cast<_Tp>(0);
      }
      static inline _Tp max() throw()
      {
        return static_cast<_Tp>(0);
      }
      static inline _Tp epsilon() throw()
      {
        return static_cast<_Tp>(0);
      }
      static inline _Tp round_error() throw()
      {
        return static_cast<_Tp>(0);
      }
      static inline _Tp infinity() throw()
      {
        return static_cast<_Tp>(0);
      }
      static inline _Tp quiet_NaN() throw()
      {
        return static_cast<_Tp>(0);
      }
      static inline _Tp signaling_NaN() throw()
      {
        return static_cast<_Tp>(0);
      }
      static inline _Tp denorm_min() throw()
      {
        return static_cast<_Tp>(0);
      }
  };
  template <>
  struct  numeric_limits<bool>
  {
      static const bool is_specialized = true;
      static inline bool min() throw()
      {
        return false;
      }
      static inline bool max() throw()
      {
        return true;
      }
      static const int digits = 1;
      static const int digits10 = 0;
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static inline bool epsilon() throw()
      {
        return false;
      }
      static inline bool round_error() throw()
      {
        return false;
      }
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const ::std::float_denorm_style has_denorm = ::std::denorm_absent;
      static const bool has_denorm_loss = false;
      static inline bool infinity() throw()
      {
        return false;
      }
      static inline bool quiet_NaN() throw()
      {
        return false;
      }
      static inline bool signaling_NaN() throw()
      {
        return false;
      }
      static inline bool denorm_min() throw()
      {
        return false;
      }
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = false;
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const ::std::float_round_style round_style = ::std::round_toward_zero;
  };
  template <>
  struct  numeric_limits<char>
  {
      static const bool is_specialized = true;
      static inline char min() throw()
      {
        return (char) -1 < 0 ?  -((char) -1 < 0 ? ((((char)1 << (sizeof(char) * 8 - ((char) -1 < 0) - 1)) - 1) << 1) + 1 : ~((char)0)) - 1 : (char)0;
      }
      static inline char max() throw()
      {
        return (char) -1 < 0 ? ((((char)1 << (sizeof(char) * 8 - ((char) -1 < 0) - 1)) - 1) << 1) + 1 : ~((char)0);
      }
      static const int digits = sizeof(char) * 8 - ((char) -1 < 0);
      static const int digits10 = (sizeof(char) * 8 - ((char) -1 < 0)) * 643L / 2136;
      static const bool is_signed = (char) -1 < 0;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static inline char epsilon() throw()
      {
        return 0;
      }
      static inline char round_error() throw()
      {
        return 0;
      }
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const ::std::float_denorm_style has_denorm = ::std::denorm_absent;
      static const bool has_denorm_loss = false;
      static inline char infinity() throw()
      {
        return char();
      }
      static inline char quiet_NaN() throw()
      {
        return char();
      }
      static inline char signaling_NaN() throw()
      {
        return char();
      }
      static inline char denorm_min() throw()
      {
        return static_cast<char>(0);
      }
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const ::std::float_round_style round_style = ::std::round_toward_zero;
  };
  template <>
  struct  numeric_limits<signed char>
  {
      static const bool is_specialized = true;
      static inline signed char min() throw()
      {
        return  -127 - 1;
      }
      static inline signed char max() throw()
      {
        return 127;
      }
      static const int digits = sizeof(signed char) * 8 - ((signed char) -1 < 0);
      static const int digits10 = (sizeof(signed char) * 8 - ((signed char) -1 < 0)) * 643L / 2136;
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static inline signed char epsilon() throw()
      {
        return 0;
      }
      static inline signed char round_error() throw()
      {
        return 0;
      }
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const ::std::float_denorm_style has_denorm = ::std::denorm_absent;
      static const bool has_denorm_loss = false;
      static inline signed char infinity() throw()
      {
        return static_cast<signed char>(0);
      }
      static inline signed char quiet_NaN() throw()
      {
        return static_cast<signed char>(0);
      }
      static inline signed char signaling_NaN() throw()
      {
        return static_cast<signed char>(0);
      }
      static inline signed char denorm_min() throw()
      {
        return static_cast<signed char>(0);
      }
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const ::std::float_round_style round_style = ::std::round_toward_zero;
  };
  template <>
  struct  numeric_limits<unsigned char>
  {
      static const bool is_specialized = true;
      static inline unsigned char min() throw()
      {
        return 0;
      }
      static inline unsigned char max() throw()
      {
        return 127 * 2U + 1;
      }
      static const int digits = sizeof(unsigned char) * 8 - ((unsigned char) -1 < 0);
      static const int digits10 = (sizeof(unsigned char) * 8 - ((unsigned char) -1 < 0)) * 643L / 2136;
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static inline unsigned char epsilon() throw()
      {
        return 0;
      }
      static inline unsigned char round_error() throw()
      {
        return 0;
      }
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const ::std::float_denorm_style has_denorm = ::std::denorm_absent;
      static const bool has_denorm_loss = false;
      static inline unsigned char infinity() throw()
      {
        return static_cast<unsigned char>(0);
      }
      static inline unsigned char quiet_NaN() throw()
      {
        return static_cast<unsigned char>(0);
      }
      static inline unsigned char signaling_NaN() throw()
      {
        return static_cast<unsigned char>(0);
      }
      static inline unsigned char denorm_min() throw()
      {
        return static_cast<unsigned char>(0);
      }
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const ::std::float_round_style round_style = ::std::round_toward_zero;
  };
  template <>
  struct  numeric_limits<wchar_t>
  {
      static const bool is_specialized = true;
      static inline wchar_t min() throw()
      {
        return (wchar_t) -1 < 0 ?  -((wchar_t) -1 < 0 ? ((((wchar_t)1 << (sizeof(wchar_t) * 8 - ((wchar_t) -1 < 0) - 1)) - 1) << 1) + 1 : ~((wchar_t)0)) - 1 : (wchar_t)0;
      }
      static inline wchar_t max() throw()
      {
        return (wchar_t) -1 < 0 ? ((((wchar_t)1 << (sizeof(wchar_t) * 8 - ((wchar_t) -1 < 0) - 1)) - 1) << 1) + 1 : ~((wchar_t)0);
      }
      static const int digits = sizeof(wchar_t) * 8 - ((wchar_t) -1 < 0);
      static const int digits10 = (sizeof(wchar_t) * 8 - ((wchar_t) -1 < 0)) * 643L / 2136;
      static const bool is_signed = (wchar_t) -1 < 0;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static inline wchar_t epsilon() throw()
      {
        return 0;
      }
      static inline wchar_t round_error() throw()
      {
        return 0;
      }
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const ::std::float_denorm_style has_denorm = ::std::denorm_absent;
      static const bool has_denorm_loss = false;
      static inline wchar_t infinity() throw()
      {
        return wchar_t();
      }
      static inline wchar_t quiet_NaN() throw()
      {
        return wchar_t();
      }
      static inline wchar_t signaling_NaN() throw()
      {
        return wchar_t();
      }
      static inline wchar_t denorm_min() throw()
      {
        return wchar_t();
      }
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const ::std::float_round_style round_style = ::std::round_toward_zero;
  };
  template <>
  struct  numeric_limits<short int>
  {
      static const bool is_specialized = true;
      static inline short int min() throw()
      {
        return  -32767 - 1;
      }
      static inline short int max() throw()
      {
        return 32767;
      }
      static const int digits = sizeof(short int) * 8 - ((short int) -1 < 0);
      static const int digits10 = (sizeof(short int) * 8 - ((short int) -1 < 0)) * 643L / 2136;
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static inline short int epsilon() throw()
      {
        return 0;
      }
      static inline short int round_error() throw()
      {
        return 0;
      }
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const ::std::float_denorm_style has_denorm = ::std::denorm_absent;
      static const bool has_denorm_loss = false;
      static inline short int infinity() throw()
      {
        return short();
      }
      static inline short int quiet_NaN() throw()
      {
        return short();
      }
      static inline short int signaling_NaN() throw()
      {
        return short();
      }
      static inline short int denorm_min() throw()
      {
        return short();
      }
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const ::std::float_round_style round_style = ::std::round_toward_zero;
  };
  template <>
  struct  numeric_limits<unsigned short int>
  {
      static const bool is_specialized = true;
      static inline unsigned short int min() throw()
      {
        return 0;
      }
      static inline unsigned short int max() throw()
      {
        return 32767 * 2U + 1;
      }
      static const int digits = sizeof(unsigned short int) * 8 - ((unsigned short int) -1 < 0);
      static const int digits10 = (sizeof(unsigned short int) * 8 - ((unsigned short int) -1 < 0)) * 643L / 2136;
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static inline unsigned short int epsilon() throw()
      {
        return 0;
      }
      static inline unsigned short int round_error() throw()
      {
        return 0;
      }
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const ::std::float_denorm_style has_denorm = ::std::denorm_absent;
      static const bool has_denorm_loss = false;
      static inline unsigned short int infinity() throw()
      {
        return static_cast<unsigned short int>(0);
      }
      static inline unsigned short int quiet_NaN() throw()
      {
        return static_cast<unsigned short int>(0);
      }
      static inline unsigned short int signaling_NaN() throw()
      {
        return static_cast<unsigned short int>(0);
      }
      static inline unsigned short int denorm_min() throw()
      {
        return static_cast<unsigned short int>(0);
      }
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const ::std::float_round_style round_style = ::std::round_toward_zero;
  };
  template <>
  struct  numeric_limits<int>
  {
      static const bool is_specialized = true;
      static inline int min() throw()
      {
        return  -2147483647 - 1;
      }
      static inline int max() throw()
      {
        return 2147483647;
      }
      static const int digits = sizeof(int) * 8 - ((int) -1 < 0);
      static const int digits10 = (sizeof(int) * 8 - ((int) -1 < 0)) * 643L / 2136;
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static inline int epsilon() throw()
      {
        return 0;
      }
      static inline int round_error() throw()
      {
        return 0;
      }
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const ::std::float_denorm_style has_denorm = ::std::denorm_absent;
      static const bool has_denorm_loss = false;
      static inline int infinity() throw()
      {
        return static_cast<int>(0);
      }
      static inline int quiet_NaN() throw()
      {
        return static_cast<int>(0);
      }
      static inline int signaling_NaN() throw()
      {
        return static_cast<int>(0);
      }
      static inline int denorm_min() throw()
      {
        return static_cast<int>(0);
      }
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const ::std::float_round_style round_style = ::std::round_toward_zero;
  };
  template <>
  struct  numeric_limits<unsigned int>
  {
      static const bool is_specialized = true;
      static inline unsigned int min() throw()
      {
        return 0;
      }
      static inline unsigned int max() throw()
      {
        return 2147483647 * 2U + 1;
      }
      static const int digits = sizeof(unsigned int) * 8 - ((unsigned int) -1 < 0);
      static const int digits10 = (sizeof(unsigned int) * 8 - ((unsigned int) -1 < 0)) * 643L / 2136;
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static inline unsigned int epsilon() throw()
      {
        return 0;
      }
      static inline unsigned int round_error() throw()
      {
        return 0;
      }
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const ::std::float_denorm_style has_denorm = ::std::denorm_absent;
      static const bool has_denorm_loss = false;
      static inline unsigned int infinity() throw()
      {
        return static_cast<unsigned int>(0);
      }
      static inline unsigned int quiet_NaN() throw()
      {
        return static_cast<unsigned int>(0);
      }
      static inline unsigned int signaling_NaN() throw()
      {
        return static_cast<unsigned int>(0);
      }
      static inline unsigned int denorm_min() throw()
      {
        return static_cast<unsigned int>(0);
      }
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const ::std::float_round_style round_style = ::std::round_toward_zero;
  };
  template <>
  struct  numeric_limits<long int>
  {
      static const bool is_specialized = true;
      static inline long int min() throw()
      {
        return  -9223372036854775807L - 1;
      }
      static inline long int max() throw()
      {
        return 9223372036854775807L;
      }
      static const int digits = sizeof(long int) * 8 - ((long int) -1 < 0);
      static const int digits10 = (sizeof(long int) * 8 - ((long int) -1 < 0)) * 643L / 2136;
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static inline long int epsilon() throw()
      {
        return 0;
      }
      static inline long int round_error() throw()
      {
        return 0;
      }
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const ::std::float_denorm_style has_denorm = ::std::denorm_absent;
      static const bool has_denorm_loss = false;
      static inline long int infinity() throw()
      {
        return static_cast<long int>(0);
      }
      static inline long int quiet_NaN() throw()
      {
        return static_cast<long int>(0);
      }
      static inline long int signaling_NaN() throw()
      {
        return static_cast<long int>(0);
      }
      static inline long int denorm_min() throw()
      {
        return static_cast<long int>(0);
      }
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const ::std::float_round_style round_style = ::std::round_toward_zero;
  };
  template <>
  struct  numeric_limits<unsigned long int>
  {
      static const bool is_specialized = true;
      static inline unsigned long int min() throw()
      {
        return 0;
      }
      static inline unsigned long int max() throw()
      {
        return 9223372036854775807L * 2LU + 1;
      }
      static const int digits = sizeof(unsigned long int) * 8 - ((unsigned long int) -1 < 0);
      static const int digits10 = (sizeof(unsigned long int) * 8 - ((unsigned long int) -1 < 0)) * 643L / 2136;
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static inline unsigned long int epsilon() throw()
      {
        return 0;
      }
      static inline unsigned long int round_error() throw()
      {
        return 0;
      }
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const ::std::float_denorm_style has_denorm = ::std::denorm_absent;
      static const bool has_denorm_loss = false;
      static inline unsigned long int infinity() throw()
      {
        return static_cast<unsigned long int>(0);
      }
      static inline unsigned long int quiet_NaN() throw()
      {
        return static_cast<unsigned long int>(0);
      }
      static inline unsigned long int signaling_NaN() throw()
      {
        return static_cast<unsigned long int>(0);
      }
      static inline unsigned long int denorm_min() throw()
      {
        return static_cast<unsigned long int>(0);
      }
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const ::std::float_round_style round_style = ::std::round_toward_zero;
  };
  template <>
  struct  numeric_limits<long long int>
  {
      static const bool is_specialized = true;
      static inline long long int min() throw()
      {
        return  -9223372036854775807LL - 1;
      }
      static inline long long int max() throw()
      {
        return 9223372036854775807LL;
      }
      static const int digits = sizeof(long long int) * 8 - ((long long int) -1 < 0);
      static const int digits10 = (sizeof(long long int) * 8 - ((long long int) -1 < 0)) * 643L / 2136;
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static inline long long int epsilon() throw()
      {
        return 0;
      }
      static inline long long int round_error() throw()
      {
        return 0;
      }
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const ::std::float_denorm_style has_denorm = ::std::denorm_absent;
      static const bool has_denorm_loss = false;
      static inline long long int infinity() throw()
      {
        return static_cast<long long int>(0);
      }
      static inline long long int quiet_NaN() throw()
      {
        return static_cast<long long int>(0);
      }
      static inline long long int signaling_NaN() throw()
      {
        return static_cast<long long int>(0);
      }
      static inline long long int denorm_min() throw()
      {
        return static_cast<long long int>(0);
      }
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const ::std::float_round_style round_style = ::std::round_toward_zero;
  };
  template <>
  struct  numeric_limits<unsigned long long int>
  {
      static const bool is_specialized = true;
      static inline unsigned long long int min() throw()
      {
        return 0;
      }
      static inline unsigned long long int max() throw()
      {
        return 9223372036854775807LL * 2LLU + 1;
      }
      static const int digits = sizeof(unsigned long long int) * 8 - ((unsigned long long int) -1 < 0);
      static const int digits10 = (sizeof(unsigned long long int) * 8 - ((unsigned long long int) -1 < 0)) * 643L / 2136;
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static inline unsigned long long int epsilon() throw()
      {
        return 0;
      }
      static inline unsigned long long int round_error() throw()
      {
        return 0;
      }
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const ::std::float_denorm_style has_denorm = ::std::denorm_absent;
      static const bool has_denorm_loss = false;
      static inline unsigned long long int infinity() throw()
      {
        return static_cast<unsigned long long int>(0);
      }
      static inline unsigned long long int quiet_NaN() throw()
      {
        return static_cast<unsigned long long int>(0);
      }
      static inline unsigned long long int signaling_NaN() throw()
      {
        return static_cast<unsigned long long int>(0);
      }
      static inline unsigned long long int denorm_min() throw()
      {
        return static_cast<unsigned long long int>(0);
      }
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const ::std::float_round_style round_style = ::std::round_toward_zero;
  };
  template <>
  struct  numeric_limits<__int128>
  {
      static const bool is_specialized = true;
      static inline __int128 min() throw()
      {
        return (__int128) -1 < 0 ?  -((__int128) -1 < 0 ? ((((__int128)1 << (sizeof(__int128) * 8 - ((__int128) -1 < 0) - 1)) - 1) << 1) + 1 : ~((__int128)0)) - 1 : (__int128)0;
      }
      static inline __int128 max() throw()
      {
        return (__int128) -1 < 0 ? ((((__int128)1 << (sizeof(__int128) * 8 - ((__int128) -1 < 0) - 1)) - 1) << 1) + 1 : ~((__int128)0);
      }
      static const int digits = sizeof(__int128) * 8 - ((__int128) -1 < 0);
      static const int digits10 = (sizeof(__int128) * 8 - ((__int128) -1 < 0)) * 643L / 2136;
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static inline __int128 epsilon() throw()
      {
        return 0;
      }
      static inline __int128 round_error() throw()
      {
        return 0;
      }
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const ::std::float_denorm_style has_denorm = ::std::denorm_absent;
      static const bool has_denorm_loss = false;
      static inline __int128 infinity() throw()
      {
        return static_cast<__int128>(0);
      }
      static inline __int128 quiet_NaN() throw()
      {
        return static_cast<__int128>(0);
      }
      static inline __int128 signaling_NaN() throw()
      {
        return static_cast<__int128>(0);
      }
      static inline __int128 denorm_min() throw()
      {
        return static_cast<__int128>(0);
      }
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const ::std::float_round_style round_style = ::std::round_toward_zero;
  };
  template <>
  struct  numeric_limits<unsigned __int128>
  {
      static const bool is_specialized = true;
      static inline unsigned __int128 min() throw()
      {
        return 0;
      }
      static inline unsigned __int128 max() throw()
      {
        return (unsigned __int128) -1 < 0 ? ((((unsigned __int128)1 << (sizeof(unsigned __int128) * 8 - ((unsigned __int128) -1 < 0) - 1)) - 1) << 1) + 1 : ~((unsigned __int128)0);
      }
      static const int digits = sizeof(unsigned __int128) * 8 - ((unsigned __int128) -1 < 0);
      static const int digits10 = (sizeof(unsigned __int128) * 8 - ((unsigned __int128) -1 < 0)) * 643L / 2136;
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static inline unsigned __int128 epsilon() throw()
      {
        return 0;
      }
      static inline unsigned __int128 round_error() throw()
      {
        return 0;
      }
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const ::std::float_denorm_style has_denorm = ::std::denorm_absent;
      static const bool has_denorm_loss = false;
      static inline unsigned __int128 infinity() throw()
      {
        return static_cast<unsigned __int128>(0);
      }
      static inline unsigned __int128 quiet_NaN() throw()
      {
        return static_cast<unsigned __int128>(0);
      }
      static inline unsigned __int128 signaling_NaN() throw()
      {
        return static_cast<unsigned __int128>(0);
      }
      static inline unsigned __int128 denorm_min() throw()
      {
        return static_cast<unsigned __int128>(0);
      }
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const ::std::float_round_style round_style = ::std::round_toward_zero;
  };
  template <>
  struct  numeric_limits<float>
  {
      static const bool is_specialized = true;
      static inline float min() throw()
      {
        return 1.175494350822287507968737e-38f;
      }
      static inline float max() throw()
      {
        return 3.402823466385288598117042e+38f;
      }
      static const int digits = 24;
      static const int digits10 = 6;
      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;
      static inline float epsilon() throw()
      {
        return 1.192092895507812500000000e-07f;
      }
      static inline float round_error() throw()
      {
        return 5.000000000000000000000000e-01f;
      }
      static const int min_exponent =  -125;
      static const int min_exponent10 =  -37;
      static const int max_exponent = 128;
      static const int max_exponent10 = 38;
      static const bool has_infinity = 1;
      static const bool has_quiet_NaN = 1;
      static const bool has_signaling_NaN = ::std::numeric_limits<float>::has_quiet_NaN;
      static const ::std::float_denorm_style has_denorm = (bool)1 ? ::std::denorm_present : ::std::denorm_absent;
      static const bool has_denorm_loss = false;
      static inline float infinity() throw()
      {
        return __builtin_huge_valf();
      }
      static inline float quiet_NaN() throw()
      {
        return __builtin_nanf("");
      }
      static inline float signaling_NaN() throw()
      {
        return __builtin_nansf("");
      }
      static inline float denorm_min() throw()
      {
        return 1.401298464324817070923730e-45f;
      }
      static const bool is_iec559 = (::std::numeric_limits<float>::has_infinity && ::std::numeric_limits<float>::has_quiet_NaN) && ::std::numeric_limits<float>::has_denorm == ::std::denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;
      static const bool traps = false;
      static const bool tinyness_before = false;
      static const ::std::float_round_style round_style = ::std::round_to_nearest;
  };
  template <>
  struct  numeric_limits<double>
  {
      static const bool is_specialized = true;
      static inline double min() throw()
      {
        return (double)2.2250738585072013830902327173324040642192159804623318305533274169e-308L;
      }
      static inline double max() throw()
      {
        return (double)1.7976931348623157081452742373170435679807056752584499659891747680e+308L;
      }
      static const int digits = 53;
      static const int digits10 = 15;
      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;
      static inline double epsilon() throw()
      {
        return (double)2.2204460492503130808472633361816406250000000000000000000000000000e-16L;
      }
      static inline double round_error() throw()
      {
        return 5.00000000000000000000000000000000000000000000000000000e-01;
      }
      static const int min_exponent =  -1021;
      static const int min_exponent10 =  -307;
      static const int max_exponent = 1024;
      static const int max_exponent10 = 308;
      static const bool has_infinity = 1;
      static const bool has_quiet_NaN = 1;
      static const bool has_signaling_NaN = ::std::numeric_limits<double>::has_quiet_NaN;
      static const ::std::float_denorm_style has_denorm = (bool)1 ? ::std::denorm_present : ::std::denorm_absent;
      static const bool has_denorm_loss = false;
      static inline double infinity() throw()
      {
        return __builtin_huge_val();
      }
      static inline double quiet_NaN() throw()
      {
        return __builtin_nan("");
      }
      static inline double signaling_NaN() throw()
      {
        return __builtin_nans("");
      }
      static inline double denorm_min() throw()
      {
        return (double)4.9406564584124654417656879286822137236505980261432476442558568250e-324L;
      }
      static const bool is_iec559 = (::std::numeric_limits<double>::has_infinity && ::std::numeric_limits<double>::has_quiet_NaN) && ::std::numeric_limits<double>::has_denorm == ::std::denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;
      static const bool traps = false;
      static const bool tinyness_before = false;
      static const ::std::float_round_style round_style = ::std::round_to_nearest;
  };
  template <>
  struct  numeric_limits<long double>
  {
      static const bool is_specialized = true;
      static inline long double min() throw()
      {
        return 3.3621031431120935062626778173217526025980793448464712401088272298e-4932L;
      }
      static inline long double max() throw()
      {
        return 1.1897314953572317650212638530309702051690633222946242004403237339e+4932L;
      }
      static const int digits = 64;
      static const int digits10 = 18;
      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;
      static inline long double epsilon() throw()
      {
        return 1.0842021724855044340074528008699417114257812500000000000000000000e-19L;
      }
      static inline long double round_error() throw()
      {
        return 5.0000000000000000000000000000000000000000000000000000000000000000e-01L;
      }
      static const int min_exponent =  -16381;
      static const int min_exponent10 =  -4931;
      static const int max_exponent = 16384;
      static const int max_exponent10 = 4932;
      static const bool has_infinity = 1;
      static const bool has_quiet_NaN = 1;
      static const bool has_signaling_NaN = ::std::numeric_limits<long double>::has_quiet_NaN;
      static const ::std::float_denorm_style has_denorm = (bool)1 ? ::std::denorm_present : ::std::denorm_absent;
      static const bool has_denorm_loss = false;
      static inline long double infinity() throw()
      {
        return __builtin_huge_vall();
      }
      static inline long double quiet_NaN() throw()
      {
        return __builtin_nanl("");
      }
      static inline long double signaling_NaN() throw()
      {
        return __builtin_nansl("");
      }
      static inline long double denorm_min() throw()
      {
        return 3.6451995318824746025284059336194198163990508156935633437209804870e-4951L;
      }
      static const bool is_iec559 = (::std::numeric_limits<long double>::has_infinity && ::std::numeric_limits<long double>::has_quiet_NaN) && ::std::numeric_limits<long double>::has_denorm == ::std::denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;
      static const bool traps = false;
      static const bool tinyness_before = false;
      static const ::std::float_round_style round_style = ::std::round_to_nearest;
  };
}
struct  tms
{
    ::clock_t tms_utime;
    ::clock_t tms_stime;
    ::clock_t tms_cutime;
    ::clock_t tms_cstime;
};
extern "C"
{
  extern ::clock_t times(::tms *__buffer) throw();
}
using namespace ::std;
struct  sse_f
{
    inline sse_f()
    {
    }
    float f[4];
};
struct  sse_i64
{
    union mcc_union_anon_47;
    union  mcc_union_anon_47
    {
        char b[8];
        short int wd[4];
        int dw[2];
    };
    ::sse_i64::mcc_union_anon_47 __sse_i64;
};
struct  sse_i
{
    union mcc_union_anon_48;
    inline sse_i()
    {
    }
    union  mcc_union_anon_48
    {
        signed char b[16];
        int i[4];
        unsigned int ui[4];
        ::sse_i64 l[2];
    };
    ::sse_i::mcc_union_anon_48 __sse_i;
};
static inline __attribute__((always_inline)) int _emm_round_nearest(double d)
{
  return (int)d;
}
static inline __attribute__((always_inline)) int _emm_round_trunc(double d)
{
  return (int)d;
}
static inline __attribute__((always_inline)) int _mm_round_trunc(float f)
{
  return (int)f;
}
static inline __attribute__((always_inline)) double _mminternal_sqrt(double src)
{
  return (float)::sqrt(src);
}
static inline __attribute__((always_inline)) ::sse_i _mm_add_epi32(::sse_i a, ::sse_i b)
{
  ::sse_i result;
  for (int i = 0; i < 4; i++)
    {
      result.__sse_i.i[i] = a.__sse_i.i[i] + b.__sse_i.i[i];
    }
  return result;
}
static inline __attribute__((always_inline)) ::sse_f _mm_add_ps(::sse_f a, ::sse_f b)
{
  ::sse_f result;
  for (int i = 0; i < 4; i++)
    {
      result.f[i] = a.f[i] + b.f[i];
    }
  return result;
}
static inline __attribute__((always_inline)) ::sse_f _mm_add_ss(::sse_f a, ::sse_f b)
{
  ::sse_f result;
  result.f[0] = a.f[0] + b.f[0];
  for (int i = 1; i < 4; i++)
    {
      result.f[i] = a.f[i];
    }
  return result;
}
static inline __attribute__((always_inline)) ::sse_f _mm_and_ps(::sse_f a, ::sse_f b)
{
  ::sse_f result;
  for (int i = 0; i < 4; i++)
    {
      *((int *)&result.f[i]) = *((int *)&a.f[i]) & *((int *)&b.f[i]);
    }
  return result;
}
static inline __attribute__((always_inline)) ::sse_i _mm_and_si128(::sse_i a, ::sse_i b)
{
  ::sse_i result;
  for (int i = 0; i < 4; i++)
    {
      result.__sse_i.i[i] = a.__sse_i.i[i] & b.__sse_i.i[i];
    }
  return result;
}
static inline __attribute__((always_inline)) ::sse_f _mm_andnot_ps(::sse_f a, ::sse_f b)
{
  ::sse_f result;
  for (int i = 0; i < 4; i++)
    {
      *((int *)&result.f[i]) = ~*((int *)&a.f[i]) & *((int *)&b.f[i]);
    }
  return result;
}
static inline __attribute__((always_inline)) ::sse_i _mm_andnot_si128(::sse_i a, ::sse_i b)
{
  ::sse_i result;
  for (int i = 0; i < 4; i++)
    {
      result.__sse_i.i[i] = ~a.__sse_i.i[i] & b.__sse_i.i[i];
    }
  return result;
}
static inline __attribute__((always_inline)) ::sse_i _mm_cmpeq_epi32(::sse_i a, ::sse_i b)
{
  ::sse_i result;
  for (int i = 0; i < 4; i++)
    {
      result.__sse_i.i[i] = a.__sse_i.i[i] == b.__sse_i.i[i] ? 4294967295U : 0;
    }
  return result;
}
static inline __attribute__((always_inline)) ::sse_f _mm_cmpeq_ps(::sse_f a, ::sse_f b)
{
  ::sse_f result;
  for (int i = 0; i < 4; i++)
    {
      *((int *)&result.f[i]) = *((int *)&a.f[i]) == *((int *)&b.f[i]) ? 4294967295U : 0;
    }
  return result;
}
static inline __attribute__((always_inline)) ::sse_f _mm_cmpge_ps(::sse_f a, ::sse_f b)
{
  ::sse_f result;
  for (int i = 0; i < 4; i++)
    {
      *((int *)&result.f[i]) = a.f[i] >= b.f[i] ? 4294967295U : 0;
    }
  return result;
}
static inline __attribute__((always_inline)) ::sse_f _mm_cmpgt_ps(::sse_f a, ::sse_f b)
{
  ::sse_f result;
  for (int i = 0; i < 4; i++)
    {
      *((int *)&result.f[i]) = a.f[i] > b.f[i] ? 4294967295U : 0;
    }
  return result;
}
static inline __attribute__((always_inline)) ::sse_f _mm_cmple_ps(::sse_f a, ::sse_f b)
{
  ::sse_f result;
  for (int i = 0; i < 4; i++)
    {
      *((int *)&result.f[i]) = a.f[i] <= b.f[i] ? 4294967295U : 0;
    }
  return result;
}
static inline __attribute__((always_inline)) ::sse_i _mm_cmplt_epi32(::sse_i a, ::sse_i b)
{
  ::sse_i result;
  int i;
  for (i = 0; i < 4; i++)
    {
      result.__sse_i.i[i] = a.__sse_i.i[i] < b.__sse_i.i[i] ? 4294967295U : 0;
    }
  return result;
}
static inline __attribute__((always_inline)) ::sse_i _mm_cmpgt_epi32(::sse_i a, ::sse_i b)
{
  ::sse_i result;
  int i;
  for (i = 0; i < 4; i++)
    {
      result.__sse_i.i[i] = a.__sse_i.i[i] > b.__sse_i.i[i] ? 4294967295U : 0;
    }
  return result;
}
static inline __attribute__((always_inline)) ::sse_f _mm_cmplt_ps(::sse_f a, ::sse_f b)
{
  ::sse_f result;
  for (int i = 0; i < 4; i++)
    {
      *((int *)&result.f[i]) = a.f[i] < b.f[i] ? 4294967295U : 0;
    }
  return result;
}
static inline __attribute__((always_inline)) ::sse_f _mm_cmple_ss(::sse_f a, ::sse_f b)
{
  ::sse_f result;
  *((int *)&result.f[0]) = a.f[0] <= b.f[0] ? 4294967295U : 0;
  for (int i = 1; i < 4; i++)
    {
      result.f[i] = a.f[i];
    }
  return result;
}
static inline __attribute__((always_inline)) ::sse_f _mm_cmpneq_ps(::sse_f a, ::sse_f b)
{
  ::sse_f result;
  for (int i = 0; i < 4; i++)
    {
      *((int *)&result.f[i]) = !(a.f[i] == b.f[i]) ? 4294967295U : 0;
    }
  return result;
}
static inline __attribute__((always_inline)) ::sse_f _mm_cvtepi32_ps(::sse_i a)
{
  ::sse_f result;
  for (int i = 0; i < 4; i++)
    {
      result.f[i] = (float)a.__sse_i.i[i];
    }
  return result;
}
static inline __attribute__((always_inline)) ::sse_i _mm_cvtps_epi32(::sse_f a)
{
  ::sse_i result;
  ::sse_f temp;
  temp = a;
  for (int i = 0; i < 4; i++)
    {
      result.__sse_i.i[i] = ::_emm_round_nearest(temp.f[i]);
    }
  return result;
}
static inline __attribute__((always_inline)) ::sse_f _mm_cvtsi32_ss(::sse_f a, int b)
{
  ::sse_f result;
  result.f[0] = (float)b;
  for (int i = 1; i < 4; i++)
    {
      *((int *)&result.f[i]) = *((int *)&a.f[i]);
    }
  return result;
}
static inline __attribute__((always_inline)) ::sse_i _mm_cvttps_epi32(::sse_f a)
{
  ::sse_i result;
  ::sse_f temp;
  temp = a;
  for (int i = 0; i < 4; i++)
    {
      result.__sse_i.i[i] = ::_emm_round_trunc(temp.f[i]);
    }
  return result;
}
static inline __attribute__((always_inline)) ::sse_i64 _mm_cvtps_pi32(::sse_f a)
{
  ::sse_i64 result;
  result.__sse_i64.dw[0] = ::_emm_round_nearest(a.f[0]);
  result.__sse_i64.dw[1] = ::_emm_round_nearest(a.f[1]);
  return result;
}
static inline __attribute__((always_inline)) int _mm_cvttss_si32(::sse_f a)
{
  int result;
  result = ::_mm_round_trunc(a.f[0]);
  return result;
}
static inline __attribute__((always_inline)) ::sse_f _mm_div_ps(::sse_f a, ::sse_f b)
{
  ::sse_f result;
  for (int i = 0; i < 4; i++)
    {
      result.f[i] = a.f[i] / b.f[i];
    }
  return result;
}
static inline __attribute__((always_inline)) ::sse_f _mm_load_ps(const float *a)
{
  ::sse_f result;
  if ((unsigned long long int)a % 16 != 0)
    {
      {
        ::fprintf(::stderr, "*** Functionality intrinsics error: %s ***\n", "address must be 16-byte aligned");
        ::exit(1);
      }
      ;
    }
  ;
  for (int i = 0; i < 4; i++)
    {
      result.f[i] = a[i];
    }
  return result;
}
static inline __attribute__((always_inline)) ::sse_i _mm_load_si128(::sse_i *p)
{
  ::sse_i result;
  if ((unsigned long long int)p % 16 != 0)
    {
      {
        ::fprintf(::stderr, "*** Functionality intrinsics error: %s ***\n", "address must be 16-byte aligned");
        ::exit(1);
      }
      ;
    }
  ;
  result = *p;
  return result;
}
static inline __attribute__((always_inline)) void _mm_maskmoveu_si128(::sse_i d, ::sse_i n, char *p)
{
  int i;
  for (i = 0; i < 16; i++)
    {
      if (n.__sse_i.b[i] & 128)
        {
          p[i] = d.__sse_i.b[i];
        }
    }
}
static inline __attribute__((always_inline)) ::sse_f _mm_max_ps(::sse_f a, ::sse_f b)
{
  ::sse_f result;
  for (int i = 0; i < 4; i++)
    {
      result.f[i] = a.f[i] > b.f[i] ? a.f[i] : b.f[i];
    }
  return result;
}
static inline __attribute__((always_inline)) ::sse_f _mm_min_ps(::sse_f a, ::sse_f b)
{
  ::sse_f result;
  for (int i = 0; i < 4; i++)
    {
      result.f[i] = a.f[i] < b.f[i] ? a.f[i] : b.f[i];
    }
  return result;
}
static inline __attribute__((always_inline)) ::sse_f _mm_movehl_ps(::sse_f a, ::sse_f b)
{
  ::sse_f result;
  result.f[0] = b.f[2];
  result.f[1] = b.f[3];
  result.f[2] = a.f[2];
  result.f[3] = a.f[3];
  return result;
}
static inline __attribute__((always_inline)) int _mm_movemask_epi8(::sse_i a)
{
  int result;
  result = (((((((((((((((a.__sse_i.b[0] >> 7 & 1) | (a.__sse_i.b[1] >> 6 & 2)) | (a.__sse_i.b[2] >> 5 & 4)) | (a.__sse_i.b[3] >> 4 & 8)) | (a.__sse_i.b[4] >> 3 & 16)) | (a.__sse_i.b[5] >> 2 & 32)) | (a.__sse_i.b[6] >> 1 & 64)) | (a.__sse_i.b[7] >> 4 & 128)) | (a.__sse_i.b[8] << 1 & 256)) | (a.__sse_i.b[9] << 2 & 512)) | (a.__sse_i.b[10] << 3 & 1024)) | (a.__sse_i.b[11] << 4 & 2048)) | (a.__sse_i.b[12] << 5 & 4096)) | (a.__sse_i.b[13] << 6 & 8192)) | (a.__sse_i.b[14] << 7 & 16384)) | (a.__sse_i.b[15] << 8 & 32768);
  return result;
}
static inline __attribute__((always_inline)) int _mm_movemask_ps(::sse_f a)
{
  int result;
  result = (((*((int *)&a.f[0]) >> 31 & 1) | (*((int *)&a.f[1]) >> 30 & 2)) | (*((int *)&a.f[2]) >> 29 & 4)) | (*((int *)&a.f[3]) >> 28 & 8);
  return result;
}
static inline __attribute__((always_inline)) ::sse_f _mm_mul_ss(::sse_f a, ::sse_f b)
{
  ::sse_f result;
  result.f[0] = a.f[0] * b.f[0];
  for (int i = 1; i < 4; i++)
    {
      result.f[i] = a.f[i];
    }
  return result;
}
static inline __attribute__((always_inline)) ::sse_f _mm_mul_ps(::sse_f a, ::sse_f b)
{
  ::sse_f result;
  for (int i = 0; i < 4; i++)
    {
      result.f[i] = a.f[i] * b.f[i];
    }
  return result;
}
static inline __attribute__((always_inline)) float _mminternal_approx(float x)
{
  unsigned int *p((unsigned int *)&x);
  *p = *p & 4294965248U;
  return x;
}
static inline __attribute__((always_inline)) ::sse_f _mm_or_ps(::sse_f a, ::sse_f b)
{
  ::sse_f result;
  for (int i = 0; i < 4; i++)
    {
      *((int *)&result.f[i]) = *((int *)&a.f[i]) | *((int *)&b.f[i]);
    }
  return result;
}
static inline __attribute__((always_inline)) ::sse_i _mm_or_si128(::sse_i a, ::sse_i b)
{
  ::sse_i result;
  for (int i = 0; i < 4; i++)
    {
      result.__sse_i.i[i] = a.__sse_i.i[i] | b.__sse_i.i[i];
    }
  return result;
}
static inline __attribute__((always_inline)) ::sse_f _mm_rcp_ps(::sse_f a)
{
  ::sse_f result;
  for (int i = 0; i < 4; i++)
    {
      result.f[i] = ::_mminternal_approx(1.000000000000000000000000e+00f / a.f[i]);
    }
  return result;
}
static inline __attribute__((always_inline)) ::sse_f _mm_rcp_ss(::sse_f a)
{
  ::sse_f result;
  result.f[0] = ::_mminternal_approx(1.000000000000000000000000e+00f / a.f[0]);
  for (int i = 1; i < 4; i++)
    {
      result.f[i] = a.f[i];
    }
  return result;
}
static inline __attribute__((always_inline)) ::sse_f _mm_rsqrt_ss(::sse_f a)
{
  ::sse_f result;
  result.f[0] = ::_mminternal_approx(1.000000000000000000000000e+00f / ::_mminternal_sqrt(a.f[0]));
  for (int i = 1; i < 4; i++)
    {
      result.f[i] = a.f[i];
    }
  return result;
}
static inline __attribute__((always_inline)) ::sse_f _mm_rsqrt_ps(::sse_f a)
{
  ::sse_f result;
  for (int i = 0; i < 4; i++)
    {
      result.f[i] = ::_mminternal_approx(1.000000000000000000000000e+00f / ::_mminternal_sqrt(a.f[i]));
    }
  return result;
}
static inline __attribute__((always_inline)) ::sse_i _mm_set1_epi32(int i)
{
  ::sse_i result;
  result.__sse_i.i[3] = result.__sse_i.i[2] = result.__sse_i.i[1] = result.__sse_i.i[0] = i;
  return result;
}
static inline __attribute__((always_inline)) ::sse_i _mm_set_epi32(int i3, int i2, int i1, int i0)
{
  ::sse_i result;
  result.__sse_i.i[0] = i0;
  result.__sse_i.i[1] = i1;
  result.__sse_i.i[2] = i2;
  result.__sse_i.i[3] = i3;
  return result;
}
static inline __attribute__((always_inline)) ::sse_f _mm_set_ps(float a, float b, float c, float d)
{
  ::sse_f result;
  result.f[0] = a;
  result.f[1] = b;
  result.f[2] = c;
  result.f[3] = d;
  return result;
}
static inline __attribute__((always_inline)) ::sse_f _mm_set_ps1(float a)
{
  ::sse_f result;
  for (int i = 0; i < 4; i++)
    {
      result.f[i] = a;
    }
  return result;
}
static inline __attribute__((always_inline)) ::sse_f _mm_set_ss(float a)
{
  ::sse_f result;
  result.f[0] = a;
  for (int i = 1; i < 4; i++)
    {
      result.f[i] = 0.000000000000000000000000e+00f;
    }
  return result;
}
static inline __attribute__((always_inline)) ::sse_i _mm_setr_epi32(int i0, int i1, int i2, int i3)
{
  ::sse_i result;
  result.__sse_i.i[0] = i0;
  result.__sse_i.i[1] = i1;
  result.__sse_i.i[2] = i2;
  result.__sse_i.i[3] = i3;
  return result;
}
static inline __attribute__((always_inline)) ::sse_f _mm_setr_ps(float a, float b, float c, float d)
{
  ::sse_f result;
  result.f[0] = a;
  result.f[1] = b;
  result.f[2] = c;
  result.f[3] = d;
  return result;
}
static inline __attribute__((always_inline)) ::sse_f _mm_setzero_ps()
{
  ::sse_f result;
  for (int i = 0; i < 4; i++)
    {
      result.f[i] = 0.00000000000000000000000000000000000000000000000000000e+00;
    }
  return result;
}
static inline __attribute__((always_inline)) ::sse_i _mm_slli_epi32(::sse_i a, int count)
{
  ::sse_i result;
  int i;
  if (count > 31)
    {
      for (int i = 0; i < 4; i++)
        {
          result.__sse_i.i[i] = 0;
        }
    }
  else
    {
      for (i = 0; i < 4; i++)
        {
          result.__sse_i.i[i] = a.__sse_i.i[i] << count;
        }
    }
  return result;
}
static inline __attribute__((always_inline)) ::sse_i _mm_shuffle_epi32(::sse_i a, int imm8)
{
  ::sse_i result;
  int t;
  for (int i = 0; i < 4; i++)
    {
      t = imm8 >> 2 * i & 3;
      result.__sse_i.i[i] = t == 0 ? a.__sse_i.i[0] : t == 1 ? a.__sse_i.i[1] : t == 2 ? a.__sse_i.i[2] : a.__sse_i.i[3];
    }
  return result;
}
static inline __attribute__((always_inline)) ::sse_f _mm_shuffle_ps(::sse_f a, ::sse_f b, unsigned int imm8)
{
  ::sse_f result;
  for (int i = 0; i < 4; i++)
    {
      result.f[i] = b.f[imm8 >> 2 * i & 3];
    }
  return result;
}
static inline __attribute__((always_inline)) void _mm_stream_ps(float *a, ::sse_f b)
{
  if ((unsigned long long int)a % 16 != 0)
    {
      {
        ::fprintf(::stderr, "*** Functionality intrinsics error: %s ***\n", "address must be 16-byte aligned");
        ::exit(1);
      }
      ;
    }
  ;
  *((::sse_f *)a) = b;
}
static inline __attribute__((always_inline)) ::sse_i _mm_srli_epi32(::sse_i a, int count)
{
  ::sse_i result;
  int i;
  if (count > 31)
    {
      for (int i = 0; i < 4; i++)
        {
          result.__sse_i.ui[i] = 0;
        }
    }
  else
    {
      for (i = 0; i < 4; i++)
        {
          result.__sse_i.ui[i] = a.__sse_i.ui[i] >> count;
        }
    }
  return result;
}
static inline __attribute__((always_inline)) ::sse_f _mm_sqrt_ps(::sse_f a)
{
  ::sse_f result;
  for (int i = 0; i < 4; i++)
    {
      result.f[i] = ::_mminternal_sqrt(a.f[i]);
    }
  return result;
}
static inline __attribute__((always_inline)) void _mm_store_ps(float *v, ::sse_f a)
{
  for (int i = 0; i < 4; i++)
    {
      v[i] = a.f[i];
    }
}
static inline __attribute__((always_inline)) ::sse_i _mm_sub_epi32(::sse_i a, ::sse_i b)
{
  ::sse_i result;
  for (int i = 0; i < 4; i++)
    {
      result.__sse_i.i[i] = a.__sse_i.i[i] - b.__sse_i.i[i];
    }
  return result;
}
static inline __attribute__((always_inline)) ::sse_f _mm_sub_ss(::sse_f a, ::sse_f b)
{
  ::sse_f result;
  result.f[0] = a.f[0] - b.f[0];
  for (int i = 1; i < 4; i++)
    {
      result.f[i] = a.f[i];
    }
  return result;
}
static inline __attribute__((always_inline)) ::sse_f _mm_sub_ps(::sse_f a, ::sse_f b)
{
  ::sse_f result;
  for (int i = 0; i < 4; i++)
    {
      result.f[i] = a.f[i] - b.f[i];
    }
  return result;
}
static inline __attribute__((always_inline)) ::sse_f _mm_unpackhi_ps(::sse_f a, ::sse_f b)
{
  ::sse_f result;
  result.f[0] = a.f[2];
  result.f[1] = b.f[2];
  result.f[2] = a.f[3];
  result.f[3] = b.f[3];
  return result;
}
static inline __attribute__((always_inline)) ::sse_f _mm_unpacklo_ps(::sse_f a, ::sse_f b)
{
  ::sse_f result;
  result.f[0] = a.f[0];
  result.f[1] = b.f[0];
  result.f[2] = a.f[1];
  result.f[3] = b.f[1];
  return result;
}
static inline __attribute__((always_inline)) ::sse_f _mm_xor_ps(::sse_f a, ::sse_f b)
{
  ::sse_f result;
  for (int i = 0; i < 4; i++)
    {
      result.f[i] = (int)a.f[i] ^ (int)b.f[i];
    }
  return result;
}
static inline __attribute__((always_inline)) ::sse_i64 _mm_packs_pi32(::sse_i64 a, ::sse_i64 b)
{
  ::sse_i64 result;
  result.__sse_i64.wd[0] = a.__sse_i64.dw[0];
  result.__sse_i64.wd[1] = a.__sse_i64.dw[1];
  result.__sse_i64.wd[2] = b.__sse_i64.dw[0];
  result.__sse_i64.wd[3] = b.__sse_i64.dw[1];
  return result;
}
static inline __attribute__((always_inline)) ::sse_i64 _mm_setzero_si64()
{
  ::sse_i64 result;
  result.__sse_i64.dw[1] = result.__sse_i64.dw[0] = 0;
  return result;
}
static inline __attribute__((always_inline)) ::sse_i64 _mm_unpacklo_pi16(::sse_i64 a, ::sse_i64 b)
{
  ::sse_i64 result;
  result.__sse_i64.wd[0] = a.__sse_i64.wd[0];
  result.__sse_i64.wd[1] = b.__sse_i64.wd[0];
  result.__sse_i64.wd[2] = a.__sse_i64.wd[1];
  result.__sse_i64.wd[3] = b.__sse_i64.wd[1];
  return result;
}
static inline __attribute__((always_inline)) ::sse_i64 _mm_unpackhi_pi16(::sse_i64 a, ::sse_i64 b)
{
  ::sse_i64 result;
  result.__sse_i64.wd[0] = a.__sse_i64.wd[2];
  result.__sse_i64.wd[1] = b.__sse_i64.wd[2];
  result.__sse_i64.wd[2] = a.__sse_i64.wd[3];
  result.__sse_i64.wd[3] = b.__sse_i64.wd[3];
  return result;
}
static inline __attribute__((always_inline)) ::sse_i64 _mm_unpacklo_pi32(::sse_i64 a, ::sse_i64 b)
{
  ::sse_i64 result;
  result.__sse_i64.dw[0] = a.__sse_i64.dw[0];
  result.__sse_i64.dw[1] = b.__sse_i64.dw[0];
  return result;
}
static inline __attribute__((always_inline)) ::sse_i64 _mm_unpackhi_pi32(::sse_i64 a, ::sse_i64 b)
{
  ::sse_i64 result;
  result.__sse_i64.dw[0] = a.__sse_i64.dw[1];
  result.__sse_i64.dw[1] = b.__sse_i64.dw[1];
  return result;
}
static inline __attribute__((always_inline)) ::sse_i64 _mm_packs_pu16(::sse_i64 a, ::sse_i64 b)
{
  ::sse_i64 result;
  result.__sse_i64.b[0] = a.__sse_i64.wd[0];
  result.__sse_i64.b[1] = a.__sse_i64.wd[1];
  result.__sse_i64.b[2] = a.__sse_i64.wd[2];
  result.__sse_i64.b[3] = a.__sse_i64.wd[3];
  result.__sse_i64.b[4] = b.__sse_i64.wd[0];
  result.__sse_i64.b[5] = b.__sse_i64.wd[1];
  result.__sse_i64.b[6] = b.__sse_i64.wd[2];
  result.__sse_i64.b[7] = b.__sse_i64.wd[3];
  return result;
}
static inline __attribute__((always_inline)) ::sse_i _mm_setr_epi64(::sse_i64 a, ::sse_i64 b)
{
  ::sse_i result;
  result.__sse_i.l[0] = a;
  result.__sse_i.l[1] = b;
  return result;
}
static inline __attribute__((always_inline)) unsigned int _mm_getcsr()
{
  return 0;
}
static inline __attribute__((always_inline)) void _mm_setcsr(unsigned int v)
{
  return ;
}
inline __attribute__((always_inline)) void *malloc_align(const int size, const int alignment  = 64)
{
  return ::memalign(alignment, size);
}
inline __attribute__((always_inline)) void free_align(void *ptr)
{
  ::free(ptr);
}
template < typename T, int alignment = 64 >
class  Align
{
  public:
    template < typename U >
    class rebind;
    typedef T value_type;
    typedef typename ::Align<T, alignment>::value_type *pointer;
    typedef const typename ::Align<T, alignment>::value_type *const_pointer;
    typedef typename ::Align<T, alignment>::value_type &reference;
    typedef const typename ::Align<T, alignment>::value_type &const_reference;
    typedef ::size_t size_type;
    typedef ::std::ptrdiff_t difference_type;
    inline Align()
    {
    }
    inline Align(const T &)
    {
    }
    inline typename ::Align<T, alignment>::pointer allocate(typename ::Align<T, alignment>::size_type n)
    {
      void *mem(malloc_align(n * sizeof(typename ::Align<T, alignment>::value_type), alignment));
      return reinterpret_cast<typename ::Align<T, alignment>::pointer>(mem);
    }
    inline __attribute__((always_inline)) void deallocate(typename ::Align<T, alignment>::pointer p, typename ::Align<T, alignment>::size_type)
    {
      if (p)
        {
          free_align(p);
        }
    }
    inline __attribute__((always_inline)) void construct(typename ::Align<T, alignment>::pointer p, const T &t)
    {
      new (p)T(t);
    }
    inline __attribute__((always_inline)) void destroy(typename ::Align<T, alignment>::pointer p)
    {
      p->~T();
    }
    template < typename U >
    class  rebind
    {
      public:
        typedef ::Align<U, 64> other;
    };
    inline typename ::Align<T, alignment>::size_type max_size() const 
    {
      return static_cast<typename ::Align<T, alignment>::size_type>( -1) / sizeof(typename ::Align<T, alignment>::value_type);
    }
};
template < ::size_t N, typename T >
inline bool is_aligned(T *t);
template < ::size_t N, typename T >
inline bool is_aligned(T *t)
{
  long int l = (long int)((unsigned char *)t - (unsigned char *)0L);
  return l % N == 0;
}
template < ::size_t N, typename T >
inline bool is_divisible(T t);
template < ::size_t N, typename T >
inline bool is_divisible(T t)
{
  return t % N == 0;
}
template < int N, typename T >
inline T nextMultipleOf(T t);
template < int N, typename T >
inline T nextMultipleOf(T t)
{
  return (t + N - 1) / N * N;
}
template < typename T >
T *aligned_malloc(int N);
template < typename T >
T *aligned_malloc(int N)
{
  return (T *)::malloc_align(N * sizeof(T) /* , 64 */ );
}
template < typename T >
void aligned_free(T *t);
template < typename T >
void aligned_free(T *t)
{
  return free_align(t);
}
inline __attribute__((always_inline)) float MBytes(unsigned int n)
{
  return (float)n / 1.024000000000000000000000e+03f;
}
inline __attribute__((always_inline)) float KBytes(unsigned int n)
{
  return (float)n / 1.024000000000000000000000e+03f;
}
namespace std __attribute__((__visibility__("default"))) {
  template < typename _CharT, typename _Traits, typename _Alloc >
  class  basic_stringbuf : public ::std::basic_streambuf<_CharT, _Traits>
  {
    public:
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef _Alloc allocator_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef ::std::basic_streambuf<typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::char_type, typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::traits_type> __streambuf_type;
      typedef ::std::basic_string<typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::char_type, _Traits, _Alloc> __string_type;
      typedef typename ::std::basic_string<typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::char_type, _Traits, _Alloc>::size_type __size_type;
    protected:
      ::std::ios_base::openmode _M_mode;
      typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::__string_type _M_string;
    public:
      inline explicit basic_stringbuf(::std::ios_base::openmode __mode  = ::std::ios_base::in | ::std::ios_base::out)
        : __streambuf_type(), _M_mode(__mode), _M_string()
      {
      }
      inline explicit basic_stringbuf(const typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::__string_type &__str, ::std::ios_base::openmode __mode  = ::std::ios_base::in | ::std::ios_base::out)
        : __streambuf_type(), _M_mode(), _M_string(__str.data(), __str.size())
      {
        _M_stringbuf_init(__mode);
      }
      inline typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::__string_type str() const 
      {
        typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::__string_type __ret;
        if (this->pptr())
          {
            if (this->pptr() > this->egptr())
              {
                __ret = __string_type(this->pbase(), this->pptr());
              }
            else
              {
                __ret = __string_type(this->pbase(), this->egptr());
              }
          }
        else
          {
            __ret = _M_string;
          }
        return __ret;
      }
      inline void str(const typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::__string_type &__s)
      {
        _M_string.assign(__s.data(), __s.size());
        _M_stringbuf_init(_M_mode);
      }
    protected:
      inline void _M_stringbuf_init(::std::ios_base::openmode __mode)
      {
        _M_mode = __mode;
        typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::__size_type __len = 0;
        if (_M_mode & (::std::ios_base::ate | ::std::ios_base::app))
          {
            __len = _M_string.size();
          }
        _M_sync(const_cast<typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::char_type *>(_M_string.data()), 0, __len);
      }
      inline virtual ::std::streamsize showmanyc()
      {
        ::std::streamsize __ret( -1);
        if (_M_mode & ::std::ios_base::in)
          {
            _M_update_egptr();
            __ret = this->egptr() - this->gptr();
          }
        return __ret;
      }
      virtual typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::int_type underflow();
      virtual typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::int_type pbackfail(typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::int_type __c  = traits_type::eof());
      virtual typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::int_type overflow(typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::int_type __c  = traits_type::eof());
      inline virtual typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::__streambuf_type *setbuf(typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::char_type *__s, ::std::streamsize __n)
      {
        if (__s && __n >= 0)
          {
            _M_string.clear();
            _M_sync(__s, __n, 0);
          }
        return this;
      }
      virtual typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type seekoff(typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::off_type __off, ::std::ios_base::seekdir __way, ::std::ios_base::openmode __mode  = ::std::ios_base::in | ::std::ios_base::out);
      virtual typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type seekpos(typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type __sp, ::std::ios_base::openmode __mode  = ::std::ios_base::in | ::std::ios_base::out);
      void _M_sync(typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::char_type *__base, typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::__size_type __i, typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::__size_type __o);
      inline void _M_update_egptr()
      {
        const bool __testin = _M_mode & ::std::ios_base::in;
        if (this->pptr() && this->pptr() > this->egptr())
          {
            if (__testin)
              {
                this->setg(this->eback(), this->gptr(), this->pptr());
              }
            else
              {
                this->setg(this->pptr(), this->pptr(), this->pptr());
              }
          }
      }
      void _M_pbump(typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::char_type *__pbeg, typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::char_type *__pend, typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::off_type __off);
  };
  template < typename _CharT, typename _Traits, typename _Alloc >
  class  basic_istringstream : public ::std::basic_istream<_CharT, _Traits>
  {
    public:
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef _Alloc allocator_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef ::std::basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef ::std::basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef ::std::basic_istream<typename ::std::basic_istringstream<_CharT, _Traits, _Alloc>::char_type, typename ::std::basic_istringstream<_CharT, _Traits, _Alloc>::traits_type> __istream_type;
    private:
      typename ::std::basic_istringstream<_CharT, _Traits, _Alloc>::__stringbuf_type _M_stringbuf;
    public:
      inline explicit basic_istringstream(::std::ios_base::openmode __mode  = ::std::ios_base::in)
        : __istream_type(), _M_stringbuf(__mode | ::std::ios_base::in)
      {
        this->init(&_M_stringbuf);
      }
      inline explicit basic_istringstream(const typename ::std::basic_istringstream<_CharT, _Traits, _Alloc>::__string_type &__str, ::std::ios_base::openmode __mode  = ::std::ios_base::in)
        : __istream_type(), _M_stringbuf(__str, __mode | ::std::ios_base::in)
      {
        this->init(&_M_stringbuf);
      }
      inline ~basic_istringstream()
      {
      }
      inline typename ::std::basic_istringstream<_CharT, _Traits, _Alloc>::__stringbuf_type *rdbuf() const 
      {
        return const_cast<typename ::std::basic_istringstream<_CharT, _Traits, _Alloc>::__stringbuf_type *>(&_M_stringbuf);
      }
      inline typename ::std::basic_istringstream<_CharT, _Traits, _Alloc>::__string_type str() const 
      {
        return _M_stringbuf.str();
      }
      inline void str(const typename ::std::basic_istringstream<_CharT, _Traits, _Alloc>::__string_type &__s)
      {
        _M_stringbuf.str(__s);
      }
  };
  template < typename _CharT, typename _Traits, typename _Alloc >
  class  basic_ostringstream : public ::std::basic_ostream<_CharT, _Traits>
  {
    public:
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef _Alloc allocator_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef ::std::basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef ::std::basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef ::std::basic_ostream<typename ::std::basic_ostringstream<_CharT, _Traits, _Alloc>::char_type, typename ::std::basic_ostringstream<_CharT, _Traits, _Alloc>::traits_type> __ostream_type;
    private:
      typename ::std::basic_ostringstream<_CharT, _Traits, _Alloc>::__stringbuf_type _M_stringbuf;
    public:
      inline explicit basic_ostringstream(::std::ios_base::openmode __mode  = ::std::ios_base::out)
        : __ostream_type(), _M_stringbuf(__mode | ::std::ios_base::out)
      {
        this->init(&_M_stringbuf);
      }
      inline explicit basic_ostringstream(const typename ::std::basic_ostringstream<_CharT, _Traits, _Alloc>::__string_type &__str, ::std::ios_base::openmode __mode  = ::std::ios_base::out)
        : __ostream_type(), _M_stringbuf(__str, __mode | ::std::ios_base::out)
      {
        this->init(&_M_stringbuf);
      }
      inline ~basic_ostringstream()
      {
      }
      inline typename ::std::basic_ostringstream<_CharT, _Traits, _Alloc>::__stringbuf_type *rdbuf() const 
      {
        return const_cast<typename ::std::basic_ostringstream<_CharT, _Traits, _Alloc>::__stringbuf_type *>(&_M_stringbuf);
      }
      inline typename ::std::basic_ostringstream<_CharT, _Traits, _Alloc>::__string_type str() const 
      {
        return _M_stringbuf.str();
      }
      inline void str(const typename ::std::basic_ostringstream<_CharT, _Traits, _Alloc>::__string_type &__s)
      {
        _M_stringbuf.str(__s);
      }
  };
  template < typename _CharT, typename _Traits, typename _Alloc >
  class  basic_stringstream : public ::std::basic_iostream<_CharT, _Traits>
  {
    public:
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef _Alloc allocator_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef ::std::basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef ::std::basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef ::std::basic_iostream<typename ::std::basic_stringstream<_CharT, _Traits, _Alloc>::char_type, typename ::std::basic_stringstream<_CharT, _Traits, _Alloc>::traits_type> __iostream_type;
    private:
      typename ::std::basic_stringstream<_CharT, _Traits, _Alloc>::__stringbuf_type _M_stringbuf;
    public:
      inline explicit basic_stringstream(::std::ios_base::openmode __m  = ::std::ios_base::out | ::std::ios_base::in)
        : __iostream_type(), _M_stringbuf(__m)
      {
        this->init(&_M_stringbuf);
      }
      inline explicit basic_stringstream(const typename ::std::basic_stringstream<_CharT, _Traits, _Alloc>::__string_type &__str, ::std::ios_base::openmode __m  = ::std::ios_base::out | ::std::ios_base::in)
        : __iostream_type(), _M_stringbuf(__str, __m)
      {
        this->init(&_M_stringbuf);
      }
      inline ~basic_stringstream()
      {
      }
      inline typename ::std::basic_stringstream<_CharT, _Traits, _Alloc>::__stringbuf_type *rdbuf() const 
      {
        return const_cast<typename ::std::basic_stringstream<_CharT, _Traits, _Alloc>::__stringbuf_type *>(&_M_stringbuf);
      }
      inline typename ::std::basic_stringstream<_CharT, _Traits, _Alloc>::__string_type str() const 
      {
        return _M_stringbuf.str();
      }
      inline void str(const typename ::std::basic_stringstream<_CharT, _Traits, _Alloc>::__string_type &__s)
      {
        _M_stringbuf.str(__s);
      }
  };
  template < typename _CharT, typename _Traits, typename _Alloc >
  typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::int_type basic_stringbuf<_CharT, _Traits, _Alloc>::pbackfail(typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::int_type __c)
  {
    typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::int_type __ret = traits_type::eof();
    if (this->eback() < this->gptr())
      {
        const bool __testeof(traits_type::eq_int_type(__c, __ret));
        if (!__testeof)
          {
            const bool __testeq(traits_type::eq(traits_type::to_char_type(__c), this->gptr()[ -1]));
            const bool __testout(this->_M_mode & ::std::ios_base::out);
            if (__testeq || __testout)
              {
                this->gbump( -1);
                if (!__testeq)
                  {
                    *this->gptr() = traits_type::to_char_type(__c);
                  }
                __ret = __c;
              }
          }
        else
          {
            this->gbump( -1);
            __ret = traits_type::not_eof(__c);
          }
      }
    return __ret;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::int_type basic_stringbuf<_CharT, _Traits, _Alloc>::overflow(typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::int_type __c)
  {
    const bool __testout(this->_M_mode & ::std::ios_base::out);
    if (__builtin_expect(!__testout, false))
      {
        return traits_type::eof();
      }
    const bool __testeof(traits_type::eq_int_type(__c, traits_type::eof()));
    if (__builtin_expect(__testeof, false))
      {
        return traits_type::not_eof(__c);
      }
    const typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::__size_type __capacity = _M_string.capacity();
    const typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::__size_type __max_size = _M_string.max_size();
    const bool __testput(this->pptr() < this->epptr());
    if (__builtin_expect(!__testput && __capacity == __max_size, false))
      {
        return traits_type::eof();
      }
    const typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::char_type __conv = traits_type::to_char_type(__c);
    if (!__testput)
      {
        const typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::__size_type __opt_len = std::max(__size_type(2 * __capacity), typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::__size_type(512));
        const typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::__size_type __len = std::min(__opt_len, __max_size);
        typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::__string_type __tmp;
        __tmp.reserve(__len);
        if (this->pbase())
          {
            __tmp.assign(this->pbase(), this->epptr() - this->pbase());
          }
        __tmp.push_back(__conv);
        _M_string.swap(__tmp);
        _M_sync(const_cast<typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::char_type *>(_M_string.data()), this->gptr() - this->eback(), this->pptr() - this->pbase());
      }
    else
      {
        *this->pptr() = __conv;
      }
    this->pbump(1);
    return __c;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::int_type basic_stringbuf<_CharT, _Traits, _Alloc>::underflow()
  {
    typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::int_type __ret = traits_type::eof();
    const bool __testin(this->_M_mode & ::std::ios_base::in);
    if (__testin)
      {
        _M_update_egptr();
        if (this->gptr() < this->egptr())
          {
            __ret = traits_type::to_int_type(*this->gptr());
          }
      }
    return __ret;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type basic_stringbuf<_CharT, _Traits, _Alloc>::seekoff(typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::off_type __off, ::std::ios_base::seekdir __way, ::std::ios_base::openmode __mode)
  {
    typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type __ret = pos_type(typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::off_type( -1));
    bool __testin(((::std::ios_base::in & this->_M_mode) & __mode) != 0);
    bool __testout(((::std::ios_base::out & this->_M_mode) & __mode) != 0);
    const bool __testboth((__testin && __testout) && __way != ::std::ios_base::cur);
    __testin &= !(__mode & ::std::ios_base::out);
    __testout &= !(__mode & ::std::ios_base::in);
    const typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::char_type *__beg = __testin ? this->eback() : this->pbase();
    if ((__beg || !__off) && ((__testin || __testout) || __testboth))
      {
        _M_update_egptr();
        typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::off_type __newoffi = __off;
        typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::off_type __newoffo = __newoffi;
        if (__way == ::std::ios_base::cur)
          {
            __newoffi += this->gptr() - __beg;
            __newoffo += this->pptr() - __beg;
          }
        else
          {
            if (__way == ::std::ios_base::end)
              {
                __newoffo = __newoffi += this->egptr() - __beg;
              }
          }
        if (((__testin || __testboth) && __newoffi >= 0) && this->egptr() - __beg >= __newoffi)
          {
            this->setg(this->eback(), this->eback() + __newoffi, this->egptr());
            __ret = pos_type(__newoffi);
          }
        if (((__testout || __testboth) && __newoffo >= 0) && this->egptr() - __beg >= __newoffo)
          {
            _M_pbump(this->pbase(), this->epptr(), __newoffo);
            __ret = pos_type(__newoffo);
          }
      }
    return __ret;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type basic_stringbuf<_CharT, _Traits, _Alloc>::seekpos(typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type __sp, ::std::ios_base::openmode __mode)
  {
    typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type __ret = pos_type(typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::off_type( -1));
    const bool __testin(((::std::ios_base::in & this->_M_mode) & __mode) != 0);
    const bool __testout(((::std::ios_base::out & this->_M_mode) & __mode) != 0);
    const typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::char_type *__beg = __testin ? this->eback() : this->pbase();
    if ((__beg || !off_type(__sp)) && (__testin || __testout))
      {
        _M_update_egptr();
        const typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::off_type __pos(__sp);
        const bool __testpos = 0 <= __pos && __pos <= this->egptr() - __beg;
        if (__testpos)
          {
            if (__testin)
              {
                this->setg(this->eback(), this->eback() + __pos, this->egptr());
              }
            if (__testout)
              {
                _M_pbump(this->pbase(), this->epptr(), __pos);
              }
            __ret = __sp;
          }
      }
    return __ret;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  void basic_stringbuf<_CharT, _Traits, _Alloc>::_M_sync(typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::char_type *__base, typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::__size_type __i, typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::__size_type __o)
  {
    const bool __testin = _M_mode & ::std::ios_base::in;
    const bool __testout = _M_mode & ::std::ios_base::out;
    typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::char_type *__endg = __base + _M_string.size();
    typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::char_type *__endp = __base + _M_string.capacity();
    if (__base != _M_string.data())
      {
        __endg += __i;
        __i = 0;
        __endp = __endg;
      }
    if (__testin)
      {
        this->setg(__base, __base + __i, __endg);
      }
    if (__testout)
      {
        _M_pbump(__base, __endp, __o);
        if (!__testin)
          {
            this->setg(__endg, __endg, __endg);
          }
      }
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  void basic_stringbuf<_CharT, _Traits, _Alloc>::_M_pbump(typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::char_type *__pbeg, typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::char_type *__pend, typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::off_type __off)
  {
    this->setp(__pbeg, __pend);
    while (__off > ::__gnu_cxx::__numeric_traits_integer<int>::__max)
      {
        this->pbump(::__gnu_cxx::__numeric_traits_integer<int>::__max);
        __off -= ::__gnu_cxx::__numeric_traits_integer<int>::__max;
      }
    this->pbump(__off);
  }
extern template class ::std::basic_stringbuf<char, ::std::char_traits<char>, ::std::allocator<char> >;
extern template class ::std::basic_istringstream<char, ::std::char_traits<char>, ::std::allocator<char> >;
extern template class ::std::basic_ostringstream<char, ::std::char_traits<char>, ::std::allocator<char> >;
extern template class ::std::basic_stringstream<char, ::std::char_traits<char>, ::std::allocator<char> >;
extern template class ::std::basic_stringbuf<wchar_t, ::std::char_traits<wchar_t>, ::std::allocator<wchar_t> >;
extern template class ::std::basic_istringstream<wchar_t, ::std::char_traits<wchar_t>, ::std::allocator<wchar_t> >;
extern template class ::std::basic_ostringstream<wchar_t, ::std::char_traits<wchar_t>, ::std::allocator<wchar_t> >;
extern template class ::std::basic_stringstream<wchar_t, ::std::char_traits<wchar_t>, ::std::allocator<wchar_t> >;
  class  codecvt_base
  {
    public:
      enum result
      {
        ok = 0,
        partial = 1,
        error = 2,
        noconv = 3
      };
  };
  template < typename _InternT, typename _ExternT, typename _StateT >
  class  __codecvt_abstract_base : public ::std::locale::facet, public ::std::codecvt_base
  {
    public:
      typedef ::std::codecvt_base::result result;
      typedef _InternT intern_type;
      typedef _ExternT extern_type;
      typedef _StateT state_type;
      inline typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::result out(typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::state_type &__state, const typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::intern_type *__from, const typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::intern_type *__from_end, const typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::intern_type *&__from_next, typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::extern_type *__to, typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::extern_type *__to_end, typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::extern_type *&__to_next) const 
      {
        return this->do_out(__state, __from, __from_end, __from_next, __to, __to_end, __to_next);
      }
      inline typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::result unshift(typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::state_type &__state, typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::extern_type *__to, typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::extern_type *__to_end, typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::extern_type *&__to_next) const 
      {
        return this->do_unshift(__state, __to, __to_end, __to_next);
      }
      inline typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::result in(typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::state_type &__state, const typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::extern_type *__from, const typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::extern_type *__from_end, const typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::extern_type *&__from_next, typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::intern_type *__to, typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::intern_type *__to_end, typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::intern_type *&__to_next) const 
      {
        return this->do_in(__state, __from, __from_end, __from_next, __to, __to_end, __to_next);
      }
      inline int encoding() const  throw()
      {
        return this->do_encoding();
      }
      inline bool always_noconv() const  throw()
      {
        return this->do_always_noconv();
      }
      inline int length(typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::state_type &__state, const typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::extern_type *__from, const typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::extern_type *__end, ::std::size_t __max) const 
      {
        return this->do_length(__state, __from, __end, __max);
      }
      inline int max_length() const  throw()
      {
        return this->do_max_length();
      }
    protected:
      inline explicit __codecvt_abstract_base(::std::size_t __refs  = 0)
        : locale::facet(__refs)
      {
      }
      inline virtual ~__codecvt_abstract_base()
      {
      }
      virtual typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::result do_out(typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::state_type &__state, const typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::intern_type *__from, const typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::intern_type *__from_end, const typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::intern_type *&__from_next, typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::extern_type *__to, typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::extern_type *__to_end, typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::extern_type *&__to_next) const  = 0 ;
      virtual typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::result do_unshift(typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::state_type &__state, typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::extern_type *__to, typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::extern_type *__to_end, typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::extern_type *&__to_next) const  = 0 ;
      virtual typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::result do_in(typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::state_type &__state, const typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::extern_type *__from, const typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::extern_type *__from_end, const typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::extern_type *&__from_next, typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::intern_type *__to, typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::intern_type *__to_end, typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::intern_type *&__to_next) const  = 0 ;
      virtual int do_encoding() const  throw() = 0 ;
      virtual bool do_always_noconv() const  throw() = 0 ;
      virtual int do_length(typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::state_type &, const typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::extern_type *__from, const typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::extern_type *__end, ::std::size_t __max) const  = 0 ;
      virtual int do_max_length() const  throw() = 0 ;
  };
  template < typename _InternT, typename _ExternT, typename _StateT >
  class  codecvt : public ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>
  {
    public:
      typedef ::std::codecvt_base::result result;
      typedef _InternT intern_type;
      typedef _ExternT extern_type;
      typedef _StateT state_type;
    protected:
      ::std::__c_locale _M_c_locale_codecvt;
    public:
      static ::std::locale::id id;
      inline explicit codecvt(::std::size_t __refs  = 0)
        : __codecvt_abstract_base<_InternT, _ExternT, _StateT>(__refs), _M_c_locale_codecvt(0)
      {
      }
      explicit codecvt(::std::__c_locale __cloc, ::std::size_t __refs  = 0);
    protected:
      inline virtual ~codecvt()
      {
      }
      virtual typename ::std::codecvt<_InternT, _ExternT, _StateT>::result do_out(typename ::std::codecvt<_InternT, _ExternT, _StateT>::state_type &__state, const typename ::std::codecvt<_InternT, _ExternT, _StateT>::intern_type *__from, const typename ::std::codecvt<_InternT, _ExternT, _StateT>::intern_type *__from_end, const typename ::std::codecvt<_InternT, _ExternT, _StateT>::intern_type *&__from_next, typename ::std::codecvt<_InternT, _ExternT, _StateT>::extern_type *__to, typename ::std::codecvt<_InternT, _ExternT, _StateT>::extern_type *__to_end, typename ::std::codecvt<_InternT, _ExternT, _StateT>::extern_type *&__to_next) const ;
      virtual typename ::std::codecvt<_InternT, _ExternT, _StateT>::result do_unshift(typename ::std::codecvt<_InternT, _ExternT, _StateT>::state_type &__state, typename ::std::codecvt<_InternT, _ExternT, _StateT>::extern_type *__to, typename ::std::codecvt<_InternT, _ExternT, _StateT>::extern_type *__to_end, typename ::std::codecvt<_InternT, _ExternT, _StateT>::extern_type *&__to_next) const ;
      virtual typename ::std::codecvt<_InternT, _ExternT, _StateT>::result do_in(typename ::std::codecvt<_InternT, _ExternT, _StateT>::state_type &__state, const typename ::std::codecvt<_InternT, _ExternT, _StateT>::extern_type *__from, const typename ::std::codecvt<_InternT, _ExternT, _StateT>::extern_type *__from_end, const typename ::std::codecvt<_InternT, _ExternT, _StateT>::extern_type *&__from_next, typename ::std::codecvt<_InternT, _ExternT, _StateT>::intern_type *__to, typename ::std::codecvt<_InternT, _ExternT, _StateT>::intern_type *__to_end, typename ::std::codecvt<_InternT, _ExternT, _StateT>::intern_type *&__to_next) const ;
      virtual int do_encoding() const  throw();
      virtual bool do_always_noconv() const  throw();
      virtual int do_length(typename ::std::codecvt<_InternT, _ExternT, _StateT>::state_type &, const typename ::std::codecvt<_InternT, _ExternT, _StateT>::extern_type *__from, const typename ::std::codecvt<_InternT, _ExternT, _StateT>::extern_type *__end, ::std::size_t __max) const ;
      virtual int do_max_length() const  throw();
  };
  template < typename _InternT, typename _ExternT, typename _StateT >
  ::std::locale::id codecvt<_InternT, _ExternT, _StateT>::id;
  template <>
  class  codecvt<char, char, ::mbstate_t> : public ::std::__codecvt_abstract_base<char, char, ::mbstate_t>
  {
    public:
      typedef char intern_type;
      typedef char extern_type;
      typedef ::mbstate_t state_type;
    protected:
      ::std::__c_locale _M_c_locale_codecvt;
    public:
      static ::std::locale::id id;
      explicit codecvt(::std::size_t __refs  = 0);
      explicit codecvt(::std::__c_locale __cloc, ::std::size_t __refs  = 0);
    protected:
      virtual ~codecvt();
      virtual ::std::__codecvt_abstract_base<char, char, ::mbstate_t>::result do_out(::std::codecvt<char, char, ::mbstate_t>::state_type &__state, const ::std::codecvt<char, char, ::mbstate_t>::intern_type *__from, const ::std::codecvt<char, char, ::mbstate_t>::intern_type *__from_end, const ::std::codecvt<char, char, ::mbstate_t>::intern_type *&__from_next, ::std::codecvt<char, char, ::mbstate_t>::extern_type *__to, ::std::codecvt<char, char, ::mbstate_t>::extern_type *__to_end, ::std::codecvt<char, char, ::mbstate_t>::extern_type *&__to_next) const ;
      virtual ::std::__codecvt_abstract_base<char, char, ::mbstate_t>::result do_unshift(::std::codecvt<char, char, ::mbstate_t>::state_type &__state, ::std::codecvt<char, char, ::mbstate_t>::extern_type *__to, ::std::codecvt<char, char, ::mbstate_t>::extern_type *__to_end, ::std::codecvt<char, char, ::mbstate_t>::extern_type *&__to_next) const ;
      virtual ::std::__codecvt_abstract_base<char, char, ::mbstate_t>::result do_in(::std::codecvt<char, char, ::mbstate_t>::state_type &__state, const ::std::codecvt<char, char, ::mbstate_t>::extern_type *__from, const ::std::codecvt<char, char, ::mbstate_t>::extern_type *__from_end, const ::std::codecvt<char, char, ::mbstate_t>::extern_type *&__from_next, ::std::codecvt<char, char, ::mbstate_t>::intern_type *__to, ::std::codecvt<char, char, ::mbstate_t>::intern_type *__to_end, ::std::codecvt<char, char, ::mbstate_t>::intern_type *&__to_next) const ;
      virtual int do_encoding() const  throw();
      virtual bool do_always_noconv() const  throw();
      virtual int do_length(::std::codecvt<char, char, ::mbstate_t>::state_type &, const ::std::codecvt<char, char, ::mbstate_t>::extern_type *__from, const ::std::codecvt<char, char, ::mbstate_t>::extern_type *__end, ::std::size_t __max) const ;
      virtual int do_max_length() const  throw();
    public:
  };
  template <>
  class  codecvt<wchar_t, char, ::mbstate_t> : public ::std::__codecvt_abstract_base<wchar_t, char, ::mbstate_t>
  {
    public:
      typedef wchar_t intern_type;
      typedef char extern_type;
      typedef ::mbstate_t state_type;
    protected:
      ::std::__c_locale _M_c_locale_codecvt;
    public:
      static ::std::locale::id id;
      explicit codecvt(::std::size_t __refs  = 0);
      explicit codecvt(::std::__c_locale __cloc, ::std::size_t __refs  = 0);
    protected:
      virtual ~codecvt();
      virtual ::std::__codecvt_abstract_base<wchar_t, char, ::mbstate_t>::result do_out(::std::codecvt<wchar_t, char, ::mbstate_t>::state_type &__state, const ::std::codecvt<wchar_t, char, ::mbstate_t>::intern_type *__from, const ::std::codecvt<wchar_t, char, ::mbstate_t>::intern_type *__from_end, const ::std::codecvt<wchar_t, char, ::mbstate_t>::intern_type *&__from_next, ::std::codecvt<wchar_t, char, ::mbstate_t>::extern_type *__to, ::std::codecvt<wchar_t, char, ::mbstate_t>::extern_type *__to_end, ::std::codecvt<wchar_t, char, ::mbstate_t>::extern_type *&__to_next) const ;
      virtual ::std::__codecvt_abstract_base<wchar_t, char, ::mbstate_t>::result do_unshift(::std::codecvt<wchar_t, char, ::mbstate_t>::state_type &__state, ::std::codecvt<wchar_t, char, ::mbstate_t>::extern_type *__to, ::std::codecvt<wchar_t, char, ::mbstate_t>::extern_type *__to_end, ::std::codecvt<wchar_t, char, ::mbstate_t>::extern_type *&__to_next) const ;
      virtual ::std::__codecvt_abstract_base<wchar_t, char, ::mbstate_t>::result do_in(::std::codecvt<wchar_t, char, ::mbstate_t>::state_type &__state, const ::std::codecvt<wchar_t, char, ::mbstate_t>::extern_type *__from, const ::std::codecvt<wchar_t, char, ::mbstate_t>::extern_type *__from_end, const ::std::codecvt<wchar_t, char, ::mbstate_t>::extern_type *&__from_next, ::std::codecvt<wchar_t, char, ::mbstate_t>::intern_type *__to, ::std::codecvt<wchar_t, char, ::mbstate_t>::intern_type *__to_end, ::std::codecvt<wchar_t, char, ::mbstate_t>::intern_type *&__to_next) const ;
      virtual int do_encoding() const  throw();
      virtual bool do_always_noconv() const  throw();
      virtual int do_length(::std::codecvt<wchar_t, char, ::mbstate_t>::state_type &, const ::std::codecvt<wchar_t, char, ::mbstate_t>::extern_type *__from, const ::std::codecvt<wchar_t, char, ::mbstate_t>::extern_type *__end, ::std::size_t __max) const ;
      virtual int do_max_length() const  throw();
    public:
  };
  template < typename _InternT, typename _ExternT, typename _StateT >
  class  codecvt_byname : public ::std::codecvt<_InternT, _ExternT, _StateT>
  {
    public:
      inline explicit codecvt_byname(const char *__s, ::std::size_t __refs  = 0)
        : codecvt<_InternT, _ExternT, _StateT>(__refs)
      {
        if (__builtin_strcmp(__s, "C") != 0 && __builtin_strcmp(__s, "POSIX") != 0)
          {
            this->_S_destroy_c_locale(this->_M_c_locale_codecvt);
            this->_S_create_c_locale(this->_M_c_locale_codecvt, __s);
          }
      }
    protected:
      inline virtual ~codecvt_byname()
      {
      }
  };
extern template class ::std::codecvt_byname<char, char, ::mbstate_t>;
extern template const ::std::codecvt<char, char, ::mbstate_t> &use_facet< ::std::codecvt<char, char, ::mbstate_t> >(const ::std::locale &);
extern template bool has_facet< ::std::codecvt<char, char, ::mbstate_t> >(const ::std::locale &);
extern template class ::std::codecvt_byname<wchar_t, char, ::mbstate_t>;
extern template const ::std::codecvt<wchar_t, char, ::mbstate_t> &use_facet< ::std::codecvt<wchar_t, char, ::mbstate_t> >(const ::std::locale &);
extern template bool has_facet< ::std::codecvt<wchar_t, char, ::mbstate_t> >(const ::std::locale &);
  using ::FILE;
  using ::fpos_t;
  using ::clearerr;
  using ::fclose;
  using ::feof;
  using ::ferror;
  using ::fflush;
  using ::fgetc;
  using ::fgetpos;
  using ::fgets;
  using ::fopen;
  using ::fprintf;
  using ::fputc;
  using ::fputs;
  using ::fread;
  using ::freopen;
  using ::fscanf;
  using ::fseek;
  using ::fsetpos;
  using ::ftell;
  using ::fwrite;
  using ::getc;
  using ::getchar;
  using ::gets;
  using ::perror;
  using ::printf;
  using ::putc;
  using ::putchar;
  using ::puts;
  using ::remove;
  using ::rename;
  using ::rewind;
  using ::scanf;
  using ::setbuf;
  using ::setvbuf;
  using ::sprintf;
  using ::sscanf;
  using ::tmpfile;
  using ::tmpnam;
  using ::ungetc;
  using ::vfprintf;
  using ::vprintf;
  using ::vsprintf;
}
namespace __gnu_cxx __attribute__((__visibility__("default"))) {
  using ::snprintf;
  using ::vfscanf;
  using ::vscanf;
  using ::vsnprintf;
  using ::vsscanf;
}
namespace std __attribute__((__visibility__("default"))) {
  using ::__gnu_cxx::snprintf;
  using ::__gnu_cxx::vfscanf;
  using ::__gnu_cxx::vscanf;
  using ::__gnu_cxx::vsnprintf;
  using ::__gnu_cxx::vsscanf;
  typedef ::__gthread_mutex_t __c_lock;
  typedef ::FILE __c_file;
  template < typename _CharT >
  class __basic_file;
  template <>
  class  __basic_file<char>
  {
      ::std::__c_file *_M_cfile;
      bool _M_cfile_created;
    public:
      __basic_file(::std::__c_lock *__lock  = 0) throw();
      ::std::__basic_file<char> *open(const char *__name, ::std::ios_base::openmode __mode, int __prot  = 436);
      ::std::__basic_file<char> *sys_open(::std::__c_file *__file, ::std::ios_base::openmode);
      ::std::__basic_file<char> *sys_open(int __fd, ::std::ios_base::openmode __mode) throw();
      ::std::__basic_file<char> *close();
      bool is_open() const  throw()__attribute__((__pure__));
      int fd() throw()__attribute__((__pure__));
      ::std::__c_file *file() throw()__attribute__((__pure__));
      ~__basic_file();
      ::std::streamsize xsputn(const char *__s, ::std::streamsize __n);
      ::std::streamsize xsputn_2(const char *__s1, ::std::streamsize __n1, const char *__s2, ::std::streamsize __n2);
      ::std::streamsize xsgetn(char *__s, ::std::streamsize __n);
      ::std::streamoff seekoff(::std::streamoff __off, ::std::ios_base::seekdir __way) throw();
      int sync();
      ::std::streamsize showmanyc();
  };
  template < typename _CharT, typename _Traits >
  class  basic_filebuf : public ::std::basic_streambuf<_CharT, _Traits>
  {
    public:
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef ::std::basic_streambuf<typename ::std::basic_filebuf<_CharT, _Traits>::char_type, typename ::std::basic_filebuf<_CharT, _Traits>::traits_type> __streambuf_type;
      typedef ::std::basic_filebuf<typename ::std::basic_filebuf<_CharT, _Traits>::char_type, typename ::std::basic_filebuf<_CharT, _Traits>::traits_type> __filebuf_type;
      typedef ::std::__basic_file<char> __file_type;
      typedef typename _Traits::state_type __state_type;
      typedef ::std::codecvt<typename ::std::basic_filebuf<_CharT, _Traits>::char_type, char, typename ::std::basic_filebuf<_CharT, _Traits>::__state_type> __codecvt_type;
    protected:
      ::std::__c_lock _M_lock;
      typename ::std::basic_filebuf<_CharT, _Traits>::__file_type _M_file;
      ::std::ios_base::openmode _M_mode;
      typename ::std::basic_filebuf<_CharT, _Traits>::__state_type _M_state_beg;
      typename ::std::basic_filebuf<_CharT, _Traits>::__state_type _M_state_cur;
      typename ::std::basic_filebuf<_CharT, _Traits>::__state_type _M_state_last;
      typename ::std::basic_filebuf<_CharT, _Traits>::char_type *_M_buf;
      ::std::size_t _M_buf_size;
      bool _M_buf_allocated;
      bool _M_reading;
      bool _M_writing;
      typename ::std::basic_filebuf<_CharT, _Traits>::char_type _M_pback;
      typename ::std::basic_filebuf<_CharT, _Traits>::char_type *_M_pback_cur_save;
      typename ::std::basic_filebuf<_CharT, _Traits>::char_type *_M_pback_end_save;
      bool _M_pback_init;
      const typename ::std::basic_filebuf<_CharT, _Traits>::__codecvt_type *_M_codecvt;
      char *_M_ext_buf;
      ::std::streamsize _M_ext_buf_size;
      const char *_M_ext_next;
      char *_M_ext_end;
      inline void _M_create_pback()
      {
        if (!_M_pback_init)
          {
            _M_pback_cur_save = this->gptr();
            _M_pback_end_save = this->egptr();
            this->setg(&_M_pback, &_M_pback, &_M_pback + 1);
            _M_pback_init = true;
          }
      }
      inline void _M_destroy_pback() throw()
      {
        if (_M_pback_init)
          {
            _M_pback_cur_save += this->gptr() != this->eback();
            this->setg(_M_buf, _M_pback_cur_save, _M_pback_end_save);
            _M_pback_init = false;
          }
      }
    public:
      basic_filebuf();
      inline virtual ~basic_filebuf()
      {
        this->close();
      }
      inline bool is_open() const  throw()
      {
        return _M_file.is_open();
      }
      typename ::std::basic_filebuf<_CharT, _Traits>::__filebuf_type *open(const char *__s, ::std::ios_base::openmode __mode);
      typename ::std::basic_filebuf<_CharT, _Traits>::__filebuf_type *close();
    protected:
      void _M_allocate_internal_buffer();
      void _M_destroy_internal_buffer() throw();
      virtual ::std::streamsize showmanyc();
      virtual typename ::std::basic_filebuf<_CharT, _Traits>::int_type underflow();
      virtual typename ::std::basic_filebuf<_CharT, _Traits>::int_type pbackfail(typename ::std::basic_filebuf<_CharT, _Traits>::int_type __i  = _Traits::eof());
      virtual typename ::std::basic_filebuf<_CharT, _Traits>::int_type overflow(typename ::std::basic_filebuf<_CharT, _Traits>::int_type __c  = _Traits::eof());
      bool _M_convert_to_external(typename ::std::basic_filebuf<_CharT, _Traits>::char_type *__ibuf, ::std::streamsize __ilen);
      virtual typename ::std::basic_filebuf<_CharT, _Traits>::__streambuf_type *setbuf(typename ::std::basic_filebuf<_CharT, _Traits>::char_type *__s, ::std::streamsize __n);
      virtual typename ::std::basic_filebuf<_CharT, _Traits>::pos_type seekoff(typename ::std::basic_filebuf<_CharT, _Traits>::off_type __off, ::std::ios_base::seekdir __way, ::std::ios_base::openmode  = ::std::ios_base::in | ::std::ios_base::out);
      virtual typename ::std::basic_filebuf<_CharT, _Traits>::pos_type seekpos(typename ::std::basic_filebuf<_CharT, _Traits>::pos_type __pos, ::std::ios_base::openmode  = ::std::ios_base::in | ::std::ios_base::out);
      typename ::std::basic_filebuf<_CharT, _Traits>::pos_type _M_seek(typename ::std::basic_filebuf<_CharT, _Traits>::off_type __off, ::std::ios_base::seekdir __way, typename ::std::basic_filebuf<_CharT, _Traits>::__state_type __state);
      int _M_get_ext_pos(typename ::std::basic_filebuf<_CharT, _Traits>::__state_type &__state);
      virtual int sync();
      virtual void imbue(const ::std::locale &__loc);
      virtual ::std::streamsize xsgetn(typename ::std::basic_filebuf<_CharT, _Traits>::char_type *__s, ::std::streamsize __n);
      virtual ::std::streamsize xsputn(const typename ::std::basic_filebuf<_CharT, _Traits>::char_type *__s, ::std::streamsize __n);
      bool _M_terminate_output();
      inline void _M_set_buffer(::std::streamsize __off)
      {
        const bool __testin = _M_mode & ::std::ios_base::in;
        const bool __testout = _M_mode & ::std::ios_base::out;
        if (__testin && __off > 0)
          {
            this->setg(_M_buf, _M_buf, _M_buf + __off);
          }
        else
          {
            this->setg(_M_buf, _M_buf, _M_buf);
          }
        if ((__testout && __off == 0) && _M_buf_size > 1)
          {
            this->setp(_M_buf, _M_buf + _M_buf_size - 1);
          }
        else
          {
            this->setp(0, 0);
          }
      }
    friend class ::std::ios_base;
  };
  template < typename _CharT, typename _Traits >
  class  basic_ifstream : public ::std::basic_istream<_CharT, _Traits>
  {
    public:
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef ::std::basic_filebuf<typename ::std::basic_ifstream<_CharT, _Traits>::char_type, typename ::std::basic_ifstream<_CharT, _Traits>::traits_type> __filebuf_type;
      typedef ::std::basic_istream<typename ::std::basic_ifstream<_CharT, _Traits>::char_type, typename ::std::basic_ifstream<_CharT, _Traits>::traits_type> __istream_type;
    private:
      typename ::std::basic_ifstream<_CharT, _Traits>::__filebuf_type _M_filebuf;
    public:
      inline basic_ifstream()
        : __istream_type(), _M_filebuf()
      {
        this->init(&_M_filebuf);
      }
      inline explicit basic_ifstream(const char *__s, ::std::ios_base::openmode __mode  = ::std::ios_base::in)
        : __istream_type(), _M_filebuf()
      {
        this->init(&_M_filebuf);
        this->open(__s, __mode);
      }
      inline ~basic_ifstream()
      {
      }
      inline typename ::std::basic_ifstream<_CharT, _Traits>::__filebuf_type *rdbuf() const 
      {
        return const_cast<typename ::std::basic_ifstream<_CharT, _Traits>::__filebuf_type *>(&_M_filebuf);
      }
      inline bool is_open()
      {
        return _M_filebuf.is_open();
      }
      inline bool is_open() const 
      {
        return _M_filebuf.is_open();
      }
      inline void open(const char *__s, ::std::ios_base::openmode __mode  = ::std::ios_base::in)
      {
        if (!_M_filebuf.open(__s, __mode | ::std::ios_base::in))
          {
            this->setstate(::std::ios_base::failbit);
          }
        else
          {
            this->clear();
          }
      }
      inline void close()
      {
        if (!_M_filebuf.close())
          {
            this->setstate(::std::ios_base::failbit);
          }
      }
  };
  template < typename _CharT, typename _Traits >
  class  basic_ofstream : public ::std::basic_ostream<_CharT, _Traits>
  {
    public:
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef ::std::basic_filebuf<typename ::std::basic_ofstream<_CharT, _Traits>::char_type, typename ::std::basic_ofstream<_CharT, _Traits>::traits_type> __filebuf_type;
      typedef ::std::basic_ostream<typename ::std::basic_ofstream<_CharT, _Traits>::char_type, typename ::std::basic_ofstream<_CharT, _Traits>::traits_type> __ostream_type;
    private:
      typename ::std::basic_ofstream<_CharT, _Traits>::__filebuf_type _M_filebuf;
    public:
      inline basic_ofstream()
        : __ostream_type(), _M_filebuf()
      {
        this->init(&_M_filebuf);
      }
      inline explicit basic_ofstream(const char *__s, ::std::ios_base::openmode __mode  = ::std::ios_base::out | ::std::ios_base::trunc)
        : __ostream_type(), _M_filebuf()
      {
        this->init(&_M_filebuf);
        this->open(__s, __mode);
      }
      inline ~basic_ofstream()
      {
      }
      inline typename ::std::basic_ofstream<_CharT, _Traits>::__filebuf_type *rdbuf() const 
      {
        return const_cast<typename ::std::basic_ofstream<_CharT, _Traits>::__filebuf_type *>(&_M_filebuf);
      }
      inline bool is_open()
      {
        return _M_filebuf.is_open();
      }
      inline bool is_open() const 
      {
        return _M_filebuf.is_open();
      }
      inline void open(const char *__s, ::std::ios_base::openmode __mode  = ::std::ios_base::out | ::std::ios_base::trunc)
      {
        if (!_M_filebuf.open(__s, __mode | ::std::ios_base::out))
          {
            this->setstate(::std::ios_base::failbit);
          }
        else
          {
            this->clear();
          }
      }
      inline void close()
      {
        if (!_M_filebuf.close())
          {
            this->setstate(::std::ios_base::failbit);
          }
      }
  };
  template < typename _CharT, typename _Traits >
  class  basic_fstream : public ::std::basic_iostream<_CharT, _Traits>
  {
    public:
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef ::std::basic_filebuf<typename ::std::basic_fstream<_CharT, _Traits>::char_type, typename ::std::basic_fstream<_CharT, _Traits>::traits_type> __filebuf_type;
      typedef ::std::basic_ios<typename ::std::basic_fstream<_CharT, _Traits>::char_type, typename ::std::basic_fstream<_CharT, _Traits>::traits_type> __ios_type;
      typedef ::std::basic_iostream<typename ::std::basic_fstream<_CharT, _Traits>::char_type, typename ::std::basic_fstream<_CharT, _Traits>::traits_type> __iostream_type;
    private:
      typename ::std::basic_fstream<_CharT, _Traits>::__filebuf_type _M_filebuf;
    public:
      inline basic_fstream()
        : __iostream_type(), _M_filebuf()
      {
        this->init(&_M_filebuf);
      }
      inline explicit basic_fstream(const char *__s, ::std::ios_base::openmode __mode  = ::std::ios_base::in | ::std::ios_base::out)
        : __iostream_type(0), _M_filebuf()
      {
        this->init(&_M_filebuf);
        this->open(__s, __mode);
      }
      inline ~basic_fstream()
      {
      }
      inline typename ::std::basic_fstream<_CharT, _Traits>::__filebuf_type *rdbuf() const 
      {
        return const_cast<typename ::std::basic_fstream<_CharT, _Traits>::__filebuf_type *>(&_M_filebuf);
      }
      inline bool is_open()
      {
        return _M_filebuf.is_open();
      }
      inline bool is_open() const 
      {
        return _M_filebuf.is_open();
      }
      inline void open(const char *__s, ::std::ios_base::openmode __mode  = ::std::ios_base::in | ::std::ios_base::out)
      {
        if (!_M_filebuf.open(__s, __mode))
          {
            this->setstate(::std::ios_base::failbit);
          }
        else
          {
            this->clear();
          }
      }
      inline void close()
      {
        if (!_M_filebuf.close())
          {
            this->setstate(::std::ios_base::failbit);
          }
      }
  };
  template < typename _CharT, typename _Traits >
  void basic_filebuf<_CharT, _Traits>::_M_allocate_internal_buffer()
  {
    if (!_M_buf_allocated && !_M_buf)
      {
        _M_buf = (new typename ::std::basic_filebuf<_CharT, _Traits>::char_type [_M_buf_size]);
        _M_buf_allocated = true;
      }
  }
  template < typename _CharT, typename _Traits >
  void basic_filebuf<_CharT, _Traits>::_M_destroy_internal_buffer() throw()
  {
    if (_M_buf_allocated)
      {
        delete[] _M_buf;
        _M_buf = 0;
        _M_buf_allocated = false;
      }
    delete[] _M_ext_buf;
    _M_ext_buf = 0;
    _M_ext_buf_size = 0;
    _M_ext_next = 0;
    _M_ext_end = 0;
  }
  template < typename _CharT, typename _Traits >
  basic_filebuf<_CharT, _Traits>::basic_filebuf()
    : __streambuf_type(), _M_lock(), _M_file(&_M_lock), _M_mode((::std::ios_base::openmode)0), _M_state_beg(), _M_state_cur(), _M_state_last(), _M_buf(0), _M_buf_size(8192), _M_buf_allocated(false), _M_reading(false), _M_writing(false), _M_pback(), _M_pback_cur_save(0), _M_pback_end_save(0), _M_pback_init(false), _M_codecvt(0), _M_ext_buf(0), _M_ext_buf_size(0), _M_ext_next(0), _M_ext_end(0)
  {
    if (has_facet<typename ::std::basic_filebuf<_CharT, _Traits>::__codecvt_type>(this->_M_buf_locale))
      {
        _M_codecvt = &use_facet<typename ::std::basic_filebuf<_CharT, _Traits>::__codecvt_type>(this->_M_buf_locale);
      }
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_filebuf<_CharT, _Traits>::__filebuf_type *basic_filebuf<_CharT, _Traits>::open(const char *__s, ::std::ios_base::openmode __mode)
  {
    typename ::std::basic_filebuf<_CharT, _Traits>::__filebuf_type *__ret = 0;
    if (!this->is_open())
      {
        _M_file.open(__s, __mode);
        if (this->is_open())
          {
            _M_allocate_internal_buffer();
            _M_mode = __mode;
            _M_reading = false;
            _M_writing = false;
            _M_set_buffer( -1);
            _M_state_last = _M_state_cur = _M_state_beg;
            if (__mode & ::std::ios_base::ate && this->seekoff(0, ::std::ios_base::end, __mode) == pos_type(typename ::std::basic_filebuf<_CharT, _Traits>::off_type( -1)))
              {
                this->close();
              }
            else
              {
                __ret = this;
              }
          }
      }
    return __ret;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_filebuf<_CharT, _Traits>::__filebuf_type *basic_filebuf<_CharT, _Traits>::close()
  {
    if (!this->is_open())
      {
        return 0;
      }
    bool __testfail(false);
    {
      struct  __close_sentry
      {
          ::std::basic_filebuf<_CharT, _Traits> *__fb;
          inline __close_sentry(::std::basic_filebuf<_CharT, _Traits> *__fbi)
            : __fb(__fbi)
          {
          }
          inline ~__close_sentry()
          {
            __fb->_M_mode = (::std::ios_base::openmode)0;
            __fb->_M_pback_init = false;
            __fb->_M_destroy_internal_buffer();
            __fb->_M_reading = false;
            __fb->_M_writing = false;
            __fb->_M_set_buffer( -1);
            __fb->_M_state_last = __fb->_M_state_cur = __fb->_M_state_beg;
          }
      };
      __close_sentry __cs(this);
      try
      {
        if (!_M_terminate_output())
          {
            __testfail = true;
          }
      }
      catch (::__cxxabiv1::__forced_unwind &)
      {
        _M_file.close();
        throw;
      }
      catch (...)
      {
        __testfail = true;
      }
    }
    if (!_M_file.close())
      {
        __testfail = true;
      }
    if (__testfail)
      {
        return 0;
      }
    else
      {
        return this;
      }
  }
  template < typename _CharT, typename _Traits >
  ::std::streamsize basic_filebuf<_CharT, _Traits>::showmanyc()
  {
    ::std::streamsize __ret( -1);
    const bool __testin = _M_mode & ::std::ios_base::in;
    if (__testin && this->is_open())
      {
        __ret = this->egptr() - this->gptr();
        if (__check_facet(_M_codecvt).encoding() >= 0)
          {
            __ret += _M_file.showmanyc() / _M_codecvt->max_length();
          }
      }
    return __ret;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_filebuf<_CharT, _Traits>::int_type basic_filebuf<_CharT, _Traits>::underflow()
  {
    typename ::std::basic_filebuf<_CharT, _Traits>::int_type __ret = traits_type::eof();
    const bool __testin = _M_mode & ::std::ios_base::in;
    if (__testin)
      {
        if (_M_writing)
          {
            if (overflow() == traits_type::eof())
              {
                return __ret;
              }
            _M_set_buffer( -1);
            _M_writing = false;
          }
        _M_destroy_pback();
        if (this->gptr() < this->egptr())
          {
            return traits_type::to_int_type(*this->gptr());
          }
        const ::std::size_t __buflen = _M_buf_size > 1 ? _M_buf_size - 1 : 1;
        bool __got_eof(false);
        ::std::streamsize __ilen(0);
        ::std::codecvt_base::result __r(::std::codecvt_base::ok);
        if (__check_facet(_M_codecvt).always_noconv())
          {
            __ilen = _M_file.xsgetn(reinterpret_cast<char *>(this->eback()), __buflen);
            if (__ilen == 0)
              {
                __got_eof = true;
              }
          }
        else
          {
            const int __enc(_M_codecvt->encoding());
            ::std::streamsize __blen;
            ::std::streamsize __rlen;
            if (__enc > 0)
              {
                __blen = __rlen = __buflen * __enc;
              }
            else
              {
                __blen = __buflen + _M_codecvt->max_length() - 1;
                __rlen = __buflen;
              }
            const ::std::streamsize __remainder = _M_ext_end - _M_ext_next;
            __rlen = __rlen > __remainder ? __rlen - __remainder : 0;
            if ((_M_reading && this->egptr() == this->eback()) && __remainder)
              {
                __rlen = 0;
              }
            if (_M_ext_buf_size < __blen)
              {
                char *__buf(new char [__blen]);
                if (__remainder)
                  {
                    __builtin_memcpy(__buf, _M_ext_next, __remainder);
                  }
                delete[] _M_ext_buf;
                _M_ext_buf = __buf;
                _M_ext_buf_size = __blen;
              }
            else
              {
                if (__remainder)
                  {
                    __builtin_memmove(_M_ext_buf, _M_ext_next, __remainder);
                  }
              }
            _M_ext_next = _M_ext_buf;
            _M_ext_end = _M_ext_buf + __remainder;
            _M_state_last = _M_state_cur;
            do
              {
                if (__rlen > 0)
                  {
                    if (_M_ext_end - _M_ext_buf + __rlen > _M_ext_buf_size)
                      {
                        ::std::__throw_ios_failure("basic_filebuf::underflow codecvt::max_length() is not valid");
                      }
                    ::std::streamsize __elen(_M_file.xsgetn(_M_ext_end, __rlen));
                    if (__elen == 0)
                      {
                        __got_eof = true;
                      }
                    else
                      {
                        if (__elen ==  -1)
                          {
                            break;
                          }
                      }
                    _M_ext_end += __elen;
                  }
                typename ::std::basic_filebuf<_CharT, _Traits>::char_type *__iend = this->eback();
                if (_M_ext_next < _M_ext_end)
                  {
                    __r = _M_codecvt->in(_M_state_cur, _M_ext_next, _M_ext_end, _M_ext_next, this->eback(), this->eback() + __buflen, __iend);
                  }
                if (__r == ::std::codecvt_base::noconv)
                  {
                    ::std::size_t __avail = _M_ext_end - _M_ext_buf;
                    __ilen = ::std::min /* <unsigned long int> */ (__avail, __buflen);
                    traits_type::copy(this->eback(), reinterpret_cast<typename ::std::basic_filebuf<_CharT, _Traits>::char_type *>(_M_ext_buf), __ilen);
                    _M_ext_next = _M_ext_buf + __ilen;
                  }
                else
                  {
                    __ilen = __iend - this->eback();
                  }
                if (__r == ::std::codecvt_base::error)
                  {
                    break;
                  }
                __rlen = 1;
              }
            while (__ilen == 0 && !__got_eof);
          }
        if (__ilen > 0)
          {
            _M_set_buffer(__ilen);
            _M_reading = true;
            __ret = traits_type::to_int_type(*this->gptr());
          }
        else
          {
            if (__got_eof)
              {
                _M_set_buffer( -1);
                _M_reading = false;
                if (__r == ::std::codecvt_base::partial)
                  {
                    ::std::__throw_ios_failure("basic_filebuf::underflow incomplete character in file");
                  }
              }
            else
              {
                if (__r == ::std::codecvt_base::error)
                  {
                    ::std::__throw_ios_failure("basic_filebuf::underflow invalid byte sequence in file");
                  }
                else
                  {
                    ::std::__throw_ios_failure("basic_filebuf::underflow error reading the file");
                  }
              }
          }
      }
    return __ret;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_filebuf<_CharT, _Traits>::int_type basic_filebuf<_CharT, _Traits>::pbackfail(typename ::std::basic_filebuf<_CharT, _Traits>::int_type __i)
  {
    typename ::std::basic_filebuf<_CharT, _Traits>::int_type __ret = traits_type::eof();
    const bool __testin = _M_mode & ::std::ios_base::in;
    if (__testin)
      {
        if (_M_writing)
          {
            if (overflow() == traits_type::eof())
              {
                return __ret;
              }
            _M_set_buffer( -1);
            _M_writing = false;
          }
        const bool __testpb = _M_pback_init;
        const bool __testeof(traits_type::eq_int_type(__i, __ret));
        typename ::std::basic_filebuf<_CharT, _Traits>::int_type __tmp;
        if (this->eback() < this->gptr())
          {
            this->gbump( -1);
            __tmp = traits_type::to_int_type(*this->gptr());
          }
        else
          {
            if (this->seekoff( -1, ::std::ios_base::cur) != pos_type(typename ::std::basic_filebuf<_CharT, _Traits>::off_type( -1)))
              {
                __tmp = this->underflow();
                if (traits_type::eq_int_type(__tmp, __ret))
                  {
                    return __ret;
                  }
              }
            else
              {
                return __ret;
              }
          }
        if (!__testeof && traits_type::eq_int_type(__i, __tmp))
          {
            __ret = __i;
          }
        else
          {
            if (__testeof)
              {
                __ret = traits_type::not_eof(__i);
              }
            else
              {
                if (!__testpb)
                  {
                    _M_create_pback();
                    _M_reading = true;
                    *this->gptr() = traits_type::to_char_type(__i);
                    __ret = __i;
                  }
              }
          }
      }
    return __ret;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_filebuf<_CharT, _Traits>::int_type basic_filebuf<_CharT, _Traits>::overflow(typename ::std::basic_filebuf<_CharT, _Traits>::int_type __c)
  {
    typename ::std::basic_filebuf<_CharT, _Traits>::int_type __ret = traits_type::eof();
    const bool __testeof(traits_type::eq_int_type(__c, __ret));
    const bool __testout = _M_mode & ::std::ios_base::out;
    if (__testout)
      {
        if (_M_reading)
          {
            _M_destroy_pback();
            const int __gptr_off(_M_get_ext_pos(_M_state_last));
            if (_M_seek(__gptr_off, ::std::ios_base::cur, _M_state_last) == pos_type(typename ::std::basic_filebuf<_CharT, _Traits>::off_type( -1)))
              {
                return __ret;
              }
          }
        if (this->pbase() < this->pptr())
          {
            if (!__testeof)
              {
                *this->pptr() = traits_type::to_char_type(__c);
                this->pbump(1);
              }
            if (_M_convert_to_external(this->pbase(), this->pptr() - this->pbase()))
              {
                _M_set_buffer(0);
                __ret = traits_type::not_eof(__c);
              }
          }
        else
          {
            if (_M_buf_size > 1)
              {
                _M_set_buffer(0);
                _M_writing = true;
                if (!__testeof)
                  {
                    *this->pptr() = traits_type::to_char_type(__c);
                    this->pbump(1);
                  }
                __ret = traits_type::not_eof(__c);
              }
            else
              {
                typename ::std::basic_filebuf<_CharT, _Traits>::char_type __conv = traits_type::to_char_type(__c);
                if (__testeof || _M_convert_to_external(&__conv, 1))
                  {
                    _M_writing = true;
                    __ret = traits_type::not_eof(__c);
                  }
              }
          }
      }
    return __ret;
  }
  template < typename _CharT, typename _Traits >
  bool basic_filebuf<_CharT, _Traits>::_M_convert_to_external(_CharT *__ibuf, ::std::streamsize __ilen)
  {
    ::std::streamsize __elen;
    ::std::streamsize __plen;
    if (__check_facet(_M_codecvt).always_noconv())
      {
        __elen = _M_file.xsputn(reinterpret_cast<char *>(__ibuf), __ilen);
        __plen = __ilen;
      }
    else
      {
        ::std::streamsize __blen(__ilen * _M_codecvt->max_length());
        char *__buf(static_cast<char *>(__builtin_alloca(__blen)));
        char *__bend;
        const typename ::std::basic_filebuf<_CharT, _Traits>::char_type *__iend;
        ::std::codecvt_base::result __r;
        __r = _M_codecvt->out(_M_state_cur, __ibuf, __ibuf + __ilen, __iend, __buf, __buf + __blen, __bend);
        if (__r == ::std::codecvt_base::ok || __r == ::std::codecvt_base::partial)
          {
            __blen = __bend - __buf;
          }
        else
          {
            if (__r == ::std::codecvt_base::noconv)
              {
                __buf = reinterpret_cast<char *>(__ibuf);
                __blen = __ilen;
              }
            else
              {
                ::std::__throw_ios_failure("basic_filebuf::_M_convert_to_external conversion error");
              }
          }
        __elen = _M_file.xsputn(__buf, __blen);
        __plen = __blen;
        if (__r == ::std::codecvt_base::partial && __elen == __plen)
          {
            const typename ::std::basic_filebuf<_CharT, _Traits>::char_type *__iresume = __iend;
            ::std::streamsize __rlen = this->pptr() - __iend;
            __r = _M_codecvt->out(_M_state_cur, __iresume, __iresume + __rlen, __iend, __buf, __buf + __blen, __bend);
            if (__r != ::std::codecvt_base::error)
              {
                __rlen = __bend - __buf;
                __elen = _M_file.xsputn(__buf, __rlen);
                __plen = __rlen;
              }
            else
              {
                ::std::__throw_ios_failure("basic_filebuf::_M_convert_to_external conversion error");
              }
          }
      }
    return __elen == __plen;
  }
  template < typename _CharT, typename _Traits >
  ::std::streamsize basic_filebuf<_CharT, _Traits>::xsgetn(_CharT *__s, ::std::streamsize __n)
  {
    ::std::streamsize __ret(0);
    if (_M_pback_init)
      {
        if (__n > 0 && this->gptr() == this->eback())
          {
            *__s++ = *this->gptr();
            this->gbump(1);
            __ret = 1;
            --__n;
          }
        _M_destroy_pback();
      }
    else
      {
        if (_M_writing)
          {
            if (overflow() == traits_type::eof())
              {
                return __ret;
              }
            _M_set_buffer( -1);
            _M_writing = false;
          }
      }
    const bool __testin = _M_mode & ::std::ios_base::in;
    const ::std::streamsize __buflen = _M_buf_size > 1 ? _M_buf_size - 1 : 1;
    if ((__n > __buflen && __check_facet(_M_codecvt).always_noconv()) && __testin)
      {
        const ::std::streamsize __avail(this->egptr() - this->gptr());
        if (__avail != 0)
          {
            traits_type::copy(__s, this->gptr(), __avail);
            __s += __avail;
            this->setg(this->eback(), this->gptr() + __avail, this->egptr());
            __ret += __avail;
            __n -= __avail;
          }
        ::std::streamsize __len;
        for (; ; )
          {
            __len = _M_file.xsgetn(reinterpret_cast<char *>(__s), __n);
            if (__len ==  -1)
              {
                ::std::__throw_ios_failure("basic_filebuf::xsgetn error reading the file");
              }
            if (__len == 0)
              {
                break;
              }
            __n -= __len;
            __ret += __len;
            if (__n == 0)
              {
                break;
              }
            __s += __len;
          }
        if (__n == 0)
          {
            _M_set_buffer(0);
            _M_reading = true;
          }
        else
          {
            if (__len == 0)
              {
                _M_set_buffer( -1);
                _M_reading = false;
              }
          }
      }
    else
      {
        __ret += __streambuf_type::xsgetn(__s, __n);
      }
    return __ret;
  }
  template < typename _CharT, typename _Traits >
  ::std::streamsize basic_filebuf<_CharT, _Traits>::xsputn(const _CharT *__s, ::std::streamsize __n)
  {
    ::std::streamsize __ret(0);
    const bool __testout = _M_mode & ::std::ios_base::out;
    if ((__check_facet(_M_codecvt).always_noconv() && __testout) && !_M_reading)
      {
        const ::std::streamsize __chunk(1LU << 10);
        ::std::streamsize __bufavail(this->epptr() - this->pptr());
        if (!_M_writing && _M_buf_size > 1)
          {
            __bufavail = _M_buf_size - 1;
          }
        const ::std::streamsize __limit(::std::min /* <long int> */ (__chunk, __bufavail));
        if (__n >= __limit)
          {
            const ::std::streamsize __buffill(this->pptr() - this->pbase());
            const char *__buf(reinterpret_cast<const char *>(this->pbase()));
            __ret = _M_file.xsputn_2(__buf, __buffill, reinterpret_cast<const char *>(__s), __n);
            if (__ret == __buffill + __n)
              {
                _M_set_buffer(0);
                _M_writing = true;
              }
            if (__ret > __buffill)
              {
                __ret -= __buffill;
              }
            else
              {
                __ret = 0;
              }
          }
        else
          {
            __ret = __streambuf_type::xsputn(__s, __n);
          }
      }
    else
      {
        __ret = __streambuf_type::xsputn(__s, __n);
      }
    return __ret;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_filebuf<_CharT, _Traits>::__streambuf_type *basic_filebuf<_CharT, _Traits>::setbuf(typename ::std::basic_filebuf<_CharT, _Traits>::char_type *__s, ::std::streamsize __n)
  {
    if (!this->is_open())
      {
        if (__s == 0 && __n == 0)
          {
            _M_buf_size = 1;
          }
        else
          {
            if (__s && __n > 0)
              {
                _M_buf = __s;
                _M_buf_size = __n;
              }
          }
      }
    return this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_filebuf<_CharT, _Traits>::pos_type basic_filebuf<_CharT, _Traits>::seekoff(typename ::std::basic_filebuf<_CharT, _Traits>::off_type __off, ::std::ios_base::seekdir __way, ::std::ios_base::openmode)
  {
    int __width(0);
    if (_M_codecvt)
      {
        __width = _M_codecvt->encoding();
      }
    if (__width < 0)
      {
        __width = 0;
      }
    typename ::std::basic_filebuf<_CharT, _Traits>::pos_type __ret = pos_type(typename ::std::basic_filebuf<_CharT, _Traits>::off_type( -1));
    const bool __testfail = __off != 0 && __width <= 0;
    if (this->is_open() && !__testfail)
      {
        bool __no_movement = (__way == ::std::ios_base::cur && __off == 0) && (!_M_writing || _M_codecvt->always_noconv());
        if (!__no_movement)
          {
            _M_destroy_pback();
          }
        typename ::std::basic_filebuf<_CharT, _Traits>::__state_type __state = _M_state_beg;
        typename ::std::basic_filebuf<_CharT, _Traits>::off_type __computed_off = __off * __width;
        if (_M_reading && __way == ::std::ios_base::cur)
          {
            __state = _M_state_last;
            __computed_off += _M_get_ext_pos(__state);
          }
        if (!__no_movement)
          {
            __ret = _M_seek(__computed_off, __way, __state);
          }
        else
          {
            if (_M_writing)
              {
                __computed_off = this->pptr() - this->pbase();
              }
            typename ::std::basic_filebuf<_CharT, _Traits>::off_type __file_off = _M_file.seekoff(0, ::std::ios_base::cur);
            if (__file_off != typename ::std::basic_filebuf<_CharT, _Traits>::off_type( -1))
              {
                __ret = __file_off + __computed_off;
                __ret.state(__state);
              }
          }
      }
    return __ret;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_filebuf<_CharT, _Traits>::pos_type basic_filebuf<_CharT, _Traits>::seekpos(typename ::std::basic_filebuf<_CharT, _Traits>::pos_type __pos, ::std::ios_base::openmode)
  {
    typename ::std::basic_filebuf<_CharT, _Traits>::pos_type __ret = pos_type(typename ::std::basic_filebuf<_CharT, _Traits>::off_type( -1));
    if (this->is_open())
      {
        _M_destroy_pback();
        __ret = _M_seek(off_type(__pos), ::std::ios_base::beg, __pos.state());
      }
    return __ret;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_filebuf<_CharT, _Traits>::pos_type basic_filebuf<_CharT, _Traits>::_M_seek(typename ::std::basic_filebuf<_CharT, _Traits>::off_type __off, ::std::ios_base::seekdir __way, typename ::std::basic_filebuf<_CharT, _Traits>::__state_type __state)
  {
    typename ::std::basic_filebuf<_CharT, _Traits>::pos_type __ret = pos_type(typename ::std::basic_filebuf<_CharT, _Traits>::off_type( -1));
    if (_M_terminate_output())
      {
        typename ::std::basic_filebuf<_CharT, _Traits>::off_type __file_off = _M_file.seekoff(__off, __way);
        if (__file_off != typename ::std::basic_filebuf<_CharT, _Traits>::off_type( -1))
          {
            _M_reading = false;
            _M_writing = false;
            _M_ext_next = _M_ext_end = _M_ext_buf;
            _M_set_buffer( -1);
            _M_state_cur = __state;
            __ret = __file_off;
            __ret.state(_M_state_cur);
          }
      }
    return __ret;
  }
  template < typename _CharT, typename _Traits >
  int basic_filebuf<_CharT, _Traits>::_M_get_ext_pos(typename ::std::basic_filebuf<_CharT, _Traits>::__state_type &__state)
  {
    if (_M_codecvt->always_noconv())
      {
        return this->gptr() - this->egptr();
      }
    else
      {
        const int __gptr_off(_M_codecvt->length(__state, _M_ext_buf, _M_ext_next, this->gptr() - this->eback()));
        return _M_ext_buf + __gptr_off - _M_ext_end;
      }
  }
  template < typename _CharT, typename _Traits >
  bool basic_filebuf<_CharT, _Traits>::_M_terminate_output()
  {
    bool __testvalid(true);
    if (this->pbase() < this->pptr())
      {
        const typename ::std::basic_filebuf<_CharT, _Traits>::int_type __tmp = this->overflow();
        if (traits_type::eq_int_type(__tmp, traits_type::eof()))
          {
            __testvalid = false;
          }
      }
    if ((_M_writing && !__check_facet(_M_codecvt).always_noconv()) && __testvalid)
      {
        const ::std::size_t __blen(128);
        char __buf[128];
        ::std::codecvt_base::result __r;
        ::std::streamsize __ilen(0);
        do
          {
            char *__next;
            __r = _M_codecvt->unshift(_M_state_cur, __buf, __buf + __blen, __next);
            if (__r == ::std::codecvt_base::error)
              {
                __testvalid = false;
              }
            else
              {
                if (__r == ::std::codecvt_base::ok || __r == ::std::codecvt_base::partial)
                  {
                    __ilen = __next - __buf;
                    if (__ilen > 0)
                      {
                        const ::std::streamsize __elen(_M_file.xsputn(__buf, __ilen));
                        if (__elen != __ilen)
                          {
                            __testvalid = false;
                          }
                      }
                  }
              }
          }
        while ((__r == ::std::codecvt_base::partial && __ilen > 0) && __testvalid);
        if (__testvalid)
          {
            const typename ::std::basic_filebuf<_CharT, _Traits>::int_type __tmp = this->overflow();
            if (traits_type::eq_int_type(__tmp, traits_type::eof()))
              {
                __testvalid = false;
              }
          }
      }
    return __testvalid;
  }
  template < typename _CharT, typename _Traits >
  int basic_filebuf<_CharT, _Traits>::sync()
  {
    int __ret(0);
    if (this->pbase() < this->pptr())
      {
        const typename ::std::basic_filebuf<_CharT, _Traits>::int_type __tmp = this->overflow();
        if (traits_type::eq_int_type(__tmp, traits_type::eof()))
          {
            __ret =  -1;
          }
      }
    return __ret;
  }
  template < typename _CharT, typename _Traits >
  void basic_filebuf<_CharT, _Traits>::imbue(const ::std::locale &__loc)
  {
    bool __testvalid(true);
    const typename ::std::basic_filebuf<_CharT, _Traits>::__codecvt_type *_M_codecvt_tmp = 0;
    if (__builtin_expect(has_facet<typename ::std::basic_filebuf<_CharT, _Traits>::__codecvt_type>(__loc), true))
      {
        _M_codecvt_tmp = &use_facet<typename ::std::basic_filebuf<_CharT, _Traits>::__codecvt_type>(__loc);
      }
    if (this->is_open())
      {
        if ((_M_reading || _M_writing) && __check_facet(_M_codecvt).encoding() ==  -1)
          {
            __testvalid = false;
          }
        else
          {
            if (_M_reading)
              {
                if (__check_facet(_M_codecvt).always_noconv())
                  {
                    if (_M_codecvt_tmp && !__check_facet(_M_codecvt_tmp).always_noconv())
                      {
                        __testvalid = this->seekoff(0, ::std::ios_base::cur, _M_mode) != pos_type(typename ::std::basic_filebuf<_CharT, _Traits>::off_type( -1));
                      }
                  }
                else
                  {
                    _M_ext_next = _M_ext_buf + _M_codecvt->length(_M_state_last, _M_ext_buf, _M_ext_next, this->gptr() - this->eback());
                    const ::std::streamsize __remainder = _M_ext_end - _M_ext_next;
                    if (__remainder)
                      {
                        __builtin_memmove(_M_ext_buf, _M_ext_next, __remainder);
                      }
                    _M_ext_next = _M_ext_buf;
                    _M_ext_end = _M_ext_buf + __remainder;
                    _M_set_buffer( -1);
                    _M_state_last = _M_state_cur = _M_state_beg;
                  }
              }
            else
              {
                if (_M_writing && (__testvalid = _M_terminate_output()))
                  {
                    _M_set_buffer( -1);
                  }
              }
          }
      }
    if (__testvalid)
      {
        _M_codecvt = _M_codecvt_tmp;
      }
    else
      {
        _M_codecvt = 0;
      }
  }
extern template class ::std::basic_filebuf<char, ::std::char_traits<char> >;
extern template class ::std::basic_ifstream<char, ::std::char_traits<char> >;
extern template class ::std::basic_ofstream<char, ::std::char_traits<char> >;
extern template class ::std::basic_fstream<char, ::std::char_traits<char> >;
extern template class ::std::basic_filebuf<wchar_t, ::std::char_traits<wchar_t> >;
extern template class ::std::basic_ifstream<wchar_t, ::std::char_traits<wchar_t> >;
extern template class ::std::basic_ofstream<wchar_t, ::std::char_traits<wchar_t> >;
extern template class ::std::basic_fstream<wchar_t, ::std::char_traits<wchar_t> >;
}
using namespace ::std;
template < typename DataType >
inline DataType convert(int n)__attribute__((always_inline));
template < typename DataType >
inline __attribute__((always_inline)) DataType convert(int n)
{
  return DataType(n);
}
template < typename DataType >
inline DataType convert(float n)__attribute__((always_inline));
template < typename DataType >
inline __attribute__((always_inline)) DataType convert(float n)
{
  return DataType(n);
}
template <>
inline __attribute__((always_inline)) ::sse_f convert< ::sse_f>(int n)
{
  return ::_mm_set_ps1((float)n);
}
template <>
inline __attribute__((always_inline)) ::sse_f convert< ::sse_f>(float n)
{
  return ::_mm_set_ps1(n);
}
template <>
inline __attribute__((always_inline)) ::sse_i convert< ::sse_i>(int n)
{
  return ::_mm_set1_epi32(n);
}
template <>
inline __attribute__((always_inline)) ::sse_i convert< ::sse_i>(float n)
{
  return ::_mm_set1_epi32((int)n);
}
inline __attribute__((always_inline)) ::sse_f convert(float n)
{
  return ::_mm_set_ps1(n);
}
inline __attribute__((always_inline)) ::sse_i convert(int n)
{
  return ::_mm_set1_epi32(n);
}
inline __attribute__((always_inline)) ::sse_f convert(float n0, float n1, float n2, float n3)
{
  return ::_mm_set_ps(n0, n1, n2, n3);
}
inline __attribute__((always_inline)) ::sse_i convert(int n0, int n1, int n2, int n3)
{
  return ::_mm_set_epi32(n0, n1, n2, n3);
}
static inline __attribute__((always_inline)) ::sse_f _mm_castsi128_ps(::sse_i n)
{
  return *((::sse_f *)&n);
}
static inline __attribute__((always_inline)) ::sse_i _mm_castps_si128(::sse_f n)
{
  return *((::sse_i *)&n);
}
inline __attribute__((always_inline)) ::sse_i cast(::sse_f v)
{
  return ::_mm_castps_si128(v);
}
inline __attribute__((always_inline)) ::sse_f cast(::sse_i v)
{
  return ::_mm_castsi128_ps(v);
}
inline __attribute__((always_inline)) ::sse_i convert(::sse_f v)
{
  return ::_mm_cvtps_epi32(v);
}
inline __attribute__((always_inline)) ::sse_f convert(::sse_i v)
{
  return ::_mm_cvtepi32_ps(v);
}
inline __attribute__((always_inline)) ::sse_f rcp(const ::sse_f src)
{
  ::sse_f tgt;
  tgt = ::_mm_rcp_ps(src);
  tgt = ::_mm_sub_ps(::_mm_add_ps(tgt, tgt), ::_mm_mul_ps(::_mm_mul_ps(tgt, tgt), src));
  return tgt;
}
static const ::sse_f maxFloat((::_mm_set_ps1(3.402823466385288598117042e+38f)));
inline __attribute__((always_inline)) ::sse_f rcp_save(const ::sse_f src)
{
  ::sse_f tgt;
  tgt = ::_mm_rcp_ps(src);
  tgt = ::_mm_sub_ps(::_mm_add_ps(tgt, tgt), ::_mm_mul_ps(::_mm_mul_ps(tgt, tgt), src));
  tgt = ::_mm_or_ps(::_mm_and_ps(::_mm_cmpneq_ps(src, ::_mm_setzero_ps()), tgt), ::_mm_andnot_ps(::_mm_cmpneq_ps(src, ::_mm_setzero_ps()), ::maxFloat));
  return tgt;
}
inline __attribute__((always_inline)) bool operator ==(::sse_f a, ::sse_f b)
{
  return ::_mm_movemask_ps(::_mm_cmpeq_ps(a, b)) == 15;
}
inline __attribute__((always_inline)) bool operator !=(::sse_f a, ::sse_f b)
{
  return ::_mm_movemask_ps(::_mm_cmpeq_ps(a, b)) != 15;
}
inline __attribute__((always_inline)) bool operator <(::sse_f a, ::sse_f b)
{
  return ::_mm_movemask_ps(::_mm_cmplt_ps(a, b)) == 15;
}
inline __attribute__((always_inline)) bool operator <=(::sse_f a, ::sse_f b)
{
  return ::_mm_movemask_ps(::_mm_cmple_ps(a, b)) == 15;
}
inline __attribute__((always_inline)) bool operator >(::sse_f a, ::sse_f b)
{
  return ::_mm_movemask_ps(::_mm_cmpgt_ps(a, b)) == 15;
}
inline __attribute__((always_inline)) bool operator >=(::sse_f a, ::sse_f b)
{
  return ::_mm_movemask_ps(::_mm_cmpge_ps(a, b)) == 15;
}
inline __attribute__((always_inline)) bool operator ==(::sse_f a, float b)
{
  return a == ::convert< ::sse_f>(b);
}
inline __attribute__((always_inline)) bool operator !=(::sse_f a, float b)
{
  return a != ::convert< ::sse_f>(b);
}
inline __attribute__((always_inline)) bool operator <(::sse_f a, float b)
{
  return a < ::convert< ::sse_f>(b);
}
inline __attribute__((always_inline)) bool operator <=(::sse_f a, float b)
{
  return a <= ::convert< ::sse_f>(b);
}
inline __attribute__((always_inline)) bool operator >(::sse_f a, float b)
{
  return a > ::convert< ::sse_f>(b);
}
inline __attribute__((always_inline)) bool operator >=(::sse_f a, float b)
{
  return a >= ::convert< ::sse_f>(b);
}
inline __attribute__((always_inline)) bool operator ==(float a, ::sse_f b)
{
  return ::convert< ::sse_f>(a) == b;
}
inline __attribute__((always_inline)) bool operator !=(float a, ::sse_f b)
{
  return ::convert< ::sse_f>(a) != b;
}
inline __attribute__((always_inline)) bool operator <(float a, ::sse_f b)
{
  return ::convert< ::sse_f>(a) < b;
}
inline __attribute__((always_inline)) bool operator <=(float a, ::sse_f b)
{
  return ::convert< ::sse_f>(a) <= b;
}
inline __attribute__((always_inline)) bool operator >(float a, ::sse_f b)
{
  return ::convert< ::sse_f>(a) > b;
}
inline __attribute__((always_inline)) bool operator >=(float a, ::sse_f b)
{
  return ::convert< ::sse_f>(a) >= b;
}
inline __attribute__((always_inline)) ::sse_f operator &(::sse_f a, ::sse_f b)
{
  return ::_mm_and_ps(a, b);
}
inline __attribute__((always_inline)) ::sse_f operator |(::sse_f a, ::sse_f b)
{
  return ::_mm_or_ps(a, b);
}
inline __attribute__((always_inline)) ::sse_f operator +(::sse_f a, ::sse_f b)
{
  return ::_mm_add_ps(a, b);
}
inline __attribute__((always_inline)) ::sse_f operator -(::sse_f a, ::sse_f b)
{
  return ::_mm_sub_ps(a, b);
}
inline __attribute__((always_inline)) ::sse_f operator *(::sse_f a, ::sse_f b)
{
  return ::_mm_mul_ps(a, b);
}
inline __attribute__((always_inline)) ::sse_f operator /(::sse_f a, ::sse_f b)
{
  return ::_mm_mul_ps(a, ::rcp(b));
}
inline __attribute__((always_inline)) ::sse_f operator &(::sse_f a, float b)
{
  return ::_mm_and_ps(a, ::convert< ::sse_f>(b));
}
inline __attribute__((always_inline)) ::sse_f operator |(::sse_f a, float b)
{
  return ::_mm_or_ps(a, ::convert< ::sse_f>(b));
}
inline __attribute__((always_inline)) ::sse_f operator +(::sse_f a, float b)
{
  return ::_mm_add_ps(a, ::convert< ::sse_f>(b));
}
inline __attribute__((always_inline)) ::sse_f operator -(::sse_f a, float b)
{
  return ::_mm_sub_ps(a, ::convert< ::sse_f>(b));
}
inline __attribute__((always_inline)) ::sse_f operator *(::sse_f a, float b)
{
  return ::_mm_mul_ps(a, ::convert< ::sse_f>(b));
}
inline __attribute__((always_inline)) ::sse_f operator /(::sse_f a, float b)
{
  return ::_mm_mul_ps(a, ::convert< ::sse_f>(1.000000000000000000000000e+00f / b));
}
inline __attribute__((always_inline)) ::sse_f operator &(float a, ::sse_f b)
{
  return ::_mm_and_ps(::convert< ::sse_f>(a), b);
}
inline __attribute__((always_inline)) ::sse_f operator |(float a, ::sse_f b)
{
  return ::_mm_or_ps(::convert< ::sse_f>(a), b);
}
inline __attribute__((always_inline)) ::sse_f operator +(float a, ::sse_f b)
{
  return ::_mm_add_ps(::convert< ::sse_f>(a), b);
}
inline __attribute__((always_inline)) ::sse_f operator -(float a, ::sse_f b)
{
  return ::_mm_sub_ps(::convert< ::sse_f>(a), b);
}
inline __attribute__((always_inline)) ::sse_f operator *(float a, ::sse_f b)
{
  return ::_mm_mul_ps(::convert< ::sse_f>(a), b);
}
inline __attribute__((always_inline)) ::sse_f operator /(float a, ::sse_f b)
{
  return ::_mm_mul_ps(::convert< ::sse_f>(a), ::rcp(b));
}
inline __attribute__((always_inline)) const ::sse_f &operator &=(::sse_f &a, ::sse_f b)
{
  return a = ::_mm_and_ps(a, b);
}
inline __attribute__((always_inline)) const ::sse_f &operator |=(::sse_f &a, ::sse_f b)
{
  return a = ::_mm_or_ps(a, b);
}
inline __attribute__((always_inline)) const ::sse_f &operator +=(::sse_f &a, ::sse_f b)
{
  return a = ::_mm_add_ps(a, b);
}
inline __attribute__((always_inline)) const ::sse_f &operator -=(::sse_f &a, ::sse_f b)
{
  return a = ::_mm_sub_ps(a, b);
}
inline __attribute__((always_inline)) const ::sse_f &operator *=(::sse_f &a, ::sse_f b)
{
  return a = ::_mm_mul_ps(a, b);
}
inline __attribute__((always_inline)) const ::sse_f &operator /=(::sse_f &a, ::sse_f b)
{
  return a = ::_mm_mul_ps(a, ::rcp(b));
}
inline __attribute__((always_inline)) const ::sse_f &operator &=(::sse_f &a, float b)
{
  return a = ::_mm_and_ps(a, ::convert< ::sse_f>(b));
}
inline __attribute__((always_inline)) const ::sse_f &operator |=(::sse_f &a, float b)
{
  return a = ::_mm_or_ps(a, ::convert< ::sse_f>(b));
}
inline __attribute__((always_inline)) const ::sse_f &operator +=(::sse_f &a, float b)
{
  return a = ::_mm_add_ps(a, ::convert< ::sse_f>(b));
}
inline __attribute__((always_inline)) const ::sse_f &operator -=(::sse_f &a, float b)
{
  return a = ::_mm_sub_ps(a, ::convert< ::sse_f>(b));
}
inline __attribute__((always_inline)) const ::sse_f &operator *=(::sse_f &a, float b)
{
  return a = ::_mm_mul_ps(a, ::convert< ::sse_f>(b));
}
inline __attribute__((always_inline)) const ::sse_f &operator /=(::sse_f &a, float b)
{
  return a = ::_mm_mul_ps(a, ::convert< ::sse_f>(1.000000000000000000000000e+00f / b));
}
inline __attribute__((always_inline)) ::sse_f abs(::sse_f a)
{
  static const ::sse_f sse_sign((::cast(::convert< ::sse_i>(2147483647))));
  return ::_mm_and_ps(a, sse_sign);
}
inline __attribute__((always_inline)) ::sse_f min(::sse_f a, ::sse_f b)
{
  return ::_mm_min_ps(a, b);
}
inline __attribute__((always_inline)) ::sse_f max(::sse_f a, ::sse_f b)
{
  return ::_mm_max_ps(a, b);
}
inline __attribute__((always_inline)) ::sse_f rcp_ss(float a)
{
  ::sse_f src((::_mm_set_ss(a)));
  ::sse_f dst((::_mm_rcp_ss(src)));
  src = ::_mm_mul_ss(src, dst);
  src = ::_mm_mul_ss(src, dst);
  dst = ::_mm_add_ss(dst, dst);
  dst = ::_mm_sub_ss(dst, src);
  return dst;
}
inline __attribute__((always_inline)) ::sse_f sqrt(::sse_f a)
{
  return ::_mm_sqrt_ps(a);
}
inline __attribute__((always_inline)) ::sse_f rsqrt(::sse_f a)
{
  static const ::sse_f sse_three((::convert(3.000000000000000000000000e+00f)));
  static const ::sse_f sse_minushalf((::convert( -5.000000000000000000000000e-01f)));
  ::sse_f rsqrta((::_mm_rsqrt_ps(a)));
  return a * rsqrta * rsqrta - sse_three * sse_minushalf * rsqrta;
}
inline __attribute__((always_inline)) float rsqrt(float a)
{
  return 1.000000000000000000000000e+00f / ::sqrtf(a);
}
inline __attribute__((always_inline)) ::std::ostream &operator <<(::std::ostream &out, const ::sse_f &t)
{
  float *f((float *)&t);
  out << "[" << f[0] << "," << f[1] << "," << f[2] << "," << f[3] << "] ";
  return out;
}
inline __attribute__((always_inline)) bool operator ==(::sse_i a, ::sse_i b)
{
  return ::_mm_movemask_epi8(::_mm_cmpeq_epi32(a, b)) == 65535;
}
inline __attribute__((always_inline)) bool operator !=(::sse_i a, ::sse_i b)
{
  return !(a == b);
}
inline __attribute__((always_inline)) bool operator <(::sse_i a, ::sse_i b)
{
  return ::_mm_movemask_epi8(::_mm_cmplt_epi32(a, b)) == 65535;
}
inline __attribute__((always_inline)) bool operator <=(::sse_i a, ::sse_i b)
{
  return ::_mm_movemask_epi8(::_mm_cmpgt_epi32(a, b)) == 0;
}
inline __attribute__((always_inline)) bool operator >(::sse_i a, ::sse_i b)
{
  return ::_mm_movemask_epi8(::_mm_cmpgt_epi32(a, b)) == 65535;
}
inline __attribute__((always_inline)) bool operator >=(::sse_i a, ::sse_i b)
{
  return ::_mm_movemask_epi8(::_mm_cmplt_epi32(a, b)) == 0;
}
inline __attribute__((always_inline)) bool operator ==(::sse_i a, int b)
{
  return a == ::convert< ::sse_i>(b);
}
inline __attribute__((always_inline)) bool operator !=(::sse_i a, int b)
{
  return a != ::convert< ::sse_i>(b);
}
inline __attribute__((always_inline)) bool operator <(::sse_i a, int b)
{
  return a < ::convert< ::sse_i>(b);
}
inline __attribute__((always_inline)) bool operator <=(::sse_i a, int b)
{
  return a <= ::convert< ::sse_i>(b);
}
inline __attribute__((always_inline)) bool operator >(::sse_i a, int b)
{
  return a > ::convert< ::sse_i>(b);
}
inline __attribute__((always_inline)) bool operator >=(::sse_i a, int b)
{
  return a >= ::convert< ::sse_i>(b);
}
inline __attribute__((always_inline)) bool operator ==(int a, ::sse_i b)
{
  return ::convert< ::sse_i>(a) == b;
}
inline __attribute__((always_inline)) bool operator !=(int a, ::sse_i b)
{
  return ::convert< ::sse_i>(a) != b;
}
inline __attribute__((always_inline)) bool operator <(int a, ::sse_i b)
{
  return ::convert< ::sse_i>(a) < b;
}
inline __attribute__((always_inline)) bool operator <=(int a, ::sse_i b)
{
  return ::convert< ::sse_i>(a) <= b;
}
inline __attribute__((always_inline)) bool operator >(int a, ::sse_i b)
{
  return ::convert< ::sse_i>(a) > b;
}
inline __attribute__((always_inline)) bool operator >=(int a, ::sse_i b)
{
  return ::convert< ::sse_i>(a) >= b;
}
inline __attribute__((always_inline)) ::sse_i operator &(::sse_i a, ::sse_i b)
{
  return ::_mm_and_si128(a, b);
}
inline __attribute__((always_inline)) ::sse_i operator |(::sse_i a, ::sse_i b)
{
  return ::_mm_or_si128(a, b);
}
inline __attribute__((always_inline)) ::sse_i operator +(::sse_i a, ::sse_i b)
{
  return ::_mm_add_epi32(a, b);
}
inline __attribute__((always_inline)) ::sse_i operator -(::sse_i a, ::sse_i b)
{
  return ::_mm_sub_epi32(a, b);
}
inline __attribute__((always_inline)) ::sse_i operator *(::sse_i a, ::sse_i b)
{
  return ::convert(::convert(a) * ::convert(b));
}
inline __attribute__((always_inline)) ::sse_i operator &(::sse_i a, int b)
{
  return ::_mm_and_si128(a, ::convert< ::sse_i>(b));
}
inline __attribute__((always_inline)) ::sse_i operator |(::sse_i a, int b)
{
  return ::_mm_or_si128(a, ::convert< ::sse_i>(b));
}
inline __attribute__((always_inline)) ::sse_i operator +(::sse_i a, int b)
{
  return ::_mm_add_epi32(a, ::convert< ::sse_i>(b));
}
inline __attribute__((always_inline)) ::sse_i operator -(::sse_i a, int b)
{
  return ::_mm_sub_epi32(a, ::convert< ::sse_i>(b));
}
inline __attribute__((always_inline)) ::sse_i operator *(::sse_i a, int b)
{
  return a * ::convert< ::sse_i>(b);
}
inline __attribute__((always_inline)) ::sse_i operator &(int a, ::sse_i b)
{
  return ::_mm_and_si128(::convert< ::sse_i>(a), b);
}
inline __attribute__((always_inline)) ::sse_i operator |(int a, ::sse_i b)
{
  return ::_mm_or_si128(::convert< ::sse_i>(a), b);
}
inline __attribute__((always_inline)) ::sse_i operator +(int a, ::sse_i b)
{
  return ::_mm_add_epi32(::convert< ::sse_i>(a), b);
}
inline __attribute__((always_inline)) ::sse_i operator -(int a, ::sse_i b)
{
  return ::_mm_sub_epi32(::convert< ::sse_i>(a), b);
}
inline __attribute__((always_inline)) ::sse_i operator *(int a, ::sse_i b)
{
  return ::convert< ::sse_i>(a) * b;
}
inline __attribute__((always_inline)) const ::sse_i &operator &=(::sse_i &a, ::sse_i b)
{
  return a = ::_mm_and_si128(a, b);
}
inline __attribute__((always_inline)) const ::sse_i &operator |=(::sse_i &a, ::sse_i b)
{
  return a = ::_mm_or_si128(a, b);
}
inline __attribute__((always_inline)) const ::sse_i &operator +=(::sse_i &a, ::sse_i b)
{
  return a = ::_mm_add_epi32(a, b);
}
inline __attribute__((always_inline)) const ::sse_i &operator -=(::sse_i &a, ::sse_i b)
{
  return a = ::_mm_sub_epi32(a, b);
}
inline __attribute__((always_inline)) const ::sse_i &operator *=(::sse_i &a, ::sse_i b)
{
  return a = a * b;
}
inline __attribute__((always_inline)) const ::sse_i &operator &=(::sse_i &a, int b)
{
  return a = ::_mm_and_si128(a, ::convert< ::sse_i>(b));
}
inline __attribute__((always_inline)) const ::sse_i &operator |=(::sse_i &a, int b)
{
  return a = ::_mm_or_si128(a, ::convert< ::sse_i>(b));
}
inline __attribute__((always_inline)) const ::sse_i &operator +=(::sse_i &a, int b)
{
  return a = ::_mm_add_epi32(a, ::convert< ::sse_i>(b));
}
inline __attribute__((always_inline)) const ::sse_i &operator -=(::sse_i &a, int b)
{
  return a = ::_mm_sub_epi32(a, ::convert< ::sse_i>(b));
}
inline __attribute__((always_inline)) const ::sse_i &operator *=(::sse_i &a, int b)
{
  return a = a * ::convert< ::sse_i>(b);
}
inline __attribute__((always_inline)) ::sse_i abs(::sse_i a)
{
  return ::_mm_srli_epi32(::_mm_slli_epi32(a, 1), 1);
}
inline __attribute__((always_inline)) ::std::ostream &operator <<(::std::ostream &out, const ::sse_i &t)
{
  int *f((int *)&t);
  out << "[" << f[0] << "," << f[1] << "," << f[2] << "," << f[3] << "] ";
  return out;
}
inline __attribute__((always_inline)) bool isNAN(const ::sse_f &a)
{
  return a == ::_mm_set_ps1(::std::numeric_limits<float>::quiet_NaN());
}
inline __attribute__((always_inline)) bool isNaN(const ::sse_f &a)
{
  return ::isNAN(a);
}
inline __attribute__((always_inline)) bool isINF(const ::sse_f &a)
{
  return a == ::_mm_set_ps1(::std::numeric_limits<float>::infinity());
}
inline __attribute__((always_inline)) float minHorizontal3f(::sse_f a)
{
  return ::std::min /* <float> */ (((float *)&a)[0], ::std::min /* <float> */ (((float *)&a)[1], ((float *)&a)[2]));
}
inline __attribute__((always_inline)) float maxHorizontal3f(::sse_f a)
{
  return ::std::max /* <float> */ (((float *)&a)[0], ::std::max /* <float> */ (((float *)&a)[1], ((float *)&a)[2]));
}
inline __attribute__((always_inline)) ::sse_f setHorizontalMin3f(const ::sse_f &x, const ::sse_f &y, const ::sse_f &z, const float v  = 0.000000000000000000000000e+00f)
{
  return ::_mm_setr_ps(::minHorizontal3f(x), ::minHorizontal3f(y), ::minHorizontal3f(z), v);
}
inline __attribute__((always_inline)) ::sse_f setHorizontalMax3f(const ::sse_f &x, const ::sse_f &y, const ::sse_f &z, const float v  = 0.000000000000000000000000e+00f)
{
  return ::_mm_setr_ps(::maxHorizontal3f(x), ::maxHorizontal3f(y), ::maxHorizontal3f(z), v);
}
template < int i >
::sse_f splat4(const ::sse_f &v);
template < int i >
::sse_f splat4(const ::sse_f &v)
{
  return ::_mm_shuffle_ps(v, v, ((i << 6 | i << 4) | i << 2) | i);
}
template < int i >
::sse_i splat4i(const ::sse_i &v);
template < int i >
::sse_i splat4i(const ::sse_i &v)
{
  return ::_mm_shuffle_epi32(v, ((i << 6 | i << 4) | i << 2) | i);
}
inline __attribute__((always_inline)) ::sse_f choose4(const ::sse_f &mask, const ::sse_f &iftrue, const ::sse_f &iffalse)
{
  return ::_mm_or_ps(::_mm_and_ps(mask, iftrue), ::_mm_andnot_ps(mask, iffalse));
}
inline __attribute__((always_inline)) void forceZeroToEpsilon(::sse_f &val)
{
  val = ::choose4(::_mm_cmpeq_ps(val, ::_mm_setzero_ps()), ::_mm_set_ps1(9.999999974752427078783512e-07f), val);
}
namespace RTTL {
  template < int N, typename DataType, int align = 0 >
  struct  RTData_t
  {
    private:
      RTData_t();
  };
  template < int N, typename DataType >
  struct  RTData_t<N, DataType, 0>
  {
      typedef DataType AlignedDataType;
      inline int alignment() const 
      {
        return 0;
      }
      inline __attribute__((always_inline)) void assignDataTypeValue(const DataType &v)
      {
        for (int i = 0; i < N; i++)
          {
            t[i] = v;
          }
      }
      inline __attribute__((always_inline)) void assignDataTypeArray(const DataType *v)
      {
        for (int i = 0; i < N; i++)
          {
            t[i] = v[i];
          }
      }
      template < int AnotherN, typename AnotherDataType, int AnotherAlign >
      inline __attribute__((always_inline)) void assign(const ::RTTL::RTData_t<AnotherN, AnotherDataType, AnotherAlign> &v)
      {
        const char __MERCURIUM_PRETTY_FUNCTION__[163] = "void ::RTTL::RTData_t<N, DataType, 0>::template assign<AnotherN, AnotherDataType, AnotherAlign>(const ::RTTL::RTData_t<AnotherN, AnotherDataType, AnotherAlign> &)";
        nElements() <= v.nElements() ? static_cast<void>(0) : ::__assert_fail("nElements() <= v.nElements()", "/home/bsc18/bsc18186/scratch/parsec/raytrace/src/RTTL/common/RTData.hxx", 44, __MERCURIUM_PRETTY_FUNCTION__);
        for (int i = 0; i < N; i++)
          {
            t[i] = v[i];
          }
      }
      inline __attribute__((always_inline)) DataType &operator [](int index)
      {
        return t[index];
      }
      inline __attribute__((always_inline)) DataType operator [](int index) const 
      {
        return t[index];
      }
      inline __attribute__((always_inline)) void operator +=(const ::RTTL::RTData_t<N, DataType, 0> &x)
      {
        for (int i = 0; i < N; i++)
          {
            t[i] += x.t[i];
          }
      }
      inline __attribute__((always_inline)) void operator -=(const ::RTTL::RTData_t<N, DataType, 0> &x)
      {
        for (int i = 0; i < N; i++)
          {
            t[i] -= x.t[i];
          }
      }
      inline __attribute__((always_inline)) void operator *=(const ::RTTL::RTData_t<N, DataType, 0> &x)
      {
        for (int i = 0; i < N; i++)
          {
            t[i] *= x.t[i];
          }
      }
      inline __attribute__((always_inline)) void operator /=(const ::RTTL::RTData_t<N, DataType, 0> &x)
      {
        for (int i = 0; i < N; i++)
          {
            t[i] /= x.t[i];
          }
      }
      inline __attribute__((always_inline)) void operator +=(const DataType &q)
      {
        for (int i = 0; i < N; i++)
          {
            t[i] += q;
          }
      }
      inline __attribute__((always_inline)) void operator -=(const DataType &q)
      {
        for (int i = 0; i < N; i++)
          {
            t[i] -= q;
          }
      }
      inline __attribute__((always_inline)) void operator *=(const DataType &q)
      {
        for (int i = 0; i < N; i++)
          {
            t[i] *= q;
          }
      }
      inline __attribute__((always_inline)) void operator /=(const DataType &q)
      {
        for (int i = 0; i < N; i++)
          {
            t[i] /= q;
          }
      }
      inline __attribute__((always_inline)) void add(const ::RTTL::RTData_t<N, DataType, 0> &v1, const ::RTTL::RTData_t<N, DataType, 0> &v2)
      {
        for (int i = 0; i < N; i++)
          {
            t[i] = v1.t[i] + v2.t[i];
          }
      }
      inline __attribute__((always_inline)) void subtract(const ::RTTL::RTData_t<N, DataType, 0> &v1, const ::RTTL::RTData_t<N, DataType, 0> &v2)
      {
        for (int i = 0; i < N; i++)
          {
            t[i] = v1.t[i] - v2.t[i];
          }
      }
      inline __attribute__((always_inline)) void multiply(const ::RTTL::RTData_t<N, DataType, 0> &v1, const ::RTTL::RTData_t<N, DataType, 0> &v2)
      {
        for (int i = 0; i < N; i++)
          {
            t[i] = v1.t[i] * v2.t[i];
          }
      }
      inline __attribute__((always_inline)) void divide(const ::RTTL::RTData_t<N, DataType, 0> &v1, const ::RTTL::RTData_t<N, DataType, 0> &v2)
      {
        for (int i = 0; i < N; i++)
          {
            t[i] = v1.t[i] / v2.t[i];
          }
      }
      inline __attribute__((always_inline)) void add(const ::RTTL::RTData_t<N, DataType, 0> &v1, const DataType *v2)
      {
        for (int i = 0; i < N; i++)
          {
            t[i] = v1.t[i] + v2[i];
          }
      }
      inline __attribute__((always_inline)) void subtract(const ::RTTL::RTData_t<N, DataType, 0> &v1, const DataType *v2)
      {
        for (int i = 0; i < N; i++)
          {
            t[i] = v1.t[i] - v2[i];
          }
      }
      inline __attribute__((always_inline)) void multiply(const ::RTTL::RTData_t<N, DataType, 0> &v1, const DataType *v2)
      {
        for (int i = 0; i < N; i++)
          {
            t[i] = v1.t[i] * v2[i];
          }
      }
      inline __attribute__((always_inline)) void divide(const ::RTTL::RTData_t<N, DataType, 0> &v1, const DataType *v2)
      {
        for (int i = 0; i < N; i++)
          {
            t[i] = v1.t[i] / v2[i];
          }
      }
      inline __attribute__((always_inline)) void add(const DataType *v1, const ::RTTL::RTData_t<N, DataType, 0> &v2)
      {
        add(v2, v1);
      }
      inline __attribute__((always_inline)) void subtract(const DataType *v1, const ::RTTL::RTData_t<N, DataType, 0> &v2)
      {
        subtract(v2, v1);
      }
      inline __attribute__((always_inline)) void multiply(const DataType *v1, const ::RTTL::RTData_t<N, DataType, 0> &v2)
      {
        multiply(v2, v1);
      }
      inline __attribute__((always_inline)) void divide(const DataType *v1, const ::RTTL::RTData_t<N, DataType, 0> &v2)
      {
        for (int i = 0; i < N; i++)
          {
            t[i] = v1[i] / v2.t[i];
          }
      }
      template < typename ScalarType >
      inline __attribute__((always_inline)) void addScalar(const ::RTTL::RTData_t<N, DataType, 0> &a, const ScalarType &b)
      {
        for (int i = 0; i < N; i++)
          {
            t[i] = a.t[i] + b;
          }
      }
      template < typename ScalarType >
      inline __attribute__((always_inline)) void subtractScalar(const ::RTTL::RTData_t<N, DataType, 0> &a, const ScalarType &b)
      {
        for (int i = 0; i < N; i++)
          {
            t[i] = a.t[i] - b;
          }
      }
      template < typename ScalarType >
      inline __attribute__((always_inline)) void subtractScalar(const ScalarType &b, const ::RTTL::RTData_t<N, DataType, 0> &a)
      {
        for (int i = 0; i < N; i++)
          {
            t[i] = b - a.t[i];
          }
      }
      template < typename ScalarType >
      inline __attribute__((always_inline)) void multiplyScalar(const ::RTTL::RTData_t<N, DataType, 0> &a, const ScalarType &b)
      {
        for (int i = 0; i < N; i++)
          {
            t[i] = a.t[i] * b;
          }
      }
      template < typename ScalarType >
      inline __attribute__((always_inline)) void divideScalar(const ::RTTL::RTData_t<N, DataType, 0> &a, const ScalarType &b)
      {
        for (int i = 0; i < N; i++)
          {
            t[i] = a.t[i] / b;
          }
      }
      template < typename ScalarType >
      inline __attribute__((always_inline)) void divideScalar(const ScalarType &b, const ::RTTL::RTData_t<N, DataType, 0> &a)
      {
        for (int i = 0; i < N; i++)
          {
            t[i] = b / a.t[i];
          }
      }
      static inline int nElements()
      {
        return N;
      }
    protected:
      DataType t[N];
  };
  template < int N, typename DataType >
  inline bool operator ==(const ::RTTL::RTData_t<N, DataType, 0> &v1, const ::RTTL::RTData_t<N, DataType, 0> &v2)__attribute__((always_inline));
  template < int N, typename DataType >
  inline __attribute__((always_inline)) bool operator ==(const ::RTTL::RTData_t<N, DataType, 0> &v1, const ::RTTL::RTData_t<N, DataType, 0> &v2)
  {
    for (int i = 0; i < N; i++)
      {
        if (v1[i] != v2[i])
          {
            return false;
          }
      }
    return true;
  }
  template < int N, typename DataType >
  inline bool operator ==(const ::RTTL::RTData_t<N, DataType, 0> &v1, const DataType v2[])__attribute__((always_inline));
  template < int N, typename DataType >
  inline __attribute__((always_inline)) bool operator ==(const ::RTTL::RTData_t<N, DataType, 0> &v1, const DataType *v2)
  {
    for (int i = 0; i < N; i++)
      {
        if (v1[i] != v2[i])
          {
            return false;
          }
      }
    return true;
  }
  template < int N, typename DataType >
  inline bool operator ==(const DataType v1[], const ::RTTL::RTData_t<N, DataType, 0> &v2)__attribute__((always_inline));
  template < int N, typename DataType >
  inline __attribute__((always_inline)) bool operator ==(const DataType *v1, const ::RTTL::RTData_t<N, DataType, 0> &v2)
  {
    for (int i = 0; i < N; i++)
      {
        if (v1[i] != v2[i])
          {
            return false;
          }
      }
    return true;
  }
  template < int N, typename DataType >
  inline bool operator ==(const ::RTTL::RTData_t<N, DataType, 0> &v1, DataType v2)__attribute__((always_inline));
  template < int N, typename DataType >
  inline __attribute__((always_inline)) bool operator ==(const ::RTTL::RTData_t<N, DataType, 0> &v1, DataType v2)
  {
    for (int i = 0; i < N; i++)
      {
        if (v1[i] != v2)
          {
            return false;
          }
      }
    return true;
  }
  template < int N, typename DataType >
  inline bool operator ==(DataType v1, const ::RTTL::RTData_t<N, DataType, 0> &v2)__attribute__((always_inline));
  template < int N, typename DataType >
  inline __attribute__((always_inline)) bool operator ==(DataType v1, const ::RTTL::RTData_t<N, DataType, 0> &v2)
  {
    for (int i = 0; i < N; i++)
      {
        if (v1 != v2[i])
          {
            return false;
          }
      }
    return true;
  }
  template < int N, typename DataType >
  struct  RTData_t<N, DataType, 16>
  {
      typedef DataType AlignedDataType;
      inline int alignment() const 
      {
        return 16;
      }
      inline __attribute__((always_inline)) void assignDataTypeValue(DataType v)
      {
        for (int i = 0; i < 1 + (N - 1) / 4; i++)
          {
            ((::sse_f *)t)[i] = _mm_set_ps1(v);
          }
      }
      inline __attribute__((always_inline)) void assignDataTypeArray(const DataType *v)
      {
        for (int i = 0; i < 1 + (N - 1) / 4; i++)
          {
            ((::sse_f *)t)[i] = ((::sse_f *)v)[i];
          }
      }
      template < int AnotherN, typename AnotherDataType, int AnotherAlign >
      inline __attribute__((always_inline)) void assign(const ::RTTL::RTData_t<AnotherN, AnotherDataType, AnotherAlign> &v)
      {
        ((::RTTL::RTData_t<N, DataType, 0> *)this)->assign(v);
      }
      inline __attribute__((always_inline)) void assign(const ::RTTL::RTData_t<N, DataType, 16> &v)
      {
        for (int i = 0; i < 1 + (N - 1) / 4; i++)
          {
            ((::sse_f *)t)[i] = ((::sse_f *)v.t)[i];
          }
      }
      inline __attribute__((always_inline)) DataType &operator [](int index)
      {
        return t[index];
      }
      inline __attribute__((always_inline)) DataType operator [](int index) const 
      {
        return t[index];
      }
      inline __attribute__((always_inline)) void operator +=(const ::RTTL::RTData_t<N, DataType, 16> &x)
      {
        for (int i = 0; i < 1 + (N - 1) / 4; i++)
          {
            ((::sse_f *)t)[i] += ((::sse_f *)x.t)[i];
          }
      }
      inline __attribute__((always_inline)) void operator -=(const ::RTTL::RTData_t<N, DataType, 16> &x)
      {
        for (int i = 0; i < 1 + (N - 1) / 4; i++)
          {
            ((::sse_f *)t)[i] -= ((::sse_f *)x.t)[i];
          }
      }
      inline __attribute__((always_inline)) void operator *=(const ::RTTL::RTData_t<N, DataType, 16> &x)
      {
        for (int i = 0; i < 1 + (N - 1) / 4; i++)
          {
            ((::sse_f *)t)[i] *= ((::sse_f *)x.t)[i];
          }
      }
      inline __attribute__((always_inline)) void operator /=(const ::RTTL::RTData_t<N, DataType, 16> &x)
      {
        for (int i = 0; i < 1 + (N - 1) / 4; i++)
          {
            ((::sse_f *)t)[i] /= ((::sse_f *)x.t)[i];
          }
      }
      inline __attribute__((always_inline)) void operator +=(const DataType &q)
      {
        for (int i = 0; i < 1 + (N - 1) / 4; i++)
          {
            ((::sse_f *)t)[i] += q;
          }
      }
      inline __attribute__((always_inline)) void operator -=(const DataType &q)
      {
        for (int i = 0; i < 1 + (N - 1) / 4; i++)
          {
            ((::sse_f *)t)[i] -= q;
          }
      }
      inline __attribute__((always_inline)) void operator *=(const DataType &q)
      {
        for (int i = 0; i < 1 + (N - 1) / 4; i++)
          {
            ((::sse_f *)t)[i] *= q;
          }
      }
      inline __attribute__((always_inline)) void operator /=(const DataType &q)
      {
        for (int i = 0; i < 1 + (N - 1) / 4; i++)
          {
            ((::sse_f *)t)[i] /= q;
          }
      }
      inline __attribute__((always_inline)) void add(const ::RTTL::RTData_t<N, DataType, 16> &v1, const ::RTTL::RTData_t<N, DataType, 16> &v2)
      {
        for (int i = 0; i < 1 + (N - 1) / 4; i++)
          {
            ((::sse_f *)t)[i] = ((::sse_f *)v1.t)[i] + ((::sse_f *)v2.t)[i];
          }
      }
      inline __attribute__((always_inline)) void subtract(const ::RTTL::RTData_t<N, DataType, 16> &v1, const ::RTTL::RTData_t<N, DataType, 16> &v2)
      {
        for (int i = 0; i < 1 + (N - 1) / 4; i++)
          {
            ((::sse_f *)t)[i] = ((::sse_f *)v1.t)[i] - ((::sse_f *)v2.t)[i];
          }
      }
      inline __attribute__((always_inline)) void multiply(const ::RTTL::RTData_t<N, DataType, 16> &v1, const ::RTTL::RTData_t<N, DataType, 16> &v2)
      {
        for (int i = 0; i < 1 + (N - 1) / 4; i++)
          {
            ((::sse_f *)t)[i] = ((::sse_f *)v1.t)[i] * ((::sse_f *)v2.t)[i];
          }
      }
      inline __attribute__((always_inline)) void divide(const ::RTTL::RTData_t<N, DataType, 16> &v1, const ::RTTL::RTData_t<N, DataType, 16> &v2)
      {
        for (int i = 0; i < 1 + (N - 1) / 4; i++)
          {
            ((::sse_f *)t)[i] = ((::sse_f *)v1.t)[i] / ((::sse_f *)v2.t)[i];
          }
      }
      inline __attribute__((always_inline)) void add(const ::RTTL::RTData_t<N, DataType, 16> &v1, const DataType *v2)
      {
        for (int i = 0; i < 1 + (N - 1) / 4; i++)
          {
            ((::sse_f *)t)[i] = ((::sse_f *)v1.t)[i] + ((::sse_f *)v2)[i];
          }
      }
      inline __attribute__((always_inline)) void subtract(const ::RTTL::RTData_t<N, DataType, 16> &v1, const DataType *v2)
      {
        for (int i = 0; i < 1 + (N - 1) / 4; i++)
          {
            ((::sse_f *)t)[i] = ((::sse_f *)v1.t)[i] - ((::sse_f *)v2)[i];
          }
      }
      inline __attribute__((always_inline)) void multiply(const ::RTTL::RTData_t<N, DataType, 16> &v1, const DataType *v2)
      {
        for (int i = 0; i < 1 + (N - 1) / 4; i++)
          {
            ((::sse_f *)t)[i] = ((::sse_f *)v1.t)[i] * ((::sse_f *)v2)[i];
          }
      }
      inline __attribute__((always_inline)) void divide(const ::RTTL::RTData_t<N, DataType, 16> &v1, const DataType *v2)
      {
        for (int i = 0; i < 1 + (N - 1) / 4; i++)
          {
            ((::sse_f *)t)[i] = ((::sse_f *)v1.t)[i] / ((::sse_f *)v2)[i];
          }
      }
      inline __attribute__((always_inline)) void add(const DataType *v1, const ::RTTL::RTData_t<N, DataType, 16> &v2)
      {
        add(v2, v1);
      }
      inline __attribute__((always_inline)) void subtract(const DataType *v1, const ::RTTL::RTData_t<N, DataType, 16> &v2)
      {
        subtract(v2, v1);
      }
      inline __attribute__((always_inline)) void multiply(const DataType *v1, const ::RTTL::RTData_t<N, DataType, 16> &v2)
      {
        multiply(v2, v1);
      }
      inline __attribute__((always_inline)) void divide(const DataType *v1, const ::RTTL::RTData_t<N, DataType, 16> &v2)
      {
        for (int i = 0; i < 1 + (N - 1) / 4; i++)
          {
            ((::sse_f *)t)[i] = v1[i] / ((::sse_f *)v2.t)[i];
          }
      }
      template < typename ScalarType >
      inline __attribute__((always_inline)) void addScalar(const ::RTTL::RTData_t<N, DataType, 16> &a, const ScalarType &b)
      {
        for (int i = 0; i < 1 + (N - 1) / 4; i++)
          {
            ((::sse_f *)t)[i] = ((::sse_f *)a.t)[i] + b;
          }
      }
      template < typename ScalarType >
      inline __attribute__((always_inline)) void subtractScalar(const ::RTTL::RTData_t<N, DataType, 16> &a, const ScalarType &b)
      {
        for (int i = 0; i < 1 + (N - 1) / 4; i++)
          {
            ((::sse_f *)t)[i] = ((::sse_f *)a.t)[i] - b;
          }
      }
      template < typename ScalarType >
      inline __attribute__((always_inline)) void subtractScalar(const ScalarType &b, const ::RTTL::RTData_t<N, DataType, 16> &a)
      {
        for (int i = 0; i < 1 + (N - 1) / 4; i++)
          {
            ((::sse_f *)t)[i] = b - ((::sse_f *)a.t)[i];
          }
      }
      template < typename ScalarType >
      inline __attribute__((always_inline)) void multiplyScalar(const ::RTTL::RTData_t<N, DataType, 16> &a, const ScalarType &b)
      {
        for (int i = 0; i < 1 + (N - 1) / 4; i++)
          {
            ((::sse_f *)t)[i] = ((::sse_f *)a.t)[i] * b;
          }
      }
      template < typename ScalarType >
      inline __attribute__((always_inline)) void divideScalar(const ::RTTL::RTData_t<N, DataType, 16> &a, const ScalarType &b)
      {
        for (int i = 0; i < 1 + (N - 1) / 4; i++)
          {
            ((::sse_f *)t)[i] = ((::sse_f *)a.t)[i] / b;
          }
      }
      template < typename ScalarType >
      inline __attribute__((always_inline)) void divideScalar(const ScalarType &b, const ::RTTL::RTData_t<N, DataType, 16> &a)
      {
        for (int i = 0; i < 1 + (N - 1) / 4; i++)
          {
            ((::sse_f *)t)[i] = b / ((::sse_f *)a.t)[i];
          }
      }
      static inline int nElements()
      {
        return N;
      }
    protected:
      typename ::RTTL::RTData_t<N, DataType, 16>::AlignedDataType t[N % 16 ? N - N % 16 + 16 : N];
  };
  template < int N, typename DataType >
  inline bool operator ==(const ::RTTL::RTData_t<N, DataType, 16> &v1, const ::RTTL::RTData_t<N, DataType, 16> &v2)__attribute__((always_inline));
  template < int N, typename DataType >
  inline __attribute__((always_inline)) bool operator ==(const ::RTTL::RTData_t<N, DataType, 16> &v1, const ::RTTL::RTData_t<N, DataType, 16> &v2)
  {
    for (int i = 0; i < 1 + (N - 1) / 4; i++)
      {
        if (((::sse_f *)&v1)[i] != ((::sse_f *)&v2)[i])
          {
            return false;
          }
      }
    return true;
  }
  template < int N, typename DataType >
  inline bool operator ==(const ::RTTL::RTData_t<N, DataType, 16> &v1, const DataType v2[])__attribute__((always_inline));
  template < int N, typename DataType >
  inline __attribute__((always_inline)) bool operator ==(const ::RTTL::RTData_t<N, DataType, 16> &v1, const DataType *v2)
  {
    for (int i = 0; i < 1 + (N - 1) / 4; i++)
      {
        if (((::sse_f *)&v1)[i] != ((::sse_f *)v2)[i])
          {
            return false;
          }
      }
    return true;
  }
  template < int N, typename DataType >
  inline bool operator ==(const DataType v1[], const ::RTTL::RTData_t<N, DataType, 16> &v2)__attribute__((always_inline));
  template < int N, typename DataType >
  inline __attribute__((always_inline)) bool operator ==(const DataType *v1, const ::RTTL::RTData_t<N, DataType, 16> &v2)
  {
    for (int i = 0; i < 1 + (N - 1) / 4; i++)
      {
        if (((::sse_f *)v1)[i] != ((::sse_f *)&v2)[i])
          {
            return false;
          }
      }
    return true;
  }
  template < int N, typename DataType >
  inline bool operator ==(const ::RTTL::RTData_t<N, DataType, 16> &v1, DataType v2)__attribute__((always_inline));
  template < int N, typename DataType >
  inline __attribute__((always_inline)) bool operator ==(const ::RTTL::RTData_t<N, DataType, 16> &v1, DataType v2)
  {
    for (int i = 0; i < 1 + (N - 1) / 4; i++)
      {
        if (((::sse_f *)&v1)[i] != _mm_set_ps1(v2))
          {
            return false;
          }
      }
    return true;
  }
  template < int N, typename DataType >
  inline bool operator ==(DataType v1, const ::RTTL::RTData_t<N, DataType, 16> &v2)__attribute__((always_inline));
  template < int N, typename DataType >
  inline __attribute__((always_inline)) bool operator ==(DataType v1, const ::RTTL::RTData_t<N, DataType, 16> &v2)
  {
    return v2 == v1;
  }
  template < int N, typename DataType, int align = 0 >
  class  RTVec_t
  {
    public:
      typedef ::RTTL::RTData_t<N, DataType, align> DataArray;
      inline RTVec_t()
      {
      }
      inline explicit RTVec_t(const DataType &v)
      {
        typename ::RTTL::RTVec_t<N, DataType, align>::DataArray &t = *this;
        t.assignDataTypeValue(v);
      }
      template < int AnotherN, typename AnotherDataType, int AnotherAlign >
      inline RTVec_t(const ::RTTL::RTVec_t<AnotherN, AnotherDataType, AnotherAlign> &x)
      {
        typename ::RTTL::RTVec_t<N, DataType, align>::DataArray &t = *this;
        const ::RTTL::RTData_t<AnotherN, AnotherDataType, AnotherAlign> &xt = x;
        t.assign(xt);
      }
      inline RTVec_t(const DataType *x)
      {
        typename ::RTTL::RTVec_t<N, DataType, align>::DataArray &t = *this;
        t.assignDataTypeArray(x);
      }
      static inline int nElements()
      {
        return N;
      }
      static inline int entrySize()
      {
        return sizeof(DataType);
      }
      static inline int totalSize()
      {
        return N * sizeof(DataType);
      }
      template < int AnotherN, typename AnotherDataType, int AnotherAlign >
      inline __attribute__((always_inline)) const ::RTTL::RTVec_t<N, DataType, align> &operator =(const ::RTTL::RTVec_t<AnotherN, AnotherDataType, AnotherAlign> &x)
      {
        const char __MERCURIUM_PRETTY_FUNCTION__[207] = "const ::RTTL::RTVec_t<N, DataType, align> &::RTTL::RTVec_t<N, DataType, align>::template operator =<AnotherN, AnotherDataType, AnotherAlign>(const ::RTTL::RTVec_t<AnotherN, AnotherDataType, AnotherAlign> &)";
        nElements() <= x.nElements() ? static_cast<void>(0) : ::__assert_fail("nElements() <= x.nElements()", "/home/bsc18/bsc18186/scratch/parsec/raytrace/src/RTTL/common/RTVecBody.h", 67, __MERCURIUM_PRETTY_FUNCTION__);
        typename ::RTTL::RTVec_t<N, DataType, align>::DataArray &t = *this;
        const ::RTTL::RTData_t<AnotherN, AnotherDataType, AnotherAlign> &xt = x;
        t.assign(xt);
        return *this;
      }
      inline __attribute__((always_inline)) const ::RTTL::RTVec_t<N, DataType, align> &operator =(const ::RTTL::RTVec_t<N, DataType, align> &x)
      {
        typename ::RTTL::RTVec_t<N, DataType, align>::DataArray &t = *this;
        const typename ::RTTL::RTVec_t<N, DataType, align>::DataArray &xt = x;
        t.assign(xt);
        return *this;
      }
      inline __attribute__((always_inline)) const ::RTTL::RTVec_t<N, DataType, align> &operator =(const DataType &x)
      {
        typename ::RTTL::RTVec_t<N, DataType, align>::DataArray &t = *this;
        t.assignDataTypeValue(x);
        return *this;
      }
      inline __attribute__((always_inline)) const ::RTTL::RTVec_t<N, DataType, align> &operator +=(const ::RTTL::RTVec_t<N, DataType, align> &x)
      {
        typename ::RTTL::RTVec_t<N, DataType, align>::DataArray &t = *this;
        t += x;
        return *this;
      }
      inline __attribute__((always_inline)) const ::RTTL::RTVec_t<N, DataType, align> &operator -=(const ::RTTL::RTVec_t<N, DataType, align> &x)
      {
        typename ::RTTL::RTVec_t<N, DataType, align>::DataArray &t = *this;
        t -= x;
        return *this;
      }
      inline __attribute__((always_inline)) const ::RTTL::RTVec_t<N, DataType, align> &operator *=(const ::RTTL::RTVec_t<N, DataType, align> &x)
      {
        typename ::RTTL::RTVec_t<N, DataType, align>::DataArray &t = *this;
        t *= x;
        return *this;
      }
      inline __attribute__((always_inline)) const ::RTTL::RTVec_t<N, DataType, align> &operator /=(const ::RTTL::RTVec_t<N, DataType, align> &x)
      {
        typename ::RTTL::RTVec_t<N, DataType, align>::DataArray &t = *this;
        t /= x;
        return *this;
      }
      inline __attribute__((always_inline)) const ::RTTL::RTVec_t<N, DataType, align> &operator +=(const DataType &q)
      {
        typename ::RTTL::RTVec_t<N, DataType, align>::DataArray &t = *this;
        t += q;
        return *this;
      }
      inline __attribute__((always_inline)) const ::RTTL::RTVec_t<N, DataType, align> &operator -=(const DataType &q)
      {
        typename ::RTTL::RTVec_t<N, DataType, align>::DataArray &t = *this;
        t -= q;
        return *this;
      }
      inline __attribute__((always_inline)) const ::RTTL::RTVec_t<N, DataType, align> &operator *=(const DataType &q)
      {
        typename ::RTTL::RTVec_t<N, DataType, align>::DataArray &t = *this;
        t *= q;
        return *this;
      }
      inline __attribute__((always_inline)) const ::RTTL::RTVec_t<N, DataType, align> &operator /=(const DataType &q)
      {
        typename ::RTTL::RTVec_t<N, DataType, align>::DataArray &t = *this;
        t /= q;
        return *this;
      }
      inline __attribute__((always_inline)) DataType dot(const ::RTTL::RTVec_t<N, DataType, align> &x) const 
      {
        DataType v;
        typename ::RTTL::RTVec_t<N, DataType, align>::DataArray &t = *this;
        const typename ::RTTL::RTVec_t<N, DataType, align>::DataArray &xt = x;
        for (int i = 0; i < N; i++)
          {
            v += t[i] * xt[i];
          }
        return v;
      }
      inline __attribute__((always_inline)) DataType lengthSquared() const 
      {
        const typename ::RTTL::RTVec_t<N, DataType, align>::DataArray &t = *this;
        DataType v = t[0] * t[0];
        for (int i = 1; i < N; i++)
          {
            v += t[i] * t[i];
          }
        return v;
      }
      inline __attribute__((always_inline)) DataType length() const 
      {
        return sqrt(lengthSquared());
      }
      inline __attribute__((always_inline)) void normalize()
      {
        DataType q = 1 / length();
        typename ::RTTL::RTVec_t<N, DataType, align>::DataArray &t = *this;
        for (int i = 0; i < N; i++)
          {
            t[i] *= q;
          }
      }
      inline __attribute__((always_inline)) void setMin(const ::RTTL::RTVec_t<N, DataType, 0> &other)
      {
        typename ::RTTL::RTVec_t<N, DataType, align>::DataArray &t = *this;
        for (int i = 0; i < N; i++)
          {
            t[i] = min(t[i], other[i]);
          }
      }
      inline __attribute__((always_inline)) void setMin(const DataType &other)
      {
        typename ::RTTL::RTVec_t<N, DataType, align>::DataArray &t = *this;
        for (int i = 0; i < N; i++)
          {
            t[i] = min(t[i], other);
          }
      }
      inline __attribute__((always_inline)) void setMax(const ::RTTL::RTVec_t<N, DataType, 0> &other)
      {
        typename ::RTTL::RTVec_t<N, DataType, align>::DataArray &t = *this;
        for (int i = 0; i < N; i++)
          {
            t[i] = max(t[i], other[i]);
          }
      }
      inline __attribute__((always_inline)) void setMax(const DataType &other)
      {
        typename ::RTTL::RTVec_t<N, DataType, align>::DataArray &t = *this;
        for (int i = 0; i < N; i++)
          {
            t[i] = max(t[i], other);
          }
      }
      static inline __attribute__((always_inline)) DataType epsilon()
      {
        return numeric_limits<DataType>::epsilon();
      }
      static inline __attribute__((always_inline)) DataType minValue()
      {
        return numeric_limits<DataType>::min();
      }
      static inline __attribute__((always_inline)) DataType maxValue()
      {
        return numeric_limits<DataType>::max();
      }
      static inline __attribute__((always_inline)) DataType infinity()
      {
        return numeric_limits<DataType>::infinity();
      }
      inline DataType &operator [](int index)
      {
        return t[index];
      }
      inline DataType operator [](int index) const 
      {
        return t[index];
      }
      inline operator DataType *()
      {
        return (DataType *)&t;
      }
      inline operator const DataType *() const 
      {
        return (DataType *)&t;
      }
      inline operator typename ::RTTL::RTVec_t<N, DataType, align>::DataArray &()
      {
        return t;
      }
      inline operator const typename ::RTTL::RTVec_t<N, DataType, align>::DataArray &() const 
      {
        return t;
      }
      inline typename ::RTTL::RTVec_t<N, DataType, align>::DataArray &array()
      {
        return t;
      }
      inline const typename ::RTTL::RTVec_t<N, DataType, align>::DataArray &array() const 
      {
        return t;
      }
      template < typename CastType >
      inline const CastType &entry(int i  = 0) const 
      {
        return *((const CastType *)&t + i);
      }
      template < typename CastType >
      inline CastType &entry(int i  = 0)
      {
        return *((CastType *)&t + i);
      }
      template < typename CastType >
      inline const CastType *pointer() const 
      {
        return (const CastType *)&t;
      }
      template < typename CastType >
      inline CastType *pointer()
      {
        return (CastType *)&t;
      }
      inline const DataType &entry(int i  = 0) const 
      {
        return *((const DataType *)&t + i);
      }
      inline DataType &entry(int i  = 0)
      {
        return *((DataType *)&t + i);
      }
      inline const DataType *pointer() const 
      {
        return (const DataType *)&t;
      }
      inline DataType *pointer()
      {
        return (DataType *)&t;
      }
      inline __attribute__((always_inline)) DataType minimum() const 
      {
        DataType v = t[0];
        for (int i = 1; i < N; i++)
          {
            v = min(v, t[i]);
          }
        return v;
      }
      inline __attribute__((always_inline)) DataType maximum() const 
      {
        DataType v = t[0];
        for (int i = 1; i < N; i++)
          {
            v = max(v, t[i]);
          }
        return v;
      }
      inline __attribute__((always_inline)) DataType absMinimum() const 
      {
        DataType v = ::abs(t[0]);
        for (int i = 1; i < N; i++)
          {
            v = ::abs(min(v, t[i]));
          }
        return v;
      }
      inline __attribute__((always_inline)) DataType absMaximum() const 
      {
        DataType v = ::abs(t[0]);
        for (int i = 1; i < N; i++)
          {
            v = ::abs(max(v, t[i]));
          }
        return v;
      }
      inline __attribute__((always_inline)) int minIndex() const 
      {
        DataType v = t[0];
        int mi(0);
        for (int i = 1; i < N; i++)
          {
            if (t[i] < v)
              {
                mi = i;
                v = t[i];
              }
          }
        return mi;
      }
      inline __attribute__((always_inline)) int maxIndex() const 
      {
        DataType v = t[0];
        int mi(0);
        for (int i = 1; i < N; i++)
          {
            if (t[i] > v)
              {
                mi = i;
                v = t[i];
              }
          }
        return mi;
      }
      inline __attribute__((always_inline)) int minAbsIndex() const 
      {
        DataType v = ::abs(t[0]);
        int mi(0);
        for (int i = 1; i < N; i++)
          {
            if (::abs(t[i]) < v)
              {
                mi = i;
                v = ::abs(t[i]);
              }
          }
        return mi;
      }
      inline __attribute__((always_inline)) int maxAbsIndex() const 
      {
        DataType v = ::abs(t[0]);
        int mi(0);
        for (int i = 1; i < N; i++)
          {
            if (::abs(t[i]) > v)
              {
                mi = i;
                v = ::abs(t[i]);
              }
          }
        return mi;
      }
    protected:
      typename ::RTTL::RTVec_t<N, DataType, align>::DataArray t;
  };
  template < typename DataType, int align >
  class  RTVec_t<2, DataType, align>
  {
    public:
      typedef ::RTTL::RTData_t<2, DataType, align> DataArray;
      inline RTVec_t()
      {
      }
      inline explicit RTVec_t(const DataType &v)
      {
        typename ::RTTL::RTVec_t<2, DataType, align>::DataArray &t = *this;
        t.assignDataTypeValue(v);
      }
      template < int AnotherN, typename AnotherDataType, int AnotherAlign >
      inline RTVec_t(const ::RTTL::RTVec_t<AnotherN, AnotherDataType, AnotherAlign> &x)
      {
        typename ::RTTL::RTVec_t<2, DataType, align>::DataArray &t = *this;
        const ::RTTL::RTData_t<AnotherN, AnotherDataType, AnotherAlign> &xt = x;
        t.assign(xt);
      }
      inline RTVec_t(const DataType *x)
      {
        typename ::RTTL::RTVec_t<2, DataType, align>::DataArray &t = *this;
        t.assignDataTypeArray(x);
      }
      static inline int nElements()
      {
        return 2;
      }
      static inline int entrySize()
      {
        return sizeof(DataType);
      }
      static inline int totalSize()
      {
        return 2 * sizeof(DataType);
      }
      template < int AnotherN, typename AnotherDataType, int AnotherAlign >
      inline __attribute__((always_inline)) const ::RTTL::RTVec_t<2, DataType, align> &operator =(const ::RTTL::RTVec_t<AnotherN, AnotherDataType, AnotherAlign> &x)
      {
        const char __MERCURIUM_PRETTY_FUNCTION__[207] = "const ::RTTL::RTVec_t<2, DataType, align> &::RTTL::RTVec_t<2, DataType, align>::template operator =<AnotherN, AnotherDataType, AnotherAlign>(const ::RTTL::RTVec_t<AnotherN, AnotherDataType, AnotherAlign> &)";
        nElements() <= x.nElements() ? static_cast<void>(0) : ::__assert_fail("nElements() <= x.nElements()", "/home/bsc18/bsc18186/scratch/parsec/raytrace/src/RTTL/common/RTVecBody.h", 67, __MERCURIUM_PRETTY_FUNCTION__);
        typename ::RTTL::RTVec_t<2, DataType, align>::DataArray &t = *this;
        const ::RTTL::RTData_t<AnotherN, AnotherDataType, AnotherAlign> &xt = x;
        t.assign(xt);
        return *this;
      }
      inline __attribute__((always_inline)) const ::RTTL::RTVec_t<2, DataType, align> &operator =(const ::RTTL::RTVec_t<2, DataType, align> &x)
      {
        typename ::RTTL::RTVec_t<2, DataType, align>::DataArray &t = *this;
        const typename ::RTTL::RTVec_t<2, DataType, align>::DataArray &xt = x;
        t.assign(xt);
        return *this;
      }
      inline __attribute__((always_inline)) const ::RTTL::RTVec_t<2, DataType, align> &operator =(const DataType &x)
      {
        typename ::RTTL::RTVec_t<2, DataType, align>::DataArray &t = *this;
        t.assignDataTypeValue(x);
        return *this;
      }
      inline __attribute__((always_inline)) const ::RTTL::RTVec_t<2, DataType, align> &operator +=(const ::RTTL::RTVec_t<2, DataType, align> &x)
      {
        typename ::RTTL::RTVec_t<2, DataType, align>::DataArray &t = *this;
        t += x;
        return *this;
      }
      inline __attribute__((always_inline)) const ::RTTL::RTVec_t<2, DataType, align> &operator -=(const ::RTTL::RTVec_t<2, DataType, align> &x)
      {
        typename ::RTTL::RTVec_t<2, DataType, align>::DataArray &t = *this;
        t -= x;
        return *this;
      }
      inline __attribute__((always_inline)) const ::RTTL::RTVec_t<2, DataType, align> &operator *=(const ::RTTL::RTVec_t<2, DataType, align> &x)
      {
        typename ::RTTL::RTVec_t<2, DataType, align>::DataArray &t = *this;
        t *= x;
        return *this;
      }
      inline __attribute__((always_inline)) const ::RTTL::RTVec_t<2, DataType, align> &operator /=(const ::RTTL::RTVec_t<2, DataType, align> &x)
      {
        typename ::RTTL::RTVec_t<2, DataType, align>::DataArray &t = *this;
        t /= x;
        return *this;
      }
      inline __attribute__((always_inline)) const ::RTTL::RTVec_t<2, DataType, align> &operator +=(const DataType &q)
      {
        typename ::RTTL::RTVec_t<2, DataType, align>::DataArray &t = *this;
        t += q;
        return *this;
      }
      inline __attribute__((always_inline)) const ::RTTL::RTVec_t<2, DataType, align> &operator -=(const DataType &q)
      {
        typename ::RTTL::RTVec_t<2, DataType, align>::DataArray &t = *this;
        t -= q;
        return *this;
      }
      inline __attribute__((always_inline)) const ::RTTL::RTVec_t<2, DataType, align> &operator *=(const DataType &q)
      {
        typename ::RTTL::RTVec_t<2, DataType, align>::DataArray &t = *this;
        t *= q;
        return *this;
      }
      inline __attribute__((always_inline)) const ::RTTL::RTVec_t<2, DataType, align> &operator /=(const DataType &q)
      {
        typename ::RTTL::RTVec_t<2, DataType, align>::DataArray &t = *this;
        t /= q;
        return *this;
      }
      inline __attribute__((always_inline)) DataType dot(const ::RTTL::RTVec_t<2, DataType, align> &x) const 
      {
        DataType v;
        typename ::RTTL::RTVec_t<2, DataType, align>::DataArray &t = *this;
        const typename ::RTTL::RTVec_t<2, DataType, align>::DataArray &xt = x;
        for (int i = 0; i < 2; i++)
          {
            v += t[i] * xt[i];
          }
        return v;
      }
      inline __attribute__((always_inline)) DataType lengthSquared() const 
      {
        const typename ::RTTL::RTVec_t<2, DataType, align>::DataArray &t = *this;
        DataType v = t[0] * t[0];
        for (int i = 1; i < 2; i++)
          {
            v += t[i] * t[i];
          }
        return v;
      }
      inline __attribute__((always_inline)) DataType length() const 
      {
        return sqrt(lengthSquared());
      }
      inline __attribute__((always_inline)) void normalize()
      {
        DataType q = 1 / length();
        typename ::RTTL::RTVec_t<2, DataType, align>::DataArray &t = *this;
        for (int i = 0; i < 2; i++)
          {
            t[i] *= q;
          }
      }
      inline __attribute__((always_inline)) void setMin(const ::RTTL::RTVec_t<2, DataType, 0> &other)
      {
        typename ::RTTL::RTVec_t<2, DataType, align>::DataArray &t = *this;
        for (int i = 0; i < 2; i++)
          {
            t[i] = min(t[i], other[i]);
          }
      }
      inline __attribute__((always_inline)) void setMin(const DataType &other)
      {
        typename ::RTTL::RTVec_t<2, DataType, align>::DataArray &t = *this;
        for (int i = 0; i < 2; i++)
          {
            t[i] = min(t[i], other);
          }
      }
      inline __attribute__((always_inline)) void setMax(const ::RTTL::RTVec_t<2, DataType, 0> &other)
      {
        typename ::RTTL::RTVec_t<2, DataType, align>::DataArray &t = *this;
        for (int i = 0; i < 2; i++)
          {
            t[i] = max(t[i], other[i]);
          }
      }
      inline __attribute__((always_inline)) void setMax(const DataType &other)
      {
        typename ::RTTL::RTVec_t<2, DataType, align>::DataArray &t = *this;
        for (int i = 0; i < 2; i++)
          {
            t[i] = max(t[i], other);
          }
      }
      static inline __attribute__((always_inline)) DataType epsilon()
      {
        return numeric_limits<DataType>::epsilon();
      }
      static inline __attribute__((always_inline)) DataType minValue()
      {
        return numeric_limits<DataType>::min();
      }
      static inline __attribute__((always_inline)) DataType maxValue()
      {
        return numeric_limits<DataType>::max();
      }
      static inline __attribute__((always_inline)) DataType infinity()
      {
        return numeric_limits<DataType>::infinity();
      }
      inline RTVec_t(const DataType &a, const DataType &b)
        : x(a), y(b)
      {
      }
      inline DataType *data()
      {
        return &x;
      }
      inline const DataType *data() const 
      {
        return &x;
      }
      inline DataType &operator [](int index)
      {
        return data()[index];
      }
      inline DataType operator [](int index) const 
      {
        return data()[index];
      }
      inline operator DataType *()
      {
        return &x;
      }
      inline operator const DataType *() const 
      {
        return &x;
      }
      inline operator typename ::RTTL::RTVec_t<2, DataType, align>::DataArray &()
      {
        return (typename ::RTTL::RTVec_t<2, DataType, align>::DataArray &)x;
      }
      inline operator const typename ::RTTL::RTVec_t<2, DataType, align>::DataArray &() const 
      {
        return (typename ::RTTL::RTVec_t<2, DataType, align>::DataArray &)x;
      }
      inline typename ::RTTL::RTVec_t<2, DataType, align>::DataArray &array()
      {
        return (typename ::RTTL::RTVec_t<2, DataType, align>::DataArray &)x;
      }
      inline const typename ::RTTL::RTVec_t<2, DataType, align>::DataArray &array() const 
      {
        return (typename ::RTTL::RTVec_t<2, DataType, align>::DataArray &)x;
      }
      template < typename CastType >
      inline const CastType &entry(int i  = 0) const 
      {
        return *((const CastType *)data() + i);
      }
      template < typename CastType >
      inline CastType &entry(int i  = 0)
      {
        return *((CastType *)data() + i);
      }
      template < typename CastType >
      inline const CastType *pointer() const 
      {
        return (const CastType *)data();
      }
      template < typename CastType >
      inline CastType *pointer()
      {
        return (CastType *)data();
      }
      inline const DataType &entry(int i  = 0) const 
      {
        return *((const DataType *)data() + i);
      }
      inline DataType &entry(int i  = 0)
      {
        return *((DataType *)data() + i);
      }
      inline const DataType *pointer() const 
      {
        return (const DataType *)data();
      }
      inline DataType *pointer()
      {
        return (DataType *)data();
      }
      inline __attribute__((always_inline)) DataType minimum() const 
      {
        return min(x, y);
      }
      inline __attribute__((always_inline)) DataType maximum() const 
      {
        return max(x, y);
      }
      inline __attribute__((always_inline)) DataType absMinimum() const 
      {
        return min(::abs(x), ::abs(y));
      }
      inline __attribute__((always_inline)) DataType absMaximum() const 
      {
        return max(::abs(x), ::abs(y));
      }
      inline __attribute__((always_inline)) int minIndex() const 
      {
        return y < x ? 1 : 0;
      }
      inline __attribute__((always_inline)) int maxIndex() const 
      {
        return y > x ? 1 : 0;
      }
      inline __attribute__((always_inline)) int minAbsIndex() const 
      {
        return ::abs(y) < ::abs(x) ? 1 : 0;
      }
      inline __attribute__((always_inline)) int maxAbsIndex() const 
      {
        return ::abs(y) > ::abs(x) ? 1 : 0;
      }
      typename ::RTTL::RTData_t<2, DataType, align>::AlignedDataType x;
      DataType y;
  };
  template < typename DataType, int align >
  class  RTVec_t<3, DataType, align>
  {
    public:
      typedef ::RTTL::RTData_t<3, DataType, align> DataArray;
      inline RTVec_t()
      {
      }
      inline explicit RTVec_t(const DataType &v)
      {
        typename ::RTTL::RTVec_t<3, DataType, align>::DataArray &t = *this;
        t.assignDataTypeValue(v);
      }
      template < int AnotherN, typename AnotherDataType, int AnotherAlign >
      inline RTVec_t(const ::RTTL::RTVec_t<AnotherN, AnotherDataType, AnotherAlign> &x)
      {
        typename ::RTTL::RTVec_t<3, DataType, align>::DataArray &t = *this;
        const ::RTTL::RTData_t<AnotherN, AnotherDataType, AnotherAlign> &xt = x;
        t.assign(xt);
      }
      inline RTVec_t(const DataType *x)
      {
        typename ::RTTL::RTVec_t<3, DataType, align>::DataArray &t = *this;
        t.assignDataTypeArray(x);
      }
      static inline int nElements()
      {
        return 3;
      }
      static inline int entrySize()
      {
        return sizeof(DataType);
      }
      static inline int totalSize()
      {
        return 3 * sizeof(DataType);
      }
      template < int AnotherN, typename AnotherDataType, int AnotherAlign >
      inline __attribute__((always_inline)) const ::RTTL::RTVec_t<3, DataType, align> &operator =(const ::RTTL::RTVec_t<AnotherN, AnotherDataType, AnotherAlign> &x)
      {
        const char __MERCURIUM_PRETTY_FUNCTION__[207] = "const ::RTTL::RTVec_t<3, DataType, align> &::RTTL::RTVec_t<3, DataType, align>::template operator =<AnotherN, AnotherDataType, AnotherAlign>(const ::RTTL::RTVec_t<AnotherN, AnotherDataType, AnotherAlign> &)";
        nElements() <= x.nElements() ? static_cast<void>(0) : ::__assert_fail("nElements() <= x.nElements()", "/home/bsc18/bsc18186/scratch/parsec/raytrace/src/RTTL/common/RTVecBody.h", 67, __MERCURIUM_PRETTY_FUNCTION__);
        typename ::RTTL::RTVec_t<3, DataType, align>::DataArray &t = *this;
        const ::RTTL::RTData_t<AnotherN, AnotherDataType, AnotherAlign> &xt = x;
        t.assign(xt);
        return *this;
      }
      inline __attribute__((always_inline)) const ::RTTL::RTVec_t<3, DataType, align> &operator =(const ::RTTL::RTVec_t<3, DataType, align> &x)
      {
        typename ::RTTL::RTVec_t<3, DataType, align>::DataArray &t = *this;
        const typename ::RTTL::RTVec_t<3, DataType, align>::DataArray &xt = x;
        t.assign(xt);
        return *this;
      }
      inline __attribute__((always_inline)) const ::RTTL::RTVec_t<3, DataType, align> &operator =(const DataType &x)
      {
        typename ::RTTL::RTVec_t<3, DataType, align>::DataArray &t = *this;
        t.assignDataTypeValue(x);
        return *this;
      }
      inline __attribute__((always_inline)) const ::RTTL::RTVec_t<3, DataType, align> &operator +=(const ::RTTL::RTVec_t<3, DataType, align> &x)
      {
        typename ::RTTL::RTVec_t<3, DataType, align>::DataArray &t = *this;
        t += x;
        return *this;
      }
      inline __attribute__((always_inline)) const ::RTTL::RTVec_t<3, DataType, align> &operator -=(const ::RTTL::RTVec_t<3, DataType, align> &x)
      {
        typename ::RTTL::RTVec_t<3, DataType, align>::DataArray &t = *this;
        t -= x;
        return *this;
      }
      inline __attribute__((always_inline)) const ::RTTL::RTVec_t<3, DataType, align> &operator *=(const ::RTTL::RTVec_t<3, DataType, align> &x)
      {
        typename ::RTTL::RTVec_t<3, DataType, align>::DataArray &t = *this;
        t *= x;
        return *this;
      }
      inline __attribute__((always_inline)) const ::RTTL::RTVec_t<3, DataType, align> &operator /=(const ::RTTL::RTVec_t<3, DataType, align> &x)
      {
        typename ::RTTL::RTVec_t<3, DataType, align>::DataArray &t = *this;
        t /= x;
        return *this;
      }
      inline __attribute__((always_inline)) const ::RTTL::RTVec_t<3, DataType, align> &operator +=(const DataType &q)
      {
        typename ::RTTL::RTVec_t<3, DataType, align>::DataArray &t = *this;
        t += q;
        return *this;
      }
      inline __attribute__((always_inline)) const ::RTTL::RTVec_t<3, DataType, align> &operator -=(const DataType &q)
      {
        typename ::RTTL::RTVec_t<3, DataType, align>::DataArray &t = *this;
        t -= q;
        return *this;
      }
      inline __attribute__((always_inline)) const ::RTTL::RTVec_t<3, DataType, align> &operator *=(const DataType &q)
      {
        typename ::RTTL::RTVec_t<3, DataType, align>::DataArray &t = *this;
        t *= q;
        return *this;
      }
      inline __attribute__((always_inline)) const ::RTTL::RTVec_t<3, DataType, align> &operator /=(const DataType &q)
      {
        typename ::RTTL::RTVec_t<3, DataType, align>::DataArray &t = *this;
        t /= q;
        return *this;
      }
      inline __attribute__((always_inline)) DataType dot(const ::RTTL::RTVec_t<3, DataType, align> &x) const 
      {
        DataType v;
        typename ::RTTL::RTVec_t<3, DataType, align>::DataArray &t = *this;
        const typename ::RTTL::RTVec_t<3, DataType, align>::DataArray &xt = x;
        for (int i = 0; i < 3; i++)
          {
            v += t[i] * xt[i];
          }
        return v;
      }
      inline __attribute__((always_inline)) DataType lengthSquared() const 
      {
        const typename ::RTTL::RTVec_t<3, DataType, align>::DataArray &t = *this;
        DataType v = t[0] * t[0];
        for (int i = 1; i < 3; i++)
          {
            v += t[i] * t[i];
          }
        return v;
      }
      inline __attribute__((always_inline)) DataType length() const 
      {
        return sqrt(lengthSquared());
      }
      inline __attribute__((always_inline)) void normalize()
      {
        DataType q = 1 / length();
        typename ::RTTL::RTVec_t<3, DataType, align>::DataArray &t = *this;
        for (int i = 0; i < 3; i++)
          {
            t[i] *= q;
          }
      }
      inline __attribute__((always_inline)) void setMin(const ::RTTL::RTVec_t<3, DataType, 0> &other)
      {
        typename ::RTTL::RTVec_t<3, DataType, align>::DataArray &t = *this;
        for (int i = 0; i < 3; i++)
          {
            t[i] = min(t[i], other[i]);
          }
      }
      inline __attribute__((always_inline)) void setMin(const DataType &other)
      {
        typename ::RTTL::RTVec_t<3, DataType, align>::DataArray &t = *this;
        for (int i = 0; i < 3; i++)
          {
            t[i] = min(t[i], other);
          }
      }
      inline __attribute__((always_inline)) void setMax(const ::RTTL::RTVec_t<3, DataType, 0> &other)
      {
        typename ::RTTL::RTVec_t<3, DataType, align>::DataArray &t = *this;
        for (int i = 0; i < 3; i++)
          {
            t[i] = max(t[i], other[i]);
          }
      }
      inline __attribute__((always_inline)) void setMax(const DataType &other)
      {
        typename ::RTTL::RTVec_t<3, DataType, align>::DataArray &t = *this;
        for (int i = 0; i < 3; i++)
          {
            t[i] = max(t[i], other);
          }
      }
      static inline __attribute__((always_inline)) DataType epsilon()
      {
        return numeric_limits<DataType>::epsilon();
      }
      static inline __attribute__((always_inline)) DataType minValue()
      {
        return numeric_limits<DataType>::min();
      }
      static inline __attribute__((always_inline)) DataType maxValue()
      {
        return numeric_limits<DataType>::max();
      }
      static inline __attribute__((always_inline)) DataType infinity()
      {
        return numeric_limits<DataType>::infinity();
      }
      inline RTVec_t(const DataType &a, const DataType &b, const DataType &c)
        : x(a), y(b), z(c)
      {
      }
      inline DataType *data()
      {
        return &x;
      }
      inline const DataType *data() const 
      {
        return &x;
      }
      inline DataType &operator [](int index)
      {
        return data()[index];
      }
      inline DataType operator [](int index) const 
      {
        return data()[index];
      }
      inline operator DataType *()
      {
        return &x;
      }
      inline operator const DataType *() const 
      {
        return &x;
      }
      inline operator typename ::RTTL::RTVec_t<3, DataType, align>::DataArray &()
      {
        return (typename ::RTTL::RTVec_t<3, DataType, align>::DataArray &)x;
      }
      inline operator const typename ::RTTL::RTVec_t<3, DataType, align>::DataArray &() const 
      {
        return (typename ::RTTL::RTVec_t<3, DataType, align>::DataArray &)x;
      }
      inline typename ::RTTL::RTVec_t<3, DataType, align>::DataArray &array()
      {
        return (typename ::RTTL::RTVec_t<3, DataType, align>::DataArray &)x;
      }
      inline const typename ::RTTL::RTVec_t<3, DataType, align>::DataArray &array() const 
      {
        return (typename ::RTTL::RTVec_t<3, DataType, align>::DataArray &)x;
      }
      template < typename CastType >
      inline const CastType &entry(int i  = 0) const 
      {
        return *((const CastType *)data() + i);
      }
      template < typename CastType >
      inline CastType &entry(int i  = 0)
      {
        return *((CastType *)data() + i);
      }
      template < typename CastType >
      inline const CastType *pointer() const 
      {
        return (const CastType *)data();
      }
      template < typename CastType >
      inline CastType *pointer()
      {
        return (CastType *)data();
      }
      inline const DataType &entry(int i  = 0) const 
      {
        return *((const DataType *)data() + i);
      }
      inline DataType &entry(int i  = 0)
      {
        return *((DataType *)data() + i);
      }
      inline const DataType *pointer() const 
      {
        return (const DataType *)data();
      }
      inline DataType *pointer()
      {
        return (DataType *)data();
      }
      inline __attribute__((always_inline)) ::RTTL::RTVec_t<3, DataType, align> cross(const ::RTTL::RTVec_t<3, DataType, align> &r) const 
      {
        return ::RTTL::RTVec_t<3, DataType, align>(y * r.z - z * r.y, z * r.x - x * r.z, x * r.y - y * r.x);
      }
      inline __attribute__((always_inline)) ::RTTL::RTVec_t<3, DataType, align> operator ^(const ::RTTL::RTVec_t<3, DataType, align> &r) const 
      {
        return ::RTTL::RTVec_t<3, DataType, align>(y * r.z - z * r.y, z * r.x - x * r.z, x * r.y - y * r.x);
      }
      inline __attribute__((always_inline)) ::RTTL::RTVec_t<3, DataType, align> normalize() const 
      {
        const DataType oneOverLength = rsqrt(x * x + y * y + z * z);
        return ::RTTL::RTVec_t<3, DataType, align>(x * oneOverLength, y * oneOverLength, z * oneOverLength);
      }
      inline __attribute__((always_inline)) DataType minimum() const 
      {
        return min(min(x, y), z);
      }
      inline __attribute__((always_inline)) DataType maximum() const 
      {
        return max(max(x, y), z);
      }
      inline __attribute__((always_inline)) DataType absMinimum() const 
      {
        return min(min(::abs(x), ::abs(y)), ::abs(z));
      }
      inline __attribute__((always_inline)) DataType absMaximum() const 
      {
        return max(max(::abs(x), ::abs(y)), ::abs(z));
      }
      inline __attribute__((always_inline)) int minIndex() const 
      {
        return y < x ? z < y ? 2 : 1 : z < x ? 2 : 0;
      }
      inline __attribute__((always_inline)) int maxIndex() const 
      {
        return y > x ? z > y ? 2 : 1 : z > x ? 2 : 0;
      }
      inline __attribute__((always_inline)) int minAbsIndex() const 
      {
        return ::abs(y) < ::abs(x) ? ::abs(z) < ::abs(y) ? 2 : 1 : ::abs(z) < ::abs(x) ? 2 : 0;
      }
      inline __attribute__((always_inline)) int maxAbsIndex() const 
      {
        return ::abs(y) > ::abs(x) ? ::abs(z) > ::abs(y) ? 2 : 1 : ::abs(z) > ::abs(x) ? 2 : 0;
      }
      typename ::RTTL::RTData_t<3, DataType, align>::AlignedDataType x;
      DataType y;
      DataType z;
  };
  template < typename DataType, int align >
  class  RTVec_t<4, DataType, align>
  {
    public:
      typedef ::RTTL::RTData_t<4, DataType, align> DataArray;
      inline RTVec_t()
      {
      }
      inline explicit RTVec_t(const DataType &v)
      {
        typename ::RTTL::RTVec_t<4, DataType, align>::DataArray &t = *this;
        t.assignDataTypeValue(v);
      }
      template < int AnotherN, typename AnotherDataType, int AnotherAlign >
      inline RTVec_t(const ::RTTL::RTVec_t<AnotherN, AnotherDataType, AnotherAlign> &x)
      {
        typename ::RTTL::RTVec_t<4, DataType, align>::DataArray &t = *this;
        const ::RTTL::RTData_t<AnotherN, AnotherDataType, AnotherAlign> &xt = x;
        t.assign(xt);
      }
      inline RTVec_t(const DataType *x)
      {
        typename ::RTTL::RTVec_t<4, DataType, align>::DataArray &t = *this;
        t.assignDataTypeArray(x);
      }
      static inline int nElements()
      {
        return 4;
      }
      static inline int entrySize()
      {
        return sizeof(DataType);
      }
      static inline int totalSize()
      {
        return 4 * sizeof(DataType);
      }
      template < int AnotherN, typename AnotherDataType, int AnotherAlign >
      inline __attribute__((always_inline)) const ::RTTL::RTVec_t<4, DataType, align> &operator =(const ::RTTL::RTVec_t<AnotherN, AnotherDataType, AnotherAlign> &x)
      {
        const char __MERCURIUM_PRETTY_FUNCTION__[207] = "const ::RTTL::RTVec_t<4, DataType, align> &::RTTL::RTVec_t<4, DataType, align>::template operator =<AnotherN, AnotherDataType, AnotherAlign>(const ::RTTL::RTVec_t<AnotherN, AnotherDataType, AnotherAlign> &)";
        nElements() <= x.nElements() ? static_cast<void>(0) : ::__assert_fail("nElements() <= x.nElements()", "/home/bsc18/bsc18186/scratch/parsec/raytrace/src/RTTL/common/RTVecBody.h", 67, __MERCURIUM_PRETTY_FUNCTION__);
        typename ::RTTL::RTVec_t<4, DataType, align>::DataArray &t = *this;
        const ::RTTL::RTData_t<AnotherN, AnotherDataType, AnotherAlign> &xt = x;
        t.assign(xt);
        return *this;
      }
      inline __attribute__((always_inline)) const ::RTTL::RTVec_t<4, DataType, align> &operator =(const ::RTTL::RTVec_t<4, DataType, align> &x)
      {
        typename ::RTTL::RTVec_t<4, DataType, align>::DataArray &t = *this;
        const typename ::RTTL::RTVec_t<4, DataType, align>::DataArray &xt = x;
        t.assign(xt);
        return *this;
      }
      inline __attribute__((always_inline)) const ::RTTL::RTVec_t<4, DataType, align> &operator =(const DataType &x)
      {
        typename ::RTTL::RTVec_t<4, DataType, align>::DataArray &t = *this;
        t.assignDataTypeValue(x);
        return *this;
      }
      inline __attribute__((always_inline)) const ::RTTL::RTVec_t<4, DataType, align> &operator +=(const ::RTTL::RTVec_t<4, DataType, align> &x)
      {
        typename ::RTTL::RTVec_t<4, DataType, align>::DataArray &t = *this;
        t += x;
        return *this;
      }
      inline __attribute__((always_inline)) const ::RTTL::RTVec_t<4, DataType, align> &operator -=(const ::RTTL::RTVec_t<4, DataType, align> &x)
      {
        typename ::RTTL::RTVec_t<4, DataType, align>::DataArray &t = *this;
        t -= x;
        return *this;
      }
      inline __attribute__((always_inline)) const ::RTTL::RTVec_t<4, DataType, align> &operator *=(const ::RTTL::RTVec_t<4, DataType, align> &x)
      {
        typename ::RTTL::RTVec_t<4, DataType, align>::DataArray &t = *this;
        t *= x;
        return *this;
      }
      inline __attribute__((always_inline)) const ::RTTL::RTVec_t<4, DataType, align> &operator /=(const ::RTTL::RTVec_t<4, DataType, align> &x)
      {
        typename ::RTTL::RTVec_t<4, DataType, align>::DataArray &t = *this;
        t /= x;
        return *this;
      }
      inline __attribute__((always_inline)) const ::RTTL::RTVec_t<4, DataType, align> &operator +=(const DataType &q)
      {
        typename ::RTTL::RTVec_t<4, DataType, align>::DataArray &t = *this;
        t += q;
        return *this;
      }
      inline __attribute__((always_inline)) const ::RTTL::RTVec_t<4, DataType, align> &operator -=(const DataType &q)
      {
        typename ::RTTL::RTVec_t<4, DataType, align>::DataArray &t = *this;
        t -= q;
        return *this;
      }
      inline __attribute__((always_inline)) const ::RTTL::RTVec_t<4, DataType, align> &operator *=(const DataType &q)
      {
        typename ::RTTL::RTVec_t<4, DataType, align>::DataArray &t = *this;
        t *= q;
        return *this;
      }
      inline __attribute__((always_inline)) const ::RTTL::RTVec_t<4, DataType, align> &operator /=(const DataType &q)
      {
        typename ::RTTL::RTVec_t<4, DataType, align>::DataArray &t = *this;
        t /= q;
        return *this;
      }
      inline __attribute__((always_inline)) DataType dot(const ::RTTL::RTVec_t<4, DataType, align> &x) const 
      {
        DataType v;
        typename ::RTTL::RTVec_t<4, DataType, align>::DataArray &t = *this;
        const typename ::RTTL::RTVec_t<4, DataType, align>::DataArray &xt = x;
        for (int i = 0; i < 4; i++)
          {
            v += t[i] * xt[i];
          }
        return v;
      }
      inline __attribute__((always_inline)) DataType lengthSquared() const 
      {
        const typename ::RTTL::RTVec_t<4, DataType, align>::DataArray &t = *this;
        DataType v = t[0] * t[0];
        for (int i = 1; i < 4; i++)
          {
            v += t[i] * t[i];
          }
        return v;
      }
      inline __attribute__((always_inline)) DataType length() const 
      {
        return sqrt(lengthSquared());
      }
      inline __attribute__((always_inline)) void normalize()
      {
        DataType q = 1 / length();
        typename ::RTTL::RTVec_t<4, DataType, align>::DataArray &t = *this;
        for (int i = 0; i < 4; i++)
          {
            t[i] *= q;
          }
      }
      inline __attribute__((always_inline)) void setMin(const ::RTTL::RTVec_t<4, DataType, 0> &other)
      {
        typename ::RTTL::RTVec_t<4, DataType, align>::DataArray &t = *this;
        for (int i = 0; i < 4; i++)
          {
            t[i] = min(t[i], other[i]);
          }
      }
      inline __attribute__((always_inline)) void setMin(const DataType &other)
      {
        typename ::RTTL::RTVec_t<4, DataType, align>::DataArray &t = *this;
        for (int i = 0; i < 4; i++)
          {
            t[i] = min(t[i], other);
          }
      }
      inline __attribute__((always_inline)) void setMax(const ::RTTL::RTVec_t<4, DataType, 0> &other)
      {
        typename ::RTTL::RTVec_t<4, DataType, align>::DataArray &t = *this;
        for (int i = 0; i < 4; i++)
          {
            t[i] = max(t[i], other[i]);
          }
      }
      inline __attribute__((always_inline)) void setMax(const DataType &other)
      {
        typename ::RTTL::RTVec_t<4, DataType, align>::DataArray &t = *this;
        for (int i = 0; i < 4; i++)
          {
            t[i] = max(t[i], other);
          }
      }
      static inline __attribute__((always_inline)) DataType epsilon()
      {
        return numeric_limits<DataType>::epsilon();
      }
      static inline __attribute__((always_inline)) DataType minValue()
      {
        return numeric_limits<DataType>::min();
      }
      static inline __attribute__((always_inline)) DataType maxValue()
      {
        return numeric_limits<DataType>::max();
      }
      static inline __attribute__((always_inline)) DataType infinity()
      {
        return numeric_limits<DataType>::infinity();
      }
      inline RTVec_t(const DataType &a, const DataType &b, const DataType &c, const DataType &d)
        : x(a), y(b), z(c), w(d)
      {
      }
      inline DataType *data()
      {
        return &x;
      }
      inline const DataType *data() const 
      {
        return &x;
      }
      inline DataType &operator [](int index)
      {
        return data()[index];
      }
      inline DataType operator [](int index) const 
      {
        return data()[index];
      }
      inline operator DataType *()
      {
        return &x;
      }
      inline operator const DataType *() const 
      {
        return &x;
      }
      inline operator typename ::RTTL::RTVec_t<4, DataType, align>::DataArray &()
      {
        return (typename ::RTTL::RTVec_t<4, DataType, align>::DataArray &)x;
      }
      inline operator const typename ::RTTL::RTVec_t<4, DataType, align>::DataArray &() const 
      {
        return (typename ::RTTL::RTVec_t<4, DataType, align>::DataArray &)x;
      }
      inline typename ::RTTL::RTVec_t<4, DataType, align>::DataArray &array()
      {
        return (typename ::RTTL::RTVec_t<4, DataType, align>::DataArray &)x;
      }
      inline const typename ::RTTL::RTVec_t<4, DataType, align>::DataArray &array() const 
      {
        return (typename ::RTTL::RTVec_t<4, DataType, align>::DataArray &)x;
      }
      template < typename CastType >
      inline const CastType &entry(int i  = 0) const 
      {
        return *((const CastType *)data() + i);
      }
      template < typename CastType >
      inline CastType &entry(int i  = 0)
      {
        return *((CastType *)data() + i);
      }
      template < typename CastType >
      inline const CastType *pointer() const 
      {
        return (const CastType *)data();
      }
      template < typename CastType >
      inline CastType *pointer()
      {
        return (CastType *)data();
      }
      inline const DataType &entry(int i  = 0) const 
      {
        return *((const DataType *)data() + i);
      }
      inline DataType &entry(int i  = 0)
      {
        return *((DataType *)data() + i);
      }
      inline const DataType *pointer() const 
      {
        return (const DataType *)data();
      }
      inline DataType *pointer()
      {
        return (DataType *)data();
      }
      inline __attribute__((always_inline)) DataType minimum() const 
      {
        return min(min(x, y), min(z, w));
      }
      inline __attribute__((always_inline)) DataType maximum() const 
      {
        return max(max(x, y), max(z, w));
      }
      inline __attribute__((always_inline)) DataType absMinimum() const 
      {
        return min(min(::abs(x), ::abs(y)), min(::abs(z), ::abs(w)));
      }
      inline __attribute__((always_inline)) DataType absMaximum() const 
      {
        return max(max(::abs(x), ::abs(y)), max(::abs(z), ::abs(w)));
      }
      inline __attribute__((always_inline)) int minIndex() const 
      {
        int i;
        DataType extr = infinity();
        if (x < extr)
          {
            extr = x;
            i = 0;
          }
        if (y < extr)
          {
            extr = y;
            i = 1;
          }
        if (z < extr)
          {
            extr = z;
            i = 2;
          }
        if (w < extr)
          {
            extr = w;
            i = 3;
          }
        return i;
      }
      inline __attribute__((always_inline)) int maxIndex() const 
      {
        int i;
        DataType extr =  -infinity();
        if (x > extr)
          {
            extr = x;
            i = 0;
          }
        if (y > extr)
          {
            extr = y;
            i = 1;
          }
        if (z > extr)
          {
            extr = z;
            i = 2;
          }
        if (w > extr)
          {
            extr = w;
            i = 3;
          }
        return i;
      }
      inline __attribute__((always_inline)) int minAbsIndex() const 
      {
        int i;
        DataType extr = infinity();
        if (::abs(x) < extr)
          {
            extr = ::abs(x);
            i = 0;
          }
        if (::abs(y) < extr)
          {
            extr = ::abs(y);
            i = 1;
          }
        if (::abs(z) < extr)
          {
            extr = ::abs(z);
            i = 2;
          }
        if (::abs(w) < extr)
          {
            extr = ::abs(w);
            i = 3;
          }
        return i;
      }
      inline __attribute__((always_inline)) int maxAbsIndex() const 
      {
        int i;
        DataType extr =  -infinity();
        if (::abs(x) > extr)
          {
            extr = ::abs(x);
            i = 0;
          }
        if (::abs(y) > extr)
          {
            extr = ::abs(y);
            i = 1;
          }
        if (::abs(z) > extr)
          {
            extr = ::abs(z);
            i = 2;
          }
        if (::abs(w) > extr)
          {
            extr = ::abs(w);
            i = 3;
          }
        return i;
      }
      typename ::RTTL::RTData_t<4, DataType, align>::AlignedDataType x;
      DataType y;
      DataType z;
      DataType w;
  };
  template < typename DataType >
  inline DataType nan()__attribute__((always_inline));
  template < typename DataType >
  inline __attribute__((always_inline)) DataType nan()
  {
    return numeric_limits<DataType>::quiet_NaN();
  }
  template < typename DataType >
  inline DataType epsilon()__attribute__((always_inline));
  template < typename DataType >
  inline __attribute__((always_inline)) DataType epsilon()
  {
    return numeric_limits<DataType>::epsilon();
  }
  template < typename DataType >
  inline DataType minValue()__attribute__((always_inline));
  template < typename DataType >
  inline __attribute__((always_inline)) DataType minValue()
  {
    return numeric_limits<DataType>::min();
  }
  template < typename DataType >
  inline DataType maxValue()__attribute__((always_inline));
  template < typename DataType >
  inline __attribute__((always_inline)) DataType maxValue()
  {
    return numeric_limits<DataType>::max();
  }
  template < typename DataType >
  inline DataType infinity()__attribute__((always_inline));
  template < typename DataType >
  inline __attribute__((always_inline)) DataType infinity()
  {
    return numeric_limits<DataType>::infinity();
  }
  template <>
  inline __attribute__((always_inline)) ::sse_f nan< ::sse_f>()
  {
    return ::_mm_set_ps1(::std::numeric_limits<float>::quiet_NaN());
  }
  template <>
  inline __attribute__((always_inline)) ::sse_f epsilon< ::sse_f>()
  {
    return ::_mm_set_ps1(1.192092895507812500000000e-07f);
  }
  template <>
  inline __attribute__((always_inline)) ::sse_f minValue< ::sse_f>()
  {
    return ::_mm_set_ps1(1.175494350822287507968737e-38f);
  }
  template <>
  inline __attribute__((always_inline)) ::sse_f maxValue< ::sse_f>()
  {
    return ::_mm_set_ps1(3.402823466385288598117042e+38f);
  }
  template <>
  inline __attribute__((always_inline)) ::sse_f infinity< ::sse_f>()
  {
    return ::_mm_set_ps1(::std::numeric_limits<float>::infinity());
  }
  template <>
  inline __attribute__((always_inline)) ::sse_i epsilon< ::sse_i>()
  {
    return ::_mm_set1_epi32(0);
  }
  template <>
  inline __attribute__((always_inline)) ::sse_i minValue< ::sse_i>()
  {
    return ::_mm_set1_epi32( -2147483647 - 1);
  }
  template <>
  inline __attribute__((always_inline)) ::sse_i maxValue< ::sse_i>()
  {
    return ::_mm_set1_epi32(2147483647);
  }
  template <>
  inline __attribute__((always_inline)) ::sse_i infinity< ::sse_i>()
  {
    return ::_mm_set1_epi32(::std::numeric_limits<int>::infinity());
  }
  template < int N, typename DataType, int align >
  inline bool operator ==(const ::RTTL::RTVec_t<N, DataType, align> &v1, const ::RTTL::RTVec_t<N, DataType, align> &v2)__attribute__((always_inline));
  template < int N, typename DataType, int align >
  inline __attribute__((always_inline)) bool operator ==(const ::RTTL::RTVec_t<N, DataType, align> &v1, const ::RTTL::RTVec_t<N, DataType, align> &v2)
  {
    return v1.array() == v2.array();
  }
  template < int N, typename DataType, int align >
  inline bool operator ==(const ::RTTL::RTVec_t<N, DataType, align> &v1, const DataType v2[])__attribute__((always_inline));
  template < int N, typename DataType, int align >
  inline __attribute__((always_inline)) bool operator ==(const ::RTTL::RTVec_t<N, DataType, align> &v1, const DataType *v2)
  {
    return v1.array() == v2;
  }
  template < int N, typename DataType, int align >
  inline bool operator ==(const DataType v1[], const ::RTTL::RTVec_t<N, DataType, align> &v2)__attribute__((always_inline));
  template < int N, typename DataType, int align >
  inline __attribute__((always_inline)) bool operator ==(const DataType *v1, const ::RTTL::RTVec_t<N, DataType, align> &v2)
  {
    return v1 == v2.array();
  }
  template < int N, typename DataType, int align >
  inline bool operator ==(const ::RTTL::RTVec_t<N, DataType, align> &v1, DataType v2[])__attribute__((always_inline));
  template < int N, typename DataType, int align >
  inline __attribute__((always_inline)) bool operator ==(const ::RTTL::RTVec_t<N, DataType, align> &v1, DataType *v2)
  {
    return v1.array() == v2;
  }
  template < int N, typename DataType, int align >
  inline bool operator ==(DataType v1[], const ::RTTL::RTVec_t<N, DataType, align> &v2)__attribute__((always_inline));
  template < int N, typename DataType, int align >
  inline __attribute__((always_inline)) bool operator ==(DataType *v1, const ::RTTL::RTVec_t<N, DataType, align> &v2)
  {
    return v1 == v2.array();
  }
  template < int N, typename DataType, int align >
  inline bool operator !=(const ::RTTL::RTVec_t<N, DataType, align> &v1, const ::RTTL::RTVec_t<N, DataType, align> &v2)__attribute__((always_inline));
  template < int N, typename DataType, int align >
  inline __attribute__((always_inline)) bool operator !=(const ::RTTL::RTVec_t<N, DataType, align> &v1, const ::RTTL::RTVec_t<N, DataType, align> &v2)
  {
    return !(v1 == v2);
  }
  template < int N, typename DataType, int align >
  inline bool operator !=(const ::RTTL::RTVec_t<N, DataType, align> &v1, const DataType v2[])__attribute__((always_inline));
  template < int N, typename DataType, int align >
  inline __attribute__((always_inline)) bool operator !=(const ::RTTL::RTVec_t<N, DataType, align> &v1, const DataType *v2)
  {
    return !(v1 == v2);
  }
  template < int N, typename DataType, int align >
  inline bool operator !=(const DataType v1[], const ::RTTL::RTVec_t<N, DataType, align> &v2)__attribute__((always_inline));
  template < int N, typename DataType, int align >
  inline __attribute__((always_inline)) bool operator !=(const DataType *v1, const ::RTTL::RTVec_t<N, DataType, align> &v2)
  {
    return !(v1 == v2);
  }
  template < int N, typename DataType, int align >
  inline bool operator !=(const ::RTTL::RTVec_t<N, DataType, align> &v1, DataType v2[])__attribute__((always_inline));
  template < int N, typename DataType, int align >
  inline __attribute__((always_inline)) bool operator !=(const ::RTTL::RTVec_t<N, DataType, align> &v1, DataType *v2)
  {
    return !(v1 == v2);
  }
  template < int N, typename DataType, int align >
  inline bool operator !=(DataType v1[], const ::RTTL::RTVec_t<N, DataType, align> &v2)__attribute__((always_inline));
  template < int N, typename DataType, int align >
  inline __attribute__((always_inline)) bool operator !=(DataType *v1, const ::RTTL::RTVec_t<N, DataType, align> &v2)
  {
    return !(v1 == v2);
  }
  template < int N, typename DataType, int align >
  inline ::RTTL::RTVec_t<N, DataType, align> operator +(const ::RTTL::RTVec_t<N, DataType, align> &a, const ::RTTL::RTVec_t<N, DataType, align> &b)__attribute__((always_inline));
  template < int N, typename DataType, int align >
  inline __attribute__((always_inline)) ::RTTL::RTVec_t<N, DataType, align> operator +(const ::RTTL::RTVec_t<N, DataType, align> &a, const ::RTTL::RTVec_t<N, DataType, align> &b)
  {
    ::RTTL::RTVec_t<N, DataType, align> result;
    result.array().add(a.array(), b.array());
    return result;
  }
  template < int N, typename DataType, int align >
  inline ::RTTL::RTVec_t<N, DataType, align> operator -(const ::RTTL::RTVec_t<N, DataType, align> &a, const ::RTTL::RTVec_t<N, DataType, align> &b)__attribute__((always_inline));
  template < int N, typename DataType, int align >
  inline __attribute__((always_inline)) ::RTTL::RTVec_t<N, DataType, align> operator -(const ::RTTL::RTVec_t<N, DataType, align> &a, const ::RTTL::RTVec_t<N, DataType, align> &b)
  {
    ::RTTL::RTVec_t<N, DataType, align> result;
    result.array().subtract(a.array(), b.array());
    return result;
  }
  template < int N, typename DataType, int align >
  inline ::RTTL::RTVec_t<N, DataType, align> operator *(const ::RTTL::RTVec_t<N, DataType, align> &a, const ::RTTL::RTVec_t<N, DataType, align> &b)__attribute__((always_inline));
  template < int N, typename DataType, int align >
  inline __attribute__((always_inline)) ::RTTL::RTVec_t<N, DataType, align> operator *(const ::RTTL::RTVec_t<N, DataType, align> &a, const ::RTTL::RTVec_t<N, DataType, align> &b)
  {
    ::RTTL::RTVec_t<N, DataType, align> result;
    result.array().multiply(a.array(), b.array());
    return result;
  }
  template < int N, typename DataType, int align >
  inline ::RTTL::RTVec_t<N, DataType, align> operator /(const ::RTTL::RTVec_t<N, DataType, align> &a, const ::RTTL::RTVec_t<N, DataType, align> &b)__attribute__((always_inline));
  template < int N, typename DataType, int align >
  inline __attribute__((always_inline)) ::RTTL::RTVec_t<N, DataType, align> operator /(const ::RTTL::RTVec_t<N, DataType, align> &a, const ::RTTL::RTVec_t<N, DataType, align> &b)
  {
    ::RTTL::RTVec_t<N, DataType, align> result;
    result.array().divide(a.array(), b.array());
    return result;
  }
  template < int N, typename DataType, int align >
  inline DataType dot(const ::RTTL::RTVec_t<N, DataType, align> &x, const ::RTTL::RTVec_t<N, DataType, align> &y)__attribute__((always_inline));
  template < int N, typename DataType, int align >
  inline __attribute__((always_inline)) DataType dot(const ::RTTL::RTVec_t<N, DataType, align> &x, const ::RTTL::RTVec_t<N, DataType, align> &y)
  {
    DataType v;
    for (int i = 0; i < N; i++)
      {
        v += x[i] * y[i];
      }
    return v;
  }
  template < int N, typename DataType, int align >
  inline ::RTTL::RTVec_t<N, DataType, align> operator -(const ::RTTL::RTVec_t<N, DataType, align> &a)__attribute__((always_inline));
  template < int N, typename DataType, int align >
  inline __attribute__((always_inline)) ::RTTL::RTVec_t<N, DataType, align> operator -(const ::RTTL::RTVec_t<N, DataType, align> &a)
  {
    ::RTTL::RTVec_t<N, DataType, align> result;
    for (int i = 0; i < N; i++)
      {
        result[i] =  -a[i];
      }
    return result;
  }
  template < int N, typename DataType, int align >
  inline bool operator ==(const ::RTTL::RTVec_t<N, DataType, align> &v1, const DataType &v2)__attribute__((always_inline));
  template < int N, typename DataType, int align >
  inline __attribute__((always_inline)) bool operator ==(const ::RTTL::RTVec_t<N, DataType, align> &v1, const DataType &v2)
  {
    return v1.array() == v2;
  }
  template < int N, typename DataType, int align >
  inline bool operator ==(const DataType &v1, const ::RTTL::RTVec_t<N, DataType, align> &v2)__attribute__((always_inline));
  template < int N, typename DataType, int align >
  inline __attribute__((always_inline)) bool operator ==(const DataType &v1, const ::RTTL::RTVec_t<N, DataType, align> &v2)
  {
    return v1 == v2.array();
  }
  template < int N, typename DataType, int align >
  inline bool operator !=(const ::RTTL::RTVec_t<N, DataType, align> &v1, const DataType &v2)__attribute__((always_inline));
  template < int N, typename DataType, int align >
  inline __attribute__((always_inline)) bool operator !=(const ::RTTL::RTVec_t<N, DataType, align> &v1, const DataType &v2)
  {
    return !(v1 == v2);
  }
  template < int N, typename DataType, int align >
  inline bool operator !=(const DataType &v1, const ::RTTL::RTVec_t<N, DataType, align> &v2)__attribute__((always_inline));
  template < int N, typename DataType, int align >
  inline __attribute__((always_inline)) bool operator !=(const DataType &v1, const ::RTTL::RTVec_t<N, DataType, align> &v2)
  {
    return !(v1 == v2);
  }
  template < int N, typename DataType, int align, typename ScalarType >
  inline ::RTTL::RTVec_t<N, DataType, align> operator +(const ::RTTL::RTVec_t<N, DataType, align> &a, const ScalarType &b)__attribute__((always_inline));
  template < int N, typename DataType, int align, typename ScalarType >
  inline __attribute__((always_inline)) ::RTTL::RTVec_t<N, DataType, align> operator +(const ::RTTL::RTVec_t<N, DataType, align> &a, const ScalarType &b)
  {
    ::RTTL::RTVec_t<N, DataType, align> result;
    result.array().addScalar(a.array(), b);
    return result;
  }
  template < int N, typename DataType, int align, typename ScalarType >
  inline ::RTTL::RTVec_t<N, DataType, align> operator +(const ScalarType &b, const ::RTTL::RTVec_t<N, DataType, align> &a)__attribute__((always_inline));
  template < int N, typename DataType, int align, typename ScalarType >
  inline __attribute__((always_inline)) ::RTTL::RTVec_t<N, DataType, align> operator +(const ScalarType &b, const ::RTTL::RTVec_t<N, DataType, align> &a)
  {
    ::RTTL::RTVec_t<N, DataType, align> result;
    result.array().addScalar(b.array(), a);
    return result;
  }
  template < int N, typename DataType, int align, typename ScalarType >
  inline ::RTTL::RTVec_t<N, DataType, align> operator -(const ::RTTL::RTVec_t<N, DataType, align> &a, const ScalarType &b)__attribute__((always_inline));
  template < int N, typename DataType, int align, typename ScalarType >
  inline __attribute__((always_inline)) ::RTTL::RTVec_t<N, DataType, align> operator -(const ::RTTL::RTVec_t<N, DataType, align> &a, const ScalarType &b)
  {
    ::RTTL::RTVec_t<N, DataType, align> result;
    result.array().subtractScalar(a.array(), b);
    return result;
  }
  template < int N, typename DataType, int align, typename ScalarType >
  inline ::RTTL::RTVec_t<N, DataType, align> operator -(const ScalarType &b, const ::RTTL::RTVec_t<N, DataType, align> &a)__attribute__((always_inline));
  template < int N, typename DataType, int align, typename ScalarType >
  inline __attribute__((always_inline)) ::RTTL::RTVec_t<N, DataType, align> operator -(const ScalarType &b, const ::RTTL::RTVec_t<N, DataType, align> &a)
  {
    ::RTTL::RTVec_t<N, DataType, align> result;
    result.array().subtractScalar(b, a.array());
    return result;
  }
  template < int N, typename DataType, int align, typename ScalarType >
  inline ::RTTL::RTVec_t<N, DataType, align> operator *(const ::RTTL::RTVec_t<N, DataType, align> &a, const ScalarType &b)__attribute__((always_inline));
  template < int N, typename DataType, int align, typename ScalarType >
  inline __attribute__((always_inline)) ::RTTL::RTVec_t<N, DataType, align> operator *(const ::RTTL::RTVec_t<N, DataType, align> &a, const ScalarType &b)
  {
    ::RTTL::RTVec_t<N, DataType, align> result;
    result.array().multiplyScalar(a.array(), b);
    return result;
  }
  template < int N, typename DataType, int align, typename ScalarType >
  inline ::RTTL::RTVec_t<N, DataType, align> operator *(const ScalarType &b, const ::RTTL::RTVec_t<N, DataType, align> &a)__attribute__((always_inline));
  template < int N, typename DataType, int align, typename ScalarType >
  inline __attribute__((always_inline)) ::RTTL::RTVec_t<N, DataType, align> operator *(const ScalarType &b, const ::RTTL::RTVec_t<N, DataType, align> &a)
  {
    ::RTTL::RTVec_t<N, DataType, align> result;
    result.array().multiplyScalar(a.array(), b);
    return result;
  }
  template < int N, typename DataType, int align, typename ScalarType >
  inline ::RTTL::RTVec_t<N, DataType, align> operator /(const ::RTTL::RTVec_t<N, DataType, align> &a, const ScalarType &b)__attribute__((always_inline));
  template < int N, typename DataType, int align, typename ScalarType >
  inline __attribute__((always_inline)) ::RTTL::RTVec_t<N, DataType, align> operator /(const ::RTTL::RTVec_t<N, DataType, align> &a, const ScalarType &b)
  {
    ::RTTL::RTVec_t<N, DataType, align> result;
    result.array().divideScalar(a.array(), b);
    return result;
  }
  template < int N, typename DataType, int align, typename ScalarType >
  inline ::RTTL::RTVec_t<N, DataType, align> operator /(const ScalarType &b, const ::RTTL::RTVec_t<N, DataType, align> &a)__attribute__((always_inline));
  template < int N, typename DataType, int align, typename ScalarType >
  inline __attribute__((always_inline)) ::RTTL::RTVec_t<N, DataType, align> operator /(const ScalarType &b, const ::RTTL::RTVec_t<N, DataType, align> &a)
  {
    ::RTTL::RTVec_t<N, DataType, align> result;
    result.array().divideScalar(b, a.array());
    return result;
  }
  template < int N, typename DataType, int align >
  inline ::std::ostream &operator <<(::std::ostream &out, const ::RTTL::RTVec_t<N, DataType, align> &t)__attribute__((always_inline));
  template < int N, typename DataType, int align >
  inline __attribute__((always_inline)) ::std::ostream &operator <<(::std::ostream &out, const ::RTTL::RTVec_t<N, DataType, align> &t)
  {
    out << "[" << t[0];
    for (int i = 1; i < N; i++)
      {
        out << "," << t[i];
      }
    out << "]";
    return out;
  }
  typedef ::RTTL::RTVec_t<2, float, 0> RTVec2f;
  typedef ::RTTL::RTVec_t<3, float, 0> RTVec3f;
  typedef ::RTTL::RTVec_t<4, float, 0> RTVec4f;
  typedef ::RTTL::RTVec_t<2, int, 0> RTVec2i;
  typedef ::RTTL::RTVec_t<3, int, 0> RTVec3i;
  typedef ::RTTL::RTVec_t<4, int, 0> RTVec4i;
  inline __attribute__((always_inline)) int maxDim3(const ::sse_f t)
  {
    return (*((::RTTL::RTVec3f *)&t)).::RTTL::RTVec_t<3, float, 0>::maxIndex();
  }
  inline __attribute__((always_inline)) ::sse_f vec3fToSSE(const ::RTTL::RTVec3f &v, const float w  = 0.000000000000000000000000e+00f)
  {
    return ::_mm_setr_ps(v.x, v.y, v.z, w);
  }
  class  Matrix4x4
  {
    public:
      float mat[4][4];
      inline __attribute__((always_inline)) float &operator ()(const int i, const int j)
      {
        return (*this).mat[i][j];
      }
      inline __attribute__((always_inline)) ::RTTL::RTVec4f getRow(int row)
      {
        ::RTTL::RTVec4f r;
        r.::RTTL::RTVec_t<4, float, 0>::operator [](0) = (*this).mat[row][0];
        r.::RTTL::RTVec_t<4, float, 0>::operator [](1) = (*this).mat[row][1];
        r.::RTTL::RTVec_t<4, float, 0>::operator [](2) = (*this).mat[row][2];
        r.::RTTL::RTVec_t<4, float, 0>::operator [](3) = (*this).mat[row][3];
        return r;
      }
      inline __attribute__((always_inline)) ::RTTL::RTVec3f getCol(int col)
      {
        ::RTTL::RTVec3f r;
        r.::RTTL::RTVec_t<3, float, 0>::operator [](0) = (*this).mat[0][col];
        r.::RTTL::RTVec_t<3, float, 0>::operator [](1) = (*this).mat[1][col];
        r.::RTTL::RTVec_t<3, float, 0>::operator [](2) = (*this).mat[2][col];
        return r;
      }
      inline __attribute__((always_inline)) void setCol(int col, const ::RTTL::RTVec3f &r)
      {
        (*this).mat[0][col] = r.::RTTL::RTVec_t<3, float, 0>::operator [](0);
        (*this).mat[1][col] = r.::RTTL::RTVec_t<3, float, 0>::operator [](1);
        (*this).mat[2][col] = r.::RTTL::RTVec_t<3, float, 0>::operator [](2);
      }
      inline __attribute__((always_inline)) void setIdentity()
      {
        for (int i = 0; i < 4; i++)
          {
            for (int j = 0; j < 4; j++)
              {
                (*this).mat[i][j] = i == j;
              }
          }
      }
      inline __attribute__((always_inline)) void setTranslationPart(const ::RTTL::RTVec3f &translation)
      {
        (*this).mat[0][3] = translation.::RTTL::RTVec_t<3, float, 0>::operator [](0);
        (*this).mat[1][3] = translation.::RTTL::RTVec_t<3, float, 0>::operator [](1);
        (*this).mat[2][3] = translation.::RTTL::RTVec_t<3, float, 0>::operator [](2);
      }
      inline __attribute__((always_inline)) void setRotationPart(const ::RTTL::RTVec3f &axis, const float angle)
      {
        ::RTTL::RTVec4f q;
        float ha(5.000000000000000000000000e-01f * angle * 3.14159265358979311599796346854418516159057617187500000e+00 / 1.800000000000000000000000e+02f);
        float sine(::sinf(ha));
        q.::RTTL::RTVec_t<4, float, 0>::operator [](3) = ::cosf(ha);
        q.::RTTL::RTVec_t<4, float, 0>::operator [](0) = sine * axis.::RTTL::RTVec_t<3, float, 0>::operator [](0);
        q.::RTTL::RTVec_t<4, float, 0>::operator [](1) = sine * axis.::RTTL::RTVec_t<3, float, 0>::operator [](1);
        q.::RTTL::RTVec_t<4, float, 0>::operator [](2) = sine * axis.::RTTL::RTVec_t<3, float, 0>::operator [](2);
        float tx(2.00000000000000000000000000000000000000000000000000000e+00 * q.::RTTL::RTVec_t<4, float, 0>::operator [](0));
        float ty(2.00000000000000000000000000000000000000000000000000000e+00 * q.::RTTL::RTVec_t<4, float, 0>::operator [](1));
        float tz(2.00000000000000000000000000000000000000000000000000000e+00 * q.::RTTL::RTVec_t<4, float, 0>::operator [](2));
        float twx(tx * q.::RTTL::RTVec_t<4, float, 0>::operator [](3));
        float twy(ty * q.::RTTL::RTVec_t<4, float, 0>::operator [](3));
        float twz(tz * q.::RTTL::RTVec_t<4, float, 0>::operator [](3));
        float txx(tx * q.::RTTL::RTVec_t<4, float, 0>::operator [](0));
        float txy(ty * q.::RTTL::RTVec_t<4, float, 0>::operator [](0));
        float txz(tz * q.::RTTL::RTVec_t<4, float, 0>::operator [](0));
        float tyy(ty * q.::RTTL::RTVec_t<4, float, 0>::operator [](1));
        float tyz(tz * q.::RTTL::RTVec_t<4, float, 0>::operator [](1));
        float tzz(tz * q.::RTTL::RTVec_t<4, float, 0>::operator [](2));
        (*this).mat[0][0] = 1.00000000000000000000000000000000000000000000000000000e+00 - (tyy + tzz);
        (*this).mat[0][1] = txy - twz;
        (*this).mat[0][2] = txz + twy;
        (*this).mat[1][0] = txy + twz;
        (*this).mat[1][1] = 1.00000000000000000000000000000000000000000000000000000e+00 - (txx + tzz);
        (*this).mat[1][2] = tyz - twx;
        (*this).mat[2][0] = txz - twy;
        (*this).mat[2][1] = tyz + twx;
        (*this).mat[2][2] = 1.00000000000000000000000000000000000000000000000000000e+00 - (txx + tyy);
      }
  };
  inline __attribute__((always_inline)) ::RTTL::Matrix4x4 operator *(::RTTL::Matrix4x4 &a, ::RTTL::Matrix4x4 &b)
  {
    ::RTTL::Matrix4x4 res;
    for (int i = 0; i < 4; i++)
      {
        for (int j = 0; j < 4; j++)
          {
            res.::RTTL::Matrix4x4::operator ()(i, j) = 0;
            for (int k = 0; k < 4; k++)
              {
                res.::RTTL::Matrix4x4::operator ()(i, j) += a.::RTTL::Matrix4x4::operator ()(i, k) * b.::RTTL::Matrix4x4::operator ()(k, j);
              }
          }
      }
    return res;
  }
  template < int N, typename DataType, int align = 0 >
  class  RTBox_t
  {
    public:
      typedef ::RTTL::RTVec_t<N, DataType, align> RTVec;
      inline RTBox_t()
      {
      }
      inline RTBox_t(const typename ::RTTL::RTBox_t<N, DataType, align>::RTVec &cmin, const typename ::RTTL::RTBox_t<N, DataType, align>::RTVec &cmax)
        : m_min(cmin), m_max(cmax)
      {
      }
      inline RTBox_t(const typename ::RTTL::RTBox_t<N, DataType, align>::RTVec *pts, int npts)
      {
        set(pts[0]);
        for (int i = 1; i < npts; i++)
          {
            extend(pts[i]);
          }
      }
      inline RTBox_t(const typename ::RTTL::RTBox_t<N, DataType, align>::RTVec &pt1, const typename ::RTTL::RTBox_t<N, DataType, align>::RTVec &pt2, const typename ::RTTL::RTBox_t<N, DataType, align>::RTVec &pt3)
      {
        set(pt1);
        extend(pt2);
        extend(pt3);
      }
      inline RTBox_t(const ::RTTL::RTBox_t<N, DataType, align> &b)
        : m_min(b.m_min), m_max(b.m_max)
      {
      }
      inline void reset()__attribute__((always_inline));
      inline __attribute__((always_inline)) void setEmpty()
      {
        reset();
      }
      inline __attribute__((always_inline)) DataType maxSide() const 
      {
        return (m_max - m_min).maximum();
      }
      inline __attribute__((always_inline)) DataType minSide() const 
      {
        return (m_max - m_min).minimum();
      }
      inline __attribute__((always_inline)) int maxIndex() const 
      {
        return (m_max - m_min).maxIndex();
      }
      inline __attribute__((always_inline)) int minIndex() const 
      {
        return (m_max - m_min).minIndex();
      }
      inline __attribute__((always_inline)) int flat() const 
      {
        for (int i = 0; i < N; i++)
          {
            if (m_min[i] == m_max[i])
              {
                return i;
              }
          }
        return  -1;
      }
      inline __attribute__((always_inline)) bool isValid() const 
      {
        return m_max >= m_min;
      }
      inline __attribute__((always_inline)) DataType volume() const 
      {
        DataType v = 1;
        for (int i = 0; i < N; i++)
          {
            v *= m_max[i] - m_min[i];
          }
        return v;
      }
      inline __attribute__((always_inline)) DataType area() const 
      {
        DataType a = (m_max[0] - m_min[0]) * (m_max[1] - m_min[1]);
        if (N >= 3)
          {
            a = 2 * (a + (m_max[0] - m_min[0]) * (m_max[2] - m_min[2]) + (m_max[1] - m_min[1]) * (m_max[2] - m_min[2]));
          }
        return a;
      }
      inline __attribute__((always_inline)) void set(const typename ::RTTL::RTBox_t<N, DataType, align>::RTVec &v)
      {
        m_min = v;
        m_max = v;
      }
      inline __attribute__((always_inline)) void extend(const typename ::RTTL::RTBox_t<N, DataType, align>::RTVec *pts, int npts)
      {
        for (int i = 0; i < npts; i++)
          {
            extend(pts[i]);
          }
      }
      inline __attribute__((always_inline)) void around(const typename ::RTTL::RTBox_t<N, DataType, align>::RTVec *pts, int npts)
      {
        const char __MERCURIUM_PRETTY_FUNCTION__[115] = "void ::RTTL::RTBox_t<N, DataType, align>::around(const typename ::RTTL::RTBox_t<N, DataType, align>::RTVec *, int)";
        npts >= 1 ? static_cast<void>(0) : ::__assert_fail("npts >= 1", "/home/bsc18/bsc18186/scratch/parsec/raytrace/src/RTTL/common/RTBox.hxx", 90, __MERCURIUM_PRETTY_FUNCTION__);
        set(pts[0]);
        extend(pts + 1, npts - 1);
      }
      inline __attribute__((always_inline)) void extend(const typename ::RTTL::RTBox_t<N, DataType, align>::RTVec &v)
      {
        m_min.setMin(v);
        m_max.setMax(v);
      }
      inline __attribute__((always_inline)) void extend(const ::RTTL::RTBox_t<N, DataType, align> &b)
      {
        m_min.setMin(b.m_min);
        m_max.setMax(b.m_max);
      }
      inline __attribute__((always_inline)) void extend(const DataType &v)
      {
        m_min.setMin(v);
        m_max.setMax(v);
      }
      inline __attribute__((always_inline)) ::RTTL::RTBox_t<N, DataType, align> intersection(const ::RTTL::RTBox_t<N, DataType, align> &b) const 
      {
        return *this - b;
      }
      inline __attribute__((always_inline)) ::RTTL::RTBox_t<N, DataType, align> clip(const ::RTTL::RTBox_t<N, DataType, align> &b) const 
      {
        return *this - b;
      }
      inline __attribute__((always_inline)) bool intersect(const ::RTTL::RTBox_t<N, DataType, align> &b) const 
      {
        return intersection(b).isValid();
      }
      inline __attribute__((always_inline)) bool enclose(const typename ::RTTL::RTBox_t<N, DataType, align>::RTVec &v) const 
      {
        return v >= m_min && v <= m_max;
      }
      inline __attribute__((always_inline)) bool encloseAny(const typename ::RTTL::RTBox_t<N, DataType, align>::RTVec *pts, int npts) const 
      {
        for (int i = 0; i < npts; i++)
          {
            if (enclose(pts[i]))
              {
                return true;
              }
          }
        return false;
      }
      inline __attribute__((always_inline)) bool encloseAll(const typename ::RTTL::RTBox_t<N, DataType, align>::RTVec *pts, int npts) const 
      {
        for (int i = 0; i < npts; i++)
          {
            if (!enclose(pts[i]))
              {
                return false;
              }
          }
        return true;
      }
      inline __attribute__((always_inline)) bool isStrictlyEnclose(const typename ::RTTL::RTBox_t<N, DataType, align>::RTVec &v) const 
      {
        return v > m_min && v < m_max;
      }
      inline __attribute__((always_inline)) bool isStrictlyEnclose(const typename ::RTTL::RTBox_t<N, DataType, align>::RTVec &v, DataType off) const 
      {
        typename ::RTTL::RTBox_t<N, DataType, align>::RTVec shift(off);
        return v > m_min + shift && v < m_max - shift;
      }
      inline __attribute__((always_inline)) bool isInside(const ::RTTL::RTBox_t<N, DataType, align> &b) const 
      {
        return m_min >= b.m_min && m_max <= b.m_max;
      }
      inline __attribute__((always_inline)) bool isStrictlyInside(const ::RTTL::RTBox_t<N, DataType, align> &b) const 
      {
        return m_min > b.m_min && m_max < b.m_max;
      }
      inline __attribute__((always_inline)) bool isStrictlyInside(const ::RTTL::RTBox_t<N, DataType, align> &b, DataType off) const 
      {
        typename ::RTTL::RTBox_t<N, DataType, align>::RTVec shift(off);
        return m_min > b.m_min - shift && m_max < b.m_max + shift;
      }
      inline __attribute__((always_inline)) void enlarge(DataType f)
      {
        m_max += f;
        m_min -= f;
      }
      inline __attribute__((always_inline)) typename ::RTTL::RTBox_t<N, DataType, align>::RTVec sides() const 
      {
        return m_max - m_min;
      }
      inline __attribute__((always_inline)) typename ::RTTL::RTBox_t<N, DataType, align>::RTVec diameter() const 
      {
        return m_max - m_min;
      }
      inline __attribute__((always_inline)) typename ::RTTL::RTBox_t<N, DataType, align>::RTVec center() const 
      {
        return 5.000000000000000000000000e-01f * (m_max + m_min);
      }
      inline __attribute__((always_inline)) bool operator ==(const ::RTTL::RTBox_t<N, DataType, align> &b) const 
      {
        return m_min == b.m_min && m_max == b.m_max;
      }
      inline __attribute__((always_inline)) bool operator !=(const ::RTTL::RTBox_t<N, DataType, align> &b) const 
      {
        return m_min != b.m_min || m_max != b.m_max;
      }
      inline __attribute__((always_inline)) const typename ::RTTL::RTBox_t<N, DataType, align>::RTVec &operator [](const int i) const 
      {
        const char __MERCURIUM_PRETTY_FUNCTION__[126] = "const typename ::RTTL::RTBox_t<N, DataType, align>::RTVec &::RTTL::RTBox_t<N, DataType, align>::operator [](const int) const ";
        i >= 0 && i < 2 ? static_cast<void>(0) : ::__assert_fail("i >= 0 && i < 2", "/home/bsc18/bsc18186/scratch/parsec/raytrace/src/RTTL/common/RTBox.hxx", 188, __MERCURIUM_PRETTY_FUNCTION__);
        return *(&m_min + i);
      }
      inline __attribute__((always_inline)) typename ::RTTL::RTBox_t<N, DataType, align>::RTVec &operator [](const int i)
      {
        const char __MERCURIUM_PRETTY_FUNCTION__[113] = "typename ::RTTL::RTBox_t<N, DataType, align>::RTVec &::RTTL::RTBox_t<N, DataType, align>::operator [](const int)";
        i >= 0 && i < 2 ? static_cast<void>(0) : ::__assert_fail("i >= 0 && i < 2", "/home/bsc18/bsc18186/scratch/parsec/raytrace/src/RTTL/common/RTBox.hxx", 193, __MERCURIUM_PRETTY_FUNCTION__);
        return *(&m_min + i);
      }
      inline __attribute__((always_inline)) const ::RTTL::RTBox_t<N, DataType, align> &operator =(const ::RTTL::RTBox_t<N, DataType, align> &b)
      {
        m_min = b.m_min;
        m_max = b.m_max;
        return *this;
      }
      inline __attribute__((always_inline)) ::RTTL::RTBox_t<N, DataType, align> operator +(const ::RTTL::RTBox_t<N, DataType, align> &b) const 
      {
        ::RTTL::RTBox_t<N, DataType, align> r = *this;
        r.m_min.setMin(b.m_min);
        r.m_max.setMax(b.m_max);
        return r;
      }
      inline __attribute__((always_inline)) ::RTTL::RTBox_t<N, DataType, align> operator -(const ::RTTL::RTBox_t<N, DataType, align> &b) const 
      {
        ::RTTL::RTBox_t<N, DataType, align> r = *this;
        r.m_min.setMax(b.m_min);
        r.m_max.setMin(b.m_max);
        return r;
      }
      inline __attribute__((always_inline)) ::RTTL::RTBox_t<N, DataType, align> operator *(DataType f) const 
      {
        return ::RTTL::RTBox_t<N, DataType, align>(m_min * f, m_max * f);
      }
      inline __attribute__((always_inline)) void operator +=(const ::RTTL::RTBox_t<N, DataType, align> &b)
      {
        extend(b);
      }
      inline __attribute__((always_inline)) void operator -=(const ::RTTL::RTBox_t<N, DataType, align> &b)
      {
        m_min.setMax(b.m_min);
        m_max.setMin(b.m_max);
      }
      inline __attribute__((always_inline)) const ::RTTL::RTBox_t<N, DataType, align> &operator *=(DataType f)
      {
        m_min *= f;
        m_max *= f;
        return *this;
      }
      inline __attribute__((always_inline)) const ::RTTL::RTBox_t<N, DataType, align> &operator /=(DataType f)
      {
        m_min /= f;
        m_max /= f;
        return *this;
      }
      inline __attribute__((always_inline)) const ::RTTL::RTBox_t<N, DataType, align> &operator %=(DataType f)
      {
        m_min %= f;
        m_max %= f;
        return *this;
      }
      typename ::RTTL::RTBox_t<N, DataType, align>::RTVec m_min;
      typename ::RTTL::RTBox_t<N, DataType, align>::RTVec m_max;
  };
  template < int N, typename DataType, int align >
  inline __attribute__((always_inline)) void RTBox_t<N, DataType, align>::reset()
  {
    m_min = ::RTTL::RTVec_t<N, DataType, align>(RTVec_t<N, DataType, align>::infinity());
    m_max = ::RTTL::RTVec_t<N, DataType, align>( -RTVec_t<N, DataType, align>::infinity());
  }
  template <>
  inline __attribute__((always_inline)) void RTBox_t<1, ::sse_f, 0>::reset()
  {
    (*this).m_min = ::_mm_set_ps1( +3.402823466385288598117042e+38f);
    (*this).m_max = ::_mm_set_ps1( -3.402823466385288598117042e+38f);
  }
  template < int N, typename DataType, int align >
  inline ::RTTL::RTBox_t<N, DataType, align> operator *(DataType f, const ::RTTL::RTBox_t<N, DataType, align> &q)__attribute__((always_inline));
  template < int N, typename DataType, int align >
  inline __attribute__((always_inline)) ::RTTL::RTBox_t<N, DataType, align> operator *(DataType f, const ::RTTL::RTBox_t<N, DataType, align> &q)
  {
    return q * f;
  }
  template < int N, typename DataType, int align >
  inline ::std::ostream &operator <<(::std::ostream &out, const ::RTTL::RTBox_t<N, DataType, align> &b)__attribute__((always_inline));
  template < int N, typename DataType, int align >
  inline __attribute__((always_inline)) ::std::ostream &operator <<(::std::ostream &out, const ::RTTL::RTBox_t<N, DataType, align> &b)
  {
    out << "[" << b.m_min << "," << b.m_max << "]";
    return out;
  }
  class  RTBox3a : public ::RTTL::RTBox_t<1, ::sse_f, 0>
  {
    public:
      inline __attribute__((always_inline)) ::sse_f center() const 
      {
        return *(*this).::RTTL::RTBox_t<1, ::sse_f, 0>::center();
      }
      inline __attribute__((always_inline)) ::sse_f diameter() const 
      {
        return *(*this).::RTTL::RTBox_t<1, ::sse_f, 0>::diameter();
      }
      inline __attribute__((always_inline)) float volume() const 
      {
        return ::RTTL::RTBox_t<3, float, 0>((*this).::RTTL::RTBox3a::min3f(), (*this).::RTTL::RTBox3a::max3f()).::RTTL::RTBox_t<3, float, 0>::volume();
      }
      inline __attribute__((always_inline)) float area() const 
      {
        return ::RTTL::RTBox_t<3, float, 0>((*this).::RTTL::RTBox3a::min3f(), (*this).::RTTL::RTBox3a::max3f()).::RTTL::RTBox_t<3, float, 0>::area();
      }
      inline __attribute__((always_inline)) ::RTTL::RTVec3f &min3f() const 
      {
        return (::RTTL::RTVec3f &)(*this).m_min;
      }
      inline __attribute__((always_inline)) ::RTTL::RTVec3f &max3f() const 
      {
        return (::RTTL::RTVec3f &)(*this).m_max;
      }
      inline __attribute__((always_inline)) ::RTTL::RTVec3f &operator [](const int i)
      {
        const char __MERCURIUM_PRETTY_FUNCTION__[57] = "::RTTL::RTVec3f &::RTTL::RTBox3a::operator [](const int)";
        i >= 0 && i < 2 ? static_cast<void>(0) : ::__assert_fail("i >= 0 && i < 2", "/home/bsc18/bsc18186/scratch/parsec/raytrace/src/RTTL/common/RTBox.hxx", 318, __MERCURIUM_PRETTY_FUNCTION__);
        return i == 0 ? *((::RTTL::RTVec3f *)&(*this).m_min.::RTTL::RTVec_t<1, ::sse_f, 0>::operator [](0)) : *((::RTTL::RTVec3f *)&(*this).m_max.::RTTL::RTVec_t<1, ::sse_f, 0>::operator [](0));
      }
      inline __attribute__((always_inline)) ::sse_f &min_f()
      {
        return (*this).m_min.::RTTL::RTVec_t<1, ::sse_f, 0>::operator [](0);
      }
      inline __attribute__((always_inline)) ::sse_f &max_f()
      {
        return (*this).m_max.::RTTL::RTVec_t<1, ::sse_f, 0>::operator [](0);
      }
      inline __attribute__((always_inline)) ::sse_f min_f() const 
      {
        return (*this).m_min.::RTTL::RTVec_t<1, ::sse_f, 0>::operator [](0);
      }
      inline __attribute__((always_inline)) ::sse_f max_f() const 
      {
        return (*this).m_max.::RTTL::RTVec_t<1, ::sse_f, 0>::operator [](0);
      }
  };
}
typedef ::RTTL::RTBox_t<2, float, 0> RTBox2f;
typedef ::RTTL::RTBox_t<3, float, 0> RTBox3f;
typedef ::RTTL::RTBox_t<4, float, 0> RTBox4f;
typedef ::RTTL::RTBox_t<2, int, 0> RTBox2i;
typedef ::RTTL::RTBox_t<3, int, 0> RTBox3i;
typedef ::RTTL::RTBox_t<4, int, 0> RTBox4i;
typedef ::RTTL::RTBox3a RTBoxSSE;
struct  timezone
{
    int tz_minuteswest;
    int tz_dsttime;
};
typedef struct ::timezone *__restrict __timezone_ptr_t;
extern "C"
{
  extern int gettimeofday(::timeval *__restrict __tv, ::__timezone_ptr_t __tz) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int settimeofday(const ::timeval *__tv, const struct ::timezone *__tz) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int adjtime(const ::timeval *__delta, ::timeval *__olddelta) throw();
}
enum __itimer_which
{
  ITIMER_REAL = 0,
  ITIMER_VIRTUAL = 1,
  ITIMER_PROF = 2
};
struct  itimerval
{
    ::timeval it_interval;
    ::timeval it_value;
};
typedef int __itimer_which_t;
extern "C"
{
  extern int getitimer(::__itimer_which_t __which, ::itimerval *__value) throw();
}
extern "C"
{
  extern int setitimer(::__itimer_which_t __which, const ::itimerval *__restrict __new, ::itimerval *__restrict __old) throw();
}
extern "C"
{
  extern int utimes(const char *__file, const ::timeval __tvp[2]) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int lutimes(const char *__file, const ::timeval __tvp[2]) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int futimes(int __fd, const ::timeval __tvp[2]) throw();
}
extern "C"
{
  extern int futimesat(int __fd, const char *__file, const ::timeval __tvp[2]) throw();
}
struct  Timer
{
    inline Timer()
    {
    }
    inline __attribute__((always_inline)) void start()
    {
      ::gettimeofday(&(*this).t1, 0L);
    }
    inline __attribute__((always_inline)) unsigned long long int cycles() const 
    {
      ::timeval t2;
      ::gettimeofday(&t2, 0L);
      return 1000000 * (t2.tv_sec - (*this).t1.tv_sec) + (t2.tv_usec - (*this).t1.tv_usec);
    }
    inline __attribute__((always_inline)) float seconds() const 
    {
      return (*this).::Timer::stop();
    }
    inline __attribute__((always_inline)) float stop() const 
    {
      ::timeval t2;
      ::gettimeofday(&t2, 0L);
      return (float)(t2.tv_sec - (*this).t1.tv_sec + (t2.tv_usec - (*this).t1.tv_usec) / 1.000000000000000000000000e+06f);
    }
  private:
    ::timeval t1;
  public:
};
extern "C"
{
  extern void *memcpy(void *__restrict __dest, const void *__restrict __src, ::size_t __n) throw()__attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern void *memmove(void *__dest, const void *__src, ::size_t __n) throw()__attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern void *memccpy(void *__restrict __dest, const void *__restrict __src, int __c, ::size_t __n) throw()__attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern void *memset(void *__s, int __c, ::size_t __n) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int memcmp(const void *__s1, const void *__s2, ::size_t __n) throw()__attribute__((__pure__)) __attribute__((__nonnull__(1, 2)));
}
extern void *memchr(void *__s, int __c, ::size_t __n) throw() __asm("memchr")__attribute__((__pure__)) __attribute__((__nonnull__(1)));
extern const void *memchr(const void *__s, int __c, ::size_t __n) throw() __asm("memchr")__attribute__((__pure__)) __attribute__((__nonnull__(1)));
void *rawmemchr(void *__s, int __c) throw() __asm("rawmemchr")__attribute__((__pure__)) __attribute__((__nonnull__(1)));
const void *rawmemchr(const void *__s, int __c) throw() __asm("rawmemchr")__attribute__((__pure__)) __attribute__((__nonnull__(1)));
void *memrchr(void *__s, int __c, ::size_t __n) throw() __asm("memrchr")__attribute__((__pure__)) __attribute__((__nonnull__(1)));
const void *memrchr(const void *__s, int __c, ::size_t __n) throw() __asm("memrchr")__attribute__((__pure__)) __attribute__((__nonnull__(1)));
extern "C"
{
  extern char *strcpy(char *__restrict __dest, const char *__restrict __src) throw()__attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern char *strncpy(char *__restrict __dest, const char *__restrict __src, ::size_t __n) throw()__attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern char *strcat(char *__restrict __dest, const char *__restrict __src) throw()__attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern char *strncat(char *__restrict __dest, const char *__restrict __src, ::size_t __n) throw()__attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int strcmp(const char *__s1, const char *__s2) throw()__attribute__((__pure__)) __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int strncmp(const char *__s1, const char *__s2, ::size_t __n) throw()__attribute__((__pure__)) __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int strcoll(const char *__s1, const char *__s2) throw()__attribute__((__pure__)) __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern ::size_t strxfrm(char *__restrict __dest, const char *__restrict __src, ::size_t __n) throw()__attribute__((__nonnull__(2)));
}
extern "C"
{
  extern int strcoll_l(const char *__s1, const char *__s2, ::__locale_t __l) throw()__attribute__((__pure__)) __attribute__((__nonnull__(1, 2, 3)));
}
extern "C"
{
  extern ::size_t strxfrm_l(char *__dest, const char *__src, ::size_t __n, ::__locale_t __l) throw()__attribute__((__nonnull__(2, 4)));
}
extern "C"
{
  extern char *_strdup(const char *__s) throw()__attribute__((__malloc__)) __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern char *strndup(const char *__string, ::size_t __n) throw()__attribute__((__malloc__)) __attribute__((__nonnull__(1)));
}
extern char *strchr(char *__s, int __c) throw() __asm("strchr")__attribute__((__pure__)) __attribute__((__nonnull__(1)));
extern const char *strchr(const char *__s, int __c) throw() __asm("strchr")__attribute__((__pure__)) __attribute__((__nonnull__(1)));
extern char *strrchr(char *__s, int __c) throw() __asm("strrchr")__attribute__((__pure__)) __attribute__((__nonnull__(1)));
extern const char *strrchr(const char *__s, int __c) throw() __asm("strrchr")__attribute__((__pure__)) __attribute__((__nonnull__(1)));
char *strchrnul(char *__s, int __c) throw() __asm("strchrnul")__attribute__((__pure__)) __attribute__((__nonnull__(1)));
const char *strchrnul(const char *__s, int __c) throw() __asm("strchrnul")__attribute__((__pure__)) __attribute__((__nonnull__(1)));
extern "C"
{
  extern ::size_t strcspn(const char *__s, const char *__reject) throw()__attribute__((__pure__)) __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern ::size_t strspn(const char *__s, const char *__accept) throw()__attribute__((__pure__)) __attribute__((__nonnull__(1, 2)));
}
extern char *strpbrk(char *__s, const char *__accept) throw() __asm("strpbrk")__attribute__((__pure__)) __attribute__((__nonnull__(1, 2)));
extern const char *strpbrk(const char *__s, const char *__accept) throw() __asm("strpbrk")__attribute__((__pure__)) __attribute__((__nonnull__(1, 2)));
extern char *strstr(char *__haystack, const char *__needle) throw() __asm("strstr")__attribute__((__pure__)) __attribute__((__nonnull__(1, 2)));
extern const char *strstr(const char *__haystack, const char *__needle) throw() __asm("strstr")__attribute__((__pure__)) __attribute__((__nonnull__(1, 2)));
extern "C"
{
  extern char *strtok(char *__restrict __s, const char *__restrict __delim) throw()__attribute__((__nonnull__(2)));
}
extern "C"
{
  extern char *__strtok_r(char *__restrict __s, const char *__restrict __delim, char **__restrict __save_ptr) throw()__attribute__((__nonnull__(2, 3)));
}
extern "C"
{
  extern char *strtok_r(char *__restrict __s, const char *__restrict __delim, char **__restrict __save_ptr) throw()__attribute__((__nonnull__(2, 3)));
}
char *strcasestr(char *__haystack, const char *__needle) throw() __asm("strcasestr")__attribute__((__pure__)) __attribute__((__nonnull__(1, 2)));
const char *strcasestr(const char *__haystack, const char *__needle) throw() __asm("strcasestr")__attribute__((__pure__)) __attribute__((__nonnull__(1, 2)));
extern "C"
{
  extern void *memmem(const void *__haystack, ::size_t __haystacklen, const void *__needle, ::size_t __needlelen) throw()__attribute__((__pure__)) __attribute__((__nonnull__(1, 3)));
}
extern "C"
{
  extern void *__mempcpy(void *__restrict __dest, const void *__restrict __src, ::size_t __n) throw()__attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern void *mempcpy(void *__restrict __dest, const void *__restrict __src, ::size_t __n) throw()__attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern ::size_t strlen(const char *__s) throw()__attribute__((__pure__)) __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern ::size_t strnlen(const char *__string, ::size_t __maxlen) throw()__attribute__((__pure__)) __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern char *strerror(int __errnum) throw();
}
extern "C"
{
  extern char *strerror_r(int __errnum, char *__buf, ::size_t __buflen) throw()__attribute__((__nonnull__(2)));
}
extern "C"
{
  extern char *strerror_l(int __errnum, ::__locale_t __l) throw();
}
extern "C"
{
  extern void __bzero(void *__s, ::size_t __n) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern void bcopy(const void *__src, void *__dest, ::size_t __n) throw()__attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern void bzero(void *__s, ::size_t __n) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int bcmp(const void *__s1, const void *__s2, ::size_t __n) throw()__attribute__((__pure__)) __attribute__((__nonnull__(1, 2)));
}
extern char *index(char *__s, int __c) throw() __asm("index")__attribute__((__pure__)) __attribute__((__nonnull__(1)));
extern const char *index(const char *__s, int __c) throw() __asm("index")__attribute__((__pure__)) __attribute__((__nonnull__(1)));
extern char *rindex(char *__s, int __c) throw() __asm("rindex")__attribute__((__pure__)) __attribute__((__nonnull__(1)));
extern const char *rindex(const char *__s, int __c) throw() __asm("rindex")__attribute__((__pure__)) __attribute__((__nonnull__(1)));
extern "C"
{
  extern int ffs(int __i) throw()__attribute__((__const__));
}
extern "C"
{
  extern int ffsl(long int __l) throw()__attribute__((__const__));
}
extern "C"
{
  extern int ffsll(long long int __ll) throw()__attribute__((__const__));
}
extern "C"
{
  extern int strcasecmp(const char *__s1, const char *__s2) throw()__attribute__((__pure__)) __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int strncasecmp(const char *__s1, const char *__s2, ::size_t __n) throw()__attribute__((__pure__)) __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int strcasecmp_l(const char *__s1, const char *__s2, ::__locale_t __loc) throw()__attribute__((__pure__)) __attribute__((__nonnull__(1, 2, 3)));
}
extern "C"
{
  extern int strncasecmp_l(const char *__s1, const char *__s2, ::size_t __n, ::__locale_t __loc) throw()__attribute__((__pure__)) __attribute__((__nonnull__(1, 2, 4)));
}
extern "C"
{
  extern char *strsep(char **__restrict __stringp, const char *__restrict __delim) throw()__attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern char *strsignal(int __sig) throw();
}
extern "C"
{
  extern char *__stpcpy(char *__restrict __dest, const char *__restrict __src) throw()__attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern char *stpcpy(char *__restrict __dest, const char *__restrict __src) throw()__attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern char *__stpncpy(char *__restrict __dest, const char *__restrict __src, ::size_t __n) throw()__attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern char *stpncpy(char *__restrict __dest, const char *__restrict __src, ::size_t __n) throw()__attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int strverscmp(const char *__s1, const char *__s2) throw()__attribute__((__pure__)) __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern char *strfry(char *__string) throw()__attribute__((__nonnull__(1)));
}
extern "C"
{
  extern void *memfrob(void *__s, ::size_t __n) throw()__attribute__((__nonnull__(1)));
}
char *basename(char *__filename) throw() __asm("basename")__attribute__((__nonnull__(1)));
const char *basename(const char *__filename) throw() __asm("basename")__attribute__((__nonnull__(1)));
namespace std __attribute__((__visibility__("default"))) {
  using ::memchr;
  using ::memcmp;
  using ::memcpy;
  using ::memmove;
  using ::memset;
  using ::strcat;
  using ::strcmp;
  using ::strcoll;
  using ::strcpy;
  using ::strcspn;
  using ::strerror;
  using ::strlen;
  using ::strncat;
  using ::strncmp;
  using ::strncpy;
  using ::strspn;
  using ::strtok;
  using ::strxfrm;
  using ::strchr;
  using ::strpbrk;
  using ::strrchr;
  using ::strstr;
  template < bool _TrivialValueTypes >
  struct  __uninitialized_copy
  {
      template < typename _InputIterator, typename _ForwardIterator >
      static inline _ForwardIterator __uninit_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator __result)
      {
        _ForwardIterator __cur = __result;
        try
        {
          for (; __first != __last; (++__first, ++__cur))
            {
              std::_Construct(std::__addressof(*__cur), *__first);
            }
          return __cur;
        }
        catch (...)
        {
          std::_Destroy(__result, __cur);
          throw;
        }
      }
  };
  template <>
  struct  __uninitialized_copy<true>
  {
      template < typename _InputIterator, typename _ForwardIterator >
      static inline _ForwardIterator __uninit_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator __result)
      {
        return std::copy(__first, __last, __result);
      }
  };
  template < typename _InputIterator, typename _ForwardIterator >
  inline _ForwardIterator uninitialized_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator __result);
  template < typename _InputIterator, typename _ForwardIterator >
  inline _ForwardIterator uninitialized_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator __result)
  {
    typedef typename ::std::iterator_traits<_InputIterator>::value_type _ValueType1;
    typedef typename ::std::iterator_traits<_ForwardIterator>::value_type _ValueType2;
    return std::__uninitialized_copy<(__is_trivial(_ValueType1)) && (__is_trivial(_ValueType2))>::__uninit_copy(__first, __last, __result);
  }
  template < bool _TrivialValueType >
  struct  __uninitialized_fill
  {
      template < typename _ForwardIterator, typename _Tp >
      static inline void __uninit_fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__x)
      {
        _ForwardIterator __cur = __first;
        try
        {
          for (; __cur != __last; ++__cur)
            {
              std::_Construct(std::__addressof(*__cur), __x);
            }
        }
        catch (...)
        {
          std::_Destroy(__first, __cur);
          throw;
        }
      }
  };
  template <>
  struct  __uninitialized_fill<true>
  {
      template < typename _ForwardIterator, typename _Tp >
      static inline void __uninit_fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__x)
      {
        std::fill(__first, __last, __x);
      }
  };
  template < typename _ForwardIterator, typename _Tp >
  inline void uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__x);
  template < typename _ForwardIterator, typename _Tp >
  inline void uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__x)
  {
    typedef typename ::std::iterator_traits<_ForwardIterator>::value_type _ValueType;
    std::__uninitialized_fill<__is_trivial(_ValueType)>::__uninit_fill(__first, __last, __x);
  }
  template < bool _TrivialValueType >
  struct  __uninitialized_fill_n
  {
      template < typename _ForwardIterator, typename _Size, typename _Tp >
      static inline void __uninit_fill_n(_ForwardIterator __first, _Size __n, const _Tp &__x)
      {
        _ForwardIterator __cur = __first;
        try
        {
          for (; __n > 0; (--__n, ++__cur))
            {
              std::_Construct(std::__addressof(*__cur), __x);
            }
        }
        catch (...)
        {
          std::_Destroy(__first, __cur);
          throw;
        }
      }
  };
  template <>
  struct  __uninitialized_fill_n<true>
  {
      template < typename _ForwardIterator, typename _Size, typename _Tp >
      static inline void __uninit_fill_n(_ForwardIterator __first, _Size __n, const _Tp &__x)
      {
        std::fill_n(__first, __n, __x);
      }
  };
  template < typename _ForwardIterator, typename _Size, typename _Tp >
  inline void uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp &__x);
  template < typename _ForwardIterator, typename _Size, typename _Tp >
  inline void uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp &__x)
  {
    typedef typename ::std::iterator_traits<_ForwardIterator>::value_type _ValueType;
    std::__uninitialized_fill_n<__is_trivial(_ValueType)>::__uninit_fill_n(__first, __n, __x);
  }
  template < typename _InputIterator, typename _ForwardIterator, typename _Allocator >
  _ForwardIterator __uninitialized_copy_a(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _Allocator &__alloc);
  template < typename _InputIterator, typename _ForwardIterator, typename _Allocator >
  _ForwardIterator __uninitialized_copy_a(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _Allocator &__alloc)
  {
    _ForwardIterator __cur = __result;
    try
    {
      typedef ::__gnu_cxx::__alloc_traits<_Allocator> __traits;
      for (; __first != __last; (++__first, ++__cur))
        {
          __traits::construct(__alloc, std::__addressof(*__cur), *__first);
        }
      return __cur;
    }
    catch (...)
    {
      std::_Destroy(__result, __cur, __alloc);
      throw;
    }
  }
  template < typename _InputIterator, typename _ForwardIterator, typename _Tp >
  inline _ForwardIterator __uninitialized_copy_a(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, ::std::allocator<_Tp> &);
  template < typename _InputIterator, typename _ForwardIterator, typename _Tp >
  inline _ForwardIterator __uninitialized_copy_a(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, ::std::allocator<_Tp> &)
  {
    return std::uninitialized_copy(__first, __last, __result);
  }
  template < typename _InputIterator, typename _ForwardIterator, typename _Allocator >
  inline _ForwardIterator __uninitialized_move_a(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _Allocator &__alloc);
  template < typename _InputIterator, typename _ForwardIterator, typename _Allocator >
  inline _ForwardIterator __uninitialized_move_a(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _Allocator &__alloc)
  {
    return std::__uninitialized_copy_a(__first, __last, __result, __alloc);
  }
  template < typename _InputIterator, typename _ForwardIterator, typename _Allocator >
  inline _ForwardIterator __uninitialized_move_if_noexcept_a(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _Allocator &__alloc);
  template < typename _InputIterator, typename _ForwardIterator, typename _Allocator >
  inline _ForwardIterator __uninitialized_move_if_noexcept_a(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _Allocator &__alloc)
  {
    return std::__uninitialized_copy_a(__first, __last, __result, __alloc);
  }
  template < typename _ForwardIterator, typename _Tp, typename _Allocator >
  void __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__x, _Allocator &__alloc);
  template < typename _ForwardIterator, typename _Tp, typename _Allocator >
  void __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__x, _Allocator &__alloc)
  {
    _ForwardIterator __cur = __first;
    try
    {
      typedef ::__gnu_cxx::__alloc_traits<_Allocator> __traits;
      for (; __cur != __last; ++__cur)
        {
          __traits::construct(__alloc, std::__addressof(*__cur), __x);
        }
    }
    catch (...)
    {
      std::_Destroy(__first, __cur, __alloc);
      throw;
    }
  }
  template < typename _ForwardIterator, typename _Tp, typename _Tp2 >
  inline void __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__x, ::std::allocator<_Tp2> &);
  template < typename _ForwardIterator, typename _Tp, typename _Tp2 >
  inline void __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__x, ::std::allocator<_Tp2> &)
  {
    std::uninitialized_fill(__first, __last, __x);
  }
  template < typename _ForwardIterator, typename _Size, typename _Tp, typename _Allocator >
  void __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n, const _Tp &__x, _Allocator &__alloc);
  template < typename _ForwardIterator, typename _Size, typename _Tp, typename _Allocator >
  void __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n, const _Tp &__x, _Allocator &__alloc)
  {
    _ForwardIterator __cur = __first;
    try
    {
      typedef ::__gnu_cxx::__alloc_traits<_Allocator> __traits;
      for (; __n > 0; (--__n, ++__cur))
        {
          __traits::construct(__alloc, std::__addressof(*__cur), __x);
        }
    }
    catch (...)
    {
      std::_Destroy(__first, __cur, __alloc);
      throw;
    }
  }
  template < typename _ForwardIterator, typename _Size, typename _Tp, typename _Tp2 >
  inline void __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n, const _Tp &__x, ::std::allocator<_Tp2> &);
  template < typename _ForwardIterator, typename _Size, typename _Tp, typename _Tp2 >
  inline void __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n, const _Tp &__x, ::std::allocator<_Tp2> &)
  {
    std::uninitialized_fill_n(__first, __n, __x);
  }
  template < typename _InputIterator1, typename _InputIterator2, typename _ForwardIterator, typename _Allocator >
  inline _ForwardIterator __uninitialized_copy_move(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _ForwardIterator __result, _Allocator &__alloc);
  template < typename _InputIterator1, typename _InputIterator2, typename _ForwardIterator, typename _Allocator >
  inline _ForwardIterator __uninitialized_copy_move(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _ForwardIterator __result, _Allocator &__alloc)
  {
    _ForwardIterator __mid = std::__uninitialized_copy_a(__first1, __last1, __result, __alloc);
    try
    {
      return std::__uninitialized_move_a(__first2, __last2, __mid, __alloc);
    }
    catch (...)
    {
      std::_Destroy(__result, __mid, __alloc);
      throw;
    }
  }
  template < typename _InputIterator1, typename _InputIterator2, typename _ForwardIterator, typename _Allocator >
  inline _ForwardIterator __uninitialized_move_copy(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _ForwardIterator __result, _Allocator &__alloc);
  template < typename _InputIterator1, typename _InputIterator2, typename _ForwardIterator, typename _Allocator >
  inline _ForwardIterator __uninitialized_move_copy(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _ForwardIterator __result, _Allocator &__alloc)
  {
    _ForwardIterator __mid = std::__uninitialized_move_a(__first1, __last1, __result, __alloc);
    try
    {
      return std::__uninitialized_copy_a(__first2, __last2, __mid, __alloc);
    }
    catch (...)
    {
      std::_Destroy(__result, __mid, __alloc);
      throw;
    }
  }
  template < typename _ForwardIterator, typename _Tp, typename _InputIterator, typename _Allocator >
  inline _ForwardIterator __uninitialized_fill_move(_ForwardIterator __result, _ForwardIterator __mid, const _Tp &__x, _InputIterator __first, _InputIterator __last, _Allocator &__alloc);
  template < typename _ForwardIterator, typename _Tp, typename _InputIterator, typename _Allocator >
  inline _ForwardIterator __uninitialized_fill_move(_ForwardIterator __result, _ForwardIterator __mid, const _Tp &__x, _InputIterator __first, _InputIterator __last, _Allocator &__alloc)
  {
    std::__uninitialized_fill_a(__result, __mid, __x, __alloc);
    try
    {
      return std::__uninitialized_move_a(__first, __last, __mid, __alloc);
    }
    catch (...)
    {
      std::_Destroy(__result, __mid, __alloc);
      throw;
    }
  }
  template < typename _InputIterator, typename _ForwardIterator, typename _Tp, typename _Allocator >
  inline void __uninitialized_move_fill(_InputIterator __first1, _InputIterator __last1, _ForwardIterator __first2, _ForwardIterator __last2, const _Tp &__x, _Allocator &__alloc);
  template < typename _InputIterator, typename _ForwardIterator, typename _Tp, typename _Allocator >
  inline void __uninitialized_move_fill(_InputIterator __first1, _InputIterator __last1, _ForwardIterator __first2, _ForwardIterator __last2, const _Tp &__x, _Allocator &__alloc)
  {
    _ForwardIterator __mid2 = std::__uninitialized_move_a(__first1, __last1, __first2, __alloc);
    try
    {
      std::__uninitialized_fill_a(__mid2, __last2, __x, __alloc);
    }
    catch (...)
    {
      std::_Destroy(__first2, __mid2, __alloc);
      throw;
    }
  }
  template < typename _Tp, typename _Alloc >
  struct  _Vector_base
  {
      struct _Vector_impl;
      typedef typename ::__gnu_cxx::__alloc_traits<_Alloc>::template rebind< _Tp>::other _Tp_alloc_type;
      typedef typename ::__gnu_cxx::__alloc_traits<typename ::std::_Vector_base<_Tp, _Alloc>::_Tp_alloc_type>::pointer pointer;
      struct  _Vector_impl : ::std::_Vector_base<_Tp, _Alloc>::_Tp_alloc_type
      {
          typename ::std::_Vector_base<_Tp, _Alloc>::pointer _M_start;
          typename ::std::_Vector_base<_Tp, _Alloc>::pointer _M_finish;
          typename ::std::_Vector_base<_Tp, _Alloc>::pointer _M_end_of_storage;
          inline _Vector_impl()
            : _Tp_alloc_type(), _M_start(0), _M_finish(0), _M_end_of_storage(0)
          {
          }
          inline _Vector_impl(const typename ::std::_Vector_base<_Tp, _Alloc>::_Tp_alloc_type &__a)
            : _Tp_alloc_type(__a), _M_start(0), _M_finish(0), _M_end_of_storage(0)
          {
          }
          inline void _M_swap_data(typename ::std::_Vector_base<_Tp, _Alloc>::_Vector_impl &__x)
          {
            std::swap(_M_start, __x._M_start);
            std::swap(_M_finish, __x._M_finish);
            std::swap(_M_end_of_storage, __x._M_end_of_storage);
          }
      };
      typedef _Alloc allocator_type;
      inline typename ::std::_Vector_base<_Tp, _Alloc>::_Tp_alloc_type &_M_get_Tp_allocator()
      {
        return *static_cast<typename ::std::_Vector_base<_Tp, _Alloc>::_Tp_alloc_type *>(&this->_M_impl);
      }
      inline const typename ::std::_Vector_base<_Tp, _Alloc>::_Tp_alloc_type &_M_get_Tp_allocator() const 
      {
        return *static_cast<const typename ::std::_Vector_base<_Tp, _Alloc>::_Tp_alloc_type *>(&this->_M_impl);
      }
      inline typename ::std::_Vector_base<_Tp, _Alloc>::allocator_type get_allocator() const 
      {
        return typename ::std::_Vector_base<_Tp, _Alloc>::allocator_type(_M_get_Tp_allocator());
      }
      inline _Vector_base()
        : _M_impl()
      {
      }
      inline _Vector_base(const typename ::std::_Vector_base<_Tp, _Alloc>::allocator_type &__a)
        : _M_impl(__a)
      {
      }
      inline _Vector_base(::std::size_t __n)
        : _M_impl()
      {
        _M_create_storage(__n);
      }
      inline _Vector_base(::std::size_t __n, const typename ::std::_Vector_base<_Tp, _Alloc>::allocator_type &__a)
        : _M_impl(__a)
      {
        _M_create_storage(__n);
      }
      inline ~_Vector_base()
      {
        _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
      }
      typename ::std::_Vector_base<_Tp, _Alloc>::_Vector_impl _M_impl;
      inline typename ::std::_Vector_base<_Tp, _Alloc>::pointer _M_allocate(::std::size_t __n)
      {
        return __n != 0 ? _M_impl.allocate(__n) : 0;
      }
      inline void _M_deallocate(typename ::std::_Vector_base<_Tp, _Alloc>::pointer __p, ::std::size_t __n)
      {
        if (__p)
          {
            _M_impl.deallocate(__p, __n);
          }
      }
    private:
      inline void _M_create_storage(::std::size_t __n)
      {
        this->_M_impl._M_start = this->_M_allocate(__n);
        this->_M_impl._M_finish = this->_M_impl._M_start;
        this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
      }
  };
  template < typename _Tp, typename _Alloc = ::std::allocator<_Tp> >
  class  vector : protected ::std::_Vector_base<_Tp, _Alloc>
  {
      typedef typename _Alloc::value_type _Alloc_value_type;
      typedef ::std::_Vector_base<_Tp, _Alloc> _Base;
      typedef typename ::std::_Vector_base<_Tp, _Alloc>::_Tp_alloc_type _Tp_alloc_type;
      typedef ::__gnu_cxx::__alloc_traits<typename ::std::vector<_Tp, _Alloc>::_Tp_alloc_type> _Alloc_traits;
    public:
      typedef _Tp value_type;
      typedef typename ::std::_Vector_base<_Tp, _Alloc>::pointer pointer;
      typedef typename ::__gnu_cxx::__alloc_traits<typename ::std::vector<_Tp, _Alloc>::_Tp_alloc_type>::const_pointer const_pointer;
      typedef typename ::__gnu_cxx::__alloc_traits<typename ::std::vector<_Tp, _Alloc>::_Tp_alloc_type>::reference reference;
      typedef typename ::__gnu_cxx::__alloc_traits<typename ::std::vector<_Tp, _Alloc>::_Tp_alloc_type>::const_reference const_reference;
      typedef ::__gnu_cxx::__normal_iterator<typename ::std::vector<_Tp, _Alloc>::pointer, ::std::vector<_Tp, _Alloc> > iterator;
      typedef ::__gnu_cxx::__normal_iterator<typename ::std::vector<_Tp, _Alloc>::const_pointer, ::std::vector<_Tp, _Alloc> > const_iterator;
      typedef ::std::reverse_iterator<typename ::std::vector<_Tp, _Alloc>::const_iterator> const_reverse_iterator;
      typedef ::std::reverse_iterator<typename ::std::vector<_Tp, _Alloc>::iterator> reverse_iterator;
      typedef ::std::size_t size_type;
      typedef ::std::ptrdiff_t difference_type;
      typedef _Alloc allocator_type;
    protected:
      using ::std::_Vector_base<_Tp, _Alloc>::_M_allocate;
      using ::std::_Vector_base<_Tp, _Alloc>::_M_deallocate;
      using ::std::_Vector_base<_Tp, _Alloc>::_M_impl;
      using ::std::_Vector_base<_Tp, _Alloc>::_M_get_Tp_allocator;
    public:
      inline vector()
        : _Base()
      {
      }
      inline explicit vector(const typename ::std::vector<_Tp, _Alloc>::allocator_type &__a)
        : _Base(__a)
      {
      }
      inline explicit vector(typename ::std::vector<_Tp, _Alloc>::size_type __n, const typename ::std::vector<_Tp, _Alloc>::value_type &__value  = typename ::std::vector<_Tp, _Alloc>::value_type(), const typename ::std::vector<_Tp, _Alloc>::allocator_type &__a  = typename ::std::vector<_Tp, _Alloc>::allocator_type())
        : _Base(__n, __a)
      {
        _M_fill_initialize(__n, __value);
      }
      inline vector(const ::std::vector<_Tp, _Alloc> &__x)
        : _Base(__x.size(), _Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()))
      {
        this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
      }
      template < typename _InputIterator >
      inline vector(_InputIterator __first, _InputIterator __last, const typename ::std::vector<_Tp, _Alloc>::allocator_type &__a  = typename ::std::vector<_Tp, _Alloc>::allocator_type())
        : _Base(__a)
      {
        typedef typename ::std::__is_integer<_InputIterator>::__type _Integral;
        _M_initialize_dispatch(__first, __last, _Integral());
      }
      inline ~vector()
      {
        std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
      }
      ::std::vector<_Tp, _Alloc> &operator =(const ::std::vector<_Tp, _Alloc> &__x);
      inline void assign(typename ::std::vector<_Tp, _Alloc>::size_type __n, const typename ::std::vector<_Tp, _Alloc>::value_type &__val)
      {
        _M_fill_assign(__n, __val);
      }
      template < typename _InputIterator >
      inline void assign(_InputIterator __first, _InputIterator __last)
      {
        typedef typename ::std::__is_integer<_InputIterator>::__type _Integral;
        _M_assign_dispatch(__first, __last, _Integral());
      }
      using ::std::_Vector_base<_Tp, _Alloc>::get_allocator;
      inline typename ::std::vector<_Tp, _Alloc>::iterator begin()
      {
        return iterator(this->_M_impl._M_start);
      }
      inline typename ::std::vector<_Tp, _Alloc>::const_iterator begin() const 
      {
        return const_iterator(this->_M_impl._M_start);
      }
      inline typename ::std::vector<_Tp, _Alloc>::iterator end()
      {
        return iterator(this->_M_impl._M_finish);
      }
      inline typename ::std::vector<_Tp, _Alloc>::const_iterator end() const 
      {
        return const_iterator(this->_M_impl._M_finish);
      }
      inline typename ::std::vector<_Tp, _Alloc>::reverse_iterator rbegin()
      {
        return reverse_iterator(end());
      }
      inline typename ::std::vector<_Tp, _Alloc>::const_reverse_iterator rbegin() const 
      {
        return const_reverse_iterator(end());
      }
      inline typename ::std::vector<_Tp, _Alloc>::reverse_iterator rend()
      {
        return reverse_iterator(begin());
      }
      inline typename ::std::vector<_Tp, _Alloc>::const_reverse_iterator rend() const 
      {
        return const_reverse_iterator(begin());
      }
      inline typename ::std::vector<_Tp, _Alloc>::size_type size() const 
      {
        return size_type(this->_M_impl._M_finish - this->_M_impl._M_start);
      }
      inline typename ::std::vector<_Tp, _Alloc>::size_type max_size() const 
      {
        return _Alloc_traits::max_size(_M_get_Tp_allocator());
      }
      inline void resize(typename ::std::vector<_Tp, _Alloc>::size_type __new_size, typename ::std::vector<_Tp, _Alloc>::value_type __x  = typename ::std::vector<_Tp, _Alloc>::value_type())
      {
        if (__new_size > size())
          {
            insert(end(), __new_size - size(), __x);
          }
        else
          {
            if (__new_size < size())
              {
                _M_erase_at_end(this->_M_impl._M_start + __new_size);
              }
          }
      }
      inline typename ::std::vector<_Tp, _Alloc>::size_type capacity() const 
      {
        return size_type(this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
      }
      inline bool empty() const 
      {
        return begin() == end();
      }
      void reserve(typename ::std::vector<_Tp, _Alloc>::size_type __n);
      inline typename ::std::vector<_Tp, _Alloc>::reference operator [](typename ::std::vector<_Tp, _Alloc>::size_type __n)
      {
        return *(this->_M_impl._M_start + __n);
      }
      inline typename ::std::vector<_Tp, _Alloc>::const_reference operator [](typename ::std::vector<_Tp, _Alloc>::size_type __n) const 
      {
        return *(this->_M_impl._M_start + __n);
      }
    protected:
      inline void _M_range_check(typename ::std::vector<_Tp, _Alloc>::size_type __n) const 
      {
        if (__n >= this->size())
          {
            ::std::__throw_out_of_range("vector::_M_range_check");
          }
      }
    public:
      inline typename ::std::vector<_Tp, _Alloc>::reference at(typename ::std::vector<_Tp, _Alloc>::size_type __n)
      {
        _M_range_check(__n);
        return (*this)[__n];
      }
      inline typename ::std::vector<_Tp, _Alloc>::const_reference at(typename ::std::vector<_Tp, _Alloc>::size_type __n) const 
      {
        _M_range_check(__n);
        return (*this)[__n];
      }
      inline typename ::std::vector<_Tp, _Alloc>::reference front()
      {
        return *begin();
      }
      inline typename ::std::vector<_Tp, _Alloc>::const_reference front() const 
      {
        return *begin();
      }
      inline typename ::std::vector<_Tp, _Alloc>::reference back()
      {
        return *(end() - 1);
      }
      inline typename ::std::vector<_Tp, _Alloc>::const_reference back() const 
      {
        return *(end() - 1);
      }
      inline typename ::std::vector<_Tp, _Alloc>::pointer data()
      {
        return std::__addressof(front());
      }
      inline typename ::std::vector<_Tp, _Alloc>::const_pointer data() const 
      {
        return std::__addressof(front());
      }
      inline void push_back(const typename ::std::vector<_Tp, _Alloc>::value_type &__x)
      {
        if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
          {
            _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, __x);
            ++this->_M_impl._M_finish;
          }
        else
          {
            _M_insert_aux(end(), __x);
          }
      }
      inline void pop_back()
      {
        --this->_M_impl._M_finish;
        _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
      }
      typename ::std::vector<_Tp, _Alloc>::iterator insert(typename ::std::vector<_Tp, _Alloc>::iterator __position, const typename ::std::vector<_Tp, _Alloc>::value_type &__x);
      inline void insert(typename ::std::vector<_Tp, _Alloc>::iterator __position, typename ::std::vector<_Tp, _Alloc>::size_type __n, const typename ::std::vector<_Tp, _Alloc>::value_type &__x)
      {
        _M_fill_insert(__position, __n, __x);
      }
      template < typename _InputIterator >
      inline void insert(typename ::std::vector<_Tp, _Alloc>::iterator __position, _InputIterator __first, _InputIterator __last)
      {
        typedef typename ::std::__is_integer<_InputIterator>::__type _Integral;
        _M_insert_dispatch(__position, __first, __last, _Integral());
      }
      typename ::std::vector<_Tp, _Alloc>::iterator erase(typename ::std::vector<_Tp, _Alloc>::iterator __position);
      typename ::std::vector<_Tp, _Alloc>::iterator erase(typename ::std::vector<_Tp, _Alloc>::iterator __first, typename ::std::vector<_Tp, _Alloc>::iterator __last);
      inline void swap(::std::vector<_Tp, _Alloc> &__x)
      {
        this->_M_impl._M_swap_data(__x._M_impl);
        _Alloc_traits::_S_on_swap(_M_get_Tp_allocator(), __x._M_get_Tp_allocator());
      }
      inline void clear()
      {
        _M_erase_at_end(this->_M_impl._M_start);
      }
    protected:
      template < typename _ForwardIterator >
      inline typename ::std::vector<_Tp, _Alloc>::pointer _M_allocate_and_copy(typename ::std::vector<_Tp, _Alloc>::size_type __n, _ForwardIterator __first, _ForwardIterator __last)
      {
        typename ::std::vector<_Tp, _Alloc>::pointer __result = this->_M_allocate(__n);
        try
        {
          std::__uninitialized_copy_a(__first, __last, __result, _M_get_Tp_allocator());
          return __result;
        }
        catch (...)
        {
          _M_deallocate(__result, __n);
          throw;
        }
      }
      template < typename _Integer >
      inline void _M_initialize_dispatch(_Integer __n, _Integer __value, ::std::__true_type)
      {
        this->_M_impl._M_start = _M_allocate(static_cast<typename ::std::vector<_Tp, _Alloc>::size_type>(__n));
        this->_M_impl._M_end_of_storage = this->_M_impl._M_start + static_cast<typename ::std::vector<_Tp, _Alloc>::size_type>(__n);
        _M_fill_initialize(static_cast<typename ::std::vector<_Tp, _Alloc>::size_type>(__n), __value);
      }
      template < typename _InputIterator >
      inline void _M_initialize_dispatch(_InputIterator __first, _InputIterator __last, ::std::__false_type)
      {
        typedef typename ::std::iterator_traits<_InputIterator>::iterator_category _IterCategory;
        _M_range_initialize(__first, __last, _IterCategory());
      }
      template < typename _InputIterator >
      inline void _M_range_initialize(_InputIterator __first, _InputIterator __last, ::std::input_iterator_tag)
      {
        for (; __first != __last; ++__first)
          {
            push_back(*__first);
          }
      }
      template < typename _ForwardIterator >
      inline void _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last, ::std::forward_iterator_tag)
      {
        const typename ::std::vector<_Tp, _Alloc>::size_type __n = std::distance(__first, __last);
        this->_M_impl._M_start = this->_M_allocate(__n);
        this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
        this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
      }
      inline void _M_fill_initialize(typename ::std::vector<_Tp, _Alloc>::size_type __n, const typename ::std::vector<_Tp, _Alloc>::value_type &__value)
      {
        std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
        this->_M_impl._M_finish = this->_M_impl._M_end_of_storage;
      }
      template < typename _Integer >
      inline void _M_assign_dispatch(_Integer __n, _Integer __val, ::std::__true_type)
      {
        _M_fill_assign(__n, __val);
      }
      template < typename _InputIterator >
      inline void _M_assign_dispatch(_InputIterator __first, _InputIterator __last, ::std::__false_type)
      {
        typedef typename ::std::iterator_traits<_InputIterator>::iterator_category _IterCategory;
        _M_assign_aux(__first, __last, _IterCategory());
      }
      template < typename _InputIterator >
      void _M_assign_aux(_InputIterator __first, _InputIterator __last, ::std::input_iterator_tag);
      template < typename _ForwardIterator >
      void _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last, ::std::forward_iterator_tag);
      void _M_fill_assign(typename ::std::vector<_Tp, _Alloc>::size_type __n, const typename ::std::vector<_Tp, _Alloc>::value_type &__val);
      template < typename _Integer >
      inline void _M_insert_dispatch(typename ::std::vector<_Tp, _Alloc>::iterator __pos, _Integer __n, _Integer __val, ::std::__true_type)
      {
        _M_fill_insert(__pos, __n, __val);
      }
      template < typename _InputIterator >
      inline void _M_insert_dispatch(typename ::std::vector<_Tp, _Alloc>::iterator __pos, _InputIterator __first, _InputIterator __last, ::std::__false_type)
      {
        typedef typename ::std::iterator_traits<_InputIterator>::iterator_category _IterCategory;
        _M_range_insert(__pos, __first, __last, _IterCategory());
      }
      template < typename _InputIterator >
      void _M_range_insert(typename ::std::vector<_Tp, _Alloc>::iterator __pos, _InputIterator __first, _InputIterator __last, ::std::input_iterator_tag);
      template < typename _ForwardIterator >
      void _M_range_insert(typename ::std::vector<_Tp, _Alloc>::iterator __position, _ForwardIterator __first, _ForwardIterator __last, ::std::forward_iterator_tag);
      void _M_fill_insert(typename ::std::vector<_Tp, _Alloc>::iterator __position, typename ::std::vector<_Tp, _Alloc>::size_type __n, const typename ::std::vector<_Tp, _Alloc>::value_type &__x);
      void _M_insert_aux(typename ::std::vector<_Tp, _Alloc>::iterator __position, const typename ::std::vector<_Tp, _Alloc>::value_type &__x);
      inline typename ::std::vector<_Tp, _Alloc>::size_type _M_check_len(typename ::std::vector<_Tp, _Alloc>::size_type __n, const char *__s) const 
      {
        if (max_size() - size() < __n)
          {
            ::std::__throw_length_error(__s);
          }
        const typename ::std::vector<_Tp, _Alloc>::size_type __len = size() + std::max(size(), __n);
        return __len < size() || __len > max_size() ? max_size() : __len;
      }
      inline void _M_erase_at_end(typename ::std::vector<_Tp, _Alloc>::pointer __pos)
      {
        std::_Destroy(__pos, this->_M_impl._M_finish, _M_get_Tp_allocator());
        this->_M_impl._M_finish = __pos;
      }
  };
  template < typename _Tp, typename _Alloc >
  inline bool operator ==(const ::std::vector<_Tp, _Alloc> &__x, const ::std::vector<_Tp, _Alloc> &__y);
  template < typename _Tp, typename _Alloc >
  inline bool operator ==(const ::std::vector<_Tp, _Alloc> &__x, const ::std::vector<_Tp, _Alloc> &__y)
  {
    return __x.size() == __y.size() && std::equal(__x.begin(), __x.end(), __y.begin());
  }
  template < typename _Tp, typename _Alloc >
  inline bool operator <(const ::std::vector<_Tp, _Alloc> &__x, const ::std::vector<_Tp, _Alloc> &__y);
  template < typename _Tp, typename _Alloc >
  inline bool operator <(const ::std::vector<_Tp, _Alloc> &__x, const ::std::vector<_Tp, _Alloc> &__y)
  {
    return std::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
  }
  template < typename _Tp, typename _Alloc >
  inline bool operator !=(const ::std::vector<_Tp, _Alloc> &__x, const ::std::vector<_Tp, _Alloc> &__y);
  template < typename _Tp, typename _Alloc >
  inline bool operator !=(const ::std::vector<_Tp, _Alloc> &__x, const ::std::vector<_Tp, _Alloc> &__y)
  {
    return !(__x == __y);
  }
  template < typename _Tp, typename _Alloc >
  inline bool operator >(const ::std::vector<_Tp, _Alloc> &__x, const ::std::vector<_Tp, _Alloc> &__y);
  template < typename _Tp, typename _Alloc >
  inline bool operator >(const ::std::vector<_Tp, _Alloc> &__x, const ::std::vector<_Tp, _Alloc> &__y)
  {
    return __y < __x;
  }
  template < typename _Tp, typename _Alloc >
  inline bool operator <=(const ::std::vector<_Tp, _Alloc> &__x, const ::std::vector<_Tp, _Alloc> &__y);
  template < typename _Tp, typename _Alloc >
  inline bool operator <=(const ::std::vector<_Tp, _Alloc> &__x, const ::std::vector<_Tp, _Alloc> &__y)
  {
    return !(__y < __x);
  }
  template < typename _Tp, typename _Alloc >
  inline bool operator >=(const ::std::vector<_Tp, _Alloc> &__x, const ::std::vector<_Tp, _Alloc> &__y);
  template < typename _Tp, typename _Alloc >
  inline bool operator >=(const ::std::vector<_Tp, _Alloc> &__x, const ::std::vector<_Tp, _Alloc> &__y)
  {
    return !(__x < __y);
  }
  template < typename _Tp, typename _Alloc >
  inline void swap(::std::vector<_Tp, _Alloc> &__x, ::std::vector<_Tp, _Alloc> &__y);
  template < typename _Tp, typename _Alloc >
  inline void swap(::std::vector<_Tp, _Alloc> &__x, ::std::vector<_Tp, _Alloc> &__y)
  {
    __x.swap(__y);
  }
  typedef unsigned long int _Bit_type;
  enum mcc_enum_anon_65
  {
    _S_word_bit = (int)(8 * sizeof(::std::_Bit_type))
  };
  struct  _Bit_reference
  {
      ::std::_Bit_type *_M_p;
      ::std::_Bit_type _M_mask;
      inline _Bit_reference(::std::_Bit_type *__x, ::std::_Bit_type __y)
        : _M_p(__x), _M_mask(__y)
      {
      }
      inline _Bit_reference()
        : _M_p(0), _M_mask(0)
      {
      }
      inline operator bool() const 
      {
        return !!(*(*this)._M_p & (*this)._M_mask);
      }
      inline ::std::_Bit_reference &operator =(bool __x)
      {
        if (__x)
          {
            *(*this)._M_p |= (*this)._M_mask;
          }
        else
          {
            *(*this)._M_p &= ~(*this)._M_mask;
          }
        return *this;
      }
      inline ::std::_Bit_reference &operator =(const ::std::_Bit_reference &__x)
      {
        return *this = (bool)__x;
      }
      inline bool operator ==(const ::std::_Bit_reference &__x) const 
      {
        return (bool)*this == (bool)__x;
      }
      inline bool operator <(const ::std::_Bit_reference &__x) const 
      {
        return !((bool)*this) && (bool)__x;
      }
      inline void flip()
      {
        *(*this)._M_p ^= (*this)._M_mask;
      }
  };
  struct  _Bit_iterator_base : ::std::iterator< ::std::random_access_iterator_tag, bool, long int, bool *, bool &>
  {
      ::std::_Bit_type *_M_p;
      unsigned int _M_offset;
      inline _Bit_iterator_base(::std::_Bit_type *__x, unsigned int __y)
        : _M_p(__x), _M_offset(__y)
      {
      }
      inline void _M_bump_up()
      {
        if ((*this)._M_offset++ == (int)::std::_S_word_bit - 1)
          {
            (*this)._M_offset = 0;
            ++(*this)._M_p;
          }
      }
      inline void _M_bump_down()
      {
        if ((*this)._M_offset-- == 0)
          {
            (*this)._M_offset = (int)::std::_S_word_bit - 1;
            --(*this)._M_p;
          }
      }
      inline void _M_incr(::std::ptrdiff_t __i)
      {
        ::std::iterator< ::std::random_access_iterator_tag, bool, long int, bool *, bool &>::difference_type __n(__i + (*this)._M_offset);
        (*this)._M_p += __n / (int)::std::_S_word_bit;
        __n = __n % (int)::std::_S_word_bit;
        if (__n < 0)
          {
            __n += (int)::std::_S_word_bit;
            --(*this)._M_p;
          }
        (*this)._M_offset = static_cast<unsigned int>(__n);
      }
      inline bool operator ==(const ::std::_Bit_iterator_base &__i) const 
      {
        return (*this)._M_p == __i._M_p && (*this)._M_offset == __i._M_offset;
      }
      inline bool operator <(const ::std::_Bit_iterator_base &__i) const 
      {
        return (*this)._M_p < __i._M_p || ((*this)._M_p == __i._M_p && (*this)._M_offset < __i._M_offset);
      }
      inline bool operator !=(const ::std::_Bit_iterator_base &__i) const 
      {
        return !(*this == __i);
      }
      inline bool operator >(const ::std::_Bit_iterator_base &__i) const 
      {
        return __i < *this;
      }
      inline bool operator <=(const ::std::_Bit_iterator_base &__i) const 
      {
        return !(__i < *this);
      }
      inline bool operator >=(const ::std::_Bit_iterator_base &__i) const 
      {
        return !(*this < __i);
      }
  };
  inline ::std::ptrdiff_t operator -(const ::std::_Bit_iterator_base &__x, const ::std::_Bit_iterator_base &__y)
  {
    return (int)::std::_S_word_bit * (__x._M_p - __y._M_p) + __x._M_offset - __y._M_offset;
  }
  struct  _Bit_iterator : ::std::_Bit_iterator_base
  {
      typedef ::std::_Bit_reference reference;
      typedef ::std::_Bit_reference *pointer;
      typedef ::std::_Bit_iterator iterator;
      inline _Bit_iterator()
        : ::std::_Bit_iterator_base(0, 0)
      {
      }
      inline _Bit_iterator(::std::_Bit_type *__x, unsigned int __y)
        : ::std::_Bit_iterator_base(__x, __y)
      {
      }
      inline ::std::_Bit_iterator::reference operator *() const 
      {
        return ::std::_Bit_reference((*this)._M_p, 1LU << (*this)._M_offset);
      }
      inline ::std::_Bit_iterator::iterator &operator ++()
      {
        (*this).::std::_Bit_iterator_base::_M_bump_up();
        return *this;
      }
      inline ::std::_Bit_iterator::iterator operator ++(int)
      {
        ::std::_Bit_iterator::iterator __tmp((*this));
        (*this).::std::_Bit_iterator_base::_M_bump_up();
        return __tmp;
      }
      inline ::std::_Bit_iterator::iterator &operator --()
      {
        (*this).::std::_Bit_iterator_base::_M_bump_down();
        return *this;
      }
      inline ::std::_Bit_iterator::iterator operator --(int)
      {
        ::std::_Bit_iterator::iterator __tmp((*this));
        (*this).::std::_Bit_iterator_base::_M_bump_down();
        return __tmp;
      }
      inline ::std::_Bit_iterator::iterator &operator +=(::std::iterator< ::std::random_access_iterator_tag, bool, long int, bool *, bool &>::difference_type __i)
      {
        (*this).::std::_Bit_iterator_base::_M_incr(__i);
        return *this;
      }
      inline ::std::_Bit_iterator::iterator &operator -=(::std::iterator< ::std::random_access_iterator_tag, bool, long int, bool *, bool &>::difference_type __i)
      {
        *this +=  -__i;
        return *this;
      }
      inline ::std::_Bit_iterator::iterator operator +(::std::iterator< ::std::random_access_iterator_tag, bool, long int, bool *, bool &>::difference_type __i) const 
      {
        ::std::_Bit_iterator::iterator __tmp((*this));
        return __tmp += __i;
      }
      inline ::std::_Bit_iterator::iterator operator -(::std::iterator< ::std::random_access_iterator_tag, bool, long int, bool *, bool &>::difference_type __i) const 
      {
        ::std::_Bit_iterator::iterator __tmp((*this));
        return __tmp -= __i;
      }
      inline ::std::_Bit_iterator::reference operator [](::std::iterator< ::std::random_access_iterator_tag, bool, long int, bool *, bool &>::difference_type __i) const 
      {
        return  *(*this + __i);
      }
  };
  inline ::std::_Bit_iterator operator +(::std::ptrdiff_t __n, const ::std::_Bit_iterator &__x)
  {
    return __x + __n;
  }
  struct  _Bit_const_iterator : ::std::_Bit_iterator_base
  {
      typedef bool reference;
      typedef bool const_reference;
      typedef const bool *pointer;
      typedef ::std::_Bit_const_iterator const_iterator;
      inline _Bit_const_iterator()
        : ::std::_Bit_iterator_base(0, 0)
      {
      }
      inline _Bit_const_iterator(::std::_Bit_type *__x, unsigned int __y)
        : ::std::_Bit_iterator_base(__x, __y)
      {
      }
      inline _Bit_const_iterator(const ::std::_Bit_iterator &__x)
        : ::std::_Bit_iterator_base(__x._M_p, __x._M_offset)
      {
      }
      inline ::std::_Bit_const_iterator::const_reference operator *() const 
      {
        return ::std::_Bit_reference((*this)._M_p, 1LU << (*this)._M_offset);
      }
      inline ::std::_Bit_const_iterator::const_iterator &operator ++()
      {
        (*this).::std::_Bit_iterator_base::_M_bump_up();
        return *this;
      }
      inline ::std::_Bit_const_iterator::const_iterator operator ++(int)
      {
        ::std::_Bit_const_iterator::const_iterator __tmp((*this));
        (*this).::std::_Bit_iterator_base::_M_bump_up();
        return __tmp;
      }
      inline ::std::_Bit_const_iterator::const_iterator &operator --()
      {
        (*this).::std::_Bit_iterator_base::_M_bump_down();
        return *this;
      }
      inline ::std::_Bit_const_iterator::const_iterator operator --(int)
      {
        ::std::_Bit_const_iterator::const_iterator __tmp((*this));
        (*this).::std::_Bit_iterator_base::_M_bump_down();
        return __tmp;
      }
      inline ::std::_Bit_const_iterator::const_iterator &operator +=(::std::iterator< ::std::random_access_iterator_tag, bool, long int, bool *, bool &>::difference_type __i)
      {
        (*this).::std::_Bit_iterator_base::_M_incr(__i);
        return *this;
      }
      inline ::std::_Bit_const_iterator::const_iterator &operator -=(::std::iterator< ::std::random_access_iterator_tag, bool, long int, bool *, bool &>::difference_type __i)
      {
        *this +=  -__i;
        return *this;
      }
      inline ::std::_Bit_const_iterator::const_iterator operator +(::std::iterator< ::std::random_access_iterator_tag, bool, long int, bool *, bool &>::difference_type __i) const 
      {
        ::std::_Bit_const_iterator::const_iterator __tmp((*this));
        return __tmp += __i;
      }
      inline ::std::_Bit_const_iterator::const_iterator operator -(::std::iterator< ::std::random_access_iterator_tag, bool, long int, bool *, bool &>::difference_type __i) const 
      {
        ::std::_Bit_const_iterator::const_iterator __tmp((*this));
        return __tmp -= __i;
      }
      inline ::std::_Bit_const_iterator::const_reference operator [](::std::iterator< ::std::random_access_iterator_tag, bool, long int, bool *, bool &>::difference_type __i) const 
      {
        return  *(*this + __i);
      }
  };
  inline ::std::_Bit_const_iterator operator +(::std::ptrdiff_t __n, const ::std::_Bit_const_iterator &__x)
  {
    return __x + __n;
  }
  inline void __fill_bvector(::std::_Bit_iterator __first, ::std::_Bit_iterator __last, bool __x)
  {
    for (; __first != __last;  ++__first)
      {
         *__first = __x;
      }
  }
  inline void fill(::std::_Bit_iterator __first, ::std::_Bit_iterator __last, const bool &__x)
  {
    if (__first._M_p != __last._M_p)
      {
        ::std::fill /* < ::std::_Bit_type *, int> */ (__first._M_p + 1, __last._M_p, __x ? ~0 : 0);
        ::std::__fill_bvector(__first, ::std::_Bit_iterator(__first._M_p + 1, 0), __x);
        ::std::__fill_bvector(::std::_Bit_iterator(__last._M_p, 0), __last, __x);
      }
    else
      {
        ::std::__fill_bvector(__first, __last, __x);
      }
  }
  template < typename _Alloc >
  struct  _Bvector_base
  {
      struct _Bvector_impl;
      typedef typename _Alloc::template rebind< ::std::_Bit_type>::other _Bit_alloc_type;
      struct  _Bvector_impl : ::std::_Bvector_base<_Alloc>::_Bit_alloc_type
      {
          ::std::_Bit_iterator _M_start;
          ::std::_Bit_iterator _M_finish;
          ::std::_Bit_type *_M_end_of_storage;
          inline _Bvector_impl()
            : _Bit_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage(0)
          {
          }
          inline _Bvector_impl(const typename ::std::_Bvector_base<_Alloc>::_Bit_alloc_type &__a)
            : _Bit_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage(0)
          {
          }
      };
      typedef _Alloc allocator_type;
      inline typename ::std::_Bvector_base<_Alloc>::_Bit_alloc_type &_M_get_Bit_allocator()
      {
        return *static_cast<typename ::std::_Bvector_base<_Alloc>::_Bit_alloc_type *>(&this->_M_impl);
      }
      inline const typename ::std::_Bvector_base<_Alloc>::_Bit_alloc_type &_M_get_Bit_allocator() const 
      {
        return *static_cast<const typename ::std::_Bvector_base<_Alloc>::_Bit_alloc_type *>(&this->_M_impl);
      }
      inline typename ::std::_Bvector_base<_Alloc>::allocator_type get_allocator() const 
      {
        return typename ::std::_Bvector_base<_Alloc>::allocator_type(_M_get_Bit_allocator());
      }
      inline _Bvector_base()
        : _M_impl()
      {
      }
      inline _Bvector_base(const typename ::std::_Bvector_base<_Alloc>::allocator_type &__a)
        : _M_impl(__a)
      {
      }
      inline ~_Bvector_base()
      {
        this->_M_deallocate();
      }
    protected:
      typename ::std::_Bvector_base<_Alloc>::_Bvector_impl _M_impl;
      inline ::std::_Bit_type *_M_allocate(::std::size_t __n)
      {
        return _M_impl.allocate(_S_nword(__n));
      }
      inline void _M_deallocate()
      {
        if (_M_impl._M_start._M_p)
          {
            _M_impl.deallocate(_M_impl._M_start._M_p, _M_impl._M_end_of_storage - _M_impl._M_start._M_p);
          }
      }
      static inline ::std::size_t _S_nword(::std::size_t __n)
      {
        return (__n + (int)::std::_S_word_bit - 1) / (int)::std::_S_word_bit;
      }
  };
  template < typename _Alloc >
  class  vector<bool, _Alloc> : protected ::std::_Bvector_base<_Alloc>
  {
      typedef ::std::_Bvector_base<_Alloc> _Base;
    public:
      typedef bool value_type;
      typedef ::std::size_t size_type;
      typedef ::std::ptrdiff_t difference_type;
      typedef ::std::_Bit_reference reference;
      typedef bool const_reference;
      typedef ::std::_Bit_reference *pointer;
      typedef const bool *const_pointer;
      typedef ::std::_Bit_iterator iterator;
      typedef ::std::_Bit_const_iterator const_iterator;
      typedef ::std::reverse_iterator<typename ::std::vector<bool, _Alloc>::const_iterator> const_reverse_iterator;
      typedef ::std::reverse_iterator<typename ::std::vector<bool, _Alloc>::iterator> reverse_iterator;
      typedef _Alloc allocator_type;
      inline typename ::std::vector<bool, _Alloc>::allocator_type get_allocator() const 
      {
        return _Base::get_allocator();
      }
    protected:
      using ::std::_Bvector_base<_Alloc>::_M_allocate;
      using ::std::_Bvector_base<_Alloc>::_M_deallocate;
      using ::std::_Bvector_base<_Alloc>::_S_nword;
      using ::std::_Bvector_base<_Alloc>::_M_get_Bit_allocator;
    public:
      inline vector()
        : _Base()
      {
      }
      inline explicit vector(const typename ::std::vector<bool, _Alloc>::allocator_type &__a)
        : _Base(__a)
      {
      }
      inline explicit vector(typename ::std::vector<bool, _Alloc>::size_type __n, const bool &__value  = bool(), const typename ::std::vector<bool, _Alloc>::allocator_type &__a  = typename ::std::vector<bool, _Alloc>::allocator_type())
        : _Base(__a)
      {
        _M_initialize(__n);
        std::fill(this->_M_impl._M_start._M_p, this->_M_impl._M_end_of_storage, __value ? ~0 : 0);
      }
      inline vector(const ::std::vector<bool, _Alloc> &__x)
        : _Base(__x._M_get_Bit_allocator())
      {
        _M_initialize(__x.size());
        _M_copy_aligned(__x.begin(), __x.end(), this->_M_impl._M_start);
      }
      template < typename _InputIterator >
      inline vector(_InputIterator __first, _InputIterator __last, const typename ::std::vector<bool, _Alloc>::allocator_type &__a  = typename ::std::vector<bool, _Alloc>::allocator_type())
        : _Base(__a)
      {
        typedef typename ::std::__is_integer<_InputIterator>::__type _Integral;
        _M_initialize_dispatch(__first, __last, _Integral());
      }
      inline ~vector()
      {
      }
      inline ::std::vector<bool, _Alloc> &operator =(const ::std::vector<bool, _Alloc> &__x)
      {
        if (&__x == this)
          {
            return *this;
          }
        if (__x.size() > capacity())
          {
            this->_M_deallocate();
            _M_initialize(__x.size());
          }
        this->_M_impl._M_finish = _M_copy_aligned(__x.begin(), __x.end(), begin());
        return *this;
      }
      inline void assign(typename ::std::vector<bool, _Alloc>::size_type __n, const bool &__x)
      {
        _M_fill_assign(__n, __x);
      }
      template < typename _InputIterator >
      inline void assign(_InputIterator __first, _InputIterator __last)
      {
        typedef typename ::std::__is_integer<_InputIterator>::__type _Integral;
        _M_assign_dispatch(__first, __last, _Integral());
      }
      inline typename ::std::vector<bool, _Alloc>::iterator begin()
      {
        return this->_M_impl._M_start;
      }
      inline typename ::std::vector<bool, _Alloc>::const_iterator begin() const 
      {
        return this->_M_impl._M_start;
      }
      inline typename ::std::vector<bool, _Alloc>::iterator end()
      {
        return this->_M_impl._M_finish;
      }
      inline typename ::std::vector<bool, _Alloc>::const_iterator end() const 
      {
        return this->_M_impl._M_finish;
      }
      inline typename ::std::vector<bool, _Alloc>::reverse_iterator rbegin()
      {
        return reverse_iterator(end());
      }
      inline typename ::std::vector<bool, _Alloc>::const_reverse_iterator rbegin() const 
      {
        return const_reverse_iterator(end());
      }
      inline typename ::std::vector<bool, _Alloc>::reverse_iterator rend()
      {
        return reverse_iterator(begin());
      }
      inline typename ::std::vector<bool, _Alloc>::const_reverse_iterator rend() const 
      {
        return const_reverse_iterator(begin());
      }
      inline typename ::std::vector<bool, _Alloc>::size_type size() const 
      {
        return size_type(end() - begin());
      }
      inline typename ::std::vector<bool, _Alloc>::size_type max_size() const 
      {
        const typename ::std::vector<bool, _Alloc>::size_type __isize = __gnu_cxx::__numeric_traits<typename ::std::vector<bool, _Alloc>::difference_type>::__max - (int)::std::_S_word_bit + 1;
        const typename ::std::vector<bool, _Alloc>::size_type __asize = _M_get_Bit_allocator().max_size();
        return __asize <= __isize / (int)::std::_S_word_bit ? __asize * (int)::std::_S_word_bit : __isize;
      }
      inline typename ::std::vector<bool, _Alloc>::size_type capacity() const 
      {
        return size_type(const_iterator(this->_M_impl._M_end_of_storage, 0) - begin());
      }
      inline bool empty() const 
      {
        return begin() == end();
      }
      inline typename ::std::vector<bool, _Alloc>::reference operator [](typename ::std::vector<bool, _Alloc>::size_type __n)
      {
        return *iterator(this->_M_impl._M_start._M_p + __n / (int)::std::_S_word_bit, __n % (int)::std::_S_word_bit);
      }
      inline typename ::std::vector<bool, _Alloc>::const_reference operator [](typename ::std::vector<bool, _Alloc>::size_type __n) const 
      {
        return *const_iterator(this->_M_impl._M_start._M_p + __n / (int)::std::_S_word_bit, __n % (int)::std::_S_word_bit);
      }
    protected:
      inline void _M_range_check(typename ::std::vector<bool, _Alloc>::size_type __n) const 
      {
        if (__n >= this->size())
          {
            ::std::__throw_out_of_range("vector<bool>::_M_range_check");
          }
      }
    public:
      inline typename ::std::vector<bool, _Alloc>::reference at(typename ::std::vector<bool, _Alloc>::size_type __n)
      {
        _M_range_check(__n);
        return (*this)[__n];
      }
      inline typename ::std::vector<bool, _Alloc>::const_reference at(typename ::std::vector<bool, _Alloc>::size_type __n) const 
      {
        _M_range_check(__n);
        return (*this)[__n];
      }
      inline void reserve(typename ::std::vector<bool, _Alloc>::size_type __n)
      {
        if (__n > max_size())
          {
            ::std::__throw_length_error("vector::reserve");
          }
        if (capacity() < __n)
          {
            _M_reallocate(__n);
          }
      }
      inline typename ::std::vector<bool, _Alloc>::reference front()
      {
        return *begin();
      }
      inline typename ::std::vector<bool, _Alloc>::const_reference front() const 
      {
        return *begin();
      }
      inline typename ::std::vector<bool, _Alloc>::reference back()
      {
        return *(end() - 1);
      }
      inline typename ::std::vector<bool, _Alloc>::const_reference back() const 
      {
        return *(end() - 1);
      }
      inline void data()
      {
      }
      inline void push_back(bool __x)
      {
        if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage)
          {
            *this->_M_impl._M_finish++ = __x;
          }
        else
          {
            _M_insert_aux(end(), __x);
          }
      }
      inline void swap(::std::vector<bool, _Alloc> &__x)
      {
        std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
        std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
        std::swap(this->_M_impl._M_end_of_storage, __x._M_impl._M_end_of_storage);
        std::__alloc_swap<typename ::std::_Bvector_base<_Alloc>::_Bit_alloc_type>::_S_do_it(_M_get_Bit_allocator(), __x._M_get_Bit_allocator());
      }
      static inline void swap(typename ::std::vector<bool, _Alloc>::reference __x, typename ::std::vector<bool, _Alloc>::reference __y)
      {
        bool __tmp = __x;
        __x = __y;
        __y = __tmp;
      }
      inline typename ::std::vector<bool, _Alloc>::iterator insert(typename ::std::vector<bool, _Alloc>::iterator __position, const bool &__x  = bool())
      {
        const typename ::std::vector<bool, _Alloc>::difference_type __n = __position - begin();
        if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage && __position == end())
          {
            *this->_M_impl._M_finish++ = __x;
          }
        else
          {
            _M_insert_aux(__position, __x);
          }
        return begin() + __n;
      }
      template < typename _InputIterator >
      inline void insert(typename ::std::vector<bool, _Alloc>::iterator __position, _InputIterator __first, _InputIterator __last)
      {
        typedef typename ::std::__is_integer<_InputIterator>::__type _Integral;
        _M_insert_dispatch(__position, __first, __last, _Integral());
      }
      inline void insert(typename ::std::vector<bool, _Alloc>::iterator __position, typename ::std::vector<bool, _Alloc>::size_type __n, const bool &__x)
      {
        _M_fill_insert(__position, __n, __x);
      }
      inline void pop_back()
      {
        --this->_M_impl._M_finish;
      }
      inline typename ::std::vector<bool, _Alloc>::iterator erase(typename ::std::vector<bool, _Alloc>::iterator __position)
      {
        if (__position + 1 != end())
          {
            std::copy(__position + 1, end(), __position);
          }
        --this->_M_impl._M_finish;
        return __position;
      }
      inline typename ::std::vector<bool, _Alloc>::iterator erase(typename ::std::vector<bool, _Alloc>::iterator __first, typename ::std::vector<bool, _Alloc>::iterator __last)
      {
        if (__first != __last)
          {
            _M_erase_at_end(std::copy(__last, end(), __first));
          }
        return __first;
      }
      inline void resize(typename ::std::vector<bool, _Alloc>::size_type __new_size, bool __x  = bool())
      {
        if (__new_size < size())
          {
            _M_erase_at_end(begin() + difference_type(__new_size));
          }
        else
          {
            insert(end(), __new_size - size(), __x);
          }
      }
      inline void flip()
      {
        for (::std::_Bit_type *__p = this->_M_impl._M_start._M_p; __p != this->_M_impl._M_end_of_storage; ++__p)
          {
            *__p = ~*__p;
          }
      }
      inline void clear()
      {
        _M_erase_at_end(begin());
      }
    protected:
      inline typename ::std::vector<bool, _Alloc>::iterator _M_copy_aligned(typename ::std::vector<bool, _Alloc>::const_iterator __first, typename ::std::vector<bool, _Alloc>::const_iterator __last, typename ::std::vector<bool, _Alloc>::iterator __result)
      {
        ::std::_Bit_type *__q(std::copy(__first._M_p, __last._M_p, __result._M_p));
        return std::copy(const_iterator(__last._M_p, 0), __last, typename ::std::vector<bool, _Alloc>::iterator(__q, 0));
      }
      inline void _M_initialize(typename ::std::vector<bool, _Alloc>::size_type __n)
      {
        ::std::_Bit_type *__q(this->_M_allocate(__n));
        this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
        this->_M_impl._M_start = typename ::std::vector<bool, _Alloc>::iterator(__q, 0);
        this->_M_impl._M_finish = this->_M_impl._M_start + difference_type(__n);
      }
      void _M_reallocate(typename ::std::vector<bool, _Alloc>::size_type __n);
      template < typename _Integer >
      inline void _M_initialize_dispatch(_Integer __n, _Integer __x, ::std::__true_type)
      {
        _M_initialize(static_cast<typename ::std::vector<bool, _Alloc>::size_type>(__n));
        std::fill(this->_M_impl._M_start._M_p, this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
      }
      template < typename _InputIterator >
      inline void _M_initialize_dispatch(_InputIterator __first, _InputIterator __last, ::std::__false_type)
      {
        _M_initialize_range(__first, __last, std::__iterator_category(__first));
      }
      template < typename _InputIterator >
      inline void _M_initialize_range(_InputIterator __first, _InputIterator __last, ::std::input_iterator_tag)
      {
        for (; __first != __last; ++__first)
          {
            push_back(*__first);
          }
      }
      template < typename _ForwardIterator >
      inline void _M_initialize_range(_ForwardIterator __first, _ForwardIterator __last, ::std::forward_iterator_tag)
      {
        const typename ::std::vector<bool, _Alloc>::size_type __n = std::distance(__first, __last);
        _M_initialize(__n);
        std::copy(__first, __last, this->_M_impl._M_start);
      }
      template < typename _Integer >
      inline void _M_assign_dispatch(_Integer __n, _Integer __val, ::std::__true_type)
      {
        _M_fill_assign(__n, __val);
      }
      template < typename _InputIterator >
      inline void _M_assign_dispatch(_InputIterator __first, _InputIterator __last, ::std::__false_type)
      {
        _M_assign_aux(__first, __last, std::__iterator_category(__first));
      }
      inline void _M_fill_assign(::std::size_t __n, bool __x)
      {
        if (__n > size())
          {
            std::fill(this->_M_impl._M_start._M_p, this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
            insert(end(), __n - size(), __x);
          }
        else
          {
            _M_erase_at_end(begin() + __n);
            std::fill(this->_M_impl._M_start._M_p, this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
          }
      }
      template < typename _InputIterator >
      inline void _M_assign_aux(_InputIterator __first, _InputIterator __last, ::std::input_iterator_tag)
      {
        typename ::std::vector<bool, _Alloc>::iterator __cur = begin();
        for (; __first != __last && __cur != end(); (++__cur, ++__first))
          {
            *__cur = *__first;
          }
        if (__first == __last)
          {
            _M_erase_at_end(__cur);
          }
        else
          {
            insert(end(), __first, __last);
          }
      }
      template < typename _ForwardIterator >
      inline void _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last, ::std::forward_iterator_tag)
      {
        const typename ::std::vector<bool, _Alloc>::size_type __len = std::distance(__first, __last);
        if (__len < size())
          {
            _M_erase_at_end(std::copy(__first, __last, begin()));
          }
        else
          {
            _ForwardIterator __mid = __first;
            std::advance(__mid, size());
            std::copy(__first, __mid, begin());
            insert(end(), __mid, __last);
          }
      }
      template < typename _Integer >
      inline void _M_insert_dispatch(typename ::std::vector<bool, _Alloc>::iterator __pos, _Integer __n, _Integer __x, ::std::__true_type)
      {
        _M_fill_insert(__pos, __n, __x);
      }
      template < typename _InputIterator >
      inline void _M_insert_dispatch(typename ::std::vector<bool, _Alloc>::iterator __pos, _InputIterator __first, _InputIterator __last, ::std::__false_type)
      {
        _M_insert_range(__pos, __first, __last, std::__iterator_category(__first));
      }
      void _M_fill_insert(typename ::std::vector<bool, _Alloc>::iterator __position, typename ::std::vector<bool, _Alloc>::size_type __n, bool __x);
      template < typename _InputIterator >
      inline void _M_insert_range(typename ::std::vector<bool, _Alloc>::iterator __pos, _InputIterator __first, _InputIterator __last, ::std::input_iterator_tag)
      {
        for (; __first != __last; ++__first)
          {
            __pos = insert(__pos, *__first);
            ++__pos;
          }
      }
      template < typename _ForwardIterator >
      void _M_insert_range(typename ::std::vector<bool, _Alloc>::iterator __position, _ForwardIterator __first, _ForwardIterator __last, ::std::forward_iterator_tag);
      void _M_insert_aux(typename ::std::vector<bool, _Alloc>::iterator __position, bool __x);
      inline typename ::std::vector<bool, _Alloc>::size_type _M_check_len(typename ::std::vector<bool, _Alloc>::size_type __n, const char *__s) const 
      {
        if (max_size() - size() < __n)
          {
            ::std::__throw_length_error(__s);
          }
        const typename ::std::vector<bool, _Alloc>::size_type __len = size() + std::max(size(), __n);
        return __len < size() || __len > max_size() ? max_size() : __len;
      }
      inline void _M_erase_at_end(typename ::std::vector<bool, _Alloc>::iterator __pos)
      {
        this->_M_impl._M_finish = __pos;
      }
  };
  template < typename _Tp, typename _Alloc >
  void vector<_Tp, _Alloc>::reserve(typename ::std::vector<_Tp, _Alloc>::size_type __n)
  {
    if (__n > this->max_size())
      {
        ::std::__throw_length_error("vector::reserve");
      }
    if (this->capacity() < __n)
      {
        const typename ::std::vector<_Tp, _Alloc>::size_type __old_size = size();
        typename ::std::vector<_Tp, _Alloc>::pointer __tmp = _M_allocate_and_copy(__n, this->_M_impl._M_start, this->_M_impl._M_finish);
        std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
        _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
        this->_M_impl._M_start = __tmp;
        this->_M_impl._M_finish = __tmp + __old_size;
        this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
      }
  }
  template < typename _Tp, typename _Alloc >
  typename ::std::vector<_Tp, _Alloc>::iterator vector<_Tp, _Alloc>::insert(typename ::std::vector<_Tp, _Alloc>::iterator __position, const typename ::std::vector<_Tp, _Alloc>::value_type &__x)
  {
    const typename ::std::vector<_Tp, _Alloc>::size_type __n = __position - begin();
    if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage && __position == end())
      {
        _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, __x);
        ++this->_M_impl._M_finish;
      }
    else
      {
        _M_insert_aux(__position, __x);
      }
    return iterator(this->_M_impl._M_start + __n);
  }
  template < typename _Tp, typename _Alloc >
  typename ::std::vector<_Tp, _Alloc>::iterator vector<_Tp, _Alloc>::erase(typename ::std::vector<_Tp, _Alloc>::iterator __position)
  {
    if (__position + 1 != end())
      {
        std::copy(__position + 1, end(), __position);
      }
    --this->_M_impl._M_finish;
    _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
    return __position;
  }
  template < typename _Tp, typename _Alloc >
  typename ::std::vector<_Tp, _Alloc>::iterator vector<_Tp, _Alloc>::erase(typename ::std::vector<_Tp, _Alloc>::iterator __first, typename ::std::vector<_Tp, _Alloc>::iterator __last)
  {
    if (__first != __last)
      {
        if (__last != end())
          {
            std::copy(__last, end(), __first);
          }
        _M_erase_at_end(__first.base() + (end() - __last));
      }
    return __first;
  }
  template < typename _Tp, typename _Alloc >
  ::std::vector<_Tp, _Alloc> &vector<_Tp, _Alloc>::operator =(const ::std::vector<_Tp, _Alloc> &__x)
  {
    if (&__x != this)
      {
        const typename ::std::vector<_Tp, _Alloc>::size_type __xlen = __x.size();
        if (__xlen > capacity())
          {
            typename ::std::vector<_Tp, _Alloc>::pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(), __x.end());
            std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
            _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
            this->_M_impl._M_start = __tmp;
            this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __xlen;
          }
        else
          {
            if (size() >= __xlen)
              {
                std::_Destroy(std::copy(__x.begin(), __x.end(), begin()), end(), _M_get_Tp_allocator());
              }
            else
              {
                std::copy(__x._M_impl._M_start, __x._M_impl._M_start + size(), this->_M_impl._M_start);
                std::__uninitialized_copy_a(__x._M_impl._M_start + size(), __x._M_impl._M_finish, this->_M_impl._M_finish, _M_get_Tp_allocator());
              }
          }
        this->_M_impl._M_finish = this->_M_impl._M_start + __xlen;
      }
    return *this;
  }
  template < typename _Tp, typename _Alloc >
  void vector<_Tp, _Alloc>::_M_fill_assign(::std::size_t __n, const typename ::std::vector<_Tp, _Alloc>::value_type &__val)
  {
    if (__n > capacity())
      {
        ::std::vector<_Tp, _Alloc> __tmp(__n, __val, _M_get_Tp_allocator());
        __tmp.swap(*this);
      }
    else
      {
        if (__n > size())
          {
            std::fill(begin(), end(), __val);
            std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - size(), __val, _M_get_Tp_allocator());
            this->_M_impl._M_finish += __n - size();
          }
        else
          {
            _M_erase_at_end(std::fill_n(this->_M_impl._M_start, __n, __val));
          }
      }
  }
  template < typename _Tp, typename _Alloc >
  template < typename _InputIterator >
  void vector<_Tp, _Alloc>::_M_assign_aux(_InputIterator __first, _InputIterator __last, ::std::input_iterator_tag)
  {
    typename ::std::vector<_Tp, _Alloc>::pointer __cur(this->_M_impl._M_start);
    for (; __first != __last && __cur != this->_M_impl._M_finish; (++__cur, ++__first))
      {
        *__cur = *__first;
      }
    if (__first == __last)
      {
        _M_erase_at_end(__cur);
      }
    else
      {
        insert(end(), __first, __last);
      }
  }
  template < typename _Tp, typename _Alloc >
  template < typename _ForwardIterator >
  void vector<_Tp, _Alloc>::_M_assign_aux(_ForwardIterator __first, _ForwardIterator __last, ::std::forward_iterator_tag)
  {
    const typename ::std::vector<_Tp, _Alloc>::size_type __len = std::distance(__first, __last);
    if (__len > capacity())
      {
        typename ::std::vector<_Tp, _Alloc>::pointer __tmp(_M_allocate_and_copy(__len, __first, __last));
        std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
        _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
        this->_M_impl._M_start = __tmp;
        this->_M_impl._M_finish = this->_M_impl._M_start + __len;
        this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
      }
    else
      {
        if (size() >= __len)
          {
            _M_erase_at_end(std::copy(__first, __last, this->_M_impl._M_start));
          }
        else
          {
            _ForwardIterator __mid = __first;
            std::advance(__mid, size());
            std::copy(__first, __mid, this->_M_impl._M_start);
            this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
          }
      }
  }
  template < typename _Tp, typename _Alloc >
  void vector<_Tp, _Alloc>::_M_insert_aux(typename ::std::vector<_Tp, _Alloc>::iterator __position, const _Tp &__x)
  {
    if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
      {
        _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, *(this->_M_impl._M_finish - 1));
        ++this->_M_impl._M_finish;
        _Tp __x_copy = __x;
        std::copy_backward(__position.base(), this->_M_impl._M_finish - 2, this->_M_impl._M_finish - 1);
        *__position = __x_copy;
      }
    else
      {
        const typename ::std::vector<_Tp, _Alloc>::size_type __len = _M_check_len(typename ::std::vector<_Tp, _Alloc>::size_type(1), "vector::_M_insert_aux");
        const typename ::std::vector<_Tp, _Alloc>::size_type __elems_before = __position - begin();
        typename ::std::vector<_Tp, _Alloc>::pointer __new_start(this->_M_allocate(__len));
        typename ::std::vector<_Tp, _Alloc>::pointer __new_finish(__new_start);
        try
        {
          _Alloc_traits::construct(this->_M_impl, __new_start + __elems_before, __x);
          __new_finish = 0;
          __new_finish = std::__uninitialized_move_if_noexcept_a(this->_M_impl._M_start, __position.base(), __new_start, _M_get_Tp_allocator());
          ++__new_finish;
          __new_finish = std::__uninitialized_move_if_noexcept_a(__position.base(), this->_M_impl._M_finish, __new_finish, _M_get_Tp_allocator());
        }
        catch (...)
        {
          if (!__new_finish)
            {
              _Alloc_traits::destroy(this->_M_impl, __new_start + __elems_before);
            }
          else
            {
              std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
            }
          _M_deallocate(__new_start, __len);
          throw;
        }
        std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
        _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
        this->_M_impl._M_start = __new_start;
        this->_M_impl._M_finish = __new_finish;
        this->_M_impl._M_end_of_storage = __new_start + __len;
      }
  }
  template < typename _Tp, typename _Alloc >
  void vector<_Tp, _Alloc>::_M_fill_insert(typename ::std::vector<_Tp, _Alloc>::iterator __position, typename ::std::vector<_Tp, _Alloc>::size_type __n, const typename ::std::vector<_Tp, _Alloc>::value_type &__x)
  {
    if (__n != 0)
      {
        if (size_type(this->_M_impl._M_end_of_storage - this->_M_impl._M_finish) >= __n)
          {
            typename ::std::vector<_Tp, _Alloc>::value_type __x_copy = __x;
            const typename ::std::vector<_Tp, _Alloc>::size_type __elems_after = end() - __position;
            typename ::std::vector<_Tp, _Alloc>::pointer __old_finish(this->_M_impl._M_finish);
            if (__elems_after > __n)
              {
                std::__uninitialized_move_a(this->_M_impl._M_finish - __n, this->_M_impl._M_finish, this->_M_impl._M_finish, _M_get_Tp_allocator());
                this->_M_impl._M_finish += __n;
                std::copy_backward(__position.base(), __old_finish - __n, __old_finish);
                std::fill(__position.base(), __position.base() + __n, __x_copy);
              }
            else
              {
                std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - __elems_after, __x_copy, _M_get_Tp_allocator());
                this->_M_impl._M_finish += __n - __elems_after;
                std::__uninitialized_move_a(__position.base(), __old_finish, this->_M_impl._M_finish, _M_get_Tp_allocator());
                this->_M_impl._M_finish += __elems_after;
                std::fill(__position.base(), __old_finish, __x_copy);
              }
          }
        else
          {
            const typename ::std::vector<_Tp, _Alloc>::size_type __len = _M_check_len(__n, "vector::_M_fill_insert");
            const typename ::std::vector<_Tp, _Alloc>::size_type __elems_before = __position - begin();
            typename ::std::vector<_Tp, _Alloc>::pointer __new_start(this->_M_allocate(__len));
            typename ::std::vector<_Tp, _Alloc>::pointer __new_finish(__new_start);
            try
            {
              std::__uninitialized_fill_n_a(__new_start + __elems_before, __n, __x, _M_get_Tp_allocator());
              __new_finish = 0;
              __new_finish = std::__uninitialized_move_if_noexcept_a(this->_M_impl._M_start, __position.base(), __new_start, _M_get_Tp_allocator());
              __new_finish += __n;
              __new_finish = std::__uninitialized_move_if_noexcept_a(__position.base(), this->_M_impl._M_finish, __new_finish, _M_get_Tp_allocator());
            }
            catch (...)
            {
              if (!__new_finish)
                {
                  std::_Destroy(__new_start + __elems_before, __new_start + __elems_before + __n, _M_get_Tp_allocator());
                }
              else
                {
                  std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
                }
              _M_deallocate(__new_start, __len);
              throw;
            }
            std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
            _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
            this->_M_impl._M_start = __new_start;
            this->_M_impl._M_finish = __new_finish;
            this->_M_impl._M_end_of_storage = __new_start + __len;
          }
      }
  }
  template < typename _Tp, typename _Alloc >
  template < typename _InputIterator >
  void vector<_Tp, _Alloc>::_M_range_insert(typename ::std::vector<_Tp, _Alloc>::iterator __pos, _InputIterator __first, _InputIterator __last, ::std::input_iterator_tag)
  {
    for (; __first != __last; ++__first)
      {
        __pos = insert(__pos, *__first);
        ++__pos;
      }
  }
  template < typename _Tp, typename _Alloc >
  template < typename _ForwardIterator >
  void vector<_Tp, _Alloc>::_M_range_insert(typename ::std::vector<_Tp, _Alloc>::iterator __position, _ForwardIterator __first, _ForwardIterator __last, ::std::forward_iterator_tag)
  {
    if (__first != __last)
      {
        const typename ::std::vector<_Tp, _Alloc>::size_type __n = std::distance(__first, __last);
        if (size_type(this->_M_impl._M_end_of_storage - this->_M_impl._M_finish) >= __n)
          {
            const typename ::std::vector<_Tp, _Alloc>::size_type __elems_after = end() - __position;
            typename ::std::vector<_Tp, _Alloc>::pointer __old_finish(this->_M_impl._M_finish);
            if (__elems_after > __n)
              {
                std::__uninitialized_move_a(this->_M_impl._M_finish - __n, this->_M_impl._M_finish, this->_M_impl._M_finish, _M_get_Tp_allocator());
                this->_M_impl._M_finish += __n;
                std::copy_backward(__position.base(), __old_finish - __n, __old_finish);
                std::copy(__first, __last, __position);
              }
            else
              {
                _ForwardIterator __mid = __first;
                std::advance(__mid, __elems_after);
                std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
                this->_M_impl._M_finish += __n - __elems_after;
                std::__uninitialized_move_a(__position.base(), __old_finish, this->_M_impl._M_finish, _M_get_Tp_allocator());
                this->_M_impl._M_finish += __elems_after;
                std::copy(__first, __mid, __position);
              }
          }
        else
          {
            const typename ::std::vector<_Tp, _Alloc>::size_type __len = _M_check_len(__n, "vector::_M_range_insert");
            typename ::std::vector<_Tp, _Alloc>::pointer __new_start(this->_M_allocate(__len));
            typename ::std::vector<_Tp, _Alloc>::pointer __new_finish(__new_start);
            try
            {
              __new_finish = std::__uninitialized_move_if_noexcept_a(this->_M_impl._M_start, __position.base(), __new_start, _M_get_Tp_allocator());
              __new_finish = std::__uninitialized_copy_a(__first, __last, __new_finish, _M_get_Tp_allocator());
              __new_finish = std::__uninitialized_move_if_noexcept_a(__position.base(), this->_M_impl._M_finish, __new_finish, _M_get_Tp_allocator());
            }
            catch (...)
            {
              std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
              _M_deallocate(__new_start, __len);
              throw;
            }
            std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
            _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
            this->_M_impl._M_start = __new_start;
            this->_M_impl._M_finish = __new_finish;
            this->_M_impl._M_end_of_storage = __new_start + __len;
          }
      }
  }
  template < typename _Alloc >
  void vector<bool, _Alloc>::_M_reallocate(typename ::std::vector<bool, _Alloc>::size_type __n)
  {
    ::std::_Bit_type *__q(this->_M_allocate(__n));
    this->_M_impl._M_finish = _M_copy_aligned(begin(), end(), typename ::std::vector<bool, _Alloc>::iterator(__q, 0));
    this->_M_deallocate();
    this->_M_impl._M_start = typename ::std::vector<bool, _Alloc>::iterator(__q, 0);
    this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
  }
  template < typename _Alloc >
  void vector<bool, _Alloc>::_M_fill_insert(typename ::std::vector<bool, _Alloc>::iterator __position, typename ::std::vector<bool, _Alloc>::size_type __n, bool __x)
  {
    if (__n == 0)
      {
        return ;
      }
    if (capacity() - size() >= __n)
      {
        std::copy_backward(__position, end(), this->_M_impl._M_finish + difference_type(__n));
        std::fill(__position, __position + difference_type(__n), __x);
        this->_M_impl._M_finish += difference_type(__n);
      }
    else
      {
        const typename ::std::vector<bool, _Alloc>::size_type __len = _M_check_len(__n, "vector<bool>::_M_fill_insert");
        ::std::_Bit_type *__q(this->_M_allocate(__len));
        typename ::std::vector<bool, _Alloc>::iterator __i = _M_copy_aligned(begin(), __position, typename ::std::vector<bool, _Alloc>::iterator(__q, 0));
        std::fill(__i, __i + difference_type(__n), __x);
        this->_M_impl._M_finish = std::copy(__position, end(), __i + difference_type(__n));
        this->_M_deallocate();
        this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
        this->_M_impl._M_start = typename ::std::vector<bool, _Alloc>::iterator(__q, 0);
      }
  }
  template < typename _Alloc >
  template < typename _ForwardIterator >
  void vector<bool, _Alloc>::_M_insert_range(typename ::std::vector<bool, _Alloc>::iterator __position, _ForwardIterator __first, _ForwardIterator __last, ::std::forward_iterator_tag)
  {
    if (__first != __last)
      {
        typename ::std::vector<bool, _Alloc>::size_type __n = std::distance(__first, __last);
        if (capacity() - size() >= __n)
          {
            std::copy_backward(__position, end(), this->_M_impl._M_finish + difference_type(__n));
            std::copy(__first, __last, __position);
            this->_M_impl._M_finish += difference_type(__n);
          }
        else
          {
            const typename ::std::vector<bool, _Alloc>::size_type __len = _M_check_len(__n, "vector<bool>::_M_insert_range");
            ::std::_Bit_type *__q(this->_M_allocate(__len));
            typename ::std::vector<bool, _Alloc>::iterator __i = _M_copy_aligned(begin(), __position, typename ::std::vector<bool, _Alloc>::iterator(__q, 0));
            __i = std::copy(__first, __last, __i);
            this->_M_impl._M_finish = std::copy(__position, end(), __i);
            this->_M_deallocate();
            this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
            this->_M_impl._M_start = typename ::std::vector<bool, _Alloc>::iterator(__q, 0);
          }
      }
  }
  template < typename _Alloc >
  void vector<bool, _Alloc>::_M_insert_aux(typename ::std::vector<bool, _Alloc>::iterator __position, bool __x)
  {
    if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage)
      {
        std::copy_backward(__position, this->_M_impl._M_finish, this->_M_impl._M_finish + 1);
        *__position = __x;
        ++this->_M_impl._M_finish;
      }
    else
      {
        const typename ::std::vector<bool, _Alloc>::size_type __len = _M_check_len(typename ::std::vector<bool, _Alloc>::size_type(1), "vector<bool>::_M_insert_aux");
        ::std::_Bit_type *__q(this->_M_allocate(__len));
        typename ::std::vector<bool, _Alloc>::iterator __i = _M_copy_aligned(begin(), __position, typename ::std::vector<bool, _Alloc>::iterator(__q, 0));
        *__i++ = __x;
        this->_M_impl._M_finish = std::copy(__position, end(), __i);
        this->_M_deallocate();
        this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
        this->_M_impl._M_start = typename ::std::vector<bool, _Alloc>::iterator(__q, 0);
      }
  }
  enum _Rb_tree_color
  {
    _S_red = false,
    _S_black = true
  };
  struct  _Rb_tree_node_base
  {
      typedef ::std::_Rb_tree_node_base *_Base_ptr;
      typedef const ::std::_Rb_tree_node_base *_Const_Base_ptr;
      ::std::_Rb_tree_color _M_color;
      ::std::_Rb_tree_node_base::_Base_ptr _M_parent;
      ::std::_Rb_tree_node_base::_Base_ptr _M_left;
      ::std::_Rb_tree_node_base::_Base_ptr _M_right;
      static inline ::std::_Rb_tree_node_base::_Base_ptr _S_minimum(::std::_Rb_tree_node_base::_Base_ptr __x)
      {
        while ((*__x)._M_left != 0)
          {
            __x = (*__x)._M_left;
          }
        return __x;
      }
      static inline ::std::_Rb_tree_node_base::_Const_Base_ptr _S_minimum(::std::_Rb_tree_node_base::_Const_Base_ptr __x)
      {
        while ((*__x)._M_left != 0)
          {
            __x = (*__x)._M_left;
          }
        return __x;
      }
      static inline ::std::_Rb_tree_node_base::_Base_ptr _S_maximum(::std::_Rb_tree_node_base::_Base_ptr __x)
      {
        while ((*__x)._M_right != 0)
          {
            __x = (*__x)._M_right;
          }
        return __x;
      }
      static inline ::std::_Rb_tree_node_base::_Const_Base_ptr _S_maximum(::std::_Rb_tree_node_base::_Const_Base_ptr __x)
      {
        while ((*__x)._M_right != 0)
          {
            __x = (*__x)._M_right;
          }
        return __x;
      }
  };
  template < typename _Val >
  struct  _Rb_tree_node : ::std::_Rb_tree_node_base
  {
      typedef ::std::_Rb_tree_node<_Val> *_Link_type;
      _Val _M_value_field;
  };
  ::std::_Rb_tree_node_base *_Rb_tree_increment(::std::_Rb_tree_node_base *__x) throw()__attribute__((__pure__));
  const ::std::_Rb_tree_node_base *_Rb_tree_increment(const ::std::_Rb_tree_node_base *__x) throw()__attribute__((__pure__));
  ::std::_Rb_tree_node_base *_Rb_tree_decrement(::std::_Rb_tree_node_base *__x) throw()__attribute__((__pure__));
  const ::std::_Rb_tree_node_base *_Rb_tree_decrement(const ::std::_Rb_tree_node_base *__x) throw()__attribute__((__pure__));
  template < typename _Tp >
  struct  _Rb_tree_iterator
  {
      typedef _Tp value_type;
      typedef _Tp &reference;
      typedef _Tp *pointer;
      typedef ::std::bidirectional_iterator_tag iterator_category;
      typedef ::std::ptrdiff_t difference_type;
      typedef ::std::_Rb_tree_iterator<_Tp> _Self;
      typedef ::std::_Rb_tree_node_base::_Base_ptr _Base_ptr;
      typedef ::std::_Rb_tree_node<_Tp> *_Link_type;
      inline _Rb_tree_iterator()
        : _M_node()
      {
      }
      inline explicit _Rb_tree_iterator(typename ::std::_Rb_tree_iterator<_Tp>::_Link_type __x)
        : _M_node(__x)
      {
      }
      inline typename ::std::_Rb_tree_iterator<_Tp>::reference operator *() const 
      {
        return static_cast<typename ::std::_Rb_tree_iterator<_Tp>::_Link_type>(_M_node)->_M_value_field;
      }
      inline typename ::std::_Rb_tree_iterator<_Tp>::pointer operator ->() const 
      {
        return std::__addressof(static_cast<typename ::std::_Rb_tree_iterator<_Tp>::_Link_type>(_M_node)->_M_value_field);
      }
      inline typename ::std::_Rb_tree_iterator<_Tp>::_Self &operator ++()
      {
        _M_node = _Rb_tree_increment(_M_node);
        return *this;
      }
      inline typename ::std::_Rb_tree_iterator<_Tp>::_Self operator ++(int)
      {
        typename ::std::_Rb_tree_iterator<_Tp>::_Self __tmp = *this;
        _M_node = _Rb_tree_increment(_M_node);
        return __tmp;
      }
      inline typename ::std::_Rb_tree_iterator<_Tp>::_Self &operator --()
      {
        _M_node = _Rb_tree_decrement(_M_node);
        return *this;
      }
      inline typename ::std::_Rb_tree_iterator<_Tp>::_Self operator --(int)
      {
        typename ::std::_Rb_tree_iterator<_Tp>::_Self __tmp = *this;
        _M_node = _Rb_tree_decrement(_M_node);
        return __tmp;
      }
      inline bool operator ==(const typename ::std::_Rb_tree_iterator<_Tp>::_Self &__x) const 
      {
        return _M_node == __x._M_node;
      }
      inline bool operator !=(const typename ::std::_Rb_tree_iterator<_Tp>::_Self &__x) const 
      {
        return _M_node != __x._M_node;
      }
      typename ::std::_Rb_tree_iterator<_Tp>::_Base_ptr _M_node;
  };
  template < typename _Tp >
  struct  _Rb_tree_const_iterator
  {
      typedef _Tp value_type;
      typedef const _Tp &reference;
      typedef const _Tp *pointer;
      typedef ::std::_Rb_tree_iterator<_Tp> iterator;
      typedef ::std::bidirectional_iterator_tag iterator_category;
      typedef ::std::ptrdiff_t difference_type;
      typedef ::std::_Rb_tree_const_iterator<_Tp> _Self;
      typedef ::std::_Rb_tree_node_base::_Const_Base_ptr _Base_ptr;
      typedef const ::std::_Rb_tree_node<_Tp> *_Link_type;
      inline _Rb_tree_const_iterator()
        : _M_node()
      {
      }
      inline explicit _Rb_tree_const_iterator(typename ::std::_Rb_tree_const_iterator<_Tp>::_Link_type __x)
        : _M_node(__x)
      {
      }
      inline _Rb_tree_const_iterator(const typename ::std::_Rb_tree_const_iterator<_Tp>::iterator &__it)
        : _M_node(__it._M_node)
      {
      }
      inline typename ::std::_Rb_tree_const_iterator<_Tp>::iterator _M_const_cast() const 
      {
        return typename ::std::_Rb_tree_const_iterator<_Tp>::iterator(static_cast<typename ::std::_Rb_tree_iterator<_Tp>::_Link_type>(const_cast<typename ::std::_Rb_tree_iterator<_Tp>::_Base_ptr>(_M_node)));
      }
      inline typename ::std::_Rb_tree_const_iterator<_Tp>::reference operator *() const 
      {
        return static_cast<typename ::std::_Rb_tree_const_iterator<_Tp>::_Link_type>(_M_node)->_M_value_field;
      }
      inline typename ::std::_Rb_tree_const_iterator<_Tp>::pointer operator ->() const 
      {
        return std::__addressof(static_cast<typename ::std::_Rb_tree_const_iterator<_Tp>::_Link_type>(_M_node)->_M_value_field);
      }
      inline typename ::std::_Rb_tree_const_iterator<_Tp>::_Self &operator ++()
      {
        _M_node = _Rb_tree_increment(_M_node);
        return *this;
      }
      inline typename ::std::_Rb_tree_const_iterator<_Tp>::_Self operator ++(int)
      {
        typename ::std::_Rb_tree_const_iterator<_Tp>::_Self __tmp = *this;
        _M_node = _Rb_tree_increment(_M_node);
        return __tmp;
      }
      inline typename ::std::_Rb_tree_const_iterator<_Tp>::_Self &operator --()
      {
        _M_node = _Rb_tree_decrement(_M_node);
        return *this;
      }
      inline typename ::std::_Rb_tree_const_iterator<_Tp>::_Self operator --(int)
      {
        typename ::std::_Rb_tree_const_iterator<_Tp>::_Self __tmp = *this;
        _M_node = _Rb_tree_decrement(_M_node);
        return __tmp;
      }
      inline bool operator ==(const typename ::std::_Rb_tree_const_iterator<_Tp>::_Self &__x) const 
      {
        return _M_node == __x._M_node;
      }
      inline bool operator !=(const typename ::std::_Rb_tree_const_iterator<_Tp>::_Self &__x) const 
      {
        return _M_node != __x._M_node;
      }
      typename ::std::_Rb_tree_const_iterator<_Tp>::_Base_ptr _M_node;
  };
  template < typename _Val >
  inline bool operator ==(const ::std::_Rb_tree_iterator<_Val> &__x, const ::std::_Rb_tree_const_iterator<_Val> &__y);
  template < typename _Val >
  inline bool operator ==(const ::std::_Rb_tree_iterator<_Val> &__x, const ::std::_Rb_tree_const_iterator<_Val> &__y)
  {
    return __x._M_node == __y._M_node;
  }
  template < typename _Val >
  inline bool operator !=(const ::std::_Rb_tree_iterator<_Val> &__x, const ::std::_Rb_tree_const_iterator<_Val> &__y);
  template < typename _Val >
  inline bool operator !=(const ::std::_Rb_tree_iterator<_Val> &__x, const ::std::_Rb_tree_const_iterator<_Val> &__y)
  {
    return __x._M_node != __y._M_node;
  }
  void _Rb_tree_insert_and_rebalance(const bool __insert_left, ::std::_Rb_tree_node_base *__x, ::std::_Rb_tree_node_base *__p, ::std::_Rb_tree_node_base &__header) throw();
  ::std::_Rb_tree_node_base *_Rb_tree_rebalance_for_erase(::std::_Rb_tree_node_base *const __z, ::std::_Rb_tree_node_base &__header) throw();
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc = ::std::allocator<_Val> >
  class  _Rb_tree
  {
    protected:
      template < typename _Key_compare, bool _Is_pod_comparator >
      struct _Rb_tree_impl;
    private:
      typedef typename _Alloc::template rebind< ::std::_Rb_tree_node<_Val> >::other _Node_allocator;
    protected:
      typedef ::std::_Rb_tree_node_base *_Base_ptr;
      typedef const ::std::_Rb_tree_node_base *_Const_Base_ptr;
    public:
      typedef _Key key_type;
      typedef _Val value_type;
      typedef typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::value_type *pointer;
      typedef const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::value_type *const_pointer;
      typedef typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::value_type &reference;
      typedef const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::value_type &const_reference;
      typedef ::std::_Rb_tree_node<_Val> *_Link_type;
      typedef const ::std::_Rb_tree_node<_Val> *_Const_Link_type;
      typedef ::std::size_t size_type;
      typedef ::std::ptrdiff_t difference_type;
      typedef _Alloc allocator_type;
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Node_allocator &_M_get_Node_allocator()
      {
        return *static_cast<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Node_allocator *>(&this->_M_impl);
      }
      inline const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Node_allocator &_M_get_Node_allocator() const 
      {
        return *static_cast<const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Node_allocator *>(&this->_M_impl);
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::allocator_type get_allocator() const 
      {
        return typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::allocator_type(_M_get_Node_allocator());
      }
    protected:
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type _M_get_node()
      {
        return _M_impl._Node_allocator::allocate(1);
      }
      inline void _M_put_node(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __p)
      {
        _M_impl._Node_allocator::deallocate(__p, 1);
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type _M_create_node(const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::value_type &__x)
      {
        typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __tmp = _M_get_node();
        try
        {
          get_allocator().construct(std::__addressof(__tmp->_M_value_field), __x);
        }
        catch (...)
        {
          _M_put_node(__tmp);
          throw;
        }
        return __tmp;
      }
      inline void _M_destroy_node(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __p)
      {
        get_allocator().destroy(std::__addressof(__p->_M_value_field));
        _M_put_node(__p);
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type _M_clone_node(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type __x)
      {
        typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __tmp = _M_create_node(__x->_M_value_field);
        __tmp->_M_color = __x->_M_color;
        __tmp->_M_left = 0;
        __tmp->_M_right = 0;
        return __tmp;
      }
      template < typename _Key_compare, bool _Is_pod_comparator = __is_pod(_Key_compare) >
      struct  _Rb_tree_impl : ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Node_allocator
      {
          _Key_compare _M_key_compare;
          ::std::_Rb_tree_node_base _M_header;
          typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type _M_node_count;
          inline _Rb_tree_impl()
            : _Node_allocator(), _M_key_compare(), _M_header(), _M_node_count(0)
          {
            _M_initialize();
          }
          inline _Rb_tree_impl(const _Key_compare &__comp, const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Node_allocator &__a)
            : _Node_allocator(__a), _M_key_compare(__comp), _M_header(), _M_node_count(0)
          {
            _M_initialize();
          }
        private:
          inline void _M_initialize()
          {
            this->_M_header._M_color = ::std::_S_red;
            this->_M_header._M_parent = 0;
            this->_M_header._M_left = &this->_M_header;
            this->_M_header._M_right = &this->_M_header;
          }
      };
      typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::template _Rb_tree_impl< _Compare, __is_pod(_Compare)> _M_impl;
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr &_M_root()
      {
        return this->_M_impl._M_header._M_parent;
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Base_ptr _M_root() const 
      {
        return this->_M_impl._M_header._M_parent;
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr &_M_leftmost()
      {
        return this->_M_impl._M_header._M_left;
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Base_ptr _M_leftmost() const 
      {
        return this->_M_impl._M_header._M_left;
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr &_M_rightmost()
      {
        return this->_M_impl._M_header._M_right;
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Base_ptr _M_rightmost() const 
      {
        return this->_M_impl._M_header._M_right;
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type _M_begin()
      {
        return static_cast<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type>(this->_M_impl._M_header._M_parent);
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type _M_begin() const 
      {
        return static_cast<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type>(this->_M_impl._M_header._M_parent);
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type _M_end()
      {
        return static_cast<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type>(&this->_M_impl._M_header);
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type _M_end() const 
      {
        return static_cast<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type>(&this->_M_impl._M_header);
      }
      static inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_reference _S_value(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type __x)
      {
        return __x->_M_value_field;
      }
      static inline const _Key &_S_key(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type __x)
      {
        return _KeyOfValue()(_S_value(__x));
      }
      static inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type _S_left(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr __x)
      {
        return static_cast<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type>(__x->_M_left);
      }
      static inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type _S_left(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Base_ptr __x)
      {
        return static_cast<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type>(__x->_M_left);
      }
      static inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type _S_right(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr __x)
      {
        return static_cast<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type>(__x->_M_right);
      }
      static inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type _S_right(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Base_ptr __x)
      {
        return static_cast<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type>(__x->_M_right);
      }
      static inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_reference _S_value(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Base_ptr __x)
      {
        return static_cast<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type>(__x)->_M_value_field;
      }
      static inline const _Key &_S_key(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Base_ptr __x)
      {
        return _KeyOfValue()(_S_value(__x));
      }
      static inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr _S_minimum(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr __x)
      {
        return _Rb_tree_node_base::_S_minimum(__x);
      }
      static inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Base_ptr _S_minimum(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Base_ptr __x)
      {
        return _Rb_tree_node_base::_S_minimum(__x);
      }
      static inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr _S_maximum(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr __x)
      {
        return _Rb_tree_node_base::_S_maximum(__x);
      }
      static inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Base_ptr _S_maximum(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Base_ptr __x)
      {
        return _Rb_tree_node_base::_S_maximum(__x);
      }
    public:
      typedef ::std::_Rb_tree_iterator<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::value_type> iterator;
      typedef ::std::_Rb_tree_const_iterator<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::value_type> const_iterator;
      typedef ::std::reverse_iterator<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator> reverse_iterator;
      typedef ::std::reverse_iterator<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator> const_reverse_iterator;
    private:
      typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator _M_insert_(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Base_ptr __x, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Base_ptr __p, const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::value_type &__v);
      typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator _M_insert_lower(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr __x, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr __p, const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::value_type &__v);
      typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator _M_insert_equal_lower(const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::value_type &__v);
      typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type _M_copy(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type __x, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __p);
      void _M_erase(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __x);
      typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator _M_lower_bound(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __x, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __y, const _Key &__k);
      typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator _M_lower_bound(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type __x, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type __y, const _Key &__k) const ;
      typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator _M_upper_bound(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __x, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __y, const _Key &__k);
      typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator _M_upper_bound(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type __x, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type __y, const _Key &__k) const ;
    public:
      inline _Rb_tree()
      {
      }
      inline _Rb_tree(const _Compare &__comp, const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::allocator_type &__a  = typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::allocator_type())
        : _M_impl(__comp, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Node_allocator(__a))
      {
      }
      inline _Rb_tree(const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__x)
        : _M_impl(__x._M_impl._M_key_compare, __x._M_get_Node_allocator())
      {
        if (__x._M_root() != 0)
          {
            _M_root() = _M_copy(__x._M_begin(), _M_end());
            _M_leftmost() = _S_minimum(_M_root());
            _M_rightmost() = _S_maximum(_M_root());
            _M_impl._M_node_count = __x._M_impl._M_node_count;
          }
      }
      inline ~_Rb_tree()
      {
        _M_erase(_M_begin());
      }
      ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &operator =(const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__x);
      inline _Compare key_comp() const 
      {
        return _M_impl._M_key_compare;
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator begin()
      {
        return typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator(static_cast<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type>(this->_M_impl._M_header._M_left));
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator begin() const 
      {
        return typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator(static_cast<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type>(this->_M_impl._M_header._M_left));
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator end()
      {
        return typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator(static_cast<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type>(&this->_M_impl._M_header));
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator end() const 
      {
        return typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator(static_cast<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type>(&this->_M_impl._M_header));
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::reverse_iterator rbegin()
      {
        return typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::reverse_iterator(end());
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_reverse_iterator rbegin() const 
      {
        return typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_reverse_iterator(end());
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::reverse_iterator rend()
      {
        return typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::reverse_iterator(begin());
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_reverse_iterator rend() const 
      {
        return typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_reverse_iterator(begin());
      }
      inline bool empty() const 
      {
        return _M_impl._M_node_count == 0;
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type size() const 
      {
        return _M_impl._M_node_count;
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type max_size() const 
      {
        return _M_get_Node_allocator().max_size();
      }
      void swap(::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__t);
      ::std::pair<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator, bool> _M_insert_unique(const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::value_type &__v);
      typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator _M_insert_equal(const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::value_type &__v);
      typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator _M_insert_unique_(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator __position, const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::value_type &__v);
      typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator _M_insert_equal_(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator __position, const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::value_type &__v);
      template < typename _InputIterator >
      void _M_insert_unique(_InputIterator __first, _InputIterator __last);
      template < typename _InputIterator >
      void _M_insert_equal(_InputIterator __first, _InputIterator __last);
    private:
      void _M_erase_aux(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator __position);
      void _M_erase_aux(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator __first, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator __last);
    public:
      inline void erase(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator __position)
      {
        _M_erase_aux(__position);
      }
      inline void erase(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator __position)
      {
        _M_erase_aux(__position);
      }
      typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type erase(const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::key_type &__x);
      inline void erase(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator __first, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator __last)
      {
        _M_erase_aux(__first, __last);
      }
      inline void erase(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator __first, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator __last)
      {
        _M_erase_aux(__first, __last);
      }
      void erase(const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::key_type *__first, const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::key_type *__last);
      inline void clear()
      {
        _M_erase(_M_begin());
        _M_leftmost() = _M_end();
        _M_root() = 0;
        _M_rightmost() = _M_end();
        _M_impl._M_node_count = 0;
      }
      typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator find(const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::key_type &__k);
      typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator find(const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::key_type &__k) const ;
      typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type count(const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::key_type &__k) const ;
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator lower_bound(const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::key_type &__k)
      {
        return _M_lower_bound(_M_begin(), _M_end(), __k);
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator lower_bound(const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::key_type &__k) const 
      {
        return _M_lower_bound(_M_begin(), _M_end(), __k);
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator upper_bound(const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::key_type &__k)
      {
        return _M_upper_bound(_M_begin(), _M_end(), __k);
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator upper_bound(const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::key_type &__k) const 
      {
        return _M_upper_bound(_M_begin(), _M_end(), __k);
      }
      ::std::pair<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator> equal_range(const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::key_type &__k);
      ::std::pair<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator> equal_range(const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::key_type &__k) const ;
      bool __rb_verify() const ;
  };
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  inline bool operator ==(const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__x, const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  inline bool operator ==(const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__x, const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__y)
  {
    return __x.size() == __y.size() && std::equal(__x.begin(), __x.end(), __y.begin());
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  inline bool operator <(const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__x, const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  inline bool operator <(const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__x, const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__y)
  {
    return std::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  inline bool operator !=(const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__x, const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  inline bool operator !=(const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__x, const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__y)
  {
    return !(__x == __y);
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  inline bool operator >(const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__x, const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  inline bool operator >(const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__x, const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__y)
  {
    return __y < __x;
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  inline bool operator <=(const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__x, const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  inline bool operator <=(const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__x, const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__y)
  {
    return !(__y < __x);
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  inline bool operator >=(const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__x, const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  inline bool operator >=(const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__x, const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__y)
  {
    return !(__x < __y);
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  inline void swap(::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__x, ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  inline void swap(::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__x, ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__y)
  {
    __x.swap(__y);
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::operator =(const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__x)
  {
    if (this != &__x)
      {
        clear();
        _M_impl._M_key_compare = __x._M_impl._M_key_compare;
        if (__x._M_root() != 0)
          {
            _M_root() = _M_copy(__x._M_begin(), _M_end());
            _M_leftmost() = _S_minimum(_M_root());
            _M_rightmost() = _S_maximum(_M_root());
            _M_impl._M_node_count = __x._M_impl._M_node_count;
          }
      }
    return *this;
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_insert_(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Base_ptr __x, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Base_ptr __p, const _Val &__v)
  {
    bool __insert_left = (__x != 0 || __p == _M_end()) || _M_impl._M_key_compare(_KeyOfValue()(__v), _S_key(__p));
    typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __z = _M_create_node(__v);
    _Rb_tree_insert_and_rebalance(__insert_left, __z, const_cast<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr>(__p), this->_M_impl._M_header);
    ++_M_impl._M_node_count;
    return typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator(__z);
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_insert_lower(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr __x, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr __p, const _Val &__v)
  {
    bool __insert_left = (__x != 0 || __p == _M_end()) || !_M_impl._M_key_compare(_S_key(__p), _KeyOfValue()(__v));
    typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __z = _M_create_node(__v);
    _Rb_tree_insert_and_rebalance(__insert_left, __z, __p, this->_M_impl._M_header);
    ++_M_impl._M_node_count;
    return typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator(__z);
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_insert_equal_lower(const _Val &__v)
  {
    typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __x = _M_begin();
    typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __y = _M_end();
    while (__x != 0)
      {
        __y = __x;
        __x = !_M_impl._M_key_compare(_S_key(__x), _KeyOfValue()(__v)) ? _S_left(__x) : _S_right(__x);
      }
    return _M_insert_lower(__x, __y, __v);
  }
  template < typename _Key, typename _Val, typename _KoV, typename _Compare, typename _Alloc >
  typename ::std::_Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_Link_type _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_M_copy(typename ::std::_Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_Const_Link_type __x, typename ::std::_Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_Link_type __p)
  {
    typename ::std::_Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_Link_type __top = _M_clone_node(__x);
    __top->_M_parent = __p;
    try
    {
      if (__x->_M_right)
        {
          __top->_M_right = _M_copy(_S_right(__x), __top);
        }
      __p = __top;
      __x = _S_left(__x);
      while (__x != 0)
        {
          typename ::std::_Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_Link_type __y = _M_clone_node(__x);
          __p->_M_left = __y;
          __y->_M_parent = __p;
          if (__x->_M_right)
            {
              __y->_M_right = _M_copy(_S_right(__x), __y);
            }
          __p = __y;
          __x = _S_left(__x);
        }
    }
    catch (...)
    {
      _M_erase(__top);
      throw;
    }
    return __top;
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  void _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_erase(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __x)
  {
    while (__x != 0)
      {
        _M_erase(_S_right(__x));
        typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __y = _S_left(__x);
        _M_destroy_node(__x);
        __x = __y;
      }
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_lower_bound(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __x, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __y, const _Key &__k)
  {
    while (__x != 0)
      {
        if (!_M_impl._M_key_compare(_S_key(__x), __k))
          {
            (__y = __x, __x = _S_left(__x));
          }
        else
          {
            __x = _S_right(__x);
          }
      }
    return typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator(__y);
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_lower_bound(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type __x, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type __y, const _Key &__k) const 
  {
    while (__x != 0)
      {
        if (!_M_impl._M_key_compare(_S_key(__x), __k))
          {
            (__y = __x, __x = _S_left(__x));
          }
        else
          {
            __x = _S_right(__x);
          }
      }
    return typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator(__y);
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_upper_bound(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __x, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __y, const _Key &__k)
  {
    while (__x != 0)
      {
        if (_M_impl._M_key_compare(__k, _S_key(__x)))
          {
            (__y = __x, __x = _S_left(__x));
          }
        else
          {
            __x = _S_right(__x);
          }
      }
    return typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator(__y);
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_upper_bound(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type __x, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type __y, const _Key &__k) const 
  {
    while (__x != 0)
      {
        if (_M_impl._M_key_compare(__k, _S_key(__x)))
          {
            (__y = __x, __x = _S_left(__x));
          }
        else
          {
            __x = _S_right(__x);
          }
      }
    return typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator(__y);
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  ::std::pair<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator> _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::equal_range(const _Key &__k)
  {
    typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __x = _M_begin();
    typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __y = _M_end();
    while (__x != 0)
      {
        if (_M_impl._M_key_compare(_S_key(__x), __k))
          {
            __x = _S_right(__x);
          }
        else
          {
            if (_M_impl._M_key_compare(__k, _S_key(__x)))
              {
                (__y = __x, __x = _S_left(__x));
              }
            else
              {
                typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __xu(__x);
                typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __yu(__y);
                (__y = __x, __x = _S_left(__x));
                __xu = _S_right(__xu);
                return ::std::pair<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator>(_M_lower_bound(__x, __y, __k), _M_upper_bound(__xu, __yu, __k));
              }
          }
      }
    return ::std::pair<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator>(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator(__y), typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator(__y));
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  ::std::pair<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator> _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::equal_range(const _Key &__k) const 
  {
    typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type __x = _M_begin();
    typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type __y = _M_end();
    while (__x != 0)
      {
        if (_M_impl._M_key_compare(_S_key(__x), __k))
          {
            __x = _S_right(__x);
          }
        else
          {
            if (_M_impl._M_key_compare(__k, _S_key(__x)))
              {
                (__y = __x, __x = _S_left(__x));
              }
            else
              {
                typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type __xu(__x);
                typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type __yu(__y);
                (__y = __x, __x = _S_left(__x));
                __xu = _S_right(__xu);
                return ::std::pair<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator>(_M_lower_bound(__x, __y, __k), _M_upper_bound(__xu, __yu, __k));
              }
          }
      }
    return ::std::pair<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator>(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator(__y), typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator(__y));
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  void _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::swap(::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__t)
  {
    if (_M_root() == 0)
      {
        if (__t._M_root() != 0)
          {
            _M_root() = __t._M_root();
            _M_leftmost() = __t._M_leftmost();
            _M_rightmost() = __t._M_rightmost();
            _M_root()->_M_parent = _M_end();
            __t._M_root() = 0;
            __t._M_leftmost() = __t._M_end();
            __t._M_rightmost() = __t._M_end();
          }
      }
    else
      {
        if (__t._M_root() == 0)
          {
            __t._M_root() = _M_root();
            __t._M_leftmost() = _M_leftmost();
            __t._M_rightmost() = _M_rightmost();
            __t._M_root()->_M_parent = __t._M_end();
            _M_root() = 0;
            _M_leftmost() = _M_end();
            _M_rightmost() = _M_end();
          }
        else
          {
            std::swap(_M_root(), __t._M_root());
            std::swap(_M_leftmost(), __t._M_leftmost());
            std::swap(_M_rightmost(), __t._M_rightmost());
            _M_root()->_M_parent = _M_end();
            __t._M_root()->_M_parent = __t._M_end();
          }
      }
    std::swap(this->_M_impl._M_node_count, __t._M_impl._M_node_count);
    std::swap(this->_M_impl._M_key_compare, __t._M_impl._M_key_compare);
    std::__alloc_swap<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Node_allocator>::_S_do_it(_M_get_Node_allocator(), __t._M_get_Node_allocator());
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  ::std::pair<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator, bool> _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_insert_unique(const _Val &__v)
  {
    typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __x = _M_begin();
    typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __y = _M_end();
    bool __comp(true);
    while (__x != 0)
      {
        __y = __x;
        __comp = _M_impl._M_key_compare(_KeyOfValue()(__v), _S_key(__x));
        __x = __comp ? _S_left(__x) : _S_right(__x);
      }
    typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator __j = typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator(__y);
    if (__comp)
      {
        if (__j == begin())
          {
            return ::std::pair<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator, bool>(_M_insert_(__x, __y, __v), true);
          }
        else
          {
            --__j;
          }
      }
    if (_M_impl._M_key_compare(_S_key(__j._M_node), _KeyOfValue()(__v)))
      {
        return ::std::pair<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator, bool>(_M_insert_(__x, __y, __v), true);
      }
    return ::std::pair<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator, bool>(__j, false);
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_insert_equal(const _Val &__v)
  {
    typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __x = _M_begin();
    typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __y = _M_end();
    while (__x != 0)
      {
        __y = __x;
        __x = _M_impl._M_key_compare(_KeyOfValue()(__v), _S_key(__x)) ? _S_left(__x) : _S_right(__x);
      }
    return _M_insert_(__x, __y, __v);
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_insert_unique_(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator __position, const _Val &__v)
  {
    if (__position._M_node == _M_end())
      {
        if (size() > 0 && _M_impl._M_key_compare(_S_key(_M_rightmost()), _KeyOfValue()(__v)))
          {
            return _M_insert_(0, _M_rightmost(), __v);
          }
        else
          {
            return _M_insert_unique(__v).first;
          }
      }
    else
      {
        if (_M_impl._M_key_compare(_KeyOfValue()(__v), _S_key(__position._M_node)))
          {
            typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator __before = __position;
            if (__position._M_node == _M_leftmost())
              {
                return _M_insert_(_M_leftmost(), _M_leftmost(), __v);
              }
            else
              {
                if (_M_impl._M_key_compare(_S_key((--__before)._M_node), _KeyOfValue()(__v)))
                  {
                    if (_S_right(__before._M_node) == 0)
                      {
                        return _M_insert_(0, __before._M_node, __v);
                      }
                    else
                      {
                        return _M_insert_(__position._M_node, __position._M_node, __v);
                      }
                  }
                else
                  {
                    return _M_insert_unique(__v).first;
                  }
              }
          }
        else
          {
            if (_M_impl._M_key_compare(_S_key(__position._M_node), _KeyOfValue()(__v)))
              {
                typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator __after = __position;
                if (__position._M_node == _M_rightmost())
                  {
                    return _M_insert_(0, _M_rightmost(), __v);
                  }
                else
                  {
                    if (_M_impl._M_key_compare(_KeyOfValue()(__v), _S_key((++__after)._M_node)))
                      {
                        if (_S_right(__position._M_node) == 0)
                          {
                            return _M_insert_(0, __position._M_node, __v);
                          }
                        else
                          {
                            return _M_insert_(__after._M_node, __after._M_node, __v);
                          }
                      }
                    else
                      {
                        return _M_insert_unique(__v).first;
                      }
                  }
              }
            else
              {
                return __position._M_const_cast();
              }
          }
      }
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_insert_equal_(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator __position, const _Val &__v)
  {
    if (__position._M_node == _M_end())
      {
        if (size() > 0 && !_M_impl._M_key_compare(_KeyOfValue()(__v), _S_key(_M_rightmost())))
          {
            return _M_insert_(0, _M_rightmost(), __v);
          }
        else
          {
            return _M_insert_equal(__v);
          }
      }
    else
      {
        if (!_M_impl._M_key_compare(_S_key(__position._M_node), _KeyOfValue()(__v)))
          {
            typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator __before = __position;
            if (__position._M_node == _M_leftmost())
              {
                return _M_insert_(_M_leftmost(), _M_leftmost(), __v);
              }
            else
              {
                if (!_M_impl._M_key_compare(_KeyOfValue()(__v), _S_key((--__before)._M_node)))
                  {
                    if (_S_right(__before._M_node) == 0)
                      {
                        return _M_insert_(0, __before._M_node, __v);
                      }
                    else
                      {
                        return _M_insert_(__position._M_node, __position._M_node, __v);
                      }
                  }
                else
                  {
                    return _M_insert_equal(__v);
                  }
              }
          }
        else
          {
            typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator __after = __position;
            if (__position._M_node == _M_rightmost())
              {
                return _M_insert_(0, _M_rightmost(), __v);
              }
            else
              {
                if (!_M_impl._M_key_compare(_S_key((++__after)._M_node), _KeyOfValue()(__v)))
                  {
                    if (_S_right(__position._M_node) == 0)
                      {
                        return _M_insert_(0, __position._M_node, __v);
                      }
                    else
                      {
                        return _M_insert_(__after._M_node, __after._M_node, __v);
                      }
                  }
                else
                  {
                    return _M_insert_equal_lower(__v);
                  }
              }
          }
      }
  }
  template < typename _Key, typename _Val, typename _KoV, typename _Cmp, typename _Alloc >
  template < typename _II >
  void _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::_M_insert_unique(_II __first, _II __last)
  {
    for (; __first != __last; ++__first)
      {
        _M_insert_unique_(end(), *__first);
      }
  }
  template < typename _Key, typename _Val, typename _KoV, typename _Cmp, typename _Alloc >
  template < typename _II >
  void _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::_M_insert_equal(_II __first, _II __last)
  {
    for (; __first != __last; ++__first)
      {
        _M_insert_equal_(end(), *__first);
      }
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  void _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_erase_aux(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator __position)
  {
    typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __y = static_cast<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type>(_Rb_tree_rebalance_for_erase(const_cast<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr>(__position._M_node), this->_M_impl._M_header));
    _M_destroy_node(__y);
    --_M_impl._M_node_count;
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  void _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_erase_aux(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator __first, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator __last)
  {
    if (__first == begin() && __last == end())
      {
        clear();
      }
    else
      {
        while (__first != __last)
          {
            erase(__first++);
          }
      }
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::erase(const _Key &__x)
  {
    ::std::pair<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator> __p = equal_range(__x);
    const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type __old_size = size();
    erase(__p.first, __p.second);
    return __old_size - size();
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  void _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::erase(const _Key *__first, const _Key *__last)
  {
    while (__first != __last)
      {
        erase(*__first++);
      }
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::find(const _Key &__k)
  {
    typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k);
    return __j == end() || _M_impl._M_key_compare(__k, _S_key(__j._M_node)) ? end() : __j;
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::find(const _Key &__k) const 
  {
    typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k);
    return __j == end() || _M_impl._M_key_compare(__k, _S_key(__j._M_node)) ? end() : __j;
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::count(const _Key &__k) const 
  {
    ::std::pair<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator> __p = equal_range(__k);
    const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type __n = std::distance(__p.first, __p.second);
    return __n;
  }
  unsigned int _Rb_tree_black_count(const ::std::_Rb_tree_node_base *__node, const ::std::_Rb_tree_node_base *__root) throw()__attribute__((__pure__));
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  bool _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::__rb_verify() const 
  {
    if (_M_impl._M_node_count == 0 || begin() == end())
      {
        return ((_M_impl._M_node_count == 0 && begin() == end()) && this->_M_impl._M_header._M_left == _M_end()) && this->_M_impl._M_header._M_right == _M_end();
      }
    unsigned int __len(_Rb_tree_black_count(_M_leftmost(), _M_root()));
    for (typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator __it = begin(); __it != end(); ++__it)
      {
        typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type __x = static_cast<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type>(__it._M_node);
        typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type __L = _S_left(__x);
        typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type __R = _S_right(__x);
        if (__x->_M_color == ::std::_S_red)
          {
            if ((__L && __L->_M_color == ::std::_S_red) || (__R && __R->_M_color == ::std::_S_red))
              {
                return false;
              }
          }
        if (__L && _M_impl._M_key_compare(_S_key(__x), _S_key(__L)))
          {
            return false;
          }
        if (__R && _M_impl._M_key_compare(_S_key(__R), _S_key(__x)))
          {
            return false;
          }
        if ((!__L && !__R) && _Rb_tree_black_count(__x, _M_root()) != __len)
          {
            return false;
          }
      }
    if (_M_leftmost() != _Rb_tree_node_base::_S_minimum(_M_root()))
      {
        return false;
      }
    if (_M_rightmost() != _Rb_tree_node_base::_S_maximum(_M_root()))
      {
        return false;
      }
    return true;
  }
  template < typename _Key, typename _Tp, typename _Compare = ::std::less<_Key>, typename _Alloc = ::std::allocator< ::std::pair<const _Key, _Tp> > >
  class  map
  {
    public:
      class value_compare;
      typedef _Key key_type;
      typedef _Tp mapped_type;
      typedef ::std::pair<const _Key, _Tp> value_type;
      typedef _Compare key_compare;
      typedef _Alloc allocator_type;
    private:
      typedef typename _Alloc::value_type _Alloc_value_type;
    public:
      class  value_compare : public ::std::binary_function<typename ::std::map<_Key, _Tp, _Compare, _Alloc>::value_type, typename ::std::map<_Key, _Tp, _Compare, _Alloc>::value_type, bool>
      {
        protected:
          _Compare comp;
          inline value_compare(_Compare __c)
            : comp(__c)
          {
          }
        public:
          inline bool operator ()(const typename ::std::map<_Key, _Tp, _Compare, _Alloc>::value_type &__x, const typename ::std::map<_Key, _Tp, _Compare, _Alloc>::value_type &__y) const 
          {
            return comp(__x.first, __y.first);
          }
        friend class ::std::map<_Key, _Tp, _Compare, _Alloc>;
      };
    private:
      typedef typename _Alloc::template rebind< typename ::std::map<_Key, _Tp, _Compare, _Alloc>::value_type>::other _Pair_alloc_type;
      typedef ::std::_Rb_tree<typename ::std::map<_Key, _Tp, _Compare, _Alloc>::key_type, typename ::std::map<_Key, _Tp, _Compare, _Alloc>::value_type, ::std::_Select1st<typename ::std::map<_Key, _Tp, _Compare, _Alloc>::value_type>, typename ::std::map<_Key, _Tp, _Compare, _Alloc>::key_compare, typename ::std::map<_Key, _Tp, _Compare, _Alloc>::_Pair_alloc_type> _Rep_type;
      typename ::std::map<_Key, _Tp, _Compare, _Alloc>::_Rep_type _M_t;
    public:
      typedef typename ::std::map<_Key, _Tp, _Compare, _Alloc>::_Pair_alloc_type::pointer pointer;
      typedef typename ::std::map<_Key, _Tp, _Compare, _Alloc>::_Pair_alloc_type::const_pointer const_pointer;
      typedef typename ::std::map<_Key, _Tp, _Compare, _Alloc>::_Pair_alloc_type::reference reference;
      typedef typename ::std::map<_Key, _Tp, _Compare, _Alloc>::_Pair_alloc_type::const_reference const_reference;
      typedef typename ::std::_Rb_tree<typename ::std::map<_Key, _Tp, _Compare, _Alloc>::key_type, typename ::std::map<_Key, _Tp, _Compare, _Alloc>::value_type, ::std::_Select1st<typename ::std::map<_Key, _Tp, _Compare, _Alloc>::value_type>, typename ::std::map<_Key, _Tp, _Compare, _Alloc>::key_compare, typename ::std::map<_Key, _Tp, _Compare, _Alloc>::_Pair_alloc_type>::iterator iterator;
      typedef typename ::std::_Rb_tree<typename ::std::map<_Key, _Tp, _Compare, _Alloc>::key_type, typename ::std::map<_Key, _Tp, _Compare, _Alloc>::value_type, ::std::_Select1st<typename ::std::map<_Key, _Tp, _Compare, _Alloc>::value_type>, typename ::std::map<_Key, _Tp, _Compare, _Alloc>::key_compare, typename ::std::map<_Key, _Tp, _Compare, _Alloc>::_Pair_alloc_type>::const_iterator const_iterator;
      typedef typename ::std::_Rb_tree<typename ::std::map<_Key, _Tp, _Compare, _Alloc>::key_type, typename ::std::map<_Key, _Tp, _Compare, _Alloc>::value_type, ::std::_Select1st<typename ::std::map<_Key, _Tp, _Compare, _Alloc>::value_type>, typename ::std::map<_Key, _Tp, _Compare, _Alloc>::key_compare, typename ::std::map<_Key, _Tp, _Compare, _Alloc>::_Pair_alloc_type>::size_type size_type;
      typedef typename ::std::_Rb_tree<typename ::std::map<_Key, _Tp, _Compare, _Alloc>::key_type, typename ::std::map<_Key, _Tp, _Compare, _Alloc>::value_type, ::std::_Select1st<typename ::std::map<_Key, _Tp, _Compare, _Alloc>::value_type>, typename ::std::map<_Key, _Tp, _Compare, _Alloc>::key_compare, typename ::std::map<_Key, _Tp, _Compare, _Alloc>::_Pair_alloc_type>::difference_type difference_type;
      typedef typename ::std::_Rb_tree<typename ::std::map<_Key, _Tp, _Compare, _Alloc>::key_type, typename ::std::map<_Key, _Tp, _Compare, _Alloc>::value_type, ::std::_Select1st<typename ::std::map<_Key, _Tp, _Compare, _Alloc>::value_type>, typename ::std::map<_Key, _Tp, _Compare, _Alloc>::key_compare, typename ::std::map<_Key, _Tp, _Compare, _Alloc>::_Pair_alloc_type>::reverse_iterator reverse_iterator;
      typedef typename ::std::_Rb_tree<typename ::std::map<_Key, _Tp, _Compare, _Alloc>::key_type, typename ::std::map<_Key, _Tp, _Compare, _Alloc>::value_type, ::std::_Select1st<typename ::std::map<_Key, _Tp, _Compare, _Alloc>::value_type>, typename ::std::map<_Key, _Tp, _Compare, _Alloc>::key_compare, typename ::std::map<_Key, _Tp, _Compare, _Alloc>::_Pair_alloc_type>::const_reverse_iterator const_reverse_iterator;
      inline map()
        : _M_t()
      {
      }
      inline explicit map(const _Compare &__comp, const typename ::std::map<_Key, _Tp, _Compare, _Alloc>::allocator_type &__a  = typename ::std::map<_Key, _Tp, _Compare, _Alloc>::allocator_type())
        : _M_t(__comp, typename ::std::map<_Key, _Tp, _Compare, _Alloc>::_Pair_alloc_type(__a))
      {
      }
      inline map(const ::std::map<_Key, _Tp, _Compare, _Alloc> &__x)
        : _M_t(__x._M_t)
      {
      }
      template < typename _InputIterator >
      inline map(_InputIterator __first, _InputIterator __last)
        : _M_t()
      {
        _M_t._M_insert_unique(__first, __last);
      }
      template < typename _InputIterator >
      inline map(_InputIterator __first, _InputIterator __last, const _Compare &__comp, const typename ::std::map<_Key, _Tp, _Compare, _Alloc>::allocator_type &__a  = typename ::std::map<_Key, _Tp, _Compare, _Alloc>::allocator_type())
        : _M_t(__comp, typename ::std::map<_Key, _Tp, _Compare, _Alloc>::_Pair_alloc_type(__a))
      {
        _M_t._M_insert_unique(__first, __last);
      }
      inline ::std::map<_Key, _Tp, _Compare, _Alloc> &operator =(const ::std::map<_Key, _Tp, _Compare, _Alloc> &__x)
      {
        _M_t = __x._M_t;
        return *this;
      }
      inline typename ::std::map<_Key, _Tp, _Compare, _Alloc>::allocator_type get_allocator() const 
      {
        return typename ::std::map<_Key, _Tp, _Compare, _Alloc>::allocator_type(_M_t.get_allocator());
      }
      inline typename ::std::map<_Key, _Tp, _Compare, _Alloc>::iterator begin()
      {
        return _M_t.begin();
      }
      inline typename ::std::map<_Key, _Tp, _Compare, _Alloc>::const_iterator begin() const 
      {
        return _M_t.begin();
      }
      inline typename ::std::map<_Key, _Tp, _Compare, _Alloc>::iterator end()
      {
        return _M_t.end();
      }
      inline typename ::std::map<_Key, _Tp, _Compare, _Alloc>::const_iterator end() const 
      {
        return _M_t.end();
      }
      inline typename ::std::map<_Key, _Tp, _Compare, _Alloc>::reverse_iterator rbegin()
      {
        return _M_t.rbegin();
      }
      inline typename ::std::map<_Key, _Tp, _Compare, _Alloc>::const_reverse_iterator rbegin() const 
      {
        return _M_t.rbegin();
      }
      inline typename ::std::map<_Key, _Tp, _Compare, _Alloc>::reverse_iterator rend()
      {
        return _M_t.rend();
      }
      inline typename ::std::map<_Key, _Tp, _Compare, _Alloc>::const_reverse_iterator rend() const 
      {
        return _M_t.rend();
      }
      inline bool empty() const 
      {
        return _M_t.empty();
      }
      inline typename ::std::map<_Key, _Tp, _Compare, _Alloc>::size_type size() const 
      {
        return _M_t.size();
      }
      inline typename ::std::map<_Key, _Tp, _Compare, _Alloc>::size_type max_size() const 
      {
        return _M_t.max_size();
      }
      inline typename ::std::map<_Key, _Tp, _Compare, _Alloc>::mapped_type &operator [](const typename ::std::map<_Key, _Tp, _Compare, _Alloc>::key_type &__k)
      {
        typename ::std::map<_Key, _Tp, _Compare, _Alloc>::iterator __i = lower_bound(__k);
        if (__i == end() || key_comp()(__k, (*__i).first))
          {
            __i = insert(__i, typename ::std::map<_Key, _Tp, _Compare, _Alloc>::value_type(__k, typename ::std::map<_Key, _Tp, _Compare, _Alloc>::mapped_type()));
          }
        return (*__i).second;
      }
      inline typename ::std::map<_Key, _Tp, _Compare, _Alloc>::mapped_type &at(const typename ::std::map<_Key, _Tp, _Compare, _Alloc>::key_type &__k)
      {
        typename ::std::map<_Key, _Tp, _Compare, _Alloc>::iterator __i = lower_bound(__k);
        if (__i == end() || key_comp()(__k, (*__i).first))
          {
            ::std::__throw_out_of_range("map::at");
          }
        return (*__i).second;
      }
      inline const typename ::std::map<_Key, _Tp, _Compare, _Alloc>::mapped_type &at(const typename ::std::map<_Key, _Tp, _Compare, _Alloc>::key_type &__k) const 
      {
        typename ::std::map<_Key, _Tp, _Compare, _Alloc>::const_iterator __i = lower_bound(__k);
        if (__i == end() || key_comp()(__k, (*__i).first))
          {
            ::std::__throw_out_of_range("map::at");
          }
        return (*__i).second;
      }
      inline ::std::pair<typename ::std::map<_Key, _Tp, _Compare, _Alloc>::iterator, bool> insert(const typename ::std::map<_Key, _Tp, _Compare, _Alloc>::value_type &__x)
      {
        return _M_t._M_insert_unique(__x);
      }
      inline typename ::std::map<_Key, _Tp, _Compare, _Alloc>::iterator insert(typename ::std::map<_Key, _Tp, _Compare, _Alloc>::iterator __position, const typename ::std::map<_Key, _Tp, _Compare, _Alloc>::value_type &__x)
      {
        return _M_t._M_insert_unique_(__position, __x);
      }
      template < typename _InputIterator >
      inline void insert(_InputIterator __first, _InputIterator __last)
      {
        _M_t._M_insert_unique(__first, __last);
      }
      inline void erase(typename ::std::map<_Key, _Tp, _Compare, _Alloc>::iterator __position)
      {
        _M_t.erase(__position);
      }
      inline typename ::std::map<_Key, _Tp, _Compare, _Alloc>::size_type erase(const typename ::std::map<_Key, _Tp, _Compare, _Alloc>::key_type &__x)
      {
        return _M_t.erase(__x);
      }
      inline void erase(typename ::std::map<_Key, _Tp, _Compare, _Alloc>::iterator __first, typename ::std::map<_Key, _Tp, _Compare, _Alloc>::iterator __last)
      {
        _M_t.erase(__first, __last);
      }
      inline void swap(::std::map<_Key, _Tp, _Compare, _Alloc> &__x)
      {
        _M_t.swap(__x._M_t);
      }
      inline void clear()
      {
        _M_t.clear();
      }
      inline typename ::std::map<_Key, _Tp, _Compare, _Alloc>::key_compare key_comp() const 
      {
        return _M_t.key_comp();
      }
      inline typename ::std::map<_Key, _Tp, _Compare, _Alloc>::value_compare value_comp() const 
      {
        return typename ::std::map<_Key, _Tp, _Compare, _Alloc>::value_compare(_M_t.key_comp());
      }
      inline typename ::std::map<_Key, _Tp, _Compare, _Alloc>::iterator find(const typename ::std::map<_Key, _Tp, _Compare, _Alloc>::key_type &__x)
      {
        return _M_t.find(__x);
      }
      inline typename ::std::map<_Key, _Tp, _Compare, _Alloc>::const_iterator find(const typename ::std::map<_Key, _Tp, _Compare, _Alloc>::key_type &__x) const 
      {
        return _M_t.find(__x);
      }
      inline typename ::std::map<_Key, _Tp, _Compare, _Alloc>::size_type count(const typename ::std::map<_Key, _Tp, _Compare, _Alloc>::key_type &__x) const 
      {
        return _M_t.find(__x) == _M_t.end() ? 0 : 1;
      }
      inline typename ::std::map<_Key, _Tp, _Compare, _Alloc>::iterator lower_bound(const typename ::std::map<_Key, _Tp, _Compare, _Alloc>::key_type &__x)
      {
        return _M_t.lower_bound(__x);
      }
      inline typename ::std::map<_Key, _Tp, _Compare, _Alloc>::const_iterator lower_bound(const typename ::std::map<_Key, _Tp, _Compare, _Alloc>::key_type &__x) const 
      {
        return _M_t.lower_bound(__x);
      }
      inline typename ::std::map<_Key, _Tp, _Compare, _Alloc>::iterator upper_bound(const typename ::std::map<_Key, _Tp, _Compare, _Alloc>::key_type &__x)
      {
        return _M_t.upper_bound(__x);
      }
      inline typename ::std::map<_Key, _Tp, _Compare, _Alloc>::const_iterator upper_bound(const typename ::std::map<_Key, _Tp, _Compare, _Alloc>::key_type &__x) const 
      {
        return _M_t.upper_bound(__x);
      }
      inline ::std::pair<typename ::std::map<_Key, _Tp, _Compare, _Alloc>::iterator, typename ::std::map<_Key, _Tp, _Compare, _Alloc>::iterator> equal_range(const typename ::std::map<_Key, _Tp, _Compare, _Alloc>::key_type &__x)
      {
        return _M_t.equal_range(__x);
      }
      inline ::std::pair<typename ::std::map<_Key, _Tp, _Compare, _Alloc>::const_iterator, typename ::std::map<_Key, _Tp, _Compare, _Alloc>::const_iterator> equal_range(const typename ::std::map<_Key, _Tp, _Compare, _Alloc>::key_type &__x) const 
      {
        return _M_t.equal_range(__x);
      }
    template < typename _K1, typename _T1, typename _C1, typename _A1 >
    friend bool operator ==(const ::std::map<_K1, _T1, _C1, _A1> &, const ::std::map<_K1, _T1, _C1, _A1> &);
    template < typename _K1, typename _T1, typename _C1, typename _A1 >
    friend bool operator <(const ::std::map<_K1, _T1, _C1, _A1> &, const ::std::map<_K1, _T1, _C1, _A1> &);
  };
  template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
  inline bool operator ==(const ::std::map<_Key, _Tp, _Compare, _Alloc> &__x, const ::std::map<_Key, _Tp, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
  inline bool operator ==(const ::std::map<_Key, _Tp, _Compare, _Alloc> &__x, const ::std::map<_Key, _Tp, _Compare, _Alloc> &__y)
  {
    return __x._M_t == __y._M_t;
  }
  template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
  inline bool operator <(const ::std::map<_Key, _Tp, _Compare, _Alloc> &__x, const ::std::map<_Key, _Tp, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
  inline bool operator <(const ::std::map<_Key, _Tp, _Compare, _Alloc> &__x, const ::std::map<_Key, _Tp, _Compare, _Alloc> &__y)
  {
    return __x._M_t < __y._M_t;
  }
  template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
  inline bool operator !=(const ::std::map<_Key, _Tp, _Compare, _Alloc> &__x, const ::std::map<_Key, _Tp, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
  inline bool operator !=(const ::std::map<_Key, _Tp, _Compare, _Alloc> &__x, const ::std::map<_Key, _Tp, _Compare, _Alloc> &__y)
  {
    return !(__x == __y);
  }
  template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
  inline bool operator >(const ::std::map<_Key, _Tp, _Compare, _Alloc> &__x, const ::std::map<_Key, _Tp, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
  inline bool operator >(const ::std::map<_Key, _Tp, _Compare, _Alloc> &__x, const ::std::map<_Key, _Tp, _Compare, _Alloc> &__y)
  {
    return __y < __x;
  }
  template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
  inline bool operator <=(const ::std::map<_Key, _Tp, _Compare, _Alloc> &__x, const ::std::map<_Key, _Tp, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
  inline bool operator <=(const ::std::map<_Key, _Tp, _Compare, _Alloc> &__x, const ::std::map<_Key, _Tp, _Compare, _Alloc> &__y)
  {
    return !(__y < __x);
  }
  template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
  inline bool operator >=(const ::std::map<_Key, _Tp, _Compare, _Alloc> &__x, const ::std::map<_Key, _Tp, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
  inline bool operator >=(const ::std::map<_Key, _Tp, _Compare, _Alloc> &__x, const ::std::map<_Key, _Tp, _Compare, _Alloc> &__y)
  {
    return !(__x < __y);
  }
  template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
  inline void swap(::std::map<_Key, _Tp, _Compare, _Alloc> &__x, ::std::map<_Key, _Tp, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
  inline void swap(::std::map<_Key, _Tp, _Compare, _Alloc> &__x, ::std::map<_Key, _Tp, _Compare, _Alloc> &__y)
  {
    __x.swap(__y);
  }
  template < typename _Key, typename _Tp, typename _Compare = ::std::less<_Key>, typename _Alloc = ::std::allocator< ::std::pair<const _Key, _Tp> > >
  class  multimap
  {
    public:
      class value_compare;
      typedef _Key key_type;
      typedef _Tp mapped_type;
      typedef ::std::pair<const _Key, _Tp> value_type;
      typedef _Compare key_compare;
      typedef _Alloc allocator_type;
    private:
      typedef typename _Alloc::value_type _Alloc_value_type;
    public:
      class  value_compare : public ::std::binary_function<typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::value_type, typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::value_type, bool>
      {
        protected:
          _Compare comp;
          inline value_compare(_Compare __c)
            : comp(__c)
          {
          }
        public:
          inline bool operator ()(const typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::value_type &__x, const typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::value_type &__y) const 
          {
            return comp(__x.first, __y.first);
          }
        friend class ::std::multimap<_Key, _Tp, _Compare, _Alloc>;
      };
    private:
      typedef typename _Alloc::template rebind< typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::value_type>::other _Pair_alloc_type;
      typedef ::std::_Rb_tree<typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::key_type, typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::value_type, ::std::_Select1st<typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::value_type>, typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::key_compare, typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::_Pair_alloc_type> _Rep_type;
      typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::_Rep_type _M_t;
    public:
      typedef typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::_Pair_alloc_type::pointer pointer;
      typedef typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::_Pair_alloc_type::const_pointer const_pointer;
      typedef typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::_Pair_alloc_type::reference reference;
      typedef typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::_Pair_alloc_type::const_reference const_reference;
      typedef typename ::std::_Rb_tree<typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::key_type, typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::value_type, ::std::_Select1st<typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::value_type>, typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::key_compare, typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::_Pair_alloc_type>::iterator iterator;
      typedef typename ::std::_Rb_tree<typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::key_type, typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::value_type, ::std::_Select1st<typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::value_type>, typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::key_compare, typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::_Pair_alloc_type>::const_iterator const_iterator;
      typedef typename ::std::_Rb_tree<typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::key_type, typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::value_type, ::std::_Select1st<typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::value_type>, typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::key_compare, typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::_Pair_alloc_type>::size_type size_type;
      typedef typename ::std::_Rb_tree<typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::key_type, typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::value_type, ::std::_Select1st<typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::value_type>, typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::key_compare, typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::_Pair_alloc_type>::difference_type difference_type;
      typedef typename ::std::_Rb_tree<typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::key_type, typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::value_type, ::std::_Select1st<typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::value_type>, typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::key_compare, typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::_Pair_alloc_type>::reverse_iterator reverse_iterator;
      typedef typename ::std::_Rb_tree<typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::key_type, typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::value_type, ::std::_Select1st<typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::value_type>, typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::key_compare, typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::_Pair_alloc_type>::const_reverse_iterator const_reverse_iterator;
      inline multimap()
        : _M_t()
      {
      }
      inline explicit multimap(const _Compare &__comp, const typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::allocator_type &__a  = typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::allocator_type())
        : _M_t(__comp, typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::_Pair_alloc_type(__a))
      {
      }
      inline multimap(const ::std::multimap<_Key, _Tp, _Compare, _Alloc> &__x)
        : _M_t(__x._M_t)
      {
      }
      template < typename _InputIterator >
      inline multimap(_InputIterator __first, _InputIterator __last)
        : _M_t()
      {
        _M_t._M_insert_equal(__first, __last);
      }
      template < typename _InputIterator >
      inline multimap(_InputIterator __first, _InputIterator __last, const _Compare &__comp, const typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::allocator_type &__a  = typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::allocator_type())
        : _M_t(__comp, typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::_Pair_alloc_type(__a))
      {
        _M_t._M_insert_equal(__first, __last);
      }
      inline ::std::multimap<_Key, _Tp, _Compare, _Alloc> &operator =(const ::std::multimap<_Key, _Tp, _Compare, _Alloc> &__x)
      {
        _M_t = __x._M_t;
        return *this;
      }
      inline typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::allocator_type get_allocator() const 
      {
        return typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::allocator_type(_M_t.get_allocator());
      }
      inline typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::iterator begin()
      {
        return _M_t.begin();
      }
      inline typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::const_iterator begin() const 
      {
        return _M_t.begin();
      }
      inline typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::iterator end()
      {
        return _M_t.end();
      }
      inline typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::const_iterator end() const 
      {
        return _M_t.end();
      }
      inline typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::reverse_iterator rbegin()
      {
        return _M_t.rbegin();
      }
      inline typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::const_reverse_iterator rbegin() const 
      {
        return _M_t.rbegin();
      }
      inline typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::reverse_iterator rend()
      {
        return _M_t.rend();
      }
      inline typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::const_reverse_iterator rend() const 
      {
        return _M_t.rend();
      }
      inline bool empty() const 
      {
        return _M_t.empty();
      }
      inline typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::size_type size() const 
      {
        return _M_t.size();
      }
      inline typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::size_type max_size() const 
      {
        return _M_t.max_size();
      }
      inline typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::iterator insert(const typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::value_type &__x)
      {
        return _M_t._M_insert_equal(__x);
      }
      inline typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::iterator insert(typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::iterator __position, const typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::value_type &__x)
      {
        return _M_t._M_insert_equal_(__position, __x);
      }
      template < typename _InputIterator >
      inline void insert(_InputIterator __first, _InputIterator __last)
      {
        _M_t._M_insert_equal(__first, __last);
      }
      inline void erase(typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::iterator __position)
      {
        _M_t.erase(__position);
      }
      inline typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::size_type erase(const typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::key_type &__x)
      {
        return _M_t.erase(__x);
      }
      inline void erase(typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::iterator __first, typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::iterator __last)
      {
        _M_t.erase(__first, __last);
      }
      inline void swap(::std::multimap<_Key, _Tp, _Compare, _Alloc> &__x)
      {
        _M_t.swap(__x._M_t);
      }
      inline void clear()
      {
        _M_t.clear();
      }
      inline typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::key_compare key_comp() const 
      {
        return _M_t.key_comp();
      }
      inline typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::value_compare value_comp() const 
      {
        return typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::value_compare(_M_t.key_comp());
      }
      inline typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::iterator find(const typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::key_type &__x)
      {
        return _M_t.find(__x);
      }
      inline typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::const_iterator find(const typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::key_type &__x) const 
      {
        return _M_t.find(__x);
      }
      inline typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::size_type count(const typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::key_type &__x) const 
      {
        return _M_t.count(__x);
      }
      inline typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::iterator lower_bound(const typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::key_type &__x)
      {
        return _M_t.lower_bound(__x);
      }
      inline typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::const_iterator lower_bound(const typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::key_type &__x) const 
      {
        return _M_t.lower_bound(__x);
      }
      inline typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::iterator upper_bound(const typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::key_type &__x)
      {
        return _M_t.upper_bound(__x);
      }
      inline typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::const_iterator upper_bound(const typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::key_type &__x) const 
      {
        return _M_t.upper_bound(__x);
      }
      inline ::std::pair<typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::iterator, typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::iterator> equal_range(const typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::key_type &__x)
      {
        return _M_t.equal_range(__x);
      }
      inline ::std::pair<typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::const_iterator, typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::const_iterator> equal_range(const typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::key_type &__x) const 
      {
        return _M_t.equal_range(__x);
      }
    template < typename _K1, typename _T1, typename _C1, typename _A1 >
    friend bool operator ==(const ::std::multimap<_K1, _T1, _C1, _A1> &, const ::std::multimap<_K1, _T1, _C1, _A1> &);
    template < typename _K1, typename _T1, typename _C1, typename _A1 >
    friend bool operator <(const ::std::multimap<_K1, _T1, _C1, _A1> &, const ::std::multimap<_K1, _T1, _C1, _A1> &);
  };
  template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
  inline bool operator ==(const ::std::multimap<_Key, _Tp, _Compare, _Alloc> &__x, const ::std::multimap<_Key, _Tp, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
  inline bool operator ==(const ::std::multimap<_Key, _Tp, _Compare, _Alloc> &__x, const ::std::multimap<_Key, _Tp, _Compare, _Alloc> &__y)
  {
    return __x._M_t == __y._M_t;
  }
  template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
  inline bool operator <(const ::std::multimap<_Key, _Tp, _Compare, _Alloc> &__x, const ::std::multimap<_Key, _Tp, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
  inline bool operator <(const ::std::multimap<_Key, _Tp, _Compare, _Alloc> &__x, const ::std::multimap<_Key, _Tp, _Compare, _Alloc> &__y)
  {
    return __x._M_t < __y._M_t;
  }
  template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
  inline bool operator !=(const ::std::multimap<_Key, _Tp, _Compare, _Alloc> &__x, const ::std::multimap<_Key, _Tp, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
  inline bool operator !=(const ::std::multimap<_Key, _Tp, _Compare, _Alloc> &__x, const ::std::multimap<_Key, _Tp, _Compare, _Alloc> &__y)
  {
    return !(__x == __y);
  }
  template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
  inline bool operator >(const ::std::multimap<_Key, _Tp, _Compare, _Alloc> &__x, const ::std::multimap<_Key, _Tp, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
  inline bool operator >(const ::std::multimap<_Key, _Tp, _Compare, _Alloc> &__x, const ::std::multimap<_Key, _Tp, _Compare, _Alloc> &__y)
  {
    return __y < __x;
  }
  template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
  inline bool operator <=(const ::std::multimap<_Key, _Tp, _Compare, _Alloc> &__x, const ::std::multimap<_Key, _Tp, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
  inline bool operator <=(const ::std::multimap<_Key, _Tp, _Compare, _Alloc> &__x, const ::std::multimap<_Key, _Tp, _Compare, _Alloc> &__y)
  {
    return !(__y < __x);
  }
  template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
  inline bool operator >=(const ::std::multimap<_Key, _Tp, _Compare, _Alloc> &__x, const ::std::multimap<_Key, _Tp, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
  inline bool operator >=(const ::std::multimap<_Key, _Tp, _Compare, _Alloc> &__x, const ::std::multimap<_Key, _Tp, _Compare, _Alloc> &__y)
  {
    return !(__x < __y);
  }
  template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
  inline void swap(::std::multimap<_Key, _Tp, _Compare, _Alloc> &__x, ::std::multimap<_Key, _Tp, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
  inline void swap(::std::multimap<_Key, _Tp, _Compare, _Alloc> &__x, ::std::multimap<_Key, _Tp, _Compare, _Alloc> &__y)
  {
    __x.swap(__y);
  }
}
namespace ISG {
  extern int current_timestamp;
  using ::RTTL::Matrix4x4;
  typedef ::RTTL::RTVec3i vec3i;
  typedef ::RTTL::RTVec3f vec3f;
  typedef ::RTTL::RTVec4i vec4i;
  typedef ::RTTL::RTVec4f vec4f;
  class  Node
  {
      int last_modified;
    public:
      inline Node()
      {
      }
      inline Node(::ISG::Node *parent)
      {
        (*this).::ISG::Node::addParent(parent);
      }
      virtual inline ~Node()
      {
      }
      template < typename nodetype >
      static inline void removeParent(nodetype *&from, ::ISG::Node *what)
      {
        if (from == 0L)
          {
            return ;
          }
        from->removeParent(what);
        if (from->parent.size() == 0)
          {
            delete from;
            from = 0L;
          }
        ;
      }
      inline void addParent(::ISG::Node *node)
      {
        if (::std::find /* < ::__gnu_cxx::__normal_iterator< ::ISG::Node **, ::std::vector< ::ISG::Node *, ::std::allocator< ::ISG::Node *> > >, ::ISG::Node *> */ ((*this).parent.::std::vector< ::ISG::Node *, ::std::allocator< ::ISG::Node *> >::begin(), (*this).parent.::std::vector< ::ISG::Node *, ::std::allocator< ::ISG::Node *> >::end(), node) == (*this).parent.::std::vector< ::ISG::Node *, ::std::allocator< ::ISG::Node *> >::end())
          {
            (*this).parent.::std::vector< ::ISG::Node *, ::std::allocator< ::ISG::Node *> >::push_back(node);
          }
      }
      inline void removeParent(::ISG::Node *node)
      {
        const char __MERCURIUM_PRETTY_FUNCTION__[46] = "void ::ISG::Node::removeParent(::ISG::Node *)";
        ::std::vector< ::ISG::Node *, ::std::allocator< ::ISG::Node *> >::iterator where((::std::find /* < ::__gnu_cxx::__normal_iterator< ::ISG::Node **, ::std::vector< ::ISG::Node *, ::std::allocator< ::ISG::Node *> > >, ::ISG::Node *> */ ((*this).parent.::std::vector< ::ISG::Node *, ::std::allocator< ::ISG::Node *> >::begin(), (*this).parent.::std::vector< ::ISG::Node *, ::std::allocator< ::ISG::Node *> >::end(), node)));
        where != (*this).parent.::std::vector< ::ISG::Node *, ::std::allocator< ::ISG::Node *> >::end() ? static_cast<void>(0) : ::__assert_fail("where != parent.end()", "/home/bsc18/bsc18186/scratch/parsec/raytrace/src/RTTL/API/ISG.hxx", 65, __MERCURIUM_PRETTY_FUNCTION__);
        (*this).parent.::std::vector< ::ISG::Node *, ::std::allocator< ::ISG::Node *> >::erase(where);
      }
      virtual inline void childWasChanged(::ISG::Node *value)
      {
        (*this).::ISG::Node::markAsDirty();
      }
      inline bool markedAsDirty()
      {
        return (*this).last_modified >= ::ISG::current_timestamp;
      }
      inline void markAsDirty()
      {
        if (!(*this).::ISG::Node::markedAsDirty())
          {
            (*this).last_modified = ::ISG::current_timestamp;
            for (int i = 0; i < (*this).parent.::std::vector< ::ISG::Node *, ::std::allocator< ::ISG::Node *> >::size(); i++)
              {
                (*(*this).parent.::std::vector< ::ISG::Node *, ::std::allocator< ::ISG::Node *> >::operator [](i)).childWasChanged(this);
              }
          }
      }
    protected:
      ::std::vector< ::ISG::Node *, ::std::allocator< ::ISG::Node *> > parent;
    public:
  };
  struct  TransformNode : ::ISG::Node
  {
      ::RTTL::Matrix4x4 matrix;
      bool is_visible;
      bool has_transform;
      inline TransformNode(::ISG::Node *t)
      {
        (*this).target = t;
        (*t).::ISG::Node::addParent(this);
      }
      inline void setTransform(::RTTL::Matrix4x4 &m)
      {
        (*this).has_transform = true;
        (*this).matrix = m;
      }
      inline void clearTransform()
      {
        (*this).has_transform = false;
      }
      ::ISG::Node *target;
  };
  struct  GroupNode : ::ISG::Node
  {
      inline void addChild(::ISG::Node *node)
      {
        (*this).children.::std::vector< ::ISG::Node *, ::std::allocator< ::ISG::Node *> >::push_back(node);
        (*node).::ISG::Node::addParent(this);
      }
      inline void removeChild(::ISG::Node *node)
      {
        const char __MERCURIUM_PRETTY_FUNCTION__[50] = "void ::ISG::GroupNode::removeChild(::ISG::Node *)";
        ::std::vector< ::ISG::Node *, ::std::allocator< ::ISG::Node *> >::iterator where((::std::find /* < ::__gnu_cxx::__normal_iterator< ::ISG::Node **, ::std::vector< ::ISG::Node *, ::std::allocator< ::ISG::Node *> > >, ::ISG::Node *> */ ((*this).children.::std::vector< ::ISG::Node *, ::std::allocator< ::ISG::Node *> >::begin(), (*this).children.::std::vector< ::ISG::Node *, ::std::allocator< ::ISG::Node *> >::end(), node)));
        where != (*this).children.::std::vector< ::ISG::Node *, ::std::allocator< ::ISG::Node *> >::end() ? static_cast<void>(0) : ::__assert_fail("where != children.end()", "/home/bsc18/bsc18186/scratch/parsec/raytrace/src/RTTL/API/ISG.hxx", 160, __MERCURIUM_PRETTY_FUNCTION__);
        (*this).children.::std::vector< ::ISG::Node *, ::std::allocator< ::ISG::Node *> >::erase(where);
        ::ISG::Node::removeParent /* < ::ISG::Node> */ (node, this);
      }
      inline ::ISG::TransformNode *attachTransformTo(::ISG::Node *child)
      {
        const char __MERCURIUM_PRETTY_FUNCTION__[73] = "::ISG::TransformNode *::ISG::GroupNode::attachTransformTo(::ISG::Node *)";
        ::std::vector< ::ISG::Node *, ::std::allocator< ::ISG::Node *> >::iterator where((::std::find /* < ::__gnu_cxx::__normal_iterator< ::ISG::Node **, ::std::vector< ::ISG::Node *, ::std::allocator< ::ISG::Node *> > >, ::ISG::Node *> */ ((*this).children.::std::vector< ::ISG::Node *, ::std::allocator< ::ISG::Node *> >::begin(), (*this).children.::std::vector< ::ISG::Node *, ::std::allocator< ::ISG::Node *> >::end(), child)));
        where != (*this).children.::std::vector< ::ISG::Node *, ::std::allocator< ::ISG::Node *> >::end() ? static_cast<void>(0) : ::__assert_fail("where != children.end()", "/home/bsc18/bsc18186/scratch/parsec/raytrace/src/RTTL/API/ISG.hxx", 172, __MERCURIUM_PRETTY_FUNCTION__);
        ::ISG::TransformNode *xfm(new (::ISG::TransformNode)((child)));
        (*this).::ISG::GroupNode::removeChild(child);
        (*this).::ISG::GroupNode::addChild(xfm);
        return xfm;
      }
      inline int getNumChildren()
      {
        return (*this).children.::std::vector< ::ISG::Node *, ::std::allocator< ::ISG::Node *> >::size();
      }
      inline ::ISG::Node *getChild(int i)
      {
        const char __MERCURIUM_PRETTY_FUNCTION__[45] = "::ISG::Node *::ISG::GroupNode::getChild(int)";
        i >= 0 && i < (*this).children.::std::vector< ::ISG::Node *, ::std::allocator< ::ISG::Node *> >::size() ? static_cast<void>(0) : ::__assert_fail("i >= 0 && i < children.size()", "/home/bsc18/bsc18186/scratch/parsec/raytrace/src/RTTL/API/ISG.hxx", 187, __MERCURIUM_PRETTY_FUNCTION__);
        return (*this).children.::std::vector< ::ISG::Node *, ::std::allocator< ::ISG::Node *> >::operator [](i);
      }
    protected:
      ::std::vector< ::ISG::Node *, ::std::allocator< ::ISG::Node *> > children;
    public:
  };
  struct World;
  struct  RootNode : ::ISG::GroupNode
  {
      inline RootNode()
      {
      }
  };
  struct  Material : ::ISG::Node
  {
      union 
      {
          int materialID;
          void *materialPtr;
      };
      inline Material(int materialID  = 0)
        : materialID(materialID)
      {
      }
  };
  template < typename target_t, typename source_t >
  inline void single_convert(target_t &target, source_t &source)__attribute__((always_inline));
  template < typename target_t, typename source_t >
  inline __attribute__((always_inline)) void single_convert(target_t &target, source_t &source)
  {
    const char __MERCURIUM_PRETTY_FUNCTION__[71] = "void ::ISG::single_convert<target_t, source_t>(target_t &, source_t &)";
    {
      ::std::cerr << "FATAL: " << "this kind of conversion ont implemented ... " << "(in " << __MERCURIUM_PRETTY_FUNCTION__ << ")" << ::std::endl<char, ::std::char_traits<char> >;
      ::exit(1);
    }
    ;
  }
  template <>
  inline __attribute__((always_inline)) void single_convert< ::RTTL::RTVec_t<4, float, 0>, ::RTTL::RTVec_t<3, float, 0> >(::ISG::vec4f &target, ::ISG::vec3f &source)
  {
    (::ISG::vec3f &)target = source;
  }
  template <>
  inline __attribute__((always_inline)) void single_convert< ::RTTL::RTVec_t<3, float, 0>, ::RTTL::RTVec_t<4, float, 0> >(::ISG::vec3f &target, ::ISG::vec4f &source)
  {
    target = (::ISG::vec3f &)source;
  }
  template < typename target_t, typename source_t >
  inline void array_convert(target_t *target, source_t *source, int count)__attribute__((always_inline));
  template < typename target_t, typename source_t >
  inline __attribute__((always_inline)) void array_convert(target_t *target, source_t *source, int count)
  {
    for (int i = 0; i < count; i++)
      {
        single_convert(target[i], source[i]);
      }
  }
  struct  World
  {
      ::std::vector< ::ISG::RootNode *, ::std::allocator< ::ISG::RootNode *> > rootNode;
      static inline ::ISG::World *getDefaultWorld()
      {
        if (::ISG::World::m_default == 0L)
          {
            ::ISG::World *w(new (::ISG::World)());
            (*w).makeDefault();
          }
        ;
        return ::ISG::World::m_default;
      }
      virtual inline void makeDefault()
      {
        ::ISG::World::m_default = this;
      }
    private:
      static ::ISG::World *m_default;
    public:
  };
  enum MeshType
  {
    RT_TRIANGLE_MESH = 0,
    RT_QUAD_MESH = 1
  };
  enum DataFormat
  {
    RT_ANY_FORMAT = 0,
    RT_UCHAR = 1,
    RT_BYTE = 2,
    RT_INT = 3,
    RT_INT2 = 4,
    RT_INT3 = 5,
    RT_INT4 = 6,
    RT_FLOAT = 7,
    RT_FLOAT2 = 8,
    RT_FLOAT3 = 9,
    RT_FLOAT4 = 10
  };
  static const int RTDataSizeOf[11U] = { 1, 1, 1, 1 * sizeof(int), 2 * sizeof(int), 3 * sizeof(int), 4 * sizeof(int), 1 * sizeof(float), 2 * sizeof(float), 3 * sizeof(float), 4 * sizeof(float) };
  enum SemanticType
  {
    RT_RAW_DATA = 0,
    RT_COORDINATE = 1,
    RT_COORDS = ::ISG::RT_COORDINATE,
    RT_VECTOR = 2,
    RT_NORMAL = 3,
    RT_TEXCOORD = 4,
    RT_INDEX = 5,
    RT_INDICES = ::ISG::RT_INDEX
  };
  struct  DataArray : ::ISG::Node
  {
      enum OwnerType
      {
        APP_IS_OWNER = 0,
        I_AM_OWNER = 1,
        NO_DATA_TO_OWN = 2
      };
      ::ISG::SemanticType type;
      ::ISG::DataFormat format;
      int units;
      int size_in_bytes;
      void *m_ptr;
      ::ISG::DataArray::OwnerType owner;
      inline DataArray(::ISG::Node *parent, ::ISG::SemanticType type, ::ISG::DataFormat format)
        : ::ISG::Node(parent), type(type), format(format), units(0), m_ptr(0L), owner(::ISG::DataArray::NO_DATA_TO_OWN)
      {
      }
      virtual inline ~DataArray()
      {
        (*this).::ISG::DataArray::clear();
      }
      inline void clear()
      {
        if ((*this).owner == ::ISG::DataArray::I_AM_OWNER && (*this).m_ptr != 0L)
          {
            ::free((*this).m_ptr);
          }
        (*this).m_ptr = 0L;
        (*this).units = 0;
        (*this).size_in_bytes = 0;
        (*this).owner = ::ISG::DataArray::NO_DATA_TO_OWN;
      }
      inline void set(::ISG::SemanticType type, ::ISG::DataFormat sourceFormat, void *ptr, int units, ::ISG::DataArray::OwnerType owner)
      {
        const char __MERCURIUM_PRETTY_FUNCTION__[109] = "void ::ISG::DataArray::set(::ISG::SemanticType, ::ISG::DataFormat, void *, int, ::ISG::DataArray::OwnerType)";
        if (::ISG::DataArray::I_AM_OWNER)
          {
            ::ISG::DataFormat &internalFormat((*this).format);
            if ((*this).type != type)
              {
                if ((*this).type == ::ISG::RT_RAW_DATA)
                  {
                    (*this).type = type;
                  }
                else
                  {
                    ::std::cerr << "FATAL: " << "writing data of incompatible format to a data array" << "(in " << __MERCURIUM_PRETTY_FUNCTION__ << ")" << ::std::endl<char, ::std::char_traits<char> >;
                    ::exit(1);
                  }
                ;
              }
            if (internalFormat == ::ISG::RT_ANY_FORMAT)
              {
                internalFormat = sourceFormat;
              }
            long int new_size_in_bytes(units * ::ISG::RTDataSizeOf[internalFormat]);
            (*this).m_ptr = ::realloc((*this).m_ptr, new_size_in_bytes);
            (*this).size_in_bytes = new_size_in_bytes;
            (*this).units = units;
            if (internalFormat == sourceFormat)
              {
                ::memcpy((*this).m_ptr, ptr, new_size_in_bytes);
              }
            else
              {
                switch (internalFormat)
                    {
                      case ::ISG::RT_FLOAT4 :
                      switch (sourceFormat)
                          {
                            case ::ISG::RT_FLOAT3 :
                            ::ISG::array_convert /* < ::RTTL::RTVec_t<4, float, 0>, ::RTTL::RTVec_t<3, float, 0> > */ ((::ISG::vec4f *)(*this).m_ptr, (::ISG::vec3f *)ptr, units);
                            break;
                            default :
                            {
                              ::std::cerr << "FATAL: " << "data conversion from this source format to FLOAT4 not implemented, yet" << "(in " << __MERCURIUM_PRETTY_FUNCTION__ << ")" << ::std::endl<char, ::std::char_traits<char> >;
                              ::exit(1);
                            }
                            ;
                          }
                      break;
                      default :
                      {
                        ::std::cerr << "FATAL: " << "data conversion to this internal format not implemented, yet" << "(in " << __MERCURIUM_PRETTY_FUNCTION__ << ")" << ::std::endl<char, ::std::char_traits<char> >;
                        ::exit(1);
                      }
                      ;
                    }
              }
          }
        else
          {
            (*this).::ISG::DataArray::clear();
            (*this).m_ptr = ptr;
            (*this).size_in_bytes = 0;
            (*this).type = type;
            (*this).format = (*this).format;
            (*this).units = units;
            (*this).owner = owner;
          }
      }
  };
  struct  BaseMesh : ::ISG::Node
  {
      ::ISG::DataArray *index;
      ::ISG::DataArray *coord;
      ::ISG::DataArray *shaderList;
      inline void setCoords(::ISG::DataArray *c)
      {
        ::ISG::Node::removeParent /* < ::ISG::DataArray> */ ((*this).coord, this);
        (*this).coord = c;
        (*(*this).coord).::ISG::Node::addParent(this);
      }
      inline void setIndices(::ISG::DataArray *i)
      {
        ::ISG::Node::removeParent /* < ::ISG::DataArray> */ ((*this).index, this);
        (*this).index = i;
        (*(*this).index).::ISG::Node::addParent(this);
      }
      ::ISG::MeshType type;
      inline BaseMesh(::ISG::Node *parent, ::ISG::MeshType type)
        : ::ISG::Node(parent), type(type), index(0L), coord(0L), shaderList(0L)
      {
      }
  };
}
using namespace ::RTTL;
using namespace ::ISG;
typedef ::ISG::Node *node_t;
typedef ::ISG::DataArray *data_t;
typedef ::ISG::BaseMesh *mesh_t;
typedef unsigned int uint_t;
enum newroot_flags_t
{
  RT_HIDDEN = 0,
  RT_VISIBLE = 1
};
void rtShow(::node_t node);
extern inline void rtHide(::node_t node)
{
  const char __MERCURIUM_PRETTY_FUNCTION__[24] = "void ::rtHide(::node_t)";
  ::std::cout << "function \'" << __MERCURIUM_PRETTY_FUNCTION__ << "\' not yet implemented" << ::std::endl<char, ::std::char_traits<char> >;
  ;
}
extern inline ::node_t rtNewRoot(::newroot_flags_t flags)
{
  ::node_t root(new (::ISG::RootNode)());
  if (flags & ::RT_VISIBLE)
    {
      ::rtShow(root);
    }
  return root;
}
extern inline ::mesh_t rtNewMesh(::node_t parent, ::ISG::MeshType type)
{
  const char __MERCURIUM_PRETTY_FUNCTION__[48] = "::mesh_t ::rtNewMesh(::node_t, ::ISG::MeshType)";
  parent ? static_cast<void>(0) : ::__assert_fail("parent", "/home/bsc18/bsc18186/scratch/parsec/raytrace/src/RTTL/API/rt.h", 82, __MERCURIUM_PRETTY_FUNCTION__);
  ::mesh_t mesh(new (::ISG::BaseMesh)((parent), (type)));
  ::ISG::GroupNode *group(dynamic_cast< ::ISG::GroupNode *>(parent));
  if (!group)
    {
      ::std::cerr << "FATAL: " << "can only add meshes to group nodes ... at least right now ... " << "(in " << __MERCURIUM_PRETTY_FUNCTION__ << ")" << ::std::endl<char, ::std::char_traits<char> >;
      ::exit(1);
    }
  ;
  (*group).::ISG::GroupNode::addChild(mesh);
  return mesh;
}
extern inline ::mesh_t rtTriangleMesh(::node_t parent)
{
  return ::rtNewMesh(parent, ::ISG::RT_TRIANGLE_MESH);
}
extern inline ::mesh_t rtQuadMesh(::node_t parent)
{
  return ::rtNewMesh(parent, ::ISG::RT_QUAD_MESH);
}
enum DataArrayFlags
{
  RT_PRIVATE = 0,
  RT_PERSISTENT = 1,
  RT_PERSISTENT_BIT = ::RT_PERSISTENT,
  RT_FORCE_OVERWRITE = 0,
  RT_NEW_ARRAY = 2,
  RT_NEW_ARRAY_BIT = ::RT_NEW_ARRAY | ::RT_FORCE_OVERWRITE,
  RT_FORCE_OVERWRITE_BIT = ::RT_NEW_ARRAY | ::RT_FORCE_OVERWRITE
};
enum MapMode
{
  RT_READ = 1,
  RT_WRITE = 2,
  RT_RW = ::RT_READ | ::RT_WRITE
};
extern inline void rtInit(int *acptr, char **avptr)
{
  ::std::cout << "initializing LRT ray tracer ..." << ::std::endl<char, ::std::char_traits<char> >;
}
extern inline void rtDestroy(::node_t node)
{
}
extern inline ::data_t rtNewDataArray(::node_t parent, ::ISG::SemanticType semanticType  = ::ISG::RT_RAW_DATA, ::ISG::DataFormat dataFormat  = ::ISG::RT_BYTE)
{
  ::ISG::DataArray *arr(new (::ISG::DataArray)((parent), (semanticType), (dataFormat)));
  return arr;
}
extern inline void rtWriteToArray(::data_t target, ::ISG::SemanticType semanticType, ::ISG::DataFormat dataFormat, unsigned char *const ptr, int count, ::DataArrayFlags flags)
{
  const char __MERCURIUM_PRETTY_FUNCTION__[118] = "void ::rtWriteToArray(::data_t, ::ISG::SemanticType, ::ISG::DataFormat, unsigned char *const , int, ::DataArrayFlags)";
  target ? static_cast<void>(0) : ::__assert_fail("target", "/home/bsc18/bsc18186/scratch/parsec/raytrace/src/RTTL/API/rt.h", 204, __MERCURIUM_PRETTY_FUNCTION__);
  ::ISG::DataArray *array(dynamic_cast< ::ISG::DataArray *>(target));
  array ? static_cast<void>(0) : ::__assert_fail("array", "/home/bsc18/bsc18186/scratch/parsec/raytrace/src/RTTL/API/rt.h", 206, __MERCURIUM_PRETTY_FUNCTION__);
  if ((flags & ::RT_PERSISTENT_BIT) == ::RT_PERSISTENT)
    {
      (*array).::ISG::DataArray::set(semanticType, dataFormat, ptr, count, ::ISG::DataArray::APP_IS_OWNER);
    }
  else
    {
      (*array).::ISG::DataArray::set(semanticType, dataFormat, ptr, count, ::ISG::DataArray::I_AM_OWNER);
    }
}
extern inline void rtCoords3f(::data_t target, const float *const coord, int coords, ::DataArrayFlags flags)
{
  ::rtWriteToArray(target, ::ISG::RT_COORDS, ::ISG::RT_FLOAT3, (unsigned char *)coord, coords, flags);
}
extern inline void rtIndices3i(::data_t target, const int *const coord, int coords, ::DataArrayFlags flags)
{
  ::rtWriteToArray(target, ::ISG::RT_INDICES, ::ISG::RT_INT3, (unsigned char *)coord, coords, flags);
}
extern inline void rtIndices4i(::data_t target, const int *const coord, int coords, ::DataArrayFlags flags)
{
  const char __MERCURIUM_PRETTY_FUNCTION__[71] = "void ::rtIndices4i(::data_t, const int *const , int, ::DataArrayFlags)";
  {
    ::std::cerr << "FATAL: " << "if mesh is triangular mesh then quad tesellation is required" << "(in " << __MERCURIUM_PRETTY_FUNCTION__ << ")" << ::std::endl<char, ::std::char_traits<char> >;
    ::exit(1);
  }
  ;
  ::rtWriteToArray(target, ::ISG::RT_INDICES, ::ISG::RT_INT4, (unsigned char *)coord, coords, flags);
}
extern inline ::data_t rtGetMeshCoords(::mesh_t m)
{
  const char __MERCURIUM_PRETTY_FUNCTION__[37] = "::data_t ::rtGetMeshCoords(::mesh_t)";
  ::ISG::BaseMesh *mesh(dynamic_cast< ::ISG::BaseMesh *>(m));
  mesh ? static_cast<void>(0) : ::__assert_fail("mesh", "/home/bsc18/bsc18186/scratch/parsec/raytrace/src/RTTL/API/rt.h", 280, __MERCURIUM_PRETTY_FUNCTION__);
  return (*mesh).coord;
}
extern inline ::data_t rtGetMeshIndices(::mesh_t m)
{
  const char __MERCURIUM_PRETTY_FUNCTION__[38] = "::data_t ::rtGetMeshIndices(::mesh_t)";
  ::ISG::BaseMesh *mesh(dynamic_cast< ::ISG::BaseMesh *>(m));
  mesh ? static_cast<void>(0) : ::__assert_fail("mesh", "/home/bsc18/bsc18186/scratch/parsec/raytrace/src/RTTL/API/rt.h", 287, __MERCURIUM_PRETTY_FUNCTION__);
  return (*mesh).index;
}
extern inline ::data_t rtNewCoordArray(::node_t parent, ::ISG::DataFormat internalFormat)
{
  ::data_t data(new (::ISG::DataArray)((parent), (::ISG::RT_COORDS), (internalFormat)));
  ::mesh_t mesh(dynamic_cast< ::ISG::BaseMesh *>(parent));
  if (mesh)
    {
      (*mesh).::ISG::BaseMesh::setCoords(data);
    }
  return data;
}
extern inline ::data_t rtNewIndexArray(::node_t parent, ::ISG::DataFormat internalFormat)
{
  ::data_t data(new (::ISG::DataArray)((parent), (::ISG::RT_INDICES), (internalFormat)));
  ::mesh_t mesh(dynamic_cast< ::ISG::BaseMesh *>(parent));
  if (mesh)
    {
      (*mesh).::ISG::BaseMesh::setIndices(data);
    }
  return data;
}
extern inline bool rtValidData(::data_t data)
{
  return data != 0L;
}
extern inline void *rtMapBuffer(::data_t data, ::MapMode mapMode)
{
  if (!data)
    {
      return 0L;
    }
  return (*data).m_ptr;
}
extern inline void rtUnmapBuffer(::data_t data)
{
}
extern inline void rtEndGeometry()
{
}
typedef void LRTvoid;
typedef int LRTint;
typedef float RTfloat;
typedef float LRTfloat;
typedef unsigned int LRTuint;
typedef unsigned int LRThandle;
typedef void *LRTFrameBufferHandle;
typedef void *LRTCamera;
typedef void *LRTContext;
typedef void *RTCamera;
enum LRTFrameBufferFormat
{
  LRT_UCHAR_RGBA = 0
};
extern "C"
{
  void lrtInit(int *argc, char **argv);
}
extern "C"
{
  ::LRTFrameBufferHandle lrtCreateTextureFB(::LRTuint width, ::LRTuint height);
}
extern "C"
{
  ::LRTvoid lrtDisplayFB(::LRTFrameBufferHandle fbHandle);
}
extern "C"
{
  ::LRTvoid lrtDestroyFB(::LRTFrameBufferHandle fbHandle);
}
extern "C"
{
  ::LRTContext lrtCreateContext();
}
extern "C"
{
  ::LRTvoid lrtDestroyContext(::LRTContext context);
}
extern "C"
{
  ::LRTCamera lrtCreateCamera();
}
extern "C"
{
  ::LRTvoid lrtDestroyCamera(::LRTCamera camera);
}
extern "C"
{
  ::LRTvoid lrtSetRenderThreads(::LRTContext context, ::LRTuint threads);
}
extern "C"
{
  ::LRTvoid lrtBuildContext(::LRTContext context);
}
extern "C"
{
  ::LRTvoid lrtRenderFrame(::LRTFrameBufferHandle fb, ::LRTContext context, ::LRTCamera camera);
}
extern "C"
{
  ::LRTvoid lrtLookAt(::LRTCamera camera, ::RTfloat eyeX, ::RTfloat eyeY, ::RTfloat eyeZ, ::RTfloat centerX, ::RTfloat centerY, ::RTfloat centerZ, ::RTfloat upX, ::RTfloat upY, ::RTfloat upZ, ::RTfloat angle, ::RTfloat aspect);
}
typedef unsigned int GLenum;
typedef unsigned char GLboolean;
typedef unsigned int GLbitfield;
typedef void GLvoid;
typedef signed char GLbyte;
typedef short int GLshort;
typedef int GLint;
typedef unsigned char GLubyte;
typedef unsigned short int GLushort;
typedef unsigned int GLuint;
typedef int GLsizei;
typedef float GLfloat;
typedef float GLclampf;
typedef double GLdouble;
typedef double GLclampd;
extern "C"
{
  void glClearIndex(::GLfloat c)__attribute__((visibility("default")));
}
extern "C"
{
  void glClearColor(::GLclampf red, ::GLclampf green, ::GLclampf blue, ::GLclampf alpha)__attribute__((visibility("default")));
}
extern "C"
{
  void glClear(::GLbitfield mask)__attribute__((visibility("default")));
}
extern "C"
{
  void glIndexMask(::GLuint mask)__attribute__((visibility("default")));
}
extern "C"
{
  void glColorMask(::GLboolean red, ::GLboolean green, ::GLboolean blue, ::GLboolean alpha)__attribute__((visibility("default")));
}
extern "C"
{
  void glAlphaFunc(::GLenum func, ::GLclampf ref)__attribute__((visibility("default")));
}
extern "C"
{
  void glBlendFunc(::GLenum sfactor, ::GLenum dfactor)__attribute__((visibility("default")));
}
extern "C"
{
  void glLogicOp(::GLenum opcode)__attribute__((visibility("default")));
}
extern "C"
{
  void glCullFace(::GLenum mode)__attribute__((visibility("default")));
}
extern "C"
{
  void glFrontFace(::GLenum mode)__attribute__((visibility("default")));
}
extern "C"
{
  void glPointSize(::GLfloat size)__attribute__((visibility("default")));
}
extern "C"
{
  void glLineWidth(::GLfloat width)__attribute__((visibility("default")));
}
extern "C"
{
  void glLineStipple(::GLint factor, ::GLushort pattern)__attribute__((visibility("default")));
}
extern "C"
{
  void glPolygonMode(::GLenum face, ::GLenum mode)__attribute__((visibility("default")));
}
extern "C"
{
  void glPolygonOffset(::GLfloat factor, ::GLfloat units)__attribute__((visibility("default")));
}
extern "C"
{
  void glPolygonStipple(const ::GLubyte *mask)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetPolygonStipple(::GLubyte *mask)__attribute__((visibility("default")));
}
extern "C"
{
  void glEdgeFlag(::GLboolean flag)__attribute__((visibility("default")));
}
extern "C"
{
  void glEdgeFlagv(const ::GLboolean *flag)__attribute__((visibility("default")));
}
extern "C"
{
  void glScissor(::GLint x, ::GLint y, ::GLsizei width, ::GLsizei height)__attribute__((visibility("default")));
}
extern "C"
{
  void glClipPlane(::GLenum plane, const ::GLdouble *equation)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetClipPlane(::GLenum plane, ::GLdouble *equation)__attribute__((visibility("default")));
}
extern "C"
{
  void glDrawBuffer(::GLenum mode)__attribute__((visibility("default")));
}
extern "C"
{
  void glReadBuffer(::GLenum mode)__attribute__((visibility("default")));
}
extern "C"
{
  void glEnable(::GLenum cap)__attribute__((visibility("default")));
}
extern "C"
{
  void glDisable(::GLenum cap)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLboolean glIsEnabled(::GLenum cap)__attribute__((visibility("default")));
}
extern "C"
{
  void glEnableClientState(::GLenum cap)__attribute__((visibility("default")));
}
extern "C"
{
  void glDisableClientState(::GLenum cap)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetBooleanv(::GLenum pname, ::GLboolean *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetDoublev(::GLenum pname, ::GLdouble *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetFloatv(::GLenum pname, ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetIntegerv(::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glPushAttrib(::GLbitfield mask)__attribute__((visibility("default")));
}
extern "C"
{
  void glPopAttrib()__attribute__((visibility("default")));
}
extern "C"
{
  void glPushClientAttrib(::GLbitfield mask)__attribute__((visibility("default")));
}
extern "C"
{
  void glPopClientAttrib()__attribute__((visibility("default")));
}
extern "C"
{
  ::GLint glRenderMode(::GLenum mode)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLenum glGetError()__attribute__((visibility("default")));
}
extern "C"
{
  const ::GLubyte *glGetString(::GLenum name)__attribute__((visibility("default")));
}
extern "C"
{
  void glFinish()__attribute__((visibility("default")));
}
extern "C"
{
  void glFlush()__attribute__((visibility("default")));
}
extern "C"
{
  void glHint(::GLenum target, ::GLenum mode)__attribute__((visibility("default")));
}
extern "C"
{
  void glClearDepth(::GLclampd depth)__attribute__((visibility("default")));
}
extern "C"
{
  void glDepthFunc(::GLenum func)__attribute__((visibility("default")));
}
extern "C"
{
  void glDepthMask(::GLboolean flag)__attribute__((visibility("default")));
}
extern "C"
{
  void glDepthRange(::GLclampd near_val, ::GLclampd far_val)__attribute__((visibility("default")));
}
extern "C"
{
  void glClearAccum(::GLfloat red, ::GLfloat green, ::GLfloat blue, ::GLfloat alpha)__attribute__((visibility("default")));
}
extern "C"
{
  void glAccum(::GLenum op, ::GLfloat value)__attribute__((visibility("default")));
}
extern "C"
{
  void glMatrixMode(::GLenum mode)__attribute__((visibility("default")));
}
extern "C"
{
  void glOrtho(::GLdouble left, ::GLdouble right, ::GLdouble bottom, ::GLdouble top, ::GLdouble near_val, ::GLdouble far_val)__attribute__((visibility("default")));
}
extern "C"
{
  void glFrustum(::GLdouble left, ::GLdouble right, ::GLdouble bottom, ::GLdouble top, ::GLdouble near_val, ::GLdouble far_val)__attribute__((visibility("default")));
}
extern "C"
{
  void glViewport(::GLint x, ::GLint y, ::GLsizei width, ::GLsizei height)__attribute__((visibility("default")));
}
extern "C"
{
  void glPushMatrix()__attribute__((visibility("default")));
}
extern "C"
{
  void glPopMatrix()__attribute__((visibility("default")));
}
extern "C"
{
  void glLoadIdentity()__attribute__((visibility("default")));
}
extern "C"
{
  void glLoadMatrixd(const ::GLdouble *m)__attribute__((visibility("default")));
}
extern "C"
{
  void glLoadMatrixf(const ::GLfloat *m)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultMatrixd(const ::GLdouble *m)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultMatrixf(const ::GLfloat *m)__attribute__((visibility("default")));
}
extern "C"
{
  void glRotated(::GLdouble angle, ::GLdouble x, ::GLdouble y, ::GLdouble z)__attribute__((visibility("default")));
}
extern "C"
{
  void glRotatef(::GLfloat angle, ::GLfloat x, ::GLfloat y, ::GLfloat z)__attribute__((visibility("default")));
}
extern "C"
{
  void glScaled(::GLdouble x, ::GLdouble y, ::GLdouble z)__attribute__((visibility("default")));
}
extern "C"
{
  void glScalef(::GLfloat x, ::GLfloat y, ::GLfloat z)__attribute__((visibility("default")));
}
extern "C"
{
  void glTranslated(::GLdouble x, ::GLdouble y, ::GLdouble z)__attribute__((visibility("default")));
}
extern "C"
{
  void glTranslatef(::GLfloat x, ::GLfloat y, ::GLfloat z)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLboolean glIsList(::GLuint list)__attribute__((visibility("default")));
}
extern "C"
{
  void glDeleteLists(::GLuint list, ::GLsizei range)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLuint glGenLists(::GLsizei range)__attribute__((visibility("default")));
}
extern "C"
{
  void glNewList(::GLuint list, ::GLenum mode)__attribute__((visibility("default")));
}
extern "C"
{
  void glEndList()__attribute__((visibility("default")));
}
extern "C"
{
  void glCallList(::GLuint list)__attribute__((visibility("default")));
}
extern "C"
{
  void glCallLists(::GLsizei n, ::GLenum type, const ::GLvoid *lists)__attribute__((visibility("default")));
}
extern "C"
{
  void glListBase(::GLuint base)__attribute__((visibility("default")));
}
extern "C"
{
  void glBegin(::GLenum mode)__attribute__((visibility("default")));
}
extern "C"
{
  void glEnd()__attribute__((visibility("default")));
}
extern "C"
{
  void glVertex2d(::GLdouble x, ::GLdouble y)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertex2f(::GLfloat x, ::GLfloat y)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertex2i(::GLint x, ::GLint y)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertex2s(::GLshort x, ::GLshort y)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertex3d(::GLdouble x, ::GLdouble y, ::GLdouble z)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertex3f(::GLfloat x, ::GLfloat y, ::GLfloat z)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertex3i(::GLint x, ::GLint y, ::GLint z)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertex3s(::GLshort x, ::GLshort y, ::GLshort z)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertex4d(::GLdouble x, ::GLdouble y, ::GLdouble z, ::GLdouble w)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertex4f(::GLfloat x, ::GLfloat y, ::GLfloat z, ::GLfloat w)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertex4i(::GLint x, ::GLint y, ::GLint z, ::GLint w)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertex4s(::GLshort x, ::GLshort y, ::GLshort z, ::GLshort w)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertex2dv(const ::GLdouble *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertex2fv(const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertex2iv(const ::GLint *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertex2sv(const ::GLshort *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertex3dv(const ::GLdouble *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertex3fv(const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertex3iv(const ::GLint *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertex3sv(const ::GLshort *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertex4dv(const ::GLdouble *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertex4fv(const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertex4iv(const ::GLint *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertex4sv(const ::GLshort *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glNormal3b(::GLbyte nx, ::GLbyte ny, ::GLbyte nz)__attribute__((visibility("default")));
}
extern "C"
{
  void glNormal3d(::GLdouble nx, ::GLdouble ny, ::GLdouble nz)__attribute__((visibility("default")));
}
extern "C"
{
  void glNormal3f(::GLfloat nx, ::GLfloat ny, ::GLfloat nz)__attribute__((visibility("default")));
}
extern "C"
{
  void glNormal3i(::GLint nx, ::GLint ny, ::GLint nz)__attribute__((visibility("default")));
}
extern "C"
{
  void glNormal3s(::GLshort nx, ::GLshort ny, ::GLshort nz)__attribute__((visibility("default")));
}
extern "C"
{
  void glNormal3bv(const ::GLbyte *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glNormal3dv(const ::GLdouble *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glNormal3fv(const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glNormal3iv(const ::GLint *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glNormal3sv(const ::GLshort *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glIndexd(::GLdouble c)__attribute__((visibility("default")));
}
extern "C"
{
  void glIndexf(::GLfloat c)__attribute__((visibility("default")));
}
extern "C"
{
  void glIndexi(::GLint c)__attribute__((visibility("default")));
}
extern "C"
{
  void glIndexs(::GLshort c)__attribute__((visibility("default")));
}
extern "C"
{
  void glIndexub(::GLubyte c)__attribute__((visibility("default")));
}
extern "C"
{
  void glIndexdv(const ::GLdouble *c)__attribute__((visibility("default")));
}
extern "C"
{
  void glIndexfv(const ::GLfloat *c)__attribute__((visibility("default")));
}
extern "C"
{
  void glIndexiv(const ::GLint *c)__attribute__((visibility("default")));
}
extern "C"
{
  void glIndexsv(const ::GLshort *c)__attribute__((visibility("default")));
}
extern "C"
{
  void glIndexubv(const ::GLubyte *c)__attribute__((visibility("default")));
}
extern "C"
{
  void glColor3b(::GLbyte red, ::GLbyte green, ::GLbyte blue)__attribute__((visibility("default")));
}
extern "C"
{
  void glColor3d(::GLdouble red, ::GLdouble green, ::GLdouble blue)__attribute__((visibility("default")));
}
extern "C"
{
  void glColor3f(::GLfloat red, ::GLfloat green, ::GLfloat blue)__attribute__((visibility("default")));
}
extern "C"
{
  void glColor3i(::GLint red, ::GLint green, ::GLint blue)__attribute__((visibility("default")));
}
extern "C"
{
  void glColor3s(::GLshort red, ::GLshort green, ::GLshort blue)__attribute__((visibility("default")));
}
extern "C"
{
  void glColor3ub(::GLubyte red, ::GLubyte green, ::GLubyte blue)__attribute__((visibility("default")));
}
extern "C"
{
  void glColor3ui(::GLuint red, ::GLuint green, ::GLuint blue)__attribute__((visibility("default")));
}
extern "C"
{
  void glColor3us(::GLushort red, ::GLushort green, ::GLushort blue)__attribute__((visibility("default")));
}
extern "C"
{
  void glColor4b(::GLbyte red, ::GLbyte green, ::GLbyte blue, ::GLbyte alpha)__attribute__((visibility("default")));
}
extern "C"
{
  void glColor4d(::GLdouble red, ::GLdouble green, ::GLdouble blue, ::GLdouble alpha)__attribute__((visibility("default")));
}
extern "C"
{
  void glColor4f(::GLfloat red, ::GLfloat green, ::GLfloat blue, ::GLfloat alpha)__attribute__((visibility("default")));
}
extern "C"
{
  void glColor4i(::GLint red, ::GLint green, ::GLint blue, ::GLint alpha)__attribute__((visibility("default")));
}
extern "C"
{
  void glColor4s(::GLshort red, ::GLshort green, ::GLshort blue, ::GLshort alpha)__attribute__((visibility("default")));
}
extern "C"
{
  void glColor4ub(::GLubyte red, ::GLubyte green, ::GLubyte blue, ::GLubyte alpha)__attribute__((visibility("default")));
}
extern "C"
{
  void glColor4ui(::GLuint red, ::GLuint green, ::GLuint blue, ::GLuint alpha)__attribute__((visibility("default")));
}
extern "C"
{
  void glColor4us(::GLushort red, ::GLushort green, ::GLushort blue, ::GLushort alpha)__attribute__((visibility("default")));
}
extern "C"
{
  void glColor3bv(const ::GLbyte *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glColor3dv(const ::GLdouble *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glColor3fv(const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glColor3iv(const ::GLint *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glColor3sv(const ::GLshort *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glColor3ubv(const ::GLubyte *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glColor3uiv(const ::GLuint *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glColor3usv(const ::GLushort *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glColor4bv(const ::GLbyte *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glColor4dv(const ::GLdouble *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glColor4fv(const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glColor4iv(const ::GLint *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glColor4sv(const ::GLshort *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glColor4ubv(const ::GLubyte *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glColor4uiv(const ::GLuint *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glColor4usv(const ::GLushort *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexCoord1d(::GLdouble s)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexCoord1f(::GLfloat s)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexCoord1i(::GLint s)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexCoord1s(::GLshort s)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexCoord2d(::GLdouble s, ::GLdouble t)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexCoord2f(::GLfloat s, ::GLfloat t)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexCoord2i(::GLint s, ::GLint t)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexCoord2s(::GLshort s, ::GLshort t)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexCoord3d(::GLdouble s, ::GLdouble t, ::GLdouble r)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexCoord3f(::GLfloat s, ::GLfloat t, ::GLfloat r)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexCoord3i(::GLint s, ::GLint t, ::GLint r)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexCoord3s(::GLshort s, ::GLshort t, ::GLshort r)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexCoord4d(::GLdouble s, ::GLdouble t, ::GLdouble r, ::GLdouble q)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexCoord4f(::GLfloat s, ::GLfloat t, ::GLfloat r, ::GLfloat q)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexCoord4i(::GLint s, ::GLint t, ::GLint r, ::GLint q)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexCoord4s(::GLshort s, ::GLshort t, ::GLshort r, ::GLshort q)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexCoord1dv(const ::GLdouble *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexCoord1fv(const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexCoord1iv(const ::GLint *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexCoord1sv(const ::GLshort *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexCoord2dv(const ::GLdouble *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexCoord2fv(const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexCoord2iv(const ::GLint *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexCoord2sv(const ::GLshort *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexCoord3dv(const ::GLdouble *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexCoord3fv(const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexCoord3iv(const ::GLint *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexCoord3sv(const ::GLshort *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexCoord4dv(const ::GLdouble *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexCoord4fv(const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexCoord4iv(const ::GLint *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexCoord4sv(const ::GLshort *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glRasterPos2d(::GLdouble x, ::GLdouble y)__attribute__((visibility("default")));
}
extern "C"
{
  void glRasterPos2f(::GLfloat x, ::GLfloat y)__attribute__((visibility("default")));
}
extern "C"
{
  void glRasterPos2i(::GLint x, ::GLint y)__attribute__((visibility("default")));
}
extern "C"
{
  void glRasterPos2s(::GLshort x, ::GLshort y)__attribute__((visibility("default")));
}
extern "C"
{
  void glRasterPos3d(::GLdouble x, ::GLdouble y, ::GLdouble z)__attribute__((visibility("default")));
}
extern "C"
{
  void glRasterPos3f(::GLfloat x, ::GLfloat y, ::GLfloat z)__attribute__((visibility("default")));
}
extern "C"
{
  void glRasterPos3i(::GLint x, ::GLint y, ::GLint z)__attribute__((visibility("default")));
}
extern "C"
{
  void glRasterPos3s(::GLshort x, ::GLshort y, ::GLshort z)__attribute__((visibility("default")));
}
extern "C"
{
  void glRasterPos4d(::GLdouble x, ::GLdouble y, ::GLdouble z, ::GLdouble w)__attribute__((visibility("default")));
}
extern "C"
{
  void glRasterPos4f(::GLfloat x, ::GLfloat y, ::GLfloat z, ::GLfloat w)__attribute__((visibility("default")));
}
extern "C"
{
  void glRasterPos4i(::GLint x, ::GLint y, ::GLint z, ::GLint w)__attribute__((visibility("default")));
}
extern "C"
{
  void glRasterPos4s(::GLshort x, ::GLshort y, ::GLshort z, ::GLshort w)__attribute__((visibility("default")));
}
extern "C"
{
  void glRasterPos2dv(const ::GLdouble *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glRasterPos2fv(const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glRasterPos2iv(const ::GLint *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glRasterPos2sv(const ::GLshort *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glRasterPos3dv(const ::GLdouble *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glRasterPos3fv(const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glRasterPos3iv(const ::GLint *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glRasterPos3sv(const ::GLshort *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glRasterPos4dv(const ::GLdouble *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glRasterPos4fv(const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glRasterPos4iv(const ::GLint *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glRasterPos4sv(const ::GLshort *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glRectd(::GLdouble x1, ::GLdouble y1, ::GLdouble x2, ::GLdouble y2)__attribute__((visibility("default")));
}
extern "C"
{
  void glRectf(::GLfloat x1, ::GLfloat y1, ::GLfloat x2, ::GLfloat y2)__attribute__((visibility("default")));
}
extern "C"
{
  void glRecti(::GLint x1, ::GLint y1, ::GLint x2, ::GLint y2)__attribute__((visibility("default")));
}
extern "C"
{
  void glRects(::GLshort x1, ::GLshort y1, ::GLshort x2, ::GLshort y2)__attribute__((visibility("default")));
}
extern "C"
{
  void glRectdv(const ::GLdouble *v1, const ::GLdouble *v2)__attribute__((visibility("default")));
}
extern "C"
{
  void glRectfv(const ::GLfloat *v1, const ::GLfloat *v2)__attribute__((visibility("default")));
}
extern "C"
{
  void glRectiv(const ::GLint *v1, const ::GLint *v2)__attribute__((visibility("default")));
}
extern "C"
{
  void glRectsv(const ::GLshort *v1, const ::GLshort *v2)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexPointer(::GLint size, ::GLenum type, ::GLsizei stride, const ::GLvoid *ptr)__attribute__((visibility("default")));
}
extern "C"
{
  void glNormalPointer(::GLenum type, ::GLsizei stride, const ::GLvoid *ptr)__attribute__((visibility("default")));
}
extern "C"
{
  void glColorPointer(::GLint size, ::GLenum type, ::GLsizei stride, const ::GLvoid *ptr)__attribute__((visibility("default")));
}
extern "C"
{
  void glIndexPointer(::GLenum type, ::GLsizei stride, const ::GLvoid *ptr)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexCoordPointer(::GLint size, ::GLenum type, ::GLsizei stride, const ::GLvoid *ptr)__attribute__((visibility("default")));
}
extern "C"
{
  void glEdgeFlagPointer(::GLsizei stride, const ::GLvoid *ptr)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetPointerv(::GLenum pname, ::GLvoid **params)__attribute__((visibility("default")));
}
extern "C"
{
  void glArrayElement(::GLint i)__attribute__((visibility("default")));
}
extern "C"
{
  void glDrawArrays(::GLenum mode, ::GLint first, ::GLsizei count)__attribute__((visibility("default")));
}
extern "C"
{
  void glDrawElements(::GLenum mode, ::GLsizei count, ::GLenum type, const ::GLvoid *indices)__attribute__((visibility("default")));
}
extern "C"
{
  void glInterleavedArrays(::GLenum format, ::GLsizei stride, const ::GLvoid *pointer)__attribute__((visibility("default")));
}
extern "C"
{
  void glShadeModel(::GLenum mode)__attribute__((visibility("default")));
}
extern "C"
{
  void glLightf(::GLenum light, ::GLenum pname, ::GLfloat param)__attribute__((visibility("default")));
}
extern "C"
{
  void glLighti(::GLenum light, ::GLenum pname, ::GLint param)__attribute__((visibility("default")));
}
extern "C"
{
  void glLightfv(::GLenum light, ::GLenum pname, const ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glLightiv(::GLenum light, ::GLenum pname, const ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetLightfv(::GLenum light, ::GLenum pname, ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetLightiv(::GLenum light, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glLightModelf(::GLenum pname, ::GLfloat param)__attribute__((visibility("default")));
}
extern "C"
{
  void glLightModeli(::GLenum pname, ::GLint param)__attribute__((visibility("default")));
}
extern "C"
{
  void glLightModelfv(::GLenum pname, const ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glLightModeliv(::GLenum pname, const ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glMaterialf(::GLenum face, ::GLenum pname, ::GLfloat param)__attribute__((visibility("default")));
}
extern "C"
{
  void glMateriali(::GLenum face, ::GLenum pname, ::GLint param)__attribute__((visibility("default")));
}
extern "C"
{
  void glMaterialfv(::GLenum face, ::GLenum pname, const ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glMaterialiv(::GLenum face, ::GLenum pname, const ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetMaterialfv(::GLenum face, ::GLenum pname, ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetMaterialiv(::GLenum face, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glColorMaterial(::GLenum face, ::GLenum mode)__attribute__((visibility("default")));
}
extern "C"
{
  void glPixelZoom(::GLfloat xfactor, ::GLfloat yfactor)__attribute__((visibility("default")));
}
extern "C"
{
  void glPixelStoref(::GLenum pname, ::GLfloat param)__attribute__((visibility("default")));
}
extern "C"
{
  void glPixelStorei(::GLenum pname, ::GLint param)__attribute__((visibility("default")));
}
extern "C"
{
  void glPixelTransferf(::GLenum pname, ::GLfloat param)__attribute__((visibility("default")));
}
extern "C"
{
  void glPixelTransferi(::GLenum pname, ::GLint param)__attribute__((visibility("default")));
}
extern "C"
{
  void glPixelMapfv(::GLenum map, ::GLsizei mapsize, const ::GLfloat *values)__attribute__((visibility("default")));
}
extern "C"
{
  void glPixelMapuiv(::GLenum map, ::GLsizei mapsize, const ::GLuint *values)__attribute__((visibility("default")));
}
extern "C"
{
  void glPixelMapusv(::GLenum map, ::GLsizei mapsize, const ::GLushort *values)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetPixelMapfv(::GLenum map, ::GLfloat *values)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetPixelMapuiv(::GLenum map, ::GLuint *values)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetPixelMapusv(::GLenum map, ::GLushort *values)__attribute__((visibility("default")));
}
extern "C"
{
  void glBitmap(::GLsizei width, ::GLsizei height, ::GLfloat xorig, ::GLfloat yorig, ::GLfloat xmove, ::GLfloat ymove, const ::GLubyte *bitmap)__attribute__((visibility("default")));
}
extern "C"
{
  void glReadPixels(::GLint x, ::GLint y, ::GLsizei width, ::GLsizei height, ::GLenum format, ::GLenum type, ::GLvoid *pixels)__attribute__((visibility("default")));
}
extern "C"
{
  void glDrawPixels(::GLsizei width, ::GLsizei height, ::GLenum format, ::GLenum type, const ::GLvoid *pixels)__attribute__((visibility("default")));
}
extern "C"
{
  void glCopyPixels(::GLint x, ::GLint y, ::GLsizei width, ::GLsizei height, ::GLenum type)__attribute__((visibility("default")));
}
extern "C"
{
  void glStencilFunc(::GLenum func, ::GLint ref, ::GLuint mask)__attribute__((visibility("default")));
}
extern "C"
{
  void glStencilMask(::GLuint mask)__attribute__((visibility("default")));
}
extern "C"
{
  void glStencilOp(::GLenum fail, ::GLenum zfail, ::GLenum zpass)__attribute__((visibility("default")));
}
extern "C"
{
  void glClearStencil(::GLint s)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexGend(::GLenum coord, ::GLenum pname, ::GLdouble param)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexGenf(::GLenum coord, ::GLenum pname, ::GLfloat param)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexGeni(::GLenum coord, ::GLenum pname, ::GLint param)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexGendv(::GLenum coord, ::GLenum pname, const ::GLdouble *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexGenfv(::GLenum coord, ::GLenum pname, const ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexGeniv(::GLenum coord, ::GLenum pname, const ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetTexGendv(::GLenum coord, ::GLenum pname, ::GLdouble *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetTexGenfv(::GLenum coord, ::GLenum pname, ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetTexGeniv(::GLenum coord, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexEnvf(::GLenum target, ::GLenum pname, ::GLfloat param)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexEnvi(::GLenum target, ::GLenum pname, ::GLint param)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexEnvfv(::GLenum target, ::GLenum pname, const ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexEnviv(::GLenum target, ::GLenum pname, const ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetTexEnvfv(::GLenum target, ::GLenum pname, ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetTexEnviv(::GLenum target, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexParameterf(::GLenum target, ::GLenum pname, ::GLfloat param)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexParameteri(::GLenum target, ::GLenum pname, ::GLint param)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexParameterfv(::GLenum target, ::GLenum pname, const ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexParameteriv(::GLenum target, ::GLenum pname, const ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetTexParameterfv(::GLenum target, ::GLenum pname, ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetTexParameteriv(::GLenum target, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetTexLevelParameterfv(::GLenum target, ::GLint level, ::GLenum pname, ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetTexLevelParameteriv(::GLenum target, ::GLint level, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexImage1D(::GLenum target, ::GLint level, ::GLint internalFormat, ::GLsizei width, ::GLint border, ::GLenum format, ::GLenum type, const ::GLvoid *pixels)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexImage2D(::GLenum target, ::GLint level, ::GLint internalFormat, ::GLsizei width, ::GLsizei height, ::GLint border, ::GLenum format, ::GLenum type, const ::GLvoid *pixels)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetTexImage(::GLenum target, ::GLint level, ::GLenum format, ::GLenum type, ::GLvoid *pixels)__attribute__((visibility("default")));
}
extern "C"
{
  void glGenTextures(::GLsizei n, ::GLuint *textures)__attribute__((visibility("default")));
}
extern "C"
{
  void glDeleteTextures(::GLsizei n, const ::GLuint *textures)__attribute__((visibility("default")));
}
extern "C"
{
  void glBindTexture(::GLenum target, ::GLuint texture)__attribute__((visibility("default")));
}
extern "C"
{
  void glPrioritizeTextures(::GLsizei n, const ::GLuint *textures, const ::GLclampf *priorities)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLboolean glAreTexturesResident(::GLsizei n, const ::GLuint *textures, ::GLboolean *residences)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLboolean glIsTexture(::GLuint texture)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexSubImage1D(::GLenum target, ::GLint level, ::GLint xoffset, ::GLsizei width, ::GLenum format, ::GLenum type, const ::GLvoid *pixels)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexSubImage2D(::GLenum target, ::GLint level, ::GLint xoffset, ::GLint yoffset, ::GLsizei width, ::GLsizei height, ::GLenum format, ::GLenum type, const ::GLvoid *pixels)__attribute__((visibility("default")));
}
extern "C"
{
  void glCopyTexImage1D(::GLenum target, ::GLint level, ::GLenum internalformat, ::GLint x, ::GLint y, ::GLsizei width, ::GLint border)__attribute__((visibility("default")));
}
extern "C"
{
  void glCopyTexImage2D(::GLenum target, ::GLint level, ::GLenum internalformat, ::GLint x, ::GLint y, ::GLsizei width, ::GLsizei height, ::GLint border)__attribute__((visibility("default")));
}
extern "C"
{
  void glCopyTexSubImage1D(::GLenum target, ::GLint level, ::GLint xoffset, ::GLint x, ::GLint y, ::GLsizei width)__attribute__((visibility("default")));
}
extern "C"
{
  void glCopyTexSubImage2D(::GLenum target, ::GLint level, ::GLint xoffset, ::GLint yoffset, ::GLint x, ::GLint y, ::GLsizei width, ::GLsizei height)__attribute__((visibility("default")));
}
extern "C"
{
  void glMap1d(::GLenum target, ::GLdouble u1, ::GLdouble u2, ::GLint stride, ::GLint order, const ::GLdouble *points)__attribute__((visibility("default")));
}
extern "C"
{
  void glMap1f(::GLenum target, ::GLfloat u1, ::GLfloat u2, ::GLint stride, ::GLint order, const ::GLfloat *points)__attribute__((visibility("default")));
}
extern "C"
{
  void glMap2d(::GLenum target, ::GLdouble u1, ::GLdouble u2, ::GLint ustride, ::GLint uorder, ::GLdouble v1, ::GLdouble v2, ::GLint vstride, ::GLint vorder, const ::GLdouble *points)__attribute__((visibility("default")));
}
extern "C"
{
  void glMap2f(::GLenum target, ::GLfloat u1, ::GLfloat u2, ::GLint ustride, ::GLint uorder, ::GLfloat v1, ::GLfloat v2, ::GLint vstride, ::GLint vorder, const ::GLfloat *points)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetMapdv(::GLenum target, ::GLenum query, ::GLdouble *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetMapfv(::GLenum target, ::GLenum query, ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetMapiv(::GLenum target, ::GLenum query, ::GLint *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glEvalCoord1d(::GLdouble u)__attribute__((visibility("default")));
}
extern "C"
{
  void glEvalCoord1f(::GLfloat u)__attribute__((visibility("default")));
}
extern "C"
{
  void glEvalCoord1dv(const ::GLdouble *u)__attribute__((visibility("default")));
}
extern "C"
{
  void glEvalCoord1fv(const ::GLfloat *u)__attribute__((visibility("default")));
}
extern "C"
{
  void glEvalCoord2d(::GLdouble u, ::GLdouble v)__attribute__((visibility("default")));
}
extern "C"
{
  void glEvalCoord2f(::GLfloat u, ::GLfloat v)__attribute__((visibility("default")));
}
extern "C"
{
  void glEvalCoord2dv(const ::GLdouble *u)__attribute__((visibility("default")));
}
extern "C"
{
  void glEvalCoord2fv(const ::GLfloat *u)__attribute__((visibility("default")));
}
extern "C"
{
  void glMapGrid1d(::GLint un, ::GLdouble u1, ::GLdouble u2)__attribute__((visibility("default")));
}
extern "C"
{
  void glMapGrid1f(::GLint un, ::GLfloat u1, ::GLfloat u2)__attribute__((visibility("default")));
}
extern "C"
{
  void glMapGrid2d(::GLint un, ::GLdouble u1, ::GLdouble u2, ::GLint vn, ::GLdouble v1, ::GLdouble v2)__attribute__((visibility("default")));
}
extern "C"
{
  void glMapGrid2f(::GLint un, ::GLfloat u1, ::GLfloat u2, ::GLint vn, ::GLfloat v1, ::GLfloat v2)__attribute__((visibility("default")));
}
extern "C"
{
  void glEvalPoint1(::GLint i)__attribute__((visibility("default")));
}
extern "C"
{
  void glEvalPoint2(::GLint i, ::GLint j)__attribute__((visibility("default")));
}
extern "C"
{
  void glEvalMesh1(::GLenum mode, ::GLint i1, ::GLint i2)__attribute__((visibility("default")));
}
extern "C"
{
  void glEvalMesh2(::GLenum mode, ::GLint i1, ::GLint i2, ::GLint j1, ::GLint j2)__attribute__((visibility("default")));
}
extern "C"
{
  void glFogf(::GLenum pname, ::GLfloat param)__attribute__((visibility("default")));
}
extern "C"
{
  void glFogi(::GLenum pname, ::GLint param)__attribute__((visibility("default")));
}
extern "C"
{
  void glFogfv(::GLenum pname, const ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glFogiv(::GLenum pname, const ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glFeedbackBuffer(::GLsizei size, ::GLenum type, ::GLfloat *buffer)__attribute__((visibility("default")));
}
extern "C"
{
  void glPassThrough(::GLfloat token)__attribute__((visibility("default")));
}
extern "C"
{
  void glSelectBuffer(::GLsizei size, ::GLuint *buffer)__attribute__((visibility("default")));
}
extern "C"
{
  void glInitNames()__attribute__((visibility("default")));
}
extern "C"
{
  void glLoadName(::GLuint name)__attribute__((visibility("default")));
}
extern "C"
{
  void glPushName(::GLuint name)__attribute__((visibility("default")));
}
extern "C"
{
  void glPopName()__attribute__((visibility("default")));
}
extern "C"
{
  void glDrawRangeElements(::GLenum mode, ::GLuint start, ::GLuint end, ::GLsizei count, ::GLenum type, const ::GLvoid *indices)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexImage3D(::GLenum target, ::GLint level, ::GLint internalFormat, ::GLsizei width, ::GLsizei height, ::GLsizei depth, ::GLint border, ::GLenum format, ::GLenum type, const ::GLvoid *pixels)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexSubImage3D(::GLenum target, ::GLint level, ::GLint xoffset, ::GLint yoffset, ::GLint zoffset, ::GLsizei width, ::GLsizei height, ::GLsizei depth, ::GLenum format, ::GLenum type, const ::GLvoid *pixels)__attribute__((visibility("default")));
}
extern "C"
{
  void glCopyTexSubImage3D(::GLenum target, ::GLint level, ::GLint xoffset, ::GLint yoffset, ::GLint zoffset, ::GLint x, ::GLint y, ::GLsizei width, ::GLsizei height)__attribute__((visibility("default")));
}
typedef void (*PFNGLDRAWRANGEELEMENTSPROC)(::GLenum, ::GLuint, ::GLuint, ::GLsizei, ::GLenum, const ::GLvoid *);
typedef void (*PFNGLTEXIMAGE3DPROC)(::GLenum, ::GLint, ::GLint, ::GLsizei, ::GLsizei, ::GLsizei, ::GLint, ::GLenum, ::GLenum, const ::GLvoid *);
typedef void (*PFNGLTEXSUBIMAGE3DPROC)(::GLenum, ::GLint, ::GLint, ::GLint, ::GLint, ::GLsizei, ::GLsizei, ::GLsizei, ::GLenum, ::GLenum, const ::GLvoid *);
typedef void (*PFNGLCOPYTEXSUBIMAGE3DPROC)(::GLenum, ::GLint, ::GLint, ::GLint, ::GLint, ::GLint, ::GLint, ::GLsizei, ::GLsizei);
extern "C"
{
  void glColorTable(::GLenum target, ::GLenum internalformat, ::GLsizei width, ::GLenum format, ::GLenum type, const ::GLvoid *table)__attribute__((visibility("default")));
}
extern "C"
{
  void glColorSubTable(::GLenum target, ::GLsizei start, ::GLsizei count, ::GLenum format, ::GLenum type, const ::GLvoid *data)__attribute__((visibility("default")));
}
extern "C"
{
  void glColorTableParameteriv(::GLenum target, ::GLenum pname, const ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glColorTableParameterfv(::GLenum target, ::GLenum pname, const ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glCopyColorSubTable(::GLenum target, ::GLsizei start, ::GLint x, ::GLint y, ::GLsizei width)__attribute__((visibility("default")));
}
extern "C"
{
  void glCopyColorTable(::GLenum target, ::GLenum internalformat, ::GLint x, ::GLint y, ::GLsizei width)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetColorTable(::GLenum target, ::GLenum format, ::GLenum type, ::GLvoid *table)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetColorTableParameterfv(::GLenum target, ::GLenum pname, ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetColorTableParameteriv(::GLenum target, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glBlendEquation(::GLenum mode)__attribute__((visibility("default")));
}
extern "C"
{
  void glBlendColor(::GLclampf red, ::GLclampf green, ::GLclampf blue, ::GLclampf alpha)__attribute__((visibility("default")));
}
extern "C"
{
  void glHistogram(::GLenum target, ::GLsizei width, ::GLenum internalformat, ::GLboolean sink)__attribute__((visibility("default")));
}
extern "C"
{
  void glResetHistogram(::GLenum target)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetHistogram(::GLenum target, ::GLboolean reset, ::GLenum format, ::GLenum type, ::GLvoid *values)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetHistogramParameterfv(::GLenum target, ::GLenum pname, ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetHistogramParameteriv(::GLenum target, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glMinmax(::GLenum target, ::GLenum internalformat, ::GLboolean sink)__attribute__((visibility("default")));
}
extern "C"
{
  void glResetMinmax(::GLenum target)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetMinmax(::GLenum target, ::GLboolean reset, ::GLenum format, ::GLenum types, ::GLvoid *values)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetMinmaxParameterfv(::GLenum target, ::GLenum pname, ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetMinmaxParameteriv(::GLenum target, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glConvolutionFilter1D(::GLenum target, ::GLenum internalformat, ::GLsizei width, ::GLenum format, ::GLenum type, const ::GLvoid *image)__attribute__((visibility("default")));
}
extern "C"
{
  void glConvolutionFilter2D(::GLenum target, ::GLenum internalformat, ::GLsizei width, ::GLsizei height, ::GLenum format, ::GLenum type, const ::GLvoid *image)__attribute__((visibility("default")));
}
extern "C"
{
  void glConvolutionParameterf(::GLenum target, ::GLenum pname, ::GLfloat params)__attribute__((visibility("default")));
}
extern "C"
{
  void glConvolutionParameterfv(::GLenum target, ::GLenum pname, const ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glConvolutionParameteri(::GLenum target, ::GLenum pname, ::GLint params)__attribute__((visibility("default")));
}
extern "C"
{
  void glConvolutionParameteriv(::GLenum target, ::GLenum pname, const ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glCopyConvolutionFilter1D(::GLenum target, ::GLenum internalformat, ::GLint x, ::GLint y, ::GLsizei width)__attribute__((visibility("default")));
}
extern "C"
{
  void glCopyConvolutionFilter2D(::GLenum target, ::GLenum internalformat, ::GLint x, ::GLint y, ::GLsizei width, ::GLsizei height)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetConvolutionFilter(::GLenum target, ::GLenum format, ::GLenum type, ::GLvoid *image)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetConvolutionParameterfv(::GLenum target, ::GLenum pname, ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetConvolutionParameteriv(::GLenum target, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glSeparableFilter2D(::GLenum target, ::GLenum internalformat, ::GLsizei width, ::GLsizei height, ::GLenum format, ::GLenum type, const ::GLvoid *row, const ::GLvoid *column)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetSeparableFilter(::GLenum target, ::GLenum format, ::GLenum type, ::GLvoid *row, ::GLvoid *column, ::GLvoid *span)__attribute__((visibility("default")));
}
typedef void (*PFNGLBLENDCOLORPROC)(::GLclampf, ::GLclampf, ::GLclampf, ::GLclampf);
typedef void (*PFNGLBLENDEQUATIONPROC)(::GLenum);
extern "C"
{
  void glActiveTexture(::GLenum texture)__attribute__((visibility("default")));
}
extern "C"
{
  void glClientActiveTexture(::GLenum texture)__attribute__((visibility("default")));
}
extern "C"
{
  void glCompressedTexImage1D(::GLenum target, ::GLint level, ::GLenum internalformat, ::GLsizei width, ::GLint border, ::GLsizei imageSize, const ::GLvoid *data)__attribute__((visibility("default")));
}
extern "C"
{
  void glCompressedTexImage2D(::GLenum target, ::GLint level, ::GLenum internalformat, ::GLsizei width, ::GLsizei height, ::GLint border, ::GLsizei imageSize, const ::GLvoid *data)__attribute__((visibility("default")));
}
extern "C"
{
  void glCompressedTexImage3D(::GLenum target, ::GLint level, ::GLenum internalformat, ::GLsizei width, ::GLsizei height, ::GLsizei depth, ::GLint border, ::GLsizei imageSize, const ::GLvoid *data)__attribute__((visibility("default")));
}
extern "C"
{
  void glCompressedTexSubImage1D(::GLenum target, ::GLint level, ::GLint xoffset, ::GLsizei width, ::GLenum format, ::GLsizei imageSize, const ::GLvoid *data)__attribute__((visibility("default")));
}
extern "C"
{
  void glCompressedTexSubImage2D(::GLenum target, ::GLint level, ::GLint xoffset, ::GLint yoffset, ::GLsizei width, ::GLsizei height, ::GLenum format, ::GLsizei imageSize, const ::GLvoid *data)__attribute__((visibility("default")));
}
extern "C"
{
  void glCompressedTexSubImage3D(::GLenum target, ::GLint level, ::GLint xoffset, ::GLint yoffset, ::GLint zoffset, ::GLsizei width, ::GLsizei height, ::GLsizei depth, ::GLenum format, ::GLsizei imageSize, const ::GLvoid *data)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetCompressedTexImage(::GLenum target, ::GLint lod, ::GLvoid *img)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord1d(::GLenum target, ::GLdouble s)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord1dv(::GLenum target, const ::GLdouble *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord1f(::GLenum target, ::GLfloat s)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord1fv(::GLenum target, const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord1i(::GLenum target, ::GLint s)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord1iv(::GLenum target, const ::GLint *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord1s(::GLenum target, ::GLshort s)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord1sv(::GLenum target, const ::GLshort *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord2d(::GLenum target, ::GLdouble s, ::GLdouble t)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord2dv(::GLenum target, const ::GLdouble *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord2f(::GLenum target, ::GLfloat s, ::GLfloat t)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord2fv(::GLenum target, const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord2i(::GLenum target, ::GLint s, ::GLint t)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord2iv(::GLenum target, const ::GLint *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord2s(::GLenum target, ::GLshort s, ::GLshort t)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord2sv(::GLenum target, const ::GLshort *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord3d(::GLenum target, ::GLdouble s, ::GLdouble t, ::GLdouble r)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord3dv(::GLenum target, const ::GLdouble *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord3f(::GLenum target, ::GLfloat s, ::GLfloat t, ::GLfloat r)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord3fv(::GLenum target, const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord3i(::GLenum target, ::GLint s, ::GLint t, ::GLint r)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord3iv(::GLenum target, const ::GLint *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord3s(::GLenum target, ::GLshort s, ::GLshort t, ::GLshort r)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord3sv(::GLenum target, const ::GLshort *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord4d(::GLenum target, ::GLdouble s, ::GLdouble t, ::GLdouble r, ::GLdouble q)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord4dv(::GLenum target, const ::GLdouble *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord4f(::GLenum target, ::GLfloat s, ::GLfloat t, ::GLfloat r, ::GLfloat q)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord4fv(::GLenum target, const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord4i(::GLenum target, ::GLint s, ::GLint t, ::GLint r, ::GLint q)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord4iv(::GLenum target, const ::GLint *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord4s(::GLenum target, ::GLshort s, ::GLshort t, ::GLshort r, ::GLshort q)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord4sv(::GLenum target, const ::GLshort *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glLoadTransposeMatrixd(const ::GLdouble m[16])__attribute__((visibility("default")));
}
extern "C"
{
  void glLoadTransposeMatrixf(const ::GLfloat m[16])__attribute__((visibility("default")));
}
extern "C"
{
  void glMultTransposeMatrixd(const ::GLdouble m[16])__attribute__((visibility("default")));
}
extern "C"
{
  void glMultTransposeMatrixf(const ::GLfloat m[16])__attribute__((visibility("default")));
}
extern "C"
{
  void glSampleCoverage(::GLclampf value, ::GLboolean invert)__attribute__((visibility("default")));
}
typedef void (*PFNGLACTIVETEXTUREPROC)(::GLenum);
typedef void (*PFNGLSAMPLECOVERAGEPROC)(::GLclampf, ::GLboolean);
typedef void (*PFNGLCOMPRESSEDTEXIMAGE3DPROC)(::GLenum, ::GLint, ::GLenum, ::GLsizei, ::GLsizei, ::GLsizei, ::GLint, ::GLsizei, const ::GLvoid *);
typedef void (*PFNGLCOMPRESSEDTEXIMAGE2DPROC)(::GLenum, ::GLint, ::GLenum, ::GLsizei, ::GLsizei, ::GLint, ::GLsizei, const ::GLvoid *);
typedef void (*PFNGLCOMPRESSEDTEXIMAGE1DPROC)(::GLenum, ::GLint, ::GLenum, ::GLsizei, ::GLint, ::GLsizei, const ::GLvoid *);
typedef void (*PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC)(::GLenum, ::GLint, ::GLint, ::GLint, ::GLint, ::GLsizei, ::GLsizei, ::GLsizei, ::GLenum, ::GLsizei, const ::GLvoid *);
typedef void (*PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC)(::GLenum, ::GLint, ::GLint, ::GLint, ::GLsizei, ::GLsizei, ::GLenum, ::GLsizei, const ::GLvoid *);
typedef void (*PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC)(::GLenum, ::GLint, ::GLint, ::GLsizei, ::GLenum, ::GLsizei, const ::GLvoid *);
typedef void (*PFNGLGETCOMPRESSEDTEXIMAGEPROC)(::GLenum, ::GLint, ::GLvoid *);
extern "C"
{
  void glActiveTextureARB(::GLenum texture)__attribute__((visibility("default")));
}
extern "C"
{
  void glClientActiveTextureARB(::GLenum texture)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord1dARB(::GLenum target, ::GLdouble s)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord1dvARB(::GLenum target, const ::GLdouble *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord1fARB(::GLenum target, ::GLfloat s)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord1fvARB(::GLenum target, const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord1iARB(::GLenum target, ::GLint s)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord1ivARB(::GLenum target, const ::GLint *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord1sARB(::GLenum target, ::GLshort s)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord1svARB(::GLenum target, const ::GLshort *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord2dARB(::GLenum target, ::GLdouble s, ::GLdouble t)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord2dvARB(::GLenum target, const ::GLdouble *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord2fARB(::GLenum target, ::GLfloat s, ::GLfloat t)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord2fvARB(::GLenum target, const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord2iARB(::GLenum target, ::GLint s, ::GLint t)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord2ivARB(::GLenum target, const ::GLint *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord2sARB(::GLenum target, ::GLshort s, ::GLshort t)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord2svARB(::GLenum target, const ::GLshort *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord3dARB(::GLenum target, ::GLdouble s, ::GLdouble t, ::GLdouble r)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord3dvARB(::GLenum target, const ::GLdouble *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord3fARB(::GLenum target, ::GLfloat s, ::GLfloat t, ::GLfloat r)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord3fvARB(::GLenum target, const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord3iARB(::GLenum target, ::GLint s, ::GLint t, ::GLint r)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord3ivARB(::GLenum target, const ::GLint *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord3sARB(::GLenum target, ::GLshort s, ::GLshort t, ::GLshort r)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord3svARB(::GLenum target, const ::GLshort *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord4dARB(::GLenum target, ::GLdouble s, ::GLdouble t, ::GLdouble r, ::GLdouble q)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord4dvARB(::GLenum target, const ::GLdouble *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord4fARB(::GLenum target, ::GLfloat s, ::GLfloat t, ::GLfloat r, ::GLfloat q)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord4fvARB(::GLenum target, const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord4iARB(::GLenum target, ::GLint s, ::GLint t, ::GLint r, ::GLint q)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord4ivARB(::GLenum target, const ::GLint *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord4sARB(::GLenum target, ::GLshort s, ::GLshort t, ::GLshort r, ::GLshort q)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord4svARB(::GLenum target, const ::GLshort *v)__attribute__((visibility("default")));
}
typedef void (*PFNGLACTIVETEXTUREARBPROC)(::GLenum);
typedef void (*PFNGLCLIENTACTIVETEXTUREARBPROC)(::GLenum);
typedef void (*PFNGLMULTITEXCOORD1DARBPROC)(::GLenum, ::GLdouble);
typedef void (*PFNGLMULTITEXCOORD1DVARBPROC)(::GLenum, const ::GLdouble *);
typedef void (*PFNGLMULTITEXCOORD1FARBPROC)(::GLenum, ::GLfloat);
typedef void (*PFNGLMULTITEXCOORD1FVARBPROC)(::GLenum, const ::GLfloat *);
typedef void (*PFNGLMULTITEXCOORD1IARBPROC)(::GLenum, ::GLint);
typedef void (*PFNGLMULTITEXCOORD1IVARBPROC)(::GLenum, const ::GLint *);
typedef void (*PFNGLMULTITEXCOORD1SARBPROC)(::GLenum, ::GLshort);
typedef void (*PFNGLMULTITEXCOORD1SVARBPROC)(::GLenum, const ::GLshort *);
typedef void (*PFNGLMULTITEXCOORD2DARBPROC)(::GLenum, ::GLdouble, ::GLdouble);
typedef void (*PFNGLMULTITEXCOORD2DVARBPROC)(::GLenum, const ::GLdouble *);
typedef void (*PFNGLMULTITEXCOORD2FARBPROC)(::GLenum, ::GLfloat, ::GLfloat);
typedef void (*PFNGLMULTITEXCOORD2FVARBPROC)(::GLenum, const ::GLfloat *);
typedef void (*PFNGLMULTITEXCOORD2IARBPROC)(::GLenum, ::GLint, ::GLint);
typedef void (*PFNGLMULTITEXCOORD2IVARBPROC)(::GLenum, const ::GLint *);
typedef void (*PFNGLMULTITEXCOORD2SARBPROC)(::GLenum, ::GLshort, ::GLshort);
typedef void (*PFNGLMULTITEXCOORD2SVARBPROC)(::GLenum, const ::GLshort *);
typedef void (*PFNGLMULTITEXCOORD3DARBPROC)(::GLenum, ::GLdouble, ::GLdouble, ::GLdouble);
typedef void (*PFNGLMULTITEXCOORD3DVARBPROC)(::GLenum, const ::GLdouble *);
typedef void (*PFNGLMULTITEXCOORD3FARBPROC)(::GLenum, ::GLfloat, ::GLfloat, ::GLfloat);
typedef void (*PFNGLMULTITEXCOORD3FVARBPROC)(::GLenum, const ::GLfloat *);
typedef void (*PFNGLMULTITEXCOORD3IARBPROC)(::GLenum, ::GLint, ::GLint, ::GLint);
typedef void (*PFNGLMULTITEXCOORD3IVARBPROC)(::GLenum, const ::GLint *);
typedef void (*PFNGLMULTITEXCOORD3SARBPROC)(::GLenum, ::GLshort, ::GLshort, ::GLshort);
typedef void (*PFNGLMULTITEXCOORD3SVARBPROC)(::GLenum, const ::GLshort *);
typedef void (*PFNGLMULTITEXCOORD4DARBPROC)(::GLenum, ::GLdouble, ::GLdouble, ::GLdouble, ::GLdouble);
typedef void (*PFNGLMULTITEXCOORD4DVARBPROC)(::GLenum, const ::GLdouble *);
typedef void (*PFNGLMULTITEXCOORD4FARBPROC)(::GLenum, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat);
typedef void (*PFNGLMULTITEXCOORD4FVARBPROC)(::GLenum, const ::GLfloat *);
typedef void (*PFNGLMULTITEXCOORD4IARBPROC)(::GLenum, ::GLint, ::GLint, ::GLint, ::GLint);
typedef void (*PFNGLMULTITEXCOORD4IVARBPROC)(::GLenum, const ::GLint *);
typedef void (*PFNGLMULTITEXCOORD4SARBPROC)(::GLenum, ::GLshort, ::GLshort, ::GLshort, ::GLshort);
typedef void (*PFNGLMULTITEXCOORD4SVARBPROC)(::GLenum, const ::GLshort *);
typedef char GLchar;
typedef ::ptrdiff_t GLintptr;
typedef ::ptrdiff_t GLsizeiptr;
typedef ::ptrdiff_t GLintptrARB;
typedef ::ptrdiff_t GLsizeiptrARB;
typedef char GLcharARB;
typedef unsigned int GLhandleARB;
typedef unsigned short int GLhalfARB;
typedef unsigned short int GLhalfNV;
struct  imaxdiv_t
{
    long int quot;
    long int rem;
};
extern "C"
{
  extern ::intmax_t imaxabs(::intmax_t __n) throw()__attribute__((__const__));
}
extern "C"
{
  extern ::imaxdiv_t imaxdiv(::intmax_t __numer, ::intmax_t __denom) throw()__attribute__((__const__));
}
extern "C"
{
  extern ::intmax_t strtoimax(const char *__restrict __nptr, char **__restrict __endptr, int __base) throw();
}
extern "C"
{
  extern ::uintmax_t strtoumax(const char *__restrict __nptr, char **__restrict __endptr, int __base) throw();
}
extern "C"
{
  extern ::intmax_t wcstoimax(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) throw();
}
extern "C"
{
  extern ::uintmax_t wcstoumax(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) throw();
}
typedef ::int64_t GLint64EXT;
typedef ::uint64_t GLuint64EXT;
typedef ::int64_t GLint64;
typedef ::uint64_t GLuint64;
struct __GLsync;
typedef ::__GLsync *GLsync;
struct _cl_context;
struct _cl_event;
typedef void (*GLDEBUGPROCARB)(::GLenum, ::GLenum, ::GLuint, ::GLenum, ::GLsizei, const ::GLchar *, ::GLvoid *);
typedef void (*GLDEBUGPROCAMD)(::GLuint, ::GLenum, ::GLenum, ::GLsizei, const ::GLchar *, ::GLvoid *);
typedef ::GLintptr GLvdpauSurfaceNV;
typedef void (*PFNGLCOLORTABLEPROC)(::GLenum, ::GLenum, ::GLsizei, ::GLenum, ::GLenum, const ::GLvoid *);
typedef void (*PFNGLCOLORTABLEPARAMETERFVPROC)(::GLenum, ::GLenum, const ::GLfloat *);
typedef void (*PFNGLCOLORTABLEPARAMETERIVPROC)(::GLenum, ::GLenum, const ::GLint *);
typedef void (*PFNGLCOPYCOLORTABLEPROC)(::GLenum, ::GLenum, ::GLint, ::GLint, ::GLsizei);
typedef void (*PFNGLGETCOLORTABLEPROC)(::GLenum, ::GLenum, ::GLenum, ::GLvoid *);
typedef void (*PFNGLGETCOLORTABLEPARAMETERFVPROC)(::GLenum, ::GLenum, ::GLfloat *);
typedef void (*PFNGLGETCOLORTABLEPARAMETERIVPROC)(::GLenum, ::GLenum, ::GLint *);
typedef void (*PFNGLCOLORSUBTABLEPROC)(::GLenum, ::GLsizei, ::GLsizei, ::GLenum, ::GLenum, const ::GLvoid *);
typedef void (*PFNGLCOPYCOLORSUBTABLEPROC)(::GLenum, ::GLsizei, ::GLint, ::GLint, ::GLsizei);
typedef void (*PFNGLCONVOLUTIONFILTER1DPROC)(::GLenum, ::GLenum, ::GLsizei, ::GLenum, ::GLenum, const ::GLvoid *);
typedef void (*PFNGLCONVOLUTIONFILTER2DPROC)(::GLenum, ::GLenum, ::GLsizei, ::GLsizei, ::GLenum, ::GLenum, const ::GLvoid *);
typedef void (*PFNGLCONVOLUTIONPARAMETERFPROC)(::GLenum, ::GLenum, ::GLfloat);
typedef void (*PFNGLCONVOLUTIONPARAMETERFVPROC)(::GLenum, ::GLenum, const ::GLfloat *);
typedef void (*PFNGLCONVOLUTIONPARAMETERIPROC)(::GLenum, ::GLenum, ::GLint);
typedef void (*PFNGLCONVOLUTIONPARAMETERIVPROC)(::GLenum, ::GLenum, const ::GLint *);
typedef void (*PFNGLCOPYCONVOLUTIONFILTER1DPROC)(::GLenum, ::GLenum, ::GLint, ::GLint, ::GLsizei);
typedef void (*PFNGLCOPYCONVOLUTIONFILTER2DPROC)(::GLenum, ::GLenum, ::GLint, ::GLint, ::GLsizei, ::GLsizei);
typedef void (*PFNGLGETCONVOLUTIONFILTERPROC)(::GLenum, ::GLenum, ::GLenum, ::GLvoid *);
typedef void (*PFNGLGETCONVOLUTIONPARAMETERFVPROC)(::GLenum, ::GLenum, ::GLfloat *);
typedef void (*PFNGLGETCONVOLUTIONPARAMETERIVPROC)(::GLenum, ::GLenum, ::GLint *);
typedef void (*PFNGLGETSEPARABLEFILTERPROC)(::GLenum, ::GLenum, ::GLenum, ::GLvoid *, ::GLvoid *, ::GLvoid *);
typedef void (*PFNGLSEPARABLEFILTER2DPROC)(::GLenum, ::GLenum, ::GLsizei, ::GLsizei, ::GLenum, ::GLenum, const ::GLvoid *, const ::GLvoid *);
typedef void (*PFNGLGETHISTOGRAMPROC)(::GLenum, ::GLboolean, ::GLenum, ::GLenum, ::GLvoid *);
typedef void (*PFNGLGETHISTOGRAMPARAMETERFVPROC)(::GLenum, ::GLenum, ::GLfloat *);
typedef void (*PFNGLGETHISTOGRAMPARAMETERIVPROC)(::GLenum, ::GLenum, ::GLint *);
typedef void (*PFNGLGETMINMAXPROC)(::GLenum, ::GLboolean, ::GLenum, ::GLenum, ::GLvoid *);
typedef void (*PFNGLGETMINMAXPARAMETERFVPROC)(::GLenum, ::GLenum, ::GLfloat *);
typedef void (*PFNGLGETMINMAXPARAMETERIVPROC)(::GLenum, ::GLenum, ::GLint *);
typedef void (*PFNGLHISTOGRAMPROC)(::GLenum, ::GLsizei, ::GLenum, ::GLboolean);
typedef void (*PFNGLMINMAXPROC)(::GLenum, ::GLenum, ::GLboolean);
typedef void (*PFNGLRESETHISTOGRAMPROC)(::GLenum);
typedef void (*PFNGLRESETMINMAXPROC)(::GLenum);
typedef void (*PFNGLCLIENTACTIVETEXTUREPROC)(::GLenum);
typedef void (*PFNGLMULTITEXCOORD1DPROC)(::GLenum, ::GLdouble);
typedef void (*PFNGLMULTITEXCOORD1DVPROC)(::GLenum, const ::GLdouble *);
typedef void (*PFNGLMULTITEXCOORD1FPROC)(::GLenum, ::GLfloat);
typedef void (*PFNGLMULTITEXCOORD1FVPROC)(::GLenum, const ::GLfloat *);
typedef void (*PFNGLMULTITEXCOORD1IPROC)(::GLenum, ::GLint);
typedef void (*PFNGLMULTITEXCOORD1IVPROC)(::GLenum, const ::GLint *);
typedef void (*PFNGLMULTITEXCOORD1SPROC)(::GLenum, ::GLshort);
typedef void (*PFNGLMULTITEXCOORD1SVPROC)(::GLenum, const ::GLshort *);
typedef void (*PFNGLMULTITEXCOORD2DPROC)(::GLenum, ::GLdouble, ::GLdouble);
typedef void (*PFNGLMULTITEXCOORD2DVPROC)(::GLenum, const ::GLdouble *);
typedef void (*PFNGLMULTITEXCOORD2FPROC)(::GLenum, ::GLfloat, ::GLfloat);
typedef void (*PFNGLMULTITEXCOORD2FVPROC)(::GLenum, const ::GLfloat *);
typedef void (*PFNGLMULTITEXCOORD2IPROC)(::GLenum, ::GLint, ::GLint);
typedef void (*PFNGLMULTITEXCOORD2IVPROC)(::GLenum, const ::GLint *);
typedef void (*PFNGLMULTITEXCOORD2SPROC)(::GLenum, ::GLshort, ::GLshort);
typedef void (*PFNGLMULTITEXCOORD2SVPROC)(::GLenum, const ::GLshort *);
typedef void (*PFNGLMULTITEXCOORD3DPROC)(::GLenum, ::GLdouble, ::GLdouble, ::GLdouble);
typedef void (*PFNGLMULTITEXCOORD3DVPROC)(::GLenum, const ::GLdouble *);
typedef void (*PFNGLMULTITEXCOORD3FPROC)(::GLenum, ::GLfloat, ::GLfloat, ::GLfloat);
typedef void (*PFNGLMULTITEXCOORD3FVPROC)(::GLenum, const ::GLfloat *);
typedef void (*PFNGLMULTITEXCOORD3IPROC)(::GLenum, ::GLint, ::GLint, ::GLint);
typedef void (*PFNGLMULTITEXCOORD3IVPROC)(::GLenum, const ::GLint *);
typedef void (*PFNGLMULTITEXCOORD3SPROC)(::GLenum, ::GLshort, ::GLshort, ::GLshort);
typedef void (*PFNGLMULTITEXCOORD3SVPROC)(::GLenum, const ::GLshort *);
typedef void (*PFNGLMULTITEXCOORD4DPROC)(::GLenum, ::GLdouble, ::GLdouble, ::GLdouble, ::GLdouble);
typedef void (*PFNGLMULTITEXCOORD4DVPROC)(::GLenum, const ::GLdouble *);
typedef void (*PFNGLMULTITEXCOORD4FPROC)(::GLenum, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat);
typedef void (*PFNGLMULTITEXCOORD4FVPROC)(::GLenum, const ::GLfloat *);
typedef void (*PFNGLMULTITEXCOORD4IPROC)(::GLenum, ::GLint, ::GLint, ::GLint, ::GLint);
typedef void (*PFNGLMULTITEXCOORD4IVPROC)(::GLenum, const ::GLint *);
typedef void (*PFNGLMULTITEXCOORD4SPROC)(::GLenum, ::GLshort, ::GLshort, ::GLshort, ::GLshort);
typedef void (*PFNGLMULTITEXCOORD4SVPROC)(::GLenum, const ::GLshort *);
typedef void (*PFNGLLOADTRANSPOSEMATRIXFPROC)(const ::GLfloat *);
typedef void (*PFNGLLOADTRANSPOSEMATRIXDPROC)(const ::GLdouble *);
typedef void (*PFNGLMULTTRANSPOSEMATRIXFPROC)(const ::GLfloat *);
typedef void (*PFNGLMULTTRANSPOSEMATRIXDPROC)(const ::GLdouble *);
extern "C"
{
  void glBlendFuncSeparate(::GLenum sfactorRGB, ::GLenum dfactorRGB, ::GLenum sfactorAlpha, ::GLenum dfactorAlpha)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiDrawArrays(::GLenum mode, const ::GLint *first, const ::GLsizei *count, ::GLsizei primcount)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiDrawElements(::GLenum mode, const ::GLsizei *count, ::GLenum type, const ::GLvoid **indices, ::GLsizei primcount)__attribute__((visibility("default")));
}
extern "C"
{
  void glPointParameterf(::GLenum pname, ::GLfloat param)__attribute__((visibility("default")));
}
extern "C"
{
  void glPointParameterfv(::GLenum pname, const ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glPointParameteri(::GLenum pname, ::GLint param)__attribute__((visibility("default")));
}
extern "C"
{
  void glPointParameteriv(::GLenum pname, const ::GLint *params)__attribute__((visibility("default")));
}
typedef void (*PFNGLBLENDFUNCSEPARATEPROC)(::GLenum, ::GLenum, ::GLenum, ::GLenum);
typedef void (*PFNGLMULTIDRAWARRAYSPROC)(::GLenum, const ::GLint *, const ::GLsizei *, ::GLsizei);
typedef void (*PFNGLMULTIDRAWELEMENTSPROC)(::GLenum, const ::GLsizei *, ::GLenum, const ::GLvoid **, ::GLsizei);
typedef void (*PFNGLPOINTPARAMETERFPROC)(::GLenum, ::GLfloat);
typedef void (*PFNGLPOINTPARAMETERFVPROC)(::GLenum, const ::GLfloat *);
typedef void (*PFNGLPOINTPARAMETERIPROC)(::GLenum, ::GLint);
typedef void (*PFNGLPOINTPARAMETERIVPROC)(::GLenum, const ::GLint *);
extern "C"
{
  void glFogCoordf(::GLfloat coord)__attribute__((visibility("default")));
}
extern "C"
{
  void glFogCoordfv(const ::GLfloat *coord)__attribute__((visibility("default")));
}
extern "C"
{
  void glFogCoordd(::GLdouble coord)__attribute__((visibility("default")));
}
extern "C"
{
  void glFogCoorddv(const ::GLdouble *coord)__attribute__((visibility("default")));
}
extern "C"
{
  void glFogCoordPointer(::GLenum type, ::GLsizei stride, const ::GLvoid *pointer)__attribute__((visibility("default")));
}
extern "C"
{
  void glSecondaryColor3b(::GLbyte red, ::GLbyte green, ::GLbyte blue)__attribute__((visibility("default")));
}
extern "C"
{
  void glSecondaryColor3bv(const ::GLbyte *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glSecondaryColor3d(::GLdouble red, ::GLdouble green, ::GLdouble blue)__attribute__((visibility("default")));
}
extern "C"
{
  void glSecondaryColor3dv(const ::GLdouble *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glSecondaryColor3f(::GLfloat red, ::GLfloat green, ::GLfloat blue)__attribute__((visibility("default")));
}
extern "C"
{
  void glSecondaryColor3fv(const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glSecondaryColor3i(::GLint red, ::GLint green, ::GLint blue)__attribute__((visibility("default")));
}
extern "C"
{
  void glSecondaryColor3iv(const ::GLint *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glSecondaryColor3s(::GLshort red, ::GLshort green, ::GLshort blue)__attribute__((visibility("default")));
}
extern "C"
{
  void glSecondaryColor3sv(const ::GLshort *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glSecondaryColor3ub(::GLubyte red, ::GLubyte green, ::GLubyte blue)__attribute__((visibility("default")));
}
extern "C"
{
  void glSecondaryColor3ubv(const ::GLubyte *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glSecondaryColor3ui(::GLuint red, ::GLuint green, ::GLuint blue)__attribute__((visibility("default")));
}
extern "C"
{
  void glSecondaryColor3uiv(const ::GLuint *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glSecondaryColor3us(::GLushort red, ::GLushort green, ::GLushort blue)__attribute__((visibility("default")));
}
extern "C"
{
  void glSecondaryColor3usv(const ::GLushort *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glSecondaryColorPointer(::GLint size, ::GLenum type, ::GLsizei stride, const ::GLvoid *pointer)__attribute__((visibility("default")));
}
extern "C"
{
  void glWindowPos2d(::GLdouble x, ::GLdouble y)__attribute__((visibility("default")));
}
extern "C"
{
  void glWindowPos2dv(const ::GLdouble *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glWindowPos2f(::GLfloat x, ::GLfloat y)__attribute__((visibility("default")));
}
extern "C"
{
  void glWindowPos2fv(const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glWindowPos2i(::GLint x, ::GLint y)__attribute__((visibility("default")));
}
extern "C"
{
  void glWindowPos2iv(const ::GLint *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glWindowPos2s(::GLshort x, ::GLshort y)__attribute__((visibility("default")));
}
extern "C"
{
  void glWindowPos2sv(const ::GLshort *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glWindowPos3d(::GLdouble x, ::GLdouble y, ::GLdouble z)__attribute__((visibility("default")));
}
extern "C"
{
  void glWindowPos3dv(const ::GLdouble *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glWindowPos3f(::GLfloat x, ::GLfloat y, ::GLfloat z)__attribute__((visibility("default")));
}
extern "C"
{
  void glWindowPos3fv(const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glWindowPos3i(::GLint x, ::GLint y, ::GLint z)__attribute__((visibility("default")));
}
extern "C"
{
  void glWindowPos3iv(const ::GLint *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glWindowPos3s(::GLshort x, ::GLshort y, ::GLshort z)__attribute__((visibility("default")));
}
extern "C"
{
  void glWindowPos3sv(const ::GLshort *v)__attribute__((visibility("default")));
}
typedef void (*PFNGLFOGCOORDFPROC)(::GLfloat);
typedef void (*PFNGLFOGCOORDFVPROC)(const ::GLfloat *);
typedef void (*PFNGLFOGCOORDDPROC)(::GLdouble);
typedef void (*PFNGLFOGCOORDDVPROC)(const ::GLdouble *);
typedef void (*PFNGLFOGCOORDPOINTERPROC)(::GLenum, ::GLsizei, const ::GLvoid *);
typedef void (*PFNGLSECONDARYCOLOR3BPROC)(::GLbyte, ::GLbyte, ::GLbyte);
typedef void (*PFNGLSECONDARYCOLOR3BVPROC)(const ::GLbyte *);
typedef void (*PFNGLSECONDARYCOLOR3DPROC)(::GLdouble, ::GLdouble, ::GLdouble);
typedef void (*PFNGLSECONDARYCOLOR3DVPROC)(const ::GLdouble *);
typedef void (*PFNGLSECONDARYCOLOR3FPROC)(::GLfloat, ::GLfloat, ::GLfloat);
typedef void (*PFNGLSECONDARYCOLOR3FVPROC)(const ::GLfloat *);
typedef void (*PFNGLSECONDARYCOLOR3IPROC)(::GLint, ::GLint, ::GLint);
typedef void (*PFNGLSECONDARYCOLOR3IVPROC)(const ::GLint *);
typedef void (*PFNGLSECONDARYCOLOR3SPROC)(::GLshort, ::GLshort, ::GLshort);
typedef void (*PFNGLSECONDARYCOLOR3SVPROC)(const ::GLshort *);
typedef void (*PFNGLSECONDARYCOLOR3UBPROC)(::GLubyte, ::GLubyte, ::GLubyte);
typedef void (*PFNGLSECONDARYCOLOR3UBVPROC)(const ::GLubyte *);
typedef void (*PFNGLSECONDARYCOLOR3UIPROC)(::GLuint, ::GLuint, ::GLuint);
typedef void (*PFNGLSECONDARYCOLOR3UIVPROC)(const ::GLuint *);
typedef void (*PFNGLSECONDARYCOLOR3USPROC)(::GLushort, ::GLushort, ::GLushort);
typedef void (*PFNGLSECONDARYCOLOR3USVPROC)(const ::GLushort *);
typedef void (*PFNGLSECONDARYCOLORPOINTERPROC)(::GLint, ::GLenum, ::GLsizei, const ::GLvoid *);
typedef void (*PFNGLWINDOWPOS2DPROC)(::GLdouble, ::GLdouble);
typedef void (*PFNGLWINDOWPOS2DVPROC)(const ::GLdouble *);
typedef void (*PFNGLWINDOWPOS2FPROC)(::GLfloat, ::GLfloat);
typedef void (*PFNGLWINDOWPOS2FVPROC)(const ::GLfloat *);
typedef void (*PFNGLWINDOWPOS2IPROC)(::GLint, ::GLint);
typedef void (*PFNGLWINDOWPOS2IVPROC)(const ::GLint *);
typedef void (*PFNGLWINDOWPOS2SPROC)(::GLshort, ::GLshort);
typedef void (*PFNGLWINDOWPOS2SVPROC)(const ::GLshort *);
typedef void (*PFNGLWINDOWPOS3DPROC)(::GLdouble, ::GLdouble, ::GLdouble);
typedef void (*PFNGLWINDOWPOS3DVPROC)(const ::GLdouble *);
typedef void (*PFNGLWINDOWPOS3FPROC)(::GLfloat, ::GLfloat, ::GLfloat);
typedef void (*PFNGLWINDOWPOS3FVPROC)(const ::GLfloat *);
typedef void (*PFNGLWINDOWPOS3IPROC)(::GLint, ::GLint, ::GLint);
typedef void (*PFNGLWINDOWPOS3IVPROC)(const ::GLint *);
typedef void (*PFNGLWINDOWPOS3SPROC)(::GLshort, ::GLshort, ::GLshort);
typedef void (*PFNGLWINDOWPOS3SVPROC)(const ::GLshort *);
extern "C"
{
  void glGenQueries(::GLsizei n, ::GLuint *ids)__attribute__((visibility("default")));
}
extern "C"
{
  void glDeleteQueries(::GLsizei n, const ::GLuint *ids)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLboolean glIsQuery(::GLuint id)__attribute__((visibility("default")));
}
extern "C"
{
  void glBeginQuery(::GLenum target, ::GLuint id)__attribute__((visibility("default")));
}
extern "C"
{
  void glEndQuery(::GLenum target)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetQueryiv(::GLenum target, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetQueryObjectiv(::GLuint id, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetQueryObjectuiv(::GLuint id, ::GLenum pname, ::GLuint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glBindBuffer(::GLenum target, ::GLuint buffer)__attribute__((visibility("default")));
}
extern "C"
{
  void glDeleteBuffers(::GLsizei n, const ::GLuint *buffers)__attribute__((visibility("default")));
}
extern "C"
{
  void glGenBuffers(::GLsizei n, ::GLuint *buffers)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLboolean glIsBuffer(::GLuint buffer)__attribute__((visibility("default")));
}
extern "C"
{
  void glBufferData(::GLenum target, ::GLsizeiptr size, const ::GLvoid *data, ::GLenum usage)__attribute__((visibility("default")));
}
extern "C"
{
  void glBufferSubData(::GLenum target, ::GLintptr offset, ::GLsizeiptr size, const ::GLvoid *data)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetBufferSubData(::GLenum target, ::GLintptr offset, ::GLsizeiptr size, ::GLvoid *data)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLvoid *glMapBuffer(::GLenum target, ::GLenum access)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLboolean glUnmapBuffer(::GLenum target)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetBufferParameteriv(::GLenum target, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetBufferPointerv(::GLenum target, ::GLenum pname, ::GLvoid **params)__attribute__((visibility("default")));
}
typedef void (*PFNGLGENQUERIESPROC)(::GLsizei, ::GLuint *);
typedef void (*PFNGLDELETEQUERIESPROC)(::GLsizei, const ::GLuint *);
typedef ::GLboolean (*PFNGLISQUERYPROC)(::GLuint);
typedef void (*PFNGLBEGINQUERYPROC)(::GLenum, ::GLuint);
typedef void (*PFNGLENDQUERYPROC)(::GLenum);
typedef void (*PFNGLGETQUERYIVPROC)(::GLenum, ::GLenum, ::GLint *);
typedef void (*PFNGLGETQUERYOBJECTIVPROC)(::GLuint, ::GLenum, ::GLint *);
typedef void (*PFNGLGETQUERYOBJECTUIVPROC)(::GLuint, ::GLenum, ::GLuint *);
typedef void (*PFNGLBINDBUFFERPROC)(::GLenum, ::GLuint);
typedef void (*PFNGLDELETEBUFFERSPROC)(::GLsizei, const ::GLuint *);
typedef void (*PFNGLGENBUFFERSPROC)(::GLsizei, ::GLuint *);
typedef ::GLboolean (*PFNGLISBUFFERPROC)(::GLuint);
typedef void (*PFNGLBUFFERDATAPROC)(::GLenum, ::GLsizeiptr, const ::GLvoid *, ::GLenum);
typedef void (*PFNGLBUFFERSUBDATAPROC)(::GLenum, ::GLintptr, ::GLsizeiptr, const ::GLvoid *);
typedef void (*PFNGLGETBUFFERSUBDATAPROC)(::GLenum, ::GLintptr, ::GLsizeiptr, ::GLvoid *);
typedef ::GLvoid *(*PFNGLMAPBUFFERPROC)(::GLenum, ::GLenum);
typedef ::GLboolean (*PFNGLUNMAPBUFFERPROC)(::GLenum);
typedef void (*PFNGLGETBUFFERPARAMETERIVPROC)(::GLenum, ::GLenum, ::GLint *);
typedef void (*PFNGLGETBUFFERPOINTERVPROC)(::GLenum, ::GLenum, ::GLvoid **);
extern "C"
{
  void glBlendEquationSeparate(::GLenum modeRGB, ::GLenum modeAlpha)__attribute__((visibility("default")));
}
extern "C"
{
  void glDrawBuffers(::GLsizei n, const ::GLenum *bufs)__attribute__((visibility("default")));
}
extern "C"
{
  void glStencilOpSeparate(::GLenum face, ::GLenum sfail, ::GLenum dpfail, ::GLenum dppass)__attribute__((visibility("default")));
}
extern "C"
{
  void glStencilFuncSeparate(::GLenum face, ::GLenum func, ::GLint ref, ::GLuint mask)__attribute__((visibility("default")));
}
extern "C"
{
  void glStencilMaskSeparate(::GLenum face, ::GLuint mask)__attribute__((visibility("default")));
}
extern "C"
{
  void glAttachShader(::GLuint program, ::GLuint shader)__attribute__((visibility("default")));
}
extern "C"
{
  void glBindAttribLocation(::GLuint program, ::GLuint index, const ::GLchar *name)__attribute__((visibility("default")));
}
extern "C"
{
  void glCompileShader(::GLuint shader)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLuint glCreateProgram()__attribute__((visibility("default")));
}
extern "C"
{
  ::GLuint glCreateShader(::GLenum type)__attribute__((visibility("default")));
}
extern "C"
{
  void glDeleteProgram(::GLuint program)__attribute__((visibility("default")));
}
extern "C"
{
  void glDeleteShader(::GLuint shader)__attribute__((visibility("default")));
}
extern "C"
{
  void glDetachShader(::GLuint program, ::GLuint shader)__attribute__((visibility("default")));
}
extern "C"
{
  void glDisableVertexAttribArray(::GLuint index)__attribute__((visibility("default")));
}
extern "C"
{
  void glEnableVertexAttribArray(::GLuint index)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetActiveAttrib(::GLuint program, ::GLuint index, ::GLsizei bufSize, ::GLsizei *length, ::GLint *size, ::GLenum *type, ::GLchar *name)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetActiveUniform(::GLuint program, ::GLuint index, ::GLsizei bufSize, ::GLsizei *length, ::GLint *size, ::GLenum *type, ::GLchar *name)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetAttachedShaders(::GLuint program, ::GLsizei maxCount, ::GLsizei *count, ::GLuint *obj)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLint glGetAttribLocation(::GLuint program, const ::GLchar *name)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetProgramiv(::GLuint program, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetProgramInfoLog(::GLuint program, ::GLsizei bufSize, ::GLsizei *length, ::GLchar *infoLog)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetShaderiv(::GLuint shader, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetShaderInfoLog(::GLuint shader, ::GLsizei bufSize, ::GLsizei *length, ::GLchar *infoLog)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetShaderSource(::GLuint shader, ::GLsizei bufSize, ::GLsizei *length, ::GLchar *source)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLint glGetUniformLocation(::GLuint program, const ::GLchar *name)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetUniformfv(::GLuint program, ::GLint location, ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetUniformiv(::GLuint program, ::GLint location, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetVertexAttribdv(::GLuint index, ::GLenum pname, ::GLdouble *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetVertexAttribfv(::GLuint index, ::GLenum pname, ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetVertexAttribiv(::GLuint index, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetVertexAttribPointerv(::GLuint index, ::GLenum pname, ::GLvoid **pointer)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLboolean glIsProgram(::GLuint program)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLboolean glIsShader(::GLuint shader)__attribute__((visibility("default")));
}
extern "C"
{
  void glLinkProgram(::GLuint program)__attribute__((visibility("default")));
}
extern "C"
{
  void glShaderSource(::GLuint shader, ::GLsizei count, const ::GLchar **string, const ::GLint *length)__attribute__((visibility("default")));
}
extern "C"
{
  void glUseProgram(::GLuint program)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform1f(::GLint location, ::GLfloat v0)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform2f(::GLint location, ::GLfloat v0, ::GLfloat v1)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform3f(::GLint location, ::GLfloat v0, ::GLfloat v1, ::GLfloat v2)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform4f(::GLint location, ::GLfloat v0, ::GLfloat v1, ::GLfloat v2, ::GLfloat v3)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform1i(::GLint location, ::GLint v0)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform2i(::GLint location, ::GLint v0, ::GLint v1)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform3i(::GLint location, ::GLint v0, ::GLint v1, ::GLint v2)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform4i(::GLint location, ::GLint v0, ::GLint v1, ::GLint v2, ::GLint v3)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform1fv(::GLint location, ::GLsizei count, const ::GLfloat *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform2fv(::GLint location, ::GLsizei count, const ::GLfloat *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform3fv(::GLint location, ::GLsizei count, const ::GLfloat *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform4fv(::GLint location, ::GLsizei count, const ::GLfloat *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform1iv(::GLint location, ::GLsizei count, const ::GLint *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform2iv(::GLint location, ::GLsizei count, const ::GLint *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform3iv(::GLint location, ::GLsizei count, const ::GLint *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform4iv(::GLint location, ::GLsizei count, const ::GLint *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniformMatrix2fv(::GLint location, ::GLsizei count, ::GLboolean transpose, const ::GLfloat *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniformMatrix3fv(::GLint location, ::GLsizei count, ::GLboolean transpose, const ::GLfloat *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniformMatrix4fv(::GLint location, ::GLsizei count, ::GLboolean transpose, const ::GLfloat *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glValidateProgram(::GLuint program)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib1d(::GLuint index, ::GLdouble x)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib1dv(::GLuint index, const ::GLdouble *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib1f(::GLuint index, ::GLfloat x)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib1fv(::GLuint index, const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib1s(::GLuint index, ::GLshort x)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib1sv(::GLuint index, const ::GLshort *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib2d(::GLuint index, ::GLdouble x, ::GLdouble y)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib2dv(::GLuint index, const ::GLdouble *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib2f(::GLuint index, ::GLfloat x, ::GLfloat y)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib2fv(::GLuint index, const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib2s(::GLuint index, ::GLshort x, ::GLshort y)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib2sv(::GLuint index, const ::GLshort *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib3d(::GLuint index, ::GLdouble x, ::GLdouble y, ::GLdouble z)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib3dv(::GLuint index, const ::GLdouble *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib3f(::GLuint index, ::GLfloat x, ::GLfloat y, ::GLfloat z)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib3fv(::GLuint index, const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib3s(::GLuint index, ::GLshort x, ::GLshort y, ::GLshort z)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib3sv(::GLuint index, const ::GLshort *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib4Nbv(::GLuint index, const ::GLbyte *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib4Niv(::GLuint index, const ::GLint *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib4Nsv(::GLuint index, const ::GLshort *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib4Nub(::GLuint index, ::GLubyte x, ::GLubyte y, ::GLubyte z, ::GLubyte w)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib4Nubv(::GLuint index, const ::GLubyte *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib4Nuiv(::GLuint index, const ::GLuint *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib4Nusv(::GLuint index, const ::GLushort *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib4bv(::GLuint index, const ::GLbyte *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib4d(::GLuint index, ::GLdouble x, ::GLdouble y, ::GLdouble z, ::GLdouble w)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib4dv(::GLuint index, const ::GLdouble *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib4f(::GLuint index, ::GLfloat x, ::GLfloat y, ::GLfloat z, ::GLfloat w)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib4fv(::GLuint index, const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib4iv(::GLuint index, const ::GLint *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib4s(::GLuint index, ::GLshort x, ::GLshort y, ::GLshort z, ::GLshort w)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib4sv(::GLuint index, const ::GLshort *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib4ubv(::GLuint index, const ::GLubyte *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib4uiv(::GLuint index, const ::GLuint *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib4usv(::GLuint index, const ::GLushort *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribPointer(::GLuint index, ::GLint size, ::GLenum type, ::GLboolean normalized, ::GLsizei stride, const ::GLvoid *pointer)__attribute__((visibility("default")));
}
typedef void (*PFNGLBLENDEQUATIONSEPARATEPROC)(::GLenum, ::GLenum);
typedef void (*PFNGLDRAWBUFFERSPROC)(::GLsizei, const ::GLenum *);
typedef void (*PFNGLSTENCILOPSEPARATEPROC)(::GLenum, ::GLenum, ::GLenum, ::GLenum);
typedef void (*PFNGLSTENCILFUNCSEPARATEPROC)(::GLenum, ::GLenum, ::GLint, ::GLuint);
typedef void (*PFNGLSTENCILMASKSEPARATEPROC)(::GLenum, ::GLuint);
typedef void (*PFNGLATTACHSHADERPROC)(::GLuint, ::GLuint);
typedef void (*PFNGLBINDATTRIBLOCATIONPROC)(::GLuint, ::GLuint, const ::GLchar *);
typedef void (*PFNGLCOMPILESHADERPROC)(::GLuint);
typedef ::GLuint (*PFNGLCREATEPROGRAMPROC)();
typedef ::GLuint (*PFNGLCREATESHADERPROC)(::GLenum);
typedef void (*PFNGLDELETEPROGRAMPROC)(::GLuint);
typedef void (*PFNGLDELETESHADERPROC)(::GLuint);
typedef void (*PFNGLDETACHSHADERPROC)(::GLuint, ::GLuint);
typedef void (*PFNGLDISABLEVERTEXATTRIBARRAYPROC)(::GLuint);
typedef void (*PFNGLENABLEVERTEXATTRIBARRAYPROC)(::GLuint);
typedef void (*PFNGLGETACTIVEATTRIBPROC)(::GLuint, ::GLuint, ::GLsizei, ::GLsizei *, ::GLint *, ::GLenum *, ::GLchar *);
typedef void (*PFNGLGETACTIVEUNIFORMPROC)(::GLuint, ::GLuint, ::GLsizei, ::GLsizei *, ::GLint *, ::GLenum *, ::GLchar *);
typedef void (*PFNGLGETATTACHEDSHADERSPROC)(::GLuint, ::GLsizei, ::GLsizei *, ::GLuint *);
typedef ::GLint (*PFNGLGETATTRIBLOCATIONPROC)(::GLuint, const ::GLchar *);
typedef void (*PFNGLGETPROGRAMIVPROC)(::GLuint, ::GLenum, ::GLint *);
typedef void (*PFNGLGETPROGRAMINFOLOGPROC)(::GLuint, ::GLsizei, ::GLsizei *, ::GLchar *);
typedef void (*PFNGLGETSHADERIVPROC)(::GLuint, ::GLenum, ::GLint *);
typedef void (*PFNGLGETSHADERINFOLOGPROC)(::GLuint, ::GLsizei, ::GLsizei *, ::GLchar *);
typedef void (*PFNGLGETSHADERSOURCEPROC)(::GLuint, ::GLsizei, ::GLsizei *, ::GLchar *);
typedef ::GLint (*PFNGLGETUNIFORMLOCATIONPROC)(::GLuint, const ::GLchar *);
typedef void (*PFNGLGETUNIFORMFVPROC)(::GLuint, ::GLint, ::GLfloat *);
typedef void (*PFNGLGETUNIFORMIVPROC)(::GLuint, ::GLint, ::GLint *);
typedef void (*PFNGLGETVERTEXATTRIBDVPROC)(::GLuint, ::GLenum, ::GLdouble *);
typedef void (*PFNGLGETVERTEXATTRIBFVPROC)(::GLuint, ::GLenum, ::GLfloat *);
typedef void (*PFNGLGETVERTEXATTRIBIVPROC)(::GLuint, ::GLenum, ::GLint *);
typedef void (*PFNGLGETVERTEXATTRIBPOINTERVPROC)(::GLuint, ::GLenum, ::GLvoid **);
typedef ::GLboolean (*PFNGLISPROGRAMPROC)(::GLuint);
typedef ::GLboolean (*PFNGLISSHADERPROC)(::GLuint);
typedef void (*PFNGLLINKPROGRAMPROC)(::GLuint);
typedef void (*PFNGLSHADERSOURCEPROC)(::GLuint, ::GLsizei, const ::GLchar **, const ::GLint *);
typedef void (*PFNGLUSEPROGRAMPROC)(::GLuint);
typedef void (*PFNGLUNIFORM1FPROC)(::GLint, ::GLfloat);
typedef void (*PFNGLUNIFORM2FPROC)(::GLint, ::GLfloat, ::GLfloat);
typedef void (*PFNGLUNIFORM3FPROC)(::GLint, ::GLfloat, ::GLfloat, ::GLfloat);
typedef void (*PFNGLUNIFORM4FPROC)(::GLint, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat);
typedef void (*PFNGLUNIFORM1IPROC)(::GLint, ::GLint);
typedef void (*PFNGLUNIFORM2IPROC)(::GLint, ::GLint, ::GLint);
typedef void (*PFNGLUNIFORM3IPROC)(::GLint, ::GLint, ::GLint, ::GLint);
typedef void (*PFNGLUNIFORM4IPROC)(::GLint, ::GLint, ::GLint, ::GLint, ::GLint);
typedef void (*PFNGLUNIFORM1FVPROC)(::GLint, ::GLsizei, const ::GLfloat *);
typedef void (*PFNGLUNIFORM2FVPROC)(::GLint, ::GLsizei, const ::GLfloat *);
typedef void (*PFNGLUNIFORM3FVPROC)(::GLint, ::GLsizei, const ::GLfloat *);
typedef void (*PFNGLUNIFORM4FVPROC)(::GLint, ::GLsizei, const ::GLfloat *);
typedef void (*PFNGLUNIFORM1IVPROC)(::GLint, ::GLsizei, const ::GLint *);
typedef void (*PFNGLUNIFORM2IVPROC)(::GLint, ::GLsizei, const ::GLint *);
typedef void (*PFNGLUNIFORM3IVPROC)(::GLint, ::GLsizei, const ::GLint *);
typedef void (*PFNGLUNIFORM4IVPROC)(::GLint, ::GLsizei, const ::GLint *);
typedef void (*PFNGLUNIFORMMATRIX2FVPROC)(::GLint, ::GLsizei, ::GLboolean, const ::GLfloat *);
typedef void (*PFNGLUNIFORMMATRIX3FVPROC)(::GLint, ::GLsizei, ::GLboolean, const ::GLfloat *);
typedef void (*PFNGLUNIFORMMATRIX4FVPROC)(::GLint, ::GLsizei, ::GLboolean, const ::GLfloat *);
typedef void (*PFNGLVALIDATEPROGRAMPROC)(::GLuint);
typedef void (*PFNGLVERTEXATTRIB1DPROC)(::GLuint, ::GLdouble);
typedef void (*PFNGLVERTEXATTRIB1DVPROC)(::GLuint, const ::GLdouble *);
typedef void (*PFNGLVERTEXATTRIB1FPROC)(::GLuint, ::GLfloat);
typedef void (*PFNGLVERTEXATTRIB1FVPROC)(::GLuint, const ::GLfloat *);
typedef void (*PFNGLVERTEXATTRIB1SPROC)(::GLuint, ::GLshort);
typedef void (*PFNGLVERTEXATTRIB1SVPROC)(::GLuint, const ::GLshort *);
typedef void (*PFNGLVERTEXATTRIB2DPROC)(::GLuint, ::GLdouble, ::GLdouble);
typedef void (*PFNGLVERTEXATTRIB2DVPROC)(::GLuint, const ::GLdouble *);
typedef void (*PFNGLVERTEXATTRIB2FPROC)(::GLuint, ::GLfloat, ::GLfloat);
typedef void (*PFNGLVERTEXATTRIB2FVPROC)(::GLuint, const ::GLfloat *);
typedef void (*PFNGLVERTEXATTRIB2SPROC)(::GLuint, ::GLshort, ::GLshort);
typedef void (*PFNGLVERTEXATTRIB2SVPROC)(::GLuint, const ::GLshort *);
typedef void (*PFNGLVERTEXATTRIB3DPROC)(::GLuint, ::GLdouble, ::GLdouble, ::GLdouble);
typedef void (*PFNGLVERTEXATTRIB3DVPROC)(::GLuint, const ::GLdouble *);
typedef void (*PFNGLVERTEXATTRIB3FPROC)(::GLuint, ::GLfloat, ::GLfloat, ::GLfloat);
typedef void (*PFNGLVERTEXATTRIB3FVPROC)(::GLuint, const ::GLfloat *);
typedef void (*PFNGLVERTEXATTRIB3SPROC)(::GLuint, ::GLshort, ::GLshort, ::GLshort);
typedef void (*PFNGLVERTEXATTRIB3SVPROC)(::GLuint, const ::GLshort *);
typedef void (*PFNGLVERTEXATTRIB4NBVPROC)(::GLuint, const ::GLbyte *);
typedef void (*PFNGLVERTEXATTRIB4NIVPROC)(::GLuint, const ::GLint *);
typedef void (*PFNGLVERTEXATTRIB4NSVPROC)(::GLuint, const ::GLshort *);
typedef void (*PFNGLVERTEXATTRIB4NUBPROC)(::GLuint, ::GLubyte, ::GLubyte, ::GLubyte, ::GLubyte);
typedef void (*PFNGLVERTEXATTRIB4NUBVPROC)(::GLuint, const ::GLubyte *);
typedef void (*PFNGLVERTEXATTRIB4NUIVPROC)(::GLuint, const ::GLuint *);
typedef void (*PFNGLVERTEXATTRIB4NUSVPROC)(::GLuint, const ::GLushort *);
typedef void (*PFNGLVERTEXATTRIB4BVPROC)(::GLuint, const ::GLbyte *);
typedef void (*PFNGLVERTEXATTRIB4DPROC)(::GLuint, ::GLdouble, ::GLdouble, ::GLdouble, ::GLdouble);
typedef void (*PFNGLVERTEXATTRIB4DVPROC)(::GLuint, const ::GLdouble *);
typedef void (*PFNGLVERTEXATTRIB4FPROC)(::GLuint, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat);
typedef void (*PFNGLVERTEXATTRIB4FVPROC)(::GLuint, const ::GLfloat *);
typedef void (*PFNGLVERTEXATTRIB4IVPROC)(::GLuint, const ::GLint *);
typedef void (*PFNGLVERTEXATTRIB4SPROC)(::GLuint, ::GLshort, ::GLshort, ::GLshort, ::GLshort);
typedef void (*PFNGLVERTEXATTRIB4SVPROC)(::GLuint, const ::GLshort *);
typedef void (*PFNGLVERTEXATTRIB4UBVPROC)(::GLuint, const ::GLubyte *);
typedef void (*PFNGLVERTEXATTRIB4UIVPROC)(::GLuint, const ::GLuint *);
typedef void (*PFNGLVERTEXATTRIB4USVPROC)(::GLuint, const ::GLushort *);
typedef void (*PFNGLVERTEXATTRIBPOINTERPROC)(::GLuint, ::GLint, ::GLenum, ::GLboolean, ::GLsizei, const ::GLvoid *);
extern "C"
{
  void glUniformMatrix2x3fv(::GLint location, ::GLsizei count, ::GLboolean transpose, const ::GLfloat *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniformMatrix3x2fv(::GLint location, ::GLsizei count, ::GLboolean transpose, const ::GLfloat *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniformMatrix2x4fv(::GLint location, ::GLsizei count, ::GLboolean transpose, const ::GLfloat *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniformMatrix4x2fv(::GLint location, ::GLsizei count, ::GLboolean transpose, const ::GLfloat *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniformMatrix3x4fv(::GLint location, ::GLsizei count, ::GLboolean transpose, const ::GLfloat *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniformMatrix4x3fv(::GLint location, ::GLsizei count, ::GLboolean transpose, const ::GLfloat *value)__attribute__((visibility("default")));
}
typedef void (*PFNGLUNIFORMMATRIX2X3FVPROC)(::GLint, ::GLsizei, ::GLboolean, const ::GLfloat *);
typedef void (*PFNGLUNIFORMMATRIX3X2FVPROC)(::GLint, ::GLsizei, ::GLboolean, const ::GLfloat *);
typedef void (*PFNGLUNIFORMMATRIX2X4FVPROC)(::GLint, ::GLsizei, ::GLboolean, const ::GLfloat *);
typedef void (*PFNGLUNIFORMMATRIX4X2FVPROC)(::GLint, ::GLsizei, ::GLboolean, const ::GLfloat *);
typedef void (*PFNGLUNIFORMMATRIX3X4FVPROC)(::GLint, ::GLsizei, ::GLboolean, const ::GLfloat *);
typedef void (*PFNGLUNIFORMMATRIX4X3FVPROC)(::GLint, ::GLsizei, ::GLboolean, const ::GLfloat *);
extern "C"
{
  void glColorMaski(::GLuint index, ::GLboolean r, ::GLboolean g, ::GLboolean b, ::GLboolean a)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetBooleani_v(::GLenum target, ::GLuint index, ::GLboolean *data)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetIntegeri_v(::GLenum target, ::GLuint index, ::GLint *data)__attribute__((visibility("default")));
}
extern "C"
{
  void glEnablei(::GLenum target, ::GLuint index)__attribute__((visibility("default")));
}
extern "C"
{
  void glDisablei(::GLenum target, ::GLuint index)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLboolean glIsEnabledi(::GLenum target, ::GLuint index)__attribute__((visibility("default")));
}
extern "C"
{
  void glBeginTransformFeedback(::GLenum primitiveMode)__attribute__((visibility("default")));
}
extern "C"
{
  void glEndTransformFeedback()__attribute__((visibility("default")));
}
extern "C"
{
  void glBindBufferRange(::GLenum target, ::GLuint index, ::GLuint buffer, ::GLintptr offset, ::GLsizeiptr size)__attribute__((visibility("default")));
}
extern "C"
{
  void glBindBufferBase(::GLenum target, ::GLuint index, ::GLuint buffer)__attribute__((visibility("default")));
}
extern "C"
{
  void glTransformFeedbackVaryings(::GLuint program, ::GLsizei count, const ::GLchar **varyings, ::GLenum bufferMode)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetTransformFeedbackVarying(::GLuint program, ::GLuint index, ::GLsizei bufSize, ::GLsizei *length, ::GLsizei *size, ::GLenum *type, ::GLchar *name)__attribute__((visibility("default")));
}
extern "C"
{
  void glClampColor(::GLenum target, ::GLenum clamp)__attribute__((visibility("default")));
}
extern "C"
{
  void glBeginConditionalRender(::GLuint id, ::GLenum mode)__attribute__((visibility("default")));
}
extern "C"
{
  void glEndConditionalRender()__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribIPointer(::GLuint index, ::GLint size, ::GLenum type, ::GLsizei stride, const ::GLvoid *pointer)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetVertexAttribIiv(::GLuint index, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetVertexAttribIuiv(::GLuint index, ::GLenum pname, ::GLuint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribI1i(::GLuint index, ::GLint x)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribI2i(::GLuint index, ::GLint x, ::GLint y)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribI3i(::GLuint index, ::GLint x, ::GLint y, ::GLint z)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribI4i(::GLuint index, ::GLint x, ::GLint y, ::GLint z, ::GLint w)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribI1ui(::GLuint index, ::GLuint x)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribI2ui(::GLuint index, ::GLuint x, ::GLuint y)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribI3ui(::GLuint index, ::GLuint x, ::GLuint y, ::GLuint z)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribI4ui(::GLuint index, ::GLuint x, ::GLuint y, ::GLuint z, ::GLuint w)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribI1iv(::GLuint index, const ::GLint *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribI2iv(::GLuint index, const ::GLint *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribI3iv(::GLuint index, const ::GLint *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribI4iv(::GLuint index, const ::GLint *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribI1uiv(::GLuint index, const ::GLuint *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribI2uiv(::GLuint index, const ::GLuint *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribI3uiv(::GLuint index, const ::GLuint *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribI4uiv(::GLuint index, const ::GLuint *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribI4bv(::GLuint index, const ::GLbyte *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribI4sv(::GLuint index, const ::GLshort *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribI4ubv(::GLuint index, const ::GLubyte *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribI4usv(::GLuint index, const ::GLushort *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetUniformuiv(::GLuint program, ::GLint location, ::GLuint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glBindFragDataLocation(::GLuint program, ::GLuint color, const ::GLchar *name)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLint glGetFragDataLocation(::GLuint program, const ::GLchar *name)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform1ui(::GLint location, ::GLuint v0)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform2ui(::GLint location, ::GLuint v0, ::GLuint v1)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform3ui(::GLint location, ::GLuint v0, ::GLuint v1, ::GLuint v2)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform4ui(::GLint location, ::GLuint v0, ::GLuint v1, ::GLuint v2, ::GLuint v3)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform1uiv(::GLint location, ::GLsizei count, const ::GLuint *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform2uiv(::GLint location, ::GLsizei count, const ::GLuint *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform3uiv(::GLint location, ::GLsizei count, const ::GLuint *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform4uiv(::GLint location, ::GLsizei count, const ::GLuint *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexParameterIiv(::GLenum target, ::GLenum pname, const ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexParameterIuiv(::GLenum target, ::GLenum pname, const ::GLuint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetTexParameterIiv(::GLenum target, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetTexParameterIuiv(::GLenum target, ::GLenum pname, ::GLuint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glClearBufferiv(::GLenum buffer, ::GLint drawbuffer, const ::GLint *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glClearBufferuiv(::GLenum buffer, ::GLint drawbuffer, const ::GLuint *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glClearBufferfv(::GLenum buffer, ::GLint drawbuffer, const ::GLfloat *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glClearBufferfi(::GLenum buffer, ::GLint drawbuffer, ::GLfloat depth, ::GLint stencil)__attribute__((visibility("default")));
}
extern "C"
{
  const ::GLubyte *glGetStringi(::GLenum name, ::GLuint index)__attribute__((visibility("default")));
}
typedef void (*PFNGLCOLORMASKIPROC)(::GLuint, ::GLboolean, ::GLboolean, ::GLboolean, ::GLboolean);
typedef void (*PFNGLGETBOOLEANI_VPROC)(::GLenum, ::GLuint, ::GLboolean *);
typedef void (*PFNGLGETINTEGERI_VPROC)(::GLenum, ::GLuint, ::GLint *);
typedef void (*PFNGLENABLEIPROC)(::GLenum, ::GLuint);
typedef void (*PFNGLDISABLEIPROC)(::GLenum, ::GLuint);
typedef ::GLboolean (*PFNGLISENABLEDIPROC)(::GLenum, ::GLuint);
typedef void (*PFNGLBEGINTRANSFORMFEEDBACKPROC)(::GLenum);
typedef void (*PFNGLENDTRANSFORMFEEDBACKPROC)();
typedef void (*PFNGLBINDBUFFERRANGEPROC)(::GLenum, ::GLuint, ::GLuint, ::GLintptr, ::GLsizeiptr);
typedef void (*PFNGLBINDBUFFERBASEPROC)(::GLenum, ::GLuint, ::GLuint);
typedef void (*PFNGLTRANSFORMFEEDBACKVARYINGSPROC)(::GLuint, ::GLsizei, const ::GLchar **, ::GLenum);
typedef void (*PFNGLGETTRANSFORMFEEDBACKVARYINGPROC)(::GLuint, ::GLuint, ::GLsizei, ::GLsizei *, ::GLsizei *, ::GLenum *, ::GLchar *);
typedef void (*PFNGLCLAMPCOLORPROC)(::GLenum, ::GLenum);
typedef void (*PFNGLBEGINCONDITIONALRENDERPROC)(::GLuint, ::GLenum);
typedef void (*PFNGLENDCONDITIONALRENDERPROC)();
typedef void (*PFNGLVERTEXATTRIBIPOINTERPROC)(::GLuint, ::GLint, ::GLenum, ::GLsizei, const ::GLvoid *);
typedef void (*PFNGLGETVERTEXATTRIBIIVPROC)(::GLuint, ::GLenum, ::GLint *);
typedef void (*PFNGLGETVERTEXATTRIBIUIVPROC)(::GLuint, ::GLenum, ::GLuint *);
typedef void (*PFNGLVERTEXATTRIBI1IPROC)(::GLuint, ::GLint);
typedef void (*PFNGLVERTEXATTRIBI2IPROC)(::GLuint, ::GLint, ::GLint);
typedef void (*PFNGLVERTEXATTRIBI3IPROC)(::GLuint, ::GLint, ::GLint, ::GLint);
typedef void (*PFNGLVERTEXATTRIBI4IPROC)(::GLuint, ::GLint, ::GLint, ::GLint, ::GLint);
typedef void (*PFNGLVERTEXATTRIBI1UIPROC)(::GLuint, ::GLuint);
typedef void (*PFNGLVERTEXATTRIBI2UIPROC)(::GLuint, ::GLuint, ::GLuint);
typedef void (*PFNGLVERTEXATTRIBI3UIPROC)(::GLuint, ::GLuint, ::GLuint, ::GLuint);
typedef void (*PFNGLVERTEXATTRIBI4UIPROC)(::GLuint, ::GLuint, ::GLuint, ::GLuint, ::GLuint);
typedef void (*PFNGLVERTEXATTRIBI1IVPROC)(::GLuint, const ::GLint *);
typedef void (*PFNGLVERTEXATTRIBI2IVPROC)(::GLuint, const ::GLint *);
typedef void (*PFNGLVERTEXATTRIBI3IVPROC)(::GLuint, const ::GLint *);
typedef void (*PFNGLVERTEXATTRIBI4IVPROC)(::GLuint, const ::GLint *);
typedef void (*PFNGLVERTEXATTRIBI1UIVPROC)(::GLuint, const ::GLuint *);
typedef void (*PFNGLVERTEXATTRIBI2UIVPROC)(::GLuint, const ::GLuint *);
typedef void (*PFNGLVERTEXATTRIBI3UIVPROC)(::GLuint, const ::GLuint *);
typedef void (*PFNGLVERTEXATTRIBI4UIVPROC)(::GLuint, const ::GLuint *);
typedef void (*PFNGLVERTEXATTRIBI4BVPROC)(::GLuint, const ::GLbyte *);
typedef void (*PFNGLVERTEXATTRIBI4SVPROC)(::GLuint, const ::GLshort *);
typedef void (*PFNGLVERTEXATTRIBI4UBVPROC)(::GLuint, const ::GLubyte *);
typedef void (*PFNGLVERTEXATTRIBI4USVPROC)(::GLuint, const ::GLushort *);
typedef void (*PFNGLGETUNIFORMUIVPROC)(::GLuint, ::GLint, ::GLuint *);
typedef void (*PFNGLBINDFRAGDATALOCATIONPROC)(::GLuint, ::GLuint, const ::GLchar *);
typedef ::GLint (*PFNGLGETFRAGDATALOCATIONPROC)(::GLuint, const ::GLchar *);
typedef void (*PFNGLUNIFORM1UIPROC)(::GLint, ::GLuint);
typedef void (*PFNGLUNIFORM2UIPROC)(::GLint, ::GLuint, ::GLuint);
typedef void (*PFNGLUNIFORM3UIPROC)(::GLint, ::GLuint, ::GLuint, ::GLuint);
typedef void (*PFNGLUNIFORM4UIPROC)(::GLint, ::GLuint, ::GLuint, ::GLuint, ::GLuint);
typedef void (*PFNGLUNIFORM1UIVPROC)(::GLint, ::GLsizei, const ::GLuint *);
typedef void (*PFNGLUNIFORM2UIVPROC)(::GLint, ::GLsizei, const ::GLuint *);
typedef void (*PFNGLUNIFORM3UIVPROC)(::GLint, ::GLsizei, const ::GLuint *);
typedef void (*PFNGLUNIFORM4UIVPROC)(::GLint, ::GLsizei, const ::GLuint *);
typedef void (*PFNGLTEXPARAMETERIIVPROC)(::GLenum, ::GLenum, const ::GLint *);
typedef void (*PFNGLTEXPARAMETERIUIVPROC)(::GLenum, ::GLenum, const ::GLuint *);
typedef void (*PFNGLGETTEXPARAMETERIIVPROC)(::GLenum, ::GLenum, ::GLint *);
typedef void (*PFNGLGETTEXPARAMETERIUIVPROC)(::GLenum, ::GLenum, ::GLuint *);
typedef void (*PFNGLCLEARBUFFERIVPROC)(::GLenum, ::GLint, const ::GLint *);
typedef void (*PFNGLCLEARBUFFERUIVPROC)(::GLenum, ::GLint, const ::GLuint *);
typedef void (*PFNGLCLEARBUFFERFVPROC)(::GLenum, ::GLint, const ::GLfloat *);
typedef void (*PFNGLCLEARBUFFERFIPROC)(::GLenum, ::GLint, ::GLfloat, ::GLint);
typedef const ::GLubyte *(*PFNGLGETSTRINGIPROC)(::GLenum, ::GLuint);
extern "C"
{
  void glDrawArraysInstanced(::GLenum mode, ::GLint first, ::GLsizei count, ::GLsizei primcount)__attribute__((visibility("default")));
}
extern "C"
{
  void glDrawElementsInstanced(::GLenum mode, ::GLsizei count, ::GLenum type, const ::GLvoid *indices, ::GLsizei primcount)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexBuffer(::GLenum target, ::GLenum internalformat, ::GLuint buffer)__attribute__((visibility("default")));
}
extern "C"
{
  void glPrimitiveRestartIndex(::GLuint index)__attribute__((visibility("default")));
}
typedef void (*PFNGLDRAWARRAYSINSTANCEDPROC)(::GLenum, ::GLint, ::GLsizei, ::GLsizei);
typedef void (*PFNGLDRAWELEMENTSINSTANCEDPROC)(::GLenum, ::GLsizei, ::GLenum, const ::GLvoid *, ::GLsizei);
typedef void (*PFNGLTEXBUFFERPROC)(::GLenum, ::GLenum, ::GLuint);
typedef void (*PFNGLPRIMITIVERESTARTINDEXPROC)(::GLuint);
extern "C"
{
  void glGetInteger64i_v(::GLenum target, ::GLuint index, ::GLint64 *data)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetBufferParameteri64v(::GLenum target, ::GLenum pname, ::GLint64 *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glFramebufferTexture(::GLenum target, ::GLenum attachment, ::GLuint texture, ::GLint level)__attribute__((visibility("default")));
}
typedef void (*PFNGLGETINTEGER64I_VPROC)(::GLenum, ::GLuint, ::GLint64 *);
typedef void (*PFNGLGETBUFFERPARAMETERI64VPROC)(::GLenum, ::GLenum, ::GLint64 *);
typedef void (*PFNGLFRAMEBUFFERTEXTUREPROC)(::GLenum, ::GLenum, ::GLuint, ::GLint);
extern "C"
{
  void glVertexAttribDivisor(::GLuint index, ::GLuint divisor)__attribute__((visibility("default")));
}
typedef void (*PFNGLVERTEXATTRIBDIVISORPROC)(::GLuint, ::GLuint);
extern "C"
{
  void glMinSampleShading(::GLclampf value)__attribute__((visibility("default")));
}
extern "C"
{
  void glBlendEquationi(::GLuint buf, ::GLenum mode)__attribute__((visibility("default")));
}
extern "C"
{
  void glBlendEquationSeparatei(::GLuint buf, ::GLenum modeRGB, ::GLenum modeAlpha)__attribute__((visibility("default")));
}
extern "C"
{
  void glBlendFunci(::GLuint buf, ::GLenum src, ::GLenum dst)__attribute__((visibility("default")));
}
extern "C"
{
  void glBlendFuncSeparatei(::GLuint buf, ::GLenum srcRGB, ::GLenum dstRGB, ::GLenum srcAlpha, ::GLenum dstAlpha)__attribute__((visibility("default")));
}
typedef void (*PFNGLMINSAMPLESHADINGPROC)(::GLclampf);
typedef void (*PFNGLBLENDEQUATIONIPROC)(::GLuint, ::GLenum);
typedef void (*PFNGLBLENDEQUATIONSEPARATEIPROC)(::GLuint, ::GLenum, ::GLenum);
typedef void (*PFNGLBLENDFUNCIPROC)(::GLuint, ::GLenum, ::GLenum);
typedef void (*PFNGLBLENDFUNCSEPARATEIPROC)(::GLuint, ::GLenum, ::GLenum, ::GLenum, ::GLenum);
extern "C"
{
  void glLoadTransposeMatrixfARB(const ::GLfloat *m)__attribute__((visibility("default")));
}
extern "C"
{
  void glLoadTransposeMatrixdARB(const ::GLdouble *m)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultTransposeMatrixfARB(const ::GLfloat *m)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultTransposeMatrixdARB(const ::GLdouble *m)__attribute__((visibility("default")));
}
typedef void (*PFNGLLOADTRANSPOSEMATRIXFARBPROC)(const ::GLfloat *);
typedef void (*PFNGLLOADTRANSPOSEMATRIXDARBPROC)(const ::GLdouble *);
typedef void (*PFNGLMULTTRANSPOSEMATRIXFARBPROC)(const ::GLfloat *);
typedef void (*PFNGLMULTTRANSPOSEMATRIXDARBPROC)(const ::GLdouble *);
extern "C"
{
  void glSampleCoverageARB(::GLclampf value, ::GLboolean invert)__attribute__((visibility("default")));
}
typedef void (*PFNGLSAMPLECOVERAGEARBPROC)(::GLclampf, ::GLboolean);
extern "C"
{
  void glCompressedTexImage3DARB(::GLenum target, ::GLint level, ::GLenum internalformat, ::GLsizei width, ::GLsizei height, ::GLsizei depth, ::GLint border, ::GLsizei imageSize, const ::GLvoid *data)__attribute__((visibility("default")));
}
extern "C"
{
  void glCompressedTexImage2DARB(::GLenum target, ::GLint level, ::GLenum internalformat, ::GLsizei width, ::GLsizei height, ::GLint border, ::GLsizei imageSize, const ::GLvoid *data)__attribute__((visibility("default")));
}
extern "C"
{
  void glCompressedTexImage1DARB(::GLenum target, ::GLint level, ::GLenum internalformat, ::GLsizei width, ::GLint border, ::GLsizei imageSize, const ::GLvoid *data)__attribute__((visibility("default")));
}
extern "C"
{
  void glCompressedTexSubImage3DARB(::GLenum target, ::GLint level, ::GLint xoffset, ::GLint yoffset, ::GLint zoffset, ::GLsizei width, ::GLsizei height, ::GLsizei depth, ::GLenum format, ::GLsizei imageSize, const ::GLvoid *data)__attribute__((visibility("default")));
}
extern "C"
{
  void glCompressedTexSubImage2DARB(::GLenum target, ::GLint level, ::GLint xoffset, ::GLint yoffset, ::GLsizei width, ::GLsizei height, ::GLenum format, ::GLsizei imageSize, const ::GLvoid *data)__attribute__((visibility("default")));
}
extern "C"
{
  void glCompressedTexSubImage1DARB(::GLenum target, ::GLint level, ::GLint xoffset, ::GLsizei width, ::GLenum format, ::GLsizei imageSize, const ::GLvoid *data)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetCompressedTexImageARB(::GLenum target, ::GLint level, ::GLvoid *img)__attribute__((visibility("default")));
}
typedef void (*PFNGLCOMPRESSEDTEXIMAGE3DARBPROC)(::GLenum, ::GLint, ::GLenum, ::GLsizei, ::GLsizei, ::GLsizei, ::GLint, ::GLsizei, const ::GLvoid *);
typedef void (*PFNGLCOMPRESSEDTEXIMAGE2DARBPROC)(::GLenum, ::GLint, ::GLenum, ::GLsizei, ::GLsizei, ::GLint, ::GLsizei, const ::GLvoid *);
typedef void (*PFNGLCOMPRESSEDTEXIMAGE1DARBPROC)(::GLenum, ::GLint, ::GLenum, ::GLsizei, ::GLint, ::GLsizei, const ::GLvoid *);
typedef void (*PFNGLCOMPRESSEDTEXSUBIMAGE3DARBPROC)(::GLenum, ::GLint, ::GLint, ::GLint, ::GLint, ::GLsizei, ::GLsizei, ::GLsizei, ::GLenum, ::GLsizei, const ::GLvoid *);
typedef void (*PFNGLCOMPRESSEDTEXSUBIMAGE2DARBPROC)(::GLenum, ::GLint, ::GLint, ::GLint, ::GLsizei, ::GLsizei, ::GLenum, ::GLsizei, const ::GLvoid *);
typedef void (*PFNGLCOMPRESSEDTEXSUBIMAGE1DARBPROC)(::GLenum, ::GLint, ::GLint, ::GLsizei, ::GLenum, ::GLsizei, const ::GLvoid *);
typedef void (*PFNGLGETCOMPRESSEDTEXIMAGEARBPROC)(::GLenum, ::GLint, ::GLvoid *);
extern "C"
{
  void glPointParameterfARB(::GLenum pname, ::GLfloat param)__attribute__((visibility("default")));
}
extern "C"
{
  void glPointParameterfvARB(::GLenum pname, const ::GLfloat *params)__attribute__((visibility("default")));
}
typedef void (*PFNGLPOINTPARAMETERFARBPROC)(::GLenum, ::GLfloat);
typedef void (*PFNGLPOINTPARAMETERFVARBPROC)(::GLenum, const ::GLfloat *);
extern "C"
{
  void glWeightbvARB(::GLint size, const ::GLbyte *weights)__attribute__((visibility("default")));
}
extern "C"
{
  void glWeightsvARB(::GLint size, const ::GLshort *weights)__attribute__((visibility("default")));
}
extern "C"
{
  void glWeightivARB(::GLint size, const ::GLint *weights)__attribute__((visibility("default")));
}
extern "C"
{
  void glWeightfvARB(::GLint size, const ::GLfloat *weights)__attribute__((visibility("default")));
}
extern "C"
{
  void glWeightdvARB(::GLint size, const ::GLdouble *weights)__attribute__((visibility("default")));
}
extern "C"
{
  void glWeightubvARB(::GLint size, const ::GLubyte *weights)__attribute__((visibility("default")));
}
extern "C"
{
  void glWeightusvARB(::GLint size, const ::GLushort *weights)__attribute__((visibility("default")));
}
extern "C"
{
  void glWeightuivARB(::GLint size, const ::GLuint *weights)__attribute__((visibility("default")));
}
extern "C"
{
  void glWeightPointerARB(::GLint size, ::GLenum type, ::GLsizei stride, const ::GLvoid *pointer)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexBlendARB(::GLint count)__attribute__((visibility("default")));
}
typedef void (*PFNGLWEIGHTBVARBPROC)(::GLint, const ::GLbyte *);
typedef void (*PFNGLWEIGHTSVARBPROC)(::GLint, const ::GLshort *);
typedef void (*PFNGLWEIGHTIVARBPROC)(::GLint, const ::GLint *);
typedef void (*PFNGLWEIGHTFVARBPROC)(::GLint, const ::GLfloat *);
typedef void (*PFNGLWEIGHTDVARBPROC)(::GLint, const ::GLdouble *);
typedef void (*PFNGLWEIGHTUBVARBPROC)(::GLint, const ::GLubyte *);
typedef void (*PFNGLWEIGHTUSVARBPROC)(::GLint, const ::GLushort *);
typedef void (*PFNGLWEIGHTUIVARBPROC)(::GLint, const ::GLuint *);
typedef void (*PFNGLWEIGHTPOINTERARBPROC)(::GLint, ::GLenum, ::GLsizei, const ::GLvoid *);
typedef void (*PFNGLVERTEXBLENDARBPROC)(::GLint);
extern "C"
{
  void glCurrentPaletteMatrixARB(::GLint index)__attribute__((visibility("default")));
}
extern "C"
{
  void glMatrixIndexubvARB(::GLint size, const ::GLubyte *indices)__attribute__((visibility("default")));
}
extern "C"
{
  void glMatrixIndexusvARB(::GLint size, const ::GLushort *indices)__attribute__((visibility("default")));
}
extern "C"
{
  void glMatrixIndexuivARB(::GLint size, const ::GLuint *indices)__attribute__((visibility("default")));
}
extern "C"
{
  void glMatrixIndexPointerARB(::GLint size, ::GLenum type, ::GLsizei stride, const ::GLvoid *pointer)__attribute__((visibility("default")));
}
typedef void (*PFNGLCURRENTPALETTEMATRIXARBPROC)(::GLint);
typedef void (*PFNGLMATRIXINDEXUBVARBPROC)(::GLint, const ::GLubyte *);
typedef void (*PFNGLMATRIXINDEXUSVARBPROC)(::GLint, const ::GLushort *);
typedef void (*PFNGLMATRIXINDEXUIVARBPROC)(::GLint, const ::GLuint *);
typedef void (*PFNGLMATRIXINDEXPOINTERARBPROC)(::GLint, ::GLenum, ::GLsizei, const ::GLvoid *);
extern "C"
{
  void glWindowPos2dARB(::GLdouble x, ::GLdouble y)__attribute__((visibility("default")));
}
extern "C"
{
  void glWindowPos2dvARB(const ::GLdouble *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glWindowPos2fARB(::GLfloat x, ::GLfloat y)__attribute__((visibility("default")));
}
extern "C"
{
  void glWindowPos2fvARB(const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glWindowPos2iARB(::GLint x, ::GLint y)__attribute__((visibility("default")));
}
extern "C"
{
  void glWindowPos2ivARB(const ::GLint *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glWindowPos2sARB(::GLshort x, ::GLshort y)__attribute__((visibility("default")));
}
extern "C"
{
  void glWindowPos2svARB(const ::GLshort *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glWindowPos3dARB(::GLdouble x, ::GLdouble y, ::GLdouble z)__attribute__((visibility("default")));
}
extern "C"
{
  void glWindowPos3dvARB(const ::GLdouble *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glWindowPos3fARB(::GLfloat x, ::GLfloat y, ::GLfloat z)__attribute__((visibility("default")));
}
extern "C"
{
  void glWindowPos3fvARB(const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glWindowPos3iARB(::GLint x, ::GLint y, ::GLint z)__attribute__((visibility("default")));
}
extern "C"
{
  void glWindowPos3ivARB(const ::GLint *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glWindowPos3sARB(::GLshort x, ::GLshort y, ::GLshort z)__attribute__((visibility("default")));
}
extern "C"
{
  void glWindowPos3svARB(const ::GLshort *v)__attribute__((visibility("default")));
}
typedef void (*PFNGLWINDOWPOS2DARBPROC)(::GLdouble, ::GLdouble);
typedef void (*PFNGLWINDOWPOS2DVARBPROC)(const ::GLdouble *);
typedef void (*PFNGLWINDOWPOS2FARBPROC)(::GLfloat, ::GLfloat);
typedef void (*PFNGLWINDOWPOS2FVARBPROC)(const ::GLfloat *);
typedef void (*PFNGLWINDOWPOS2IARBPROC)(::GLint, ::GLint);
typedef void (*PFNGLWINDOWPOS2IVARBPROC)(const ::GLint *);
typedef void (*PFNGLWINDOWPOS2SARBPROC)(::GLshort, ::GLshort);
typedef void (*PFNGLWINDOWPOS2SVARBPROC)(const ::GLshort *);
typedef void (*PFNGLWINDOWPOS3DARBPROC)(::GLdouble, ::GLdouble, ::GLdouble);
typedef void (*PFNGLWINDOWPOS3DVARBPROC)(const ::GLdouble *);
typedef void (*PFNGLWINDOWPOS3FARBPROC)(::GLfloat, ::GLfloat, ::GLfloat);
typedef void (*PFNGLWINDOWPOS3FVARBPROC)(const ::GLfloat *);
typedef void (*PFNGLWINDOWPOS3IARBPROC)(::GLint, ::GLint, ::GLint);
typedef void (*PFNGLWINDOWPOS3IVARBPROC)(const ::GLint *);
typedef void (*PFNGLWINDOWPOS3SARBPROC)(::GLshort, ::GLshort, ::GLshort);
typedef void (*PFNGLWINDOWPOS3SVARBPROC)(const ::GLshort *);
extern "C"
{
  void glVertexAttrib1dARB(::GLuint index, ::GLdouble x)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib1dvARB(::GLuint index, const ::GLdouble *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib1fARB(::GLuint index, ::GLfloat x)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib1fvARB(::GLuint index, const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib1sARB(::GLuint index, ::GLshort x)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib1svARB(::GLuint index, const ::GLshort *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib2dARB(::GLuint index, ::GLdouble x, ::GLdouble y)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib2dvARB(::GLuint index, const ::GLdouble *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib2fARB(::GLuint index, ::GLfloat x, ::GLfloat y)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib2fvARB(::GLuint index, const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib2sARB(::GLuint index, ::GLshort x, ::GLshort y)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib2svARB(::GLuint index, const ::GLshort *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib3dARB(::GLuint index, ::GLdouble x, ::GLdouble y, ::GLdouble z)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib3dvARB(::GLuint index, const ::GLdouble *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib3fARB(::GLuint index, ::GLfloat x, ::GLfloat y, ::GLfloat z)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib3fvARB(::GLuint index, const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib3sARB(::GLuint index, ::GLshort x, ::GLshort y, ::GLshort z)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib3svARB(::GLuint index, const ::GLshort *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib4NbvARB(::GLuint index, const ::GLbyte *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib4NivARB(::GLuint index, const ::GLint *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib4NsvARB(::GLuint index, const ::GLshort *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib4NubARB(::GLuint index, ::GLubyte x, ::GLubyte y, ::GLubyte z, ::GLubyte w)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib4NubvARB(::GLuint index, const ::GLubyte *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib4NuivARB(::GLuint index, const ::GLuint *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib4NusvARB(::GLuint index, const ::GLushort *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib4bvARB(::GLuint index, const ::GLbyte *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib4dARB(::GLuint index, ::GLdouble x, ::GLdouble y, ::GLdouble z, ::GLdouble w)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib4dvARB(::GLuint index, const ::GLdouble *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib4fARB(::GLuint index, ::GLfloat x, ::GLfloat y, ::GLfloat z, ::GLfloat w)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib4fvARB(::GLuint index, const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib4ivARB(::GLuint index, const ::GLint *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib4sARB(::GLuint index, ::GLshort x, ::GLshort y, ::GLshort z, ::GLshort w)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib4svARB(::GLuint index, const ::GLshort *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib4ubvARB(::GLuint index, const ::GLubyte *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib4uivARB(::GLuint index, const ::GLuint *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib4usvARB(::GLuint index, const ::GLushort *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribPointerARB(::GLuint index, ::GLint size, ::GLenum type, ::GLboolean normalized, ::GLsizei stride, const ::GLvoid *pointer)__attribute__((visibility("default")));
}
extern "C"
{
  void glEnableVertexAttribArrayARB(::GLuint index)__attribute__((visibility("default")));
}
extern "C"
{
  void glDisableVertexAttribArrayARB(::GLuint index)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramStringARB(::GLenum target, ::GLenum format, ::GLsizei len, const ::GLvoid *string)__attribute__((visibility("default")));
}
extern "C"
{
  void glBindProgramARB(::GLenum target, ::GLuint program)__attribute__((visibility("default")));
}
extern "C"
{
  void glDeleteProgramsARB(::GLsizei n, const ::GLuint *programs)__attribute__((visibility("default")));
}
extern "C"
{
  void glGenProgramsARB(::GLsizei n, ::GLuint *programs)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramEnvParameter4dARB(::GLenum target, ::GLuint index, ::GLdouble x, ::GLdouble y, ::GLdouble z, ::GLdouble w)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramEnvParameter4dvARB(::GLenum target, ::GLuint index, const ::GLdouble *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramEnvParameter4fARB(::GLenum target, ::GLuint index, ::GLfloat x, ::GLfloat y, ::GLfloat z, ::GLfloat w)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramEnvParameter4fvARB(::GLenum target, ::GLuint index, const ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramLocalParameter4dARB(::GLenum target, ::GLuint index, ::GLdouble x, ::GLdouble y, ::GLdouble z, ::GLdouble w)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramLocalParameter4dvARB(::GLenum target, ::GLuint index, const ::GLdouble *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramLocalParameter4fARB(::GLenum target, ::GLuint index, ::GLfloat x, ::GLfloat y, ::GLfloat z, ::GLfloat w)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramLocalParameter4fvARB(::GLenum target, ::GLuint index, const ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetProgramEnvParameterdvARB(::GLenum target, ::GLuint index, ::GLdouble *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetProgramEnvParameterfvARB(::GLenum target, ::GLuint index, ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetProgramLocalParameterdvARB(::GLenum target, ::GLuint index, ::GLdouble *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetProgramLocalParameterfvARB(::GLenum target, ::GLuint index, ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetProgramivARB(::GLenum target, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetProgramStringARB(::GLenum target, ::GLenum pname, ::GLvoid *string)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetVertexAttribdvARB(::GLuint index, ::GLenum pname, ::GLdouble *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetVertexAttribfvARB(::GLuint index, ::GLenum pname, ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetVertexAttribivARB(::GLuint index, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetVertexAttribPointervARB(::GLuint index, ::GLenum pname, ::GLvoid **pointer)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLboolean glIsProgramARB(::GLuint program)__attribute__((visibility("default")));
}
typedef void (*PFNGLVERTEXATTRIB1DARBPROC)(::GLuint, ::GLdouble);
typedef void (*PFNGLVERTEXATTRIB1DVARBPROC)(::GLuint, const ::GLdouble *);
typedef void (*PFNGLVERTEXATTRIB1FARBPROC)(::GLuint, ::GLfloat);
typedef void (*PFNGLVERTEXATTRIB1FVARBPROC)(::GLuint, const ::GLfloat *);
typedef void (*PFNGLVERTEXATTRIB1SARBPROC)(::GLuint, ::GLshort);
typedef void (*PFNGLVERTEXATTRIB1SVARBPROC)(::GLuint, const ::GLshort *);
typedef void (*PFNGLVERTEXATTRIB2DARBPROC)(::GLuint, ::GLdouble, ::GLdouble);
typedef void (*PFNGLVERTEXATTRIB2DVARBPROC)(::GLuint, const ::GLdouble *);
typedef void (*PFNGLVERTEXATTRIB2FARBPROC)(::GLuint, ::GLfloat, ::GLfloat);
typedef void (*PFNGLVERTEXATTRIB2FVARBPROC)(::GLuint, const ::GLfloat *);
typedef void (*PFNGLVERTEXATTRIB2SARBPROC)(::GLuint, ::GLshort, ::GLshort);
typedef void (*PFNGLVERTEXATTRIB2SVARBPROC)(::GLuint, const ::GLshort *);
typedef void (*PFNGLVERTEXATTRIB3DARBPROC)(::GLuint, ::GLdouble, ::GLdouble, ::GLdouble);
typedef void (*PFNGLVERTEXATTRIB3DVARBPROC)(::GLuint, const ::GLdouble *);
typedef void (*PFNGLVERTEXATTRIB3FARBPROC)(::GLuint, ::GLfloat, ::GLfloat, ::GLfloat);
typedef void (*PFNGLVERTEXATTRIB3FVARBPROC)(::GLuint, const ::GLfloat *);
typedef void (*PFNGLVERTEXATTRIB3SARBPROC)(::GLuint, ::GLshort, ::GLshort, ::GLshort);
typedef void (*PFNGLVERTEXATTRIB3SVARBPROC)(::GLuint, const ::GLshort *);
typedef void (*PFNGLVERTEXATTRIB4NBVARBPROC)(::GLuint, const ::GLbyte *);
typedef void (*PFNGLVERTEXATTRIB4NIVARBPROC)(::GLuint, const ::GLint *);
typedef void (*PFNGLVERTEXATTRIB4NSVARBPROC)(::GLuint, const ::GLshort *);
typedef void (*PFNGLVERTEXATTRIB4NUBARBPROC)(::GLuint, ::GLubyte, ::GLubyte, ::GLubyte, ::GLubyte);
typedef void (*PFNGLVERTEXATTRIB4NUBVARBPROC)(::GLuint, const ::GLubyte *);
typedef void (*PFNGLVERTEXATTRIB4NUIVARBPROC)(::GLuint, const ::GLuint *);
typedef void (*PFNGLVERTEXATTRIB4NUSVARBPROC)(::GLuint, const ::GLushort *);
typedef void (*PFNGLVERTEXATTRIB4BVARBPROC)(::GLuint, const ::GLbyte *);
typedef void (*PFNGLVERTEXATTRIB4DARBPROC)(::GLuint, ::GLdouble, ::GLdouble, ::GLdouble, ::GLdouble);
typedef void (*PFNGLVERTEXATTRIB4DVARBPROC)(::GLuint, const ::GLdouble *);
typedef void (*PFNGLVERTEXATTRIB4FARBPROC)(::GLuint, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat);
typedef void (*PFNGLVERTEXATTRIB4FVARBPROC)(::GLuint, const ::GLfloat *);
typedef void (*PFNGLVERTEXATTRIB4IVARBPROC)(::GLuint, const ::GLint *);
typedef void (*PFNGLVERTEXATTRIB4SARBPROC)(::GLuint, ::GLshort, ::GLshort, ::GLshort, ::GLshort);
typedef void (*PFNGLVERTEXATTRIB4SVARBPROC)(::GLuint, const ::GLshort *);
typedef void (*PFNGLVERTEXATTRIB4UBVARBPROC)(::GLuint, const ::GLubyte *);
typedef void (*PFNGLVERTEXATTRIB4UIVARBPROC)(::GLuint, const ::GLuint *);
typedef void (*PFNGLVERTEXATTRIB4USVARBPROC)(::GLuint, const ::GLushort *);
typedef void (*PFNGLVERTEXATTRIBPOINTERARBPROC)(::GLuint, ::GLint, ::GLenum, ::GLboolean, ::GLsizei, const ::GLvoid *);
typedef void (*PFNGLENABLEVERTEXATTRIBARRAYARBPROC)(::GLuint);
typedef void (*PFNGLDISABLEVERTEXATTRIBARRAYARBPROC)(::GLuint);
typedef void (*PFNGLPROGRAMSTRINGARBPROC)(::GLenum, ::GLenum, ::GLsizei, const ::GLvoid *);
typedef void (*PFNGLBINDPROGRAMARBPROC)(::GLenum, ::GLuint);
typedef void (*PFNGLDELETEPROGRAMSARBPROC)(::GLsizei, const ::GLuint *);
typedef void (*PFNGLGENPROGRAMSARBPROC)(::GLsizei, ::GLuint *);
typedef void (*PFNGLPROGRAMENVPARAMETER4DARBPROC)(::GLenum, ::GLuint, ::GLdouble, ::GLdouble, ::GLdouble, ::GLdouble);
typedef void (*PFNGLPROGRAMENVPARAMETER4DVARBPROC)(::GLenum, ::GLuint, const ::GLdouble *);
typedef void (*PFNGLPROGRAMENVPARAMETER4FARBPROC)(::GLenum, ::GLuint, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat);
typedef void (*PFNGLPROGRAMENVPARAMETER4FVARBPROC)(::GLenum, ::GLuint, const ::GLfloat *);
typedef void (*PFNGLPROGRAMLOCALPARAMETER4DARBPROC)(::GLenum, ::GLuint, ::GLdouble, ::GLdouble, ::GLdouble, ::GLdouble);
typedef void (*PFNGLPROGRAMLOCALPARAMETER4DVARBPROC)(::GLenum, ::GLuint, const ::GLdouble *);
typedef void (*PFNGLPROGRAMLOCALPARAMETER4FARBPROC)(::GLenum, ::GLuint, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat);
typedef void (*PFNGLPROGRAMLOCALPARAMETER4FVARBPROC)(::GLenum, ::GLuint, const ::GLfloat *);
typedef void (*PFNGLGETPROGRAMENVPARAMETERDVARBPROC)(::GLenum, ::GLuint, ::GLdouble *);
typedef void (*PFNGLGETPROGRAMENVPARAMETERFVARBPROC)(::GLenum, ::GLuint, ::GLfloat *);
typedef void (*PFNGLGETPROGRAMLOCALPARAMETERDVARBPROC)(::GLenum, ::GLuint, ::GLdouble *);
typedef void (*PFNGLGETPROGRAMLOCALPARAMETERFVARBPROC)(::GLenum, ::GLuint, ::GLfloat *);
typedef void (*PFNGLGETPROGRAMIVARBPROC)(::GLenum, ::GLenum, ::GLint *);
typedef void (*PFNGLGETPROGRAMSTRINGARBPROC)(::GLenum, ::GLenum, ::GLvoid *);
typedef void (*PFNGLGETVERTEXATTRIBDVARBPROC)(::GLuint, ::GLenum, ::GLdouble *);
typedef void (*PFNGLGETVERTEXATTRIBFVARBPROC)(::GLuint, ::GLenum, ::GLfloat *);
typedef void (*PFNGLGETVERTEXATTRIBIVARBPROC)(::GLuint, ::GLenum, ::GLint *);
typedef void (*PFNGLGETVERTEXATTRIBPOINTERVARBPROC)(::GLuint, ::GLenum, ::GLvoid **);
typedef ::GLboolean (*PFNGLISPROGRAMARBPROC)(::GLuint);
extern "C"
{
  void glBindBufferARB(::GLenum target, ::GLuint buffer)__attribute__((visibility("default")));
}
extern "C"
{
  void glDeleteBuffersARB(::GLsizei n, const ::GLuint *buffers)__attribute__((visibility("default")));
}
extern "C"
{
  void glGenBuffersARB(::GLsizei n, ::GLuint *buffers)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLboolean glIsBufferARB(::GLuint buffer)__attribute__((visibility("default")));
}
extern "C"
{
  void glBufferDataARB(::GLenum target, ::GLsizeiptrARB size, const ::GLvoid *data, ::GLenum usage)__attribute__((visibility("default")));
}
extern "C"
{
  void glBufferSubDataARB(::GLenum target, ::GLintptrARB offset, ::GLsizeiptrARB size, const ::GLvoid *data)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetBufferSubDataARB(::GLenum target, ::GLintptrARB offset, ::GLsizeiptrARB size, ::GLvoid *data)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLvoid *glMapBufferARB(::GLenum target, ::GLenum access)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLboolean glUnmapBufferARB(::GLenum target)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetBufferParameterivARB(::GLenum target, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetBufferPointervARB(::GLenum target, ::GLenum pname, ::GLvoid **params)__attribute__((visibility("default")));
}
typedef void (*PFNGLBINDBUFFERARBPROC)(::GLenum, ::GLuint);
typedef void (*PFNGLDELETEBUFFERSARBPROC)(::GLsizei, const ::GLuint *);
typedef void (*PFNGLGENBUFFERSARBPROC)(::GLsizei, ::GLuint *);
typedef ::GLboolean (*PFNGLISBUFFERARBPROC)(::GLuint);
typedef void (*PFNGLBUFFERDATAARBPROC)(::GLenum, ::GLsizeiptrARB, const ::GLvoid *, ::GLenum);
typedef void (*PFNGLBUFFERSUBDATAARBPROC)(::GLenum, ::GLintptrARB, ::GLsizeiptrARB, const ::GLvoid *);
typedef void (*PFNGLGETBUFFERSUBDATAARBPROC)(::GLenum, ::GLintptrARB, ::GLsizeiptrARB, ::GLvoid *);
typedef ::GLvoid *(*PFNGLMAPBUFFERARBPROC)(::GLenum, ::GLenum);
typedef ::GLboolean (*PFNGLUNMAPBUFFERARBPROC)(::GLenum);
typedef void (*PFNGLGETBUFFERPARAMETERIVARBPROC)(::GLenum, ::GLenum, ::GLint *);
typedef void (*PFNGLGETBUFFERPOINTERVARBPROC)(::GLenum, ::GLenum, ::GLvoid **);
extern "C"
{
  void glGenQueriesARB(::GLsizei n, ::GLuint *ids)__attribute__((visibility("default")));
}
extern "C"
{
  void glDeleteQueriesARB(::GLsizei n, const ::GLuint *ids)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLboolean glIsQueryARB(::GLuint id)__attribute__((visibility("default")));
}
extern "C"
{
  void glBeginQueryARB(::GLenum target, ::GLuint id)__attribute__((visibility("default")));
}
extern "C"
{
  void glEndQueryARB(::GLenum target)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetQueryivARB(::GLenum target, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetQueryObjectivARB(::GLuint id, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetQueryObjectuivARB(::GLuint id, ::GLenum pname, ::GLuint *params)__attribute__((visibility("default")));
}
typedef void (*PFNGLGENQUERIESARBPROC)(::GLsizei, ::GLuint *);
typedef void (*PFNGLDELETEQUERIESARBPROC)(::GLsizei, const ::GLuint *);
typedef ::GLboolean (*PFNGLISQUERYARBPROC)(::GLuint);
typedef void (*PFNGLBEGINQUERYARBPROC)(::GLenum, ::GLuint);
typedef void (*PFNGLENDQUERYARBPROC)(::GLenum);
typedef void (*PFNGLGETQUERYIVARBPROC)(::GLenum, ::GLenum, ::GLint *);
typedef void (*PFNGLGETQUERYOBJECTIVARBPROC)(::GLuint, ::GLenum, ::GLint *);
typedef void (*PFNGLGETQUERYOBJECTUIVARBPROC)(::GLuint, ::GLenum, ::GLuint *);
extern "C"
{
  void glDeleteObjectARB(::GLhandleARB obj)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLhandleARB glGetHandleARB(::GLenum pname)__attribute__((visibility("default")));
}
extern "C"
{
  void glDetachObjectARB(::GLhandleARB containerObj, ::GLhandleARB attachedObj)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLhandleARB glCreateShaderObjectARB(::GLenum shaderType)__attribute__((visibility("default")));
}
extern "C"
{
  void glShaderSourceARB(::GLhandleARB shaderObj, ::GLsizei count, const ::GLcharARB **string, const ::GLint *length)__attribute__((visibility("default")));
}
extern "C"
{
  void glCompileShaderARB(::GLhandleARB shaderObj)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLhandleARB glCreateProgramObjectARB()__attribute__((visibility("default")));
}
extern "C"
{
  void glAttachObjectARB(::GLhandleARB containerObj, ::GLhandleARB obj)__attribute__((visibility("default")));
}
extern "C"
{
  void glLinkProgramARB(::GLhandleARB programObj)__attribute__((visibility("default")));
}
extern "C"
{
  void glUseProgramObjectARB(::GLhandleARB programObj)__attribute__((visibility("default")));
}
extern "C"
{
  void glValidateProgramARB(::GLhandleARB programObj)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform1fARB(::GLint location, ::GLfloat v0)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform2fARB(::GLint location, ::GLfloat v0, ::GLfloat v1)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform3fARB(::GLint location, ::GLfloat v0, ::GLfloat v1, ::GLfloat v2)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform4fARB(::GLint location, ::GLfloat v0, ::GLfloat v1, ::GLfloat v2, ::GLfloat v3)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform1iARB(::GLint location, ::GLint v0)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform2iARB(::GLint location, ::GLint v0, ::GLint v1)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform3iARB(::GLint location, ::GLint v0, ::GLint v1, ::GLint v2)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform4iARB(::GLint location, ::GLint v0, ::GLint v1, ::GLint v2, ::GLint v3)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform1fvARB(::GLint location, ::GLsizei count, const ::GLfloat *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform2fvARB(::GLint location, ::GLsizei count, const ::GLfloat *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform3fvARB(::GLint location, ::GLsizei count, const ::GLfloat *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform4fvARB(::GLint location, ::GLsizei count, const ::GLfloat *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform1ivARB(::GLint location, ::GLsizei count, const ::GLint *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform2ivARB(::GLint location, ::GLsizei count, const ::GLint *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform3ivARB(::GLint location, ::GLsizei count, const ::GLint *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform4ivARB(::GLint location, ::GLsizei count, const ::GLint *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniformMatrix2fvARB(::GLint location, ::GLsizei count, ::GLboolean transpose, const ::GLfloat *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniformMatrix3fvARB(::GLint location, ::GLsizei count, ::GLboolean transpose, const ::GLfloat *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniformMatrix4fvARB(::GLint location, ::GLsizei count, ::GLboolean transpose, const ::GLfloat *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetObjectParameterfvARB(::GLhandleARB obj, ::GLenum pname, ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetObjectParameterivARB(::GLhandleARB obj, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetInfoLogARB(::GLhandleARB obj, ::GLsizei maxLength, ::GLsizei *length, ::GLcharARB *infoLog)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetAttachedObjectsARB(::GLhandleARB containerObj, ::GLsizei maxCount, ::GLsizei *count, ::GLhandleARB *obj)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLint glGetUniformLocationARB(::GLhandleARB programObj, const ::GLcharARB *name)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetActiveUniformARB(::GLhandleARB programObj, ::GLuint index, ::GLsizei maxLength, ::GLsizei *length, ::GLint *size, ::GLenum *type, ::GLcharARB *name)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetUniformfvARB(::GLhandleARB programObj, ::GLint location, ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetUniformivARB(::GLhandleARB programObj, ::GLint location, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetShaderSourceARB(::GLhandleARB obj, ::GLsizei maxLength, ::GLsizei *length, ::GLcharARB *source)__attribute__((visibility("default")));
}
typedef void (*PFNGLDELETEOBJECTARBPROC)(::GLhandleARB);
typedef ::GLhandleARB (*PFNGLGETHANDLEARBPROC)(::GLenum);
typedef void (*PFNGLDETACHOBJECTARBPROC)(::GLhandleARB, ::GLhandleARB);
typedef ::GLhandleARB (*PFNGLCREATESHADEROBJECTARBPROC)(::GLenum);
typedef void (*PFNGLSHADERSOURCEARBPROC)(::GLhandleARB, ::GLsizei, const ::GLcharARB **, const ::GLint *);
typedef void (*PFNGLCOMPILESHADERARBPROC)(::GLhandleARB);
typedef ::GLhandleARB (*PFNGLCREATEPROGRAMOBJECTARBPROC)();
typedef void (*PFNGLATTACHOBJECTARBPROC)(::GLhandleARB, ::GLhandleARB);
typedef void (*PFNGLLINKPROGRAMARBPROC)(::GLhandleARB);
typedef void (*PFNGLUSEPROGRAMOBJECTARBPROC)(::GLhandleARB);
typedef void (*PFNGLVALIDATEPROGRAMARBPROC)(::GLhandleARB);
typedef void (*PFNGLUNIFORM1FARBPROC)(::GLint, ::GLfloat);
typedef void (*PFNGLUNIFORM2FARBPROC)(::GLint, ::GLfloat, ::GLfloat);
typedef void (*PFNGLUNIFORM3FARBPROC)(::GLint, ::GLfloat, ::GLfloat, ::GLfloat);
typedef void (*PFNGLUNIFORM4FARBPROC)(::GLint, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat);
typedef void (*PFNGLUNIFORM1IARBPROC)(::GLint, ::GLint);
typedef void (*PFNGLUNIFORM2IARBPROC)(::GLint, ::GLint, ::GLint);
typedef void (*PFNGLUNIFORM3IARBPROC)(::GLint, ::GLint, ::GLint, ::GLint);
typedef void (*PFNGLUNIFORM4IARBPROC)(::GLint, ::GLint, ::GLint, ::GLint, ::GLint);
typedef void (*PFNGLUNIFORM1FVARBPROC)(::GLint, ::GLsizei, const ::GLfloat *);
typedef void (*PFNGLUNIFORM2FVARBPROC)(::GLint, ::GLsizei, const ::GLfloat *);
typedef void (*PFNGLUNIFORM3FVARBPROC)(::GLint, ::GLsizei, const ::GLfloat *);
typedef void (*PFNGLUNIFORM4FVARBPROC)(::GLint, ::GLsizei, const ::GLfloat *);
typedef void (*PFNGLUNIFORM1IVARBPROC)(::GLint, ::GLsizei, const ::GLint *);
typedef void (*PFNGLUNIFORM2IVARBPROC)(::GLint, ::GLsizei, const ::GLint *);
typedef void (*PFNGLUNIFORM3IVARBPROC)(::GLint, ::GLsizei, const ::GLint *);
typedef void (*PFNGLUNIFORM4IVARBPROC)(::GLint, ::GLsizei, const ::GLint *);
typedef void (*PFNGLUNIFORMMATRIX2FVARBPROC)(::GLint, ::GLsizei, ::GLboolean, const ::GLfloat *);
typedef void (*PFNGLUNIFORMMATRIX3FVARBPROC)(::GLint, ::GLsizei, ::GLboolean, const ::GLfloat *);
typedef void (*PFNGLUNIFORMMATRIX4FVARBPROC)(::GLint, ::GLsizei, ::GLboolean, const ::GLfloat *);
typedef void (*PFNGLGETOBJECTPARAMETERFVARBPROC)(::GLhandleARB, ::GLenum, ::GLfloat *);
typedef void (*PFNGLGETOBJECTPARAMETERIVARBPROC)(::GLhandleARB, ::GLenum, ::GLint *);
typedef void (*PFNGLGETINFOLOGARBPROC)(::GLhandleARB, ::GLsizei, ::GLsizei *, ::GLcharARB *);
typedef void (*PFNGLGETATTACHEDOBJECTSARBPROC)(::GLhandleARB, ::GLsizei, ::GLsizei *, ::GLhandleARB *);
typedef ::GLint (*PFNGLGETUNIFORMLOCATIONARBPROC)(::GLhandleARB, const ::GLcharARB *);
typedef void (*PFNGLGETACTIVEUNIFORMARBPROC)(::GLhandleARB, ::GLuint, ::GLsizei, ::GLsizei *, ::GLint *, ::GLenum *, ::GLcharARB *);
typedef void (*PFNGLGETUNIFORMFVARBPROC)(::GLhandleARB, ::GLint, ::GLfloat *);
typedef void (*PFNGLGETUNIFORMIVARBPROC)(::GLhandleARB, ::GLint, ::GLint *);
typedef void (*PFNGLGETSHADERSOURCEARBPROC)(::GLhandleARB, ::GLsizei, ::GLsizei *, ::GLcharARB *);
extern "C"
{
  void glBindAttribLocationARB(::GLhandleARB programObj, ::GLuint index, const ::GLcharARB *name)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetActiveAttribARB(::GLhandleARB programObj, ::GLuint index, ::GLsizei maxLength, ::GLsizei *length, ::GLint *size, ::GLenum *type, ::GLcharARB *name)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLint glGetAttribLocationARB(::GLhandleARB programObj, const ::GLcharARB *name)__attribute__((visibility("default")));
}
typedef void (*PFNGLBINDATTRIBLOCATIONARBPROC)(::GLhandleARB, ::GLuint, const ::GLcharARB *);
typedef void (*PFNGLGETACTIVEATTRIBARBPROC)(::GLhandleARB, ::GLuint, ::GLsizei, ::GLsizei *, ::GLint *, ::GLenum *, ::GLcharARB *);
typedef ::GLint (*PFNGLGETATTRIBLOCATIONARBPROC)(::GLhandleARB, const ::GLcharARB *);
extern "C"
{
  void glDrawBuffersARB(::GLsizei n, const ::GLenum *bufs)__attribute__((visibility("default")));
}
typedef void (*PFNGLDRAWBUFFERSARBPROC)(::GLsizei, const ::GLenum *);
extern "C"
{
  void glClampColorARB(::GLenum target, ::GLenum clamp)__attribute__((visibility("default")));
}
typedef void (*PFNGLCLAMPCOLORARBPROC)(::GLenum, ::GLenum);
extern "C"
{
  void glDrawArraysInstancedARB(::GLenum mode, ::GLint first, ::GLsizei count, ::GLsizei primcount)__attribute__((visibility("default")));
}
extern "C"
{
  void glDrawElementsInstancedARB(::GLenum mode, ::GLsizei count, ::GLenum type, const ::GLvoid *indices, ::GLsizei primcount)__attribute__((visibility("default")));
}
typedef void (*PFNGLDRAWARRAYSINSTANCEDARBPROC)(::GLenum, ::GLint, ::GLsizei, ::GLsizei);
typedef void (*PFNGLDRAWELEMENTSINSTANCEDARBPROC)(::GLenum, ::GLsizei, ::GLenum, const ::GLvoid *, ::GLsizei);
extern "C"
{
  ::GLboolean glIsRenderbuffer(::GLuint renderbuffer)__attribute__((visibility("default")));
}
extern "C"
{
  void glBindRenderbuffer(::GLenum target, ::GLuint renderbuffer)__attribute__((visibility("default")));
}
extern "C"
{
  void glDeleteRenderbuffers(::GLsizei n, const ::GLuint *renderbuffers)__attribute__((visibility("default")));
}
extern "C"
{
  void glGenRenderbuffers(::GLsizei n, ::GLuint *renderbuffers)__attribute__((visibility("default")));
}
extern "C"
{
  void glRenderbufferStorage(::GLenum target, ::GLenum internalformat, ::GLsizei width, ::GLsizei height)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetRenderbufferParameteriv(::GLenum target, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLboolean glIsFramebuffer(::GLuint framebuffer)__attribute__((visibility("default")));
}
extern "C"
{
  void glBindFramebuffer(::GLenum target, ::GLuint framebuffer)__attribute__((visibility("default")));
}
extern "C"
{
  void glDeleteFramebuffers(::GLsizei n, const ::GLuint *framebuffers)__attribute__((visibility("default")));
}
extern "C"
{
  void glGenFramebuffers(::GLsizei n, ::GLuint *framebuffers)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLenum glCheckFramebufferStatus(::GLenum target)__attribute__((visibility("default")));
}
extern "C"
{
  void glFramebufferTexture1D(::GLenum target, ::GLenum attachment, ::GLenum textarget, ::GLuint texture, ::GLint level)__attribute__((visibility("default")));
}
extern "C"
{
  void glFramebufferTexture2D(::GLenum target, ::GLenum attachment, ::GLenum textarget, ::GLuint texture, ::GLint level)__attribute__((visibility("default")));
}
extern "C"
{
  void glFramebufferTexture3D(::GLenum target, ::GLenum attachment, ::GLenum textarget, ::GLuint texture, ::GLint level, ::GLint zoffset)__attribute__((visibility("default")));
}
extern "C"
{
  void glFramebufferRenderbuffer(::GLenum target, ::GLenum attachment, ::GLenum renderbuffertarget, ::GLuint renderbuffer)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetFramebufferAttachmentParameteriv(::GLenum target, ::GLenum attachment, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGenerateMipmap(::GLenum target)__attribute__((visibility("default")));
}
extern "C"
{
  void glBlitFramebuffer(::GLint srcX0, ::GLint srcY0, ::GLint srcX1, ::GLint srcY1, ::GLint dstX0, ::GLint dstY0, ::GLint dstX1, ::GLint dstY1, ::GLbitfield mask, ::GLenum filter)__attribute__((visibility("default")));
}
extern "C"
{
  void glRenderbufferStorageMultisample(::GLenum target, ::GLsizei samples, ::GLenum internalformat, ::GLsizei width, ::GLsizei height)__attribute__((visibility("default")));
}
extern "C"
{
  void glFramebufferTextureLayer(::GLenum target, ::GLenum attachment, ::GLuint texture, ::GLint level, ::GLint layer)__attribute__((visibility("default")));
}
typedef ::GLboolean (*PFNGLISRENDERBUFFERPROC)(::GLuint);
typedef void (*PFNGLBINDRENDERBUFFERPROC)(::GLenum, ::GLuint);
typedef void (*PFNGLDELETERENDERBUFFERSPROC)(::GLsizei, const ::GLuint *);
typedef void (*PFNGLGENRENDERBUFFERSPROC)(::GLsizei, ::GLuint *);
typedef void (*PFNGLRENDERBUFFERSTORAGEPROC)(::GLenum, ::GLenum, ::GLsizei, ::GLsizei);
typedef void (*PFNGLGETRENDERBUFFERPARAMETERIVPROC)(::GLenum, ::GLenum, ::GLint *);
typedef ::GLboolean (*PFNGLISFRAMEBUFFERPROC)(::GLuint);
typedef void (*PFNGLBINDFRAMEBUFFERPROC)(::GLenum, ::GLuint);
typedef void (*PFNGLDELETEFRAMEBUFFERSPROC)(::GLsizei, const ::GLuint *);
typedef void (*PFNGLGENFRAMEBUFFERSPROC)(::GLsizei, ::GLuint *);
typedef ::GLenum (*PFNGLCHECKFRAMEBUFFERSTATUSPROC)(::GLenum);
typedef void (*PFNGLFRAMEBUFFERTEXTURE1DPROC)(::GLenum, ::GLenum, ::GLenum, ::GLuint, ::GLint);
typedef void (*PFNGLFRAMEBUFFERTEXTURE2DPROC)(::GLenum, ::GLenum, ::GLenum, ::GLuint, ::GLint);
typedef void (*PFNGLFRAMEBUFFERTEXTURE3DPROC)(::GLenum, ::GLenum, ::GLenum, ::GLuint, ::GLint, ::GLint);
typedef void (*PFNGLFRAMEBUFFERRENDERBUFFERPROC)(::GLenum, ::GLenum, ::GLenum, ::GLuint);
typedef void (*PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC)(::GLenum, ::GLenum, ::GLenum, ::GLint *);
typedef void (*PFNGLGENERATEMIPMAPPROC)(::GLenum);
typedef void (*PFNGLBLITFRAMEBUFFERPROC)(::GLint, ::GLint, ::GLint, ::GLint, ::GLint, ::GLint, ::GLint, ::GLint, ::GLbitfield, ::GLenum);
typedef void (*PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC)(::GLenum, ::GLsizei, ::GLenum, ::GLsizei, ::GLsizei);
typedef void (*PFNGLFRAMEBUFFERTEXTURELAYERPROC)(::GLenum, ::GLenum, ::GLuint, ::GLint, ::GLint);
extern "C"
{
  void glProgramParameteriARB(::GLuint program, ::GLenum pname, ::GLint value)__attribute__((visibility("default")));
}
extern "C"
{
  void glFramebufferTextureARB(::GLenum target, ::GLenum attachment, ::GLuint texture, ::GLint level)__attribute__((visibility("default")));
}
extern "C"
{
  void glFramebufferTextureLayerARB(::GLenum target, ::GLenum attachment, ::GLuint texture, ::GLint level, ::GLint layer)__attribute__((visibility("default")));
}
extern "C"
{
  void glFramebufferTextureFaceARB(::GLenum target, ::GLenum attachment, ::GLuint texture, ::GLint level, ::GLenum face)__attribute__((visibility("default")));
}
typedef void (*PFNGLPROGRAMPARAMETERIARBPROC)(::GLuint, ::GLenum, ::GLint);
typedef void (*PFNGLFRAMEBUFFERTEXTUREARBPROC)(::GLenum, ::GLenum, ::GLuint, ::GLint);
typedef void (*PFNGLFRAMEBUFFERTEXTURELAYERARBPROC)(::GLenum, ::GLenum, ::GLuint, ::GLint, ::GLint);
typedef void (*PFNGLFRAMEBUFFERTEXTUREFACEARBPROC)(::GLenum, ::GLenum, ::GLuint, ::GLint, ::GLenum);
extern "C"
{
  void glVertexAttribDivisorARB(::GLuint index, ::GLuint divisor)__attribute__((visibility("default")));
}
typedef void (*PFNGLVERTEXATTRIBDIVISORARBPROC)(::GLuint, ::GLuint);
extern "C"
{
  ::GLvoid *glMapBufferRange(::GLenum target, ::GLintptr offset, ::GLsizeiptr length, ::GLbitfield access)__attribute__((visibility("default")));
}
extern "C"
{
  void glFlushMappedBufferRange(::GLenum target, ::GLintptr offset, ::GLsizeiptr length)__attribute__((visibility("default")));
}
typedef ::GLvoid *(*PFNGLMAPBUFFERRANGEPROC)(::GLenum, ::GLintptr, ::GLsizeiptr, ::GLbitfield);
typedef void (*PFNGLFLUSHMAPPEDBUFFERRANGEPROC)(::GLenum, ::GLintptr, ::GLsizeiptr);
extern "C"
{
  void glTexBufferARB(::GLenum target, ::GLenum internalformat, ::GLuint buffer)__attribute__((visibility("default")));
}
typedef void (*PFNGLTEXBUFFERARBPROC)(::GLenum, ::GLenum, ::GLuint);
extern "C"
{
  void glBindVertexArray(::GLuint array)__attribute__((visibility("default")));
}
extern "C"
{
  void glDeleteVertexArrays(::GLsizei n, const ::GLuint *arrays)__attribute__((visibility("default")));
}
extern "C"
{
  void glGenVertexArrays(::GLsizei n, ::GLuint *arrays)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLboolean glIsVertexArray(::GLuint array)__attribute__((visibility("default")));
}
typedef void (*PFNGLBINDVERTEXARRAYPROC)(::GLuint);
typedef void (*PFNGLDELETEVERTEXARRAYSPROC)(::GLsizei, const ::GLuint *);
typedef void (*PFNGLGENVERTEXARRAYSPROC)(::GLsizei, ::GLuint *);
typedef ::GLboolean (*PFNGLISVERTEXARRAYPROC)(::GLuint);
extern "C"
{
  void glGetUniformIndices(::GLuint program, ::GLsizei uniformCount, const ::GLchar **uniformNames, ::GLuint *uniformIndices)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetActiveUniformsiv(::GLuint program, ::GLsizei uniformCount, const ::GLuint *uniformIndices, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetActiveUniformName(::GLuint program, ::GLuint uniformIndex, ::GLsizei bufSize, ::GLsizei *length, ::GLchar *uniformName)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLuint glGetUniformBlockIndex(::GLuint program, const ::GLchar *uniformBlockName)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetActiveUniformBlockiv(::GLuint program, ::GLuint uniformBlockIndex, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetActiveUniformBlockName(::GLuint program, ::GLuint uniformBlockIndex, ::GLsizei bufSize, ::GLsizei *length, ::GLchar *uniformBlockName)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniformBlockBinding(::GLuint program, ::GLuint uniformBlockIndex, ::GLuint uniformBlockBinding)__attribute__((visibility("default")));
}
typedef void (*PFNGLGETUNIFORMINDICESPROC)(::GLuint, ::GLsizei, const ::GLchar **, ::GLuint *);
typedef void (*PFNGLGETACTIVEUNIFORMSIVPROC)(::GLuint, ::GLsizei, const ::GLuint *, ::GLenum, ::GLint *);
typedef void (*PFNGLGETACTIVEUNIFORMNAMEPROC)(::GLuint, ::GLuint, ::GLsizei, ::GLsizei *, ::GLchar *);
typedef ::GLuint (*PFNGLGETUNIFORMBLOCKINDEXPROC)(::GLuint, const ::GLchar *);
typedef void (*PFNGLGETACTIVEUNIFORMBLOCKIVPROC)(::GLuint, ::GLuint, ::GLenum, ::GLint *);
typedef void (*PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC)(::GLuint, ::GLuint, ::GLsizei, ::GLsizei *, ::GLchar *);
typedef void (*PFNGLUNIFORMBLOCKBINDINGPROC)(::GLuint, ::GLuint, ::GLuint);
extern "C"
{
  void glCopyBufferSubData(::GLenum readTarget, ::GLenum writeTarget, ::GLintptr readOffset, ::GLintptr writeOffset, ::GLsizeiptr size)__attribute__((visibility("default")));
}
typedef void (*PFNGLCOPYBUFFERSUBDATAPROC)(::GLenum, ::GLenum, ::GLintptr, ::GLintptr, ::GLsizeiptr);
extern "C"
{
  void glDrawElementsBaseVertex(::GLenum mode, ::GLsizei count, ::GLenum type, const ::GLvoid *indices, ::GLint basevertex)__attribute__((visibility("default")));
}
extern "C"
{
  void glDrawRangeElementsBaseVertex(::GLenum mode, ::GLuint start, ::GLuint end, ::GLsizei count, ::GLenum type, const ::GLvoid *indices, ::GLint basevertex)__attribute__((visibility("default")));
}
extern "C"
{
  void glDrawElementsInstancedBaseVertex(::GLenum mode, ::GLsizei count, ::GLenum type, const ::GLvoid *indices, ::GLsizei primcount, ::GLint basevertex)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiDrawElementsBaseVertex(::GLenum mode, const ::GLsizei *count, ::GLenum type, const ::GLvoid **indices, ::GLsizei primcount, const ::GLint *basevertex)__attribute__((visibility("default")));
}
typedef void (*PFNGLDRAWELEMENTSBASEVERTEXPROC)(::GLenum, ::GLsizei, ::GLenum, const ::GLvoid *, ::GLint);
typedef void (*PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC)(::GLenum, ::GLuint, ::GLuint, ::GLsizei, ::GLenum, const ::GLvoid *, ::GLint);
typedef void (*PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC)(::GLenum, ::GLsizei, ::GLenum, const ::GLvoid *, ::GLsizei, ::GLint);
typedef void (*PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC)(::GLenum, const ::GLsizei *, ::GLenum, const ::GLvoid **, ::GLsizei, const ::GLint *);
extern "C"
{
  void glProvokingVertex(::GLenum mode)__attribute__((visibility("default")));
}
typedef void (*PFNGLPROVOKINGVERTEXPROC)(::GLenum);
extern "C"
{
  ::GLsync glFenceSync(::GLenum condition, ::GLbitfield flags)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLboolean glIsSync(::GLsync sync)__attribute__((visibility("default")));
}
extern "C"
{
  void glDeleteSync(::GLsync sync)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLenum glClientWaitSync(::GLsync sync, ::GLbitfield flags, ::GLuint64 timeout)__attribute__((visibility("default")));
}
extern "C"
{
  void glWaitSync(::GLsync sync, ::GLbitfield flags, ::GLuint64 timeout)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetInteger64v(::GLenum pname, ::GLint64 *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetSynciv(::GLsync sync, ::GLenum pname, ::GLsizei bufSize, ::GLsizei *length, ::GLint *values)__attribute__((visibility("default")));
}
typedef ::GLsync (*PFNGLFENCESYNCPROC)(::GLenum, ::GLbitfield);
typedef ::GLboolean (*PFNGLISSYNCPROC)(::GLsync);
typedef void (*PFNGLDELETESYNCPROC)(::GLsync);
typedef ::GLenum (*PFNGLCLIENTWAITSYNCPROC)(::GLsync, ::GLbitfield, ::GLuint64);
typedef void (*PFNGLWAITSYNCPROC)(::GLsync, ::GLbitfield, ::GLuint64);
typedef void (*PFNGLGETINTEGER64VPROC)(::GLenum, ::GLint64 *);
typedef void (*PFNGLGETSYNCIVPROC)(::GLsync, ::GLenum, ::GLsizei, ::GLsizei *, ::GLint *);
extern "C"
{
  void glTexImage2DMultisample(::GLenum target, ::GLsizei samples, ::GLint internalformat, ::GLsizei width, ::GLsizei height, ::GLboolean fixedsamplelocations)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexImage3DMultisample(::GLenum target, ::GLsizei samples, ::GLint internalformat, ::GLsizei width, ::GLsizei height, ::GLsizei depth, ::GLboolean fixedsamplelocations)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetMultisamplefv(::GLenum pname, ::GLuint index, ::GLfloat *val)__attribute__((visibility("default")));
}
extern "C"
{
  void glSampleMaski(::GLuint index, ::GLbitfield mask)__attribute__((visibility("default")));
}
typedef void (*PFNGLTEXIMAGE2DMULTISAMPLEPROC)(::GLenum, ::GLsizei, ::GLint, ::GLsizei, ::GLsizei, ::GLboolean);
typedef void (*PFNGLTEXIMAGE3DMULTISAMPLEPROC)(::GLenum, ::GLsizei, ::GLint, ::GLsizei, ::GLsizei, ::GLsizei, ::GLboolean);
typedef void (*PFNGLGETMULTISAMPLEFVPROC)(::GLenum, ::GLuint, ::GLfloat *);
typedef void (*PFNGLSAMPLEMASKIPROC)(::GLuint, ::GLbitfield);
extern "C"
{
  void glBlendEquationiARB(::GLuint buf, ::GLenum mode)__attribute__((visibility("default")));
}
extern "C"
{
  void glBlendEquationSeparateiARB(::GLuint buf, ::GLenum modeRGB, ::GLenum modeAlpha)__attribute__((visibility("default")));
}
extern "C"
{
  void glBlendFunciARB(::GLuint buf, ::GLenum src, ::GLenum dst)__attribute__((visibility("default")));
}
extern "C"
{
  void glBlendFuncSeparateiARB(::GLuint buf, ::GLenum srcRGB, ::GLenum dstRGB, ::GLenum srcAlpha, ::GLenum dstAlpha)__attribute__((visibility("default")));
}
typedef void (*PFNGLBLENDEQUATIONIARBPROC)(::GLuint, ::GLenum);
typedef void (*PFNGLBLENDEQUATIONSEPARATEIARBPROC)(::GLuint, ::GLenum, ::GLenum);
typedef void (*PFNGLBLENDFUNCIARBPROC)(::GLuint, ::GLenum, ::GLenum);
typedef void (*PFNGLBLENDFUNCSEPARATEIARBPROC)(::GLuint, ::GLenum, ::GLenum, ::GLenum, ::GLenum);
extern "C"
{
  void glMinSampleShadingARB(::GLclampf value)__attribute__((visibility("default")));
}
typedef void (*PFNGLMINSAMPLESHADINGARBPROC)(::GLclampf);
extern "C"
{
  void glNamedStringARB(::GLenum type, ::GLint namelen, const ::GLchar *name, ::GLint stringlen, const ::GLchar *string)__attribute__((visibility("default")));
}
extern "C"
{
  void glDeleteNamedStringARB(::GLint namelen, const ::GLchar *name)__attribute__((visibility("default")));
}
extern "C"
{
  void glCompileShaderIncludeARB(::GLuint shader, ::GLsizei count, const ::GLchar **path, const ::GLint *length)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLboolean glIsNamedStringARB(::GLint namelen, const ::GLchar *name)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetNamedStringARB(::GLint namelen, const ::GLchar *name, ::GLsizei bufSize, ::GLint *stringlen, ::GLchar *string)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetNamedStringivARB(::GLint namelen, const ::GLchar *name, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
typedef void (*PFNGLNAMEDSTRINGARBPROC)(::GLenum, ::GLint, const ::GLchar *, ::GLint, const ::GLchar *);
typedef void (*PFNGLDELETENAMEDSTRINGARBPROC)(::GLint, const ::GLchar *);
typedef void (*PFNGLCOMPILESHADERINCLUDEARBPROC)(::GLuint, ::GLsizei, const ::GLchar **, const ::GLint *);
typedef ::GLboolean (*PFNGLISNAMEDSTRINGARBPROC)(::GLint, const ::GLchar *);
typedef void (*PFNGLGETNAMEDSTRINGARBPROC)(::GLint, const ::GLchar *, ::GLsizei, ::GLint *, ::GLchar *);
typedef void (*PFNGLGETNAMEDSTRINGIVARBPROC)(::GLint, const ::GLchar *, ::GLenum, ::GLint *);
extern "C"
{
  void glBindFragDataLocationIndexed(::GLuint program, ::GLuint colorNumber, ::GLuint index, const ::GLchar *name)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLint glGetFragDataIndex(::GLuint program, const ::GLchar *name)__attribute__((visibility("default")));
}
typedef void (*PFNGLBINDFRAGDATALOCATIONINDEXEDPROC)(::GLuint, ::GLuint, ::GLuint, const ::GLchar *);
typedef ::GLint (*PFNGLGETFRAGDATAINDEXPROC)(::GLuint, const ::GLchar *);
extern "C"
{
  void glGenSamplers(::GLsizei count, ::GLuint *samplers)__attribute__((visibility("default")));
}
extern "C"
{
  void glDeleteSamplers(::GLsizei count, const ::GLuint *samplers)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLboolean glIsSampler(::GLuint sampler)__attribute__((visibility("default")));
}
extern "C"
{
  void glBindSampler(::GLuint unit, ::GLuint sampler)__attribute__((visibility("default")));
}
extern "C"
{
  void glSamplerParameteri(::GLuint sampler, ::GLenum pname, ::GLint param)__attribute__((visibility("default")));
}
extern "C"
{
  void glSamplerParameteriv(::GLuint sampler, ::GLenum pname, const ::GLint *param)__attribute__((visibility("default")));
}
extern "C"
{
  void glSamplerParameterf(::GLuint sampler, ::GLenum pname, ::GLfloat param)__attribute__((visibility("default")));
}
extern "C"
{
  void glSamplerParameterfv(::GLuint sampler, ::GLenum pname, const ::GLfloat *param)__attribute__((visibility("default")));
}
extern "C"
{
  void glSamplerParameterIiv(::GLuint sampler, ::GLenum pname, const ::GLint *param)__attribute__((visibility("default")));
}
extern "C"
{
  void glSamplerParameterIuiv(::GLuint sampler, ::GLenum pname, const ::GLuint *param)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetSamplerParameteriv(::GLuint sampler, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetSamplerParameterIiv(::GLuint sampler, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetSamplerParameterfv(::GLuint sampler, ::GLenum pname, ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetSamplerParameterIuiv(::GLuint sampler, ::GLenum pname, ::GLuint *params)__attribute__((visibility("default")));
}
typedef void (*PFNGLGENSAMPLERSPROC)(::GLsizei, ::GLuint *);
typedef void (*PFNGLDELETESAMPLERSPROC)(::GLsizei, const ::GLuint *);
typedef ::GLboolean (*PFNGLISSAMPLERPROC)(::GLuint);
typedef void (*PFNGLBINDSAMPLERPROC)(::GLuint, ::GLuint);
typedef void (*PFNGLSAMPLERPARAMETERIPROC)(::GLuint, ::GLenum, ::GLint);
typedef void (*PFNGLSAMPLERPARAMETERIVPROC)(::GLuint, ::GLenum, const ::GLint *);
typedef void (*PFNGLSAMPLERPARAMETERFPROC)(::GLuint, ::GLenum, ::GLfloat);
typedef void (*PFNGLSAMPLERPARAMETERFVPROC)(::GLuint, ::GLenum, const ::GLfloat *);
typedef void (*PFNGLSAMPLERPARAMETERIIVPROC)(::GLuint, ::GLenum, const ::GLint *);
typedef void (*PFNGLSAMPLERPARAMETERIUIVPROC)(::GLuint, ::GLenum, const ::GLuint *);
typedef void (*PFNGLGETSAMPLERPARAMETERIVPROC)(::GLuint, ::GLenum, ::GLint *);
typedef void (*PFNGLGETSAMPLERPARAMETERIIVPROC)(::GLuint, ::GLenum, ::GLint *);
typedef void (*PFNGLGETSAMPLERPARAMETERFVPROC)(::GLuint, ::GLenum, ::GLfloat *);
typedef void (*PFNGLGETSAMPLERPARAMETERIUIVPROC)(::GLuint, ::GLenum, ::GLuint *);
extern "C"
{
  void glQueryCounter(::GLuint id, ::GLenum target)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetQueryObjecti64v(::GLuint id, ::GLenum pname, ::GLint64 *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetQueryObjectui64v(::GLuint id, ::GLenum pname, ::GLuint64 *params)__attribute__((visibility("default")));
}
typedef void (*PFNGLQUERYCOUNTERPROC)(::GLuint, ::GLenum);
typedef void (*PFNGLGETQUERYOBJECTI64VPROC)(::GLuint, ::GLenum, ::GLint64 *);
typedef void (*PFNGLGETQUERYOBJECTUI64VPROC)(::GLuint, ::GLenum, ::GLuint64 *);
extern "C"
{
  void glVertexP2ui(::GLenum type, ::GLuint value)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexP2uiv(::GLenum type, const ::GLuint *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexP3ui(::GLenum type, ::GLuint value)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexP3uiv(::GLenum type, const ::GLuint *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexP4ui(::GLenum type, ::GLuint value)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexP4uiv(::GLenum type, const ::GLuint *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexCoordP1ui(::GLenum type, ::GLuint coords)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexCoordP1uiv(::GLenum type, const ::GLuint *coords)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexCoordP2ui(::GLenum type, ::GLuint coords)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexCoordP2uiv(::GLenum type, const ::GLuint *coords)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexCoordP3ui(::GLenum type, ::GLuint coords)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexCoordP3uiv(::GLenum type, const ::GLuint *coords)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexCoordP4ui(::GLenum type, ::GLuint coords)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexCoordP4uiv(::GLenum type, const ::GLuint *coords)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoordP1ui(::GLenum texture, ::GLenum type, ::GLuint coords)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoordP1uiv(::GLenum texture, ::GLenum type, const ::GLuint *coords)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoordP2ui(::GLenum texture, ::GLenum type, ::GLuint coords)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoordP2uiv(::GLenum texture, ::GLenum type, const ::GLuint *coords)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoordP3ui(::GLenum texture, ::GLenum type, ::GLuint coords)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoordP3uiv(::GLenum texture, ::GLenum type, const ::GLuint *coords)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoordP4ui(::GLenum texture, ::GLenum type, ::GLuint coords)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoordP4uiv(::GLenum texture, ::GLenum type, const ::GLuint *coords)__attribute__((visibility("default")));
}
extern "C"
{
  void glNormalP3ui(::GLenum type, ::GLuint coords)__attribute__((visibility("default")));
}
extern "C"
{
  void glNormalP3uiv(::GLenum type, const ::GLuint *coords)__attribute__((visibility("default")));
}
extern "C"
{
  void glColorP3ui(::GLenum type, ::GLuint color)__attribute__((visibility("default")));
}
extern "C"
{
  void glColorP3uiv(::GLenum type, const ::GLuint *color)__attribute__((visibility("default")));
}
extern "C"
{
  void glColorP4ui(::GLenum type, ::GLuint color)__attribute__((visibility("default")));
}
extern "C"
{
  void glColorP4uiv(::GLenum type, const ::GLuint *color)__attribute__((visibility("default")));
}
extern "C"
{
  void glSecondaryColorP3ui(::GLenum type, ::GLuint color)__attribute__((visibility("default")));
}
extern "C"
{
  void glSecondaryColorP3uiv(::GLenum type, const ::GLuint *color)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribP1ui(::GLuint index, ::GLenum type, ::GLboolean normalized, ::GLuint value)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribP1uiv(::GLuint index, ::GLenum type, ::GLboolean normalized, const ::GLuint *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribP2ui(::GLuint index, ::GLenum type, ::GLboolean normalized, ::GLuint value)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribP2uiv(::GLuint index, ::GLenum type, ::GLboolean normalized, const ::GLuint *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribP3ui(::GLuint index, ::GLenum type, ::GLboolean normalized, ::GLuint value)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribP3uiv(::GLuint index, ::GLenum type, ::GLboolean normalized, const ::GLuint *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribP4ui(::GLuint index, ::GLenum type, ::GLboolean normalized, ::GLuint value)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribP4uiv(::GLuint index, ::GLenum type, ::GLboolean normalized, const ::GLuint *value)__attribute__((visibility("default")));
}
typedef void (*PFNGLVERTEXP2UIPROC)(::GLenum, ::GLuint);
typedef void (*PFNGLVERTEXP2UIVPROC)(::GLenum, const ::GLuint *);
typedef void (*PFNGLVERTEXP3UIPROC)(::GLenum, ::GLuint);
typedef void (*PFNGLVERTEXP3UIVPROC)(::GLenum, const ::GLuint *);
typedef void (*PFNGLVERTEXP4UIPROC)(::GLenum, ::GLuint);
typedef void (*PFNGLVERTEXP4UIVPROC)(::GLenum, const ::GLuint *);
typedef void (*PFNGLTEXCOORDP1UIPROC)(::GLenum, ::GLuint);
typedef void (*PFNGLTEXCOORDP1UIVPROC)(::GLenum, const ::GLuint *);
typedef void (*PFNGLTEXCOORDP2UIPROC)(::GLenum, ::GLuint);
typedef void (*PFNGLTEXCOORDP2UIVPROC)(::GLenum, const ::GLuint *);
typedef void (*PFNGLTEXCOORDP3UIPROC)(::GLenum, ::GLuint);
typedef void (*PFNGLTEXCOORDP3UIVPROC)(::GLenum, const ::GLuint *);
typedef void (*PFNGLTEXCOORDP4UIPROC)(::GLenum, ::GLuint);
typedef void (*PFNGLTEXCOORDP4UIVPROC)(::GLenum, const ::GLuint *);
typedef void (*PFNGLMULTITEXCOORDP1UIPROC)(::GLenum, ::GLenum, ::GLuint);
typedef void (*PFNGLMULTITEXCOORDP1UIVPROC)(::GLenum, ::GLenum, const ::GLuint *);
typedef void (*PFNGLMULTITEXCOORDP2UIPROC)(::GLenum, ::GLenum, ::GLuint);
typedef void (*PFNGLMULTITEXCOORDP2UIVPROC)(::GLenum, ::GLenum, const ::GLuint *);
typedef void (*PFNGLMULTITEXCOORDP3UIPROC)(::GLenum, ::GLenum, ::GLuint);
typedef void (*PFNGLMULTITEXCOORDP3UIVPROC)(::GLenum, ::GLenum, const ::GLuint *);
typedef void (*PFNGLMULTITEXCOORDP4UIPROC)(::GLenum, ::GLenum, ::GLuint);
typedef void (*PFNGLMULTITEXCOORDP4UIVPROC)(::GLenum, ::GLenum, const ::GLuint *);
typedef void (*PFNGLNORMALP3UIPROC)(::GLenum, ::GLuint);
typedef void (*PFNGLNORMALP3UIVPROC)(::GLenum, const ::GLuint *);
typedef void (*PFNGLCOLORP3UIPROC)(::GLenum, ::GLuint);
typedef void (*PFNGLCOLORP3UIVPROC)(::GLenum, const ::GLuint *);
typedef void (*PFNGLCOLORP4UIPROC)(::GLenum, ::GLuint);
typedef void (*PFNGLCOLORP4UIVPROC)(::GLenum, const ::GLuint *);
typedef void (*PFNGLSECONDARYCOLORP3UIPROC)(::GLenum, ::GLuint);
typedef void (*PFNGLSECONDARYCOLORP3UIVPROC)(::GLenum, const ::GLuint *);
typedef void (*PFNGLVERTEXATTRIBP1UIPROC)(::GLuint, ::GLenum, ::GLboolean, ::GLuint);
typedef void (*PFNGLVERTEXATTRIBP1UIVPROC)(::GLuint, ::GLenum, ::GLboolean, const ::GLuint *);
typedef void (*PFNGLVERTEXATTRIBP2UIPROC)(::GLuint, ::GLenum, ::GLboolean, ::GLuint);
typedef void (*PFNGLVERTEXATTRIBP2UIVPROC)(::GLuint, ::GLenum, ::GLboolean, const ::GLuint *);
typedef void (*PFNGLVERTEXATTRIBP3UIPROC)(::GLuint, ::GLenum, ::GLboolean, ::GLuint);
typedef void (*PFNGLVERTEXATTRIBP3UIVPROC)(::GLuint, ::GLenum, ::GLboolean, const ::GLuint *);
typedef void (*PFNGLVERTEXATTRIBP4UIPROC)(::GLuint, ::GLenum, ::GLboolean, ::GLuint);
typedef void (*PFNGLVERTEXATTRIBP4UIVPROC)(::GLuint, ::GLenum, ::GLboolean, const ::GLuint *);
extern "C"
{
  void glDrawArraysIndirect(::GLenum mode, const ::GLvoid *indirect)__attribute__((visibility("default")));
}
extern "C"
{
  void glDrawElementsIndirect(::GLenum mode, ::GLenum type, const ::GLvoid *indirect)__attribute__((visibility("default")));
}
typedef void (*PFNGLDRAWARRAYSINDIRECTPROC)(::GLenum, const ::GLvoid *);
typedef void (*PFNGLDRAWELEMENTSINDIRECTPROC)(::GLenum, ::GLenum, const ::GLvoid *);
extern "C"
{
  void glUniform1d(::GLint location, ::GLdouble x)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform2d(::GLint location, ::GLdouble x, ::GLdouble y)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform3d(::GLint location, ::GLdouble x, ::GLdouble y, ::GLdouble z)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform4d(::GLint location, ::GLdouble x, ::GLdouble y, ::GLdouble z, ::GLdouble w)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform1dv(::GLint location, ::GLsizei count, const ::GLdouble *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform2dv(::GLint location, ::GLsizei count, const ::GLdouble *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform3dv(::GLint location, ::GLsizei count, const ::GLdouble *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform4dv(::GLint location, ::GLsizei count, const ::GLdouble *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniformMatrix2dv(::GLint location, ::GLsizei count, ::GLboolean transpose, const ::GLdouble *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniformMatrix3dv(::GLint location, ::GLsizei count, ::GLboolean transpose, const ::GLdouble *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniformMatrix4dv(::GLint location, ::GLsizei count, ::GLboolean transpose, const ::GLdouble *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniformMatrix2x3dv(::GLint location, ::GLsizei count, ::GLboolean transpose, const ::GLdouble *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniformMatrix2x4dv(::GLint location, ::GLsizei count, ::GLboolean transpose, const ::GLdouble *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniformMatrix3x2dv(::GLint location, ::GLsizei count, ::GLboolean transpose, const ::GLdouble *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniformMatrix3x4dv(::GLint location, ::GLsizei count, ::GLboolean transpose, const ::GLdouble *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniformMatrix4x2dv(::GLint location, ::GLsizei count, ::GLboolean transpose, const ::GLdouble *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniformMatrix4x3dv(::GLint location, ::GLsizei count, ::GLboolean transpose, const ::GLdouble *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetUniformdv(::GLuint program, ::GLint location, ::GLdouble *params)__attribute__((visibility("default")));
}
typedef void (*PFNGLUNIFORM1DPROC)(::GLint, ::GLdouble);
typedef void (*PFNGLUNIFORM2DPROC)(::GLint, ::GLdouble, ::GLdouble);
typedef void (*PFNGLUNIFORM3DPROC)(::GLint, ::GLdouble, ::GLdouble, ::GLdouble);
typedef void (*PFNGLUNIFORM4DPROC)(::GLint, ::GLdouble, ::GLdouble, ::GLdouble, ::GLdouble);
typedef void (*PFNGLUNIFORM1DVPROC)(::GLint, ::GLsizei, const ::GLdouble *);
typedef void (*PFNGLUNIFORM2DVPROC)(::GLint, ::GLsizei, const ::GLdouble *);
typedef void (*PFNGLUNIFORM3DVPROC)(::GLint, ::GLsizei, const ::GLdouble *);
typedef void (*PFNGLUNIFORM4DVPROC)(::GLint, ::GLsizei, const ::GLdouble *);
typedef void (*PFNGLUNIFORMMATRIX2DVPROC)(::GLint, ::GLsizei, ::GLboolean, const ::GLdouble *);
typedef void (*PFNGLUNIFORMMATRIX3DVPROC)(::GLint, ::GLsizei, ::GLboolean, const ::GLdouble *);
typedef void (*PFNGLUNIFORMMATRIX4DVPROC)(::GLint, ::GLsizei, ::GLboolean, const ::GLdouble *);
typedef void (*PFNGLUNIFORMMATRIX2X3DVPROC)(::GLint, ::GLsizei, ::GLboolean, const ::GLdouble *);
typedef void (*PFNGLUNIFORMMATRIX2X4DVPROC)(::GLint, ::GLsizei, ::GLboolean, const ::GLdouble *);
typedef void (*PFNGLUNIFORMMATRIX3X2DVPROC)(::GLint, ::GLsizei, ::GLboolean, const ::GLdouble *);
typedef void (*PFNGLUNIFORMMATRIX3X4DVPROC)(::GLint, ::GLsizei, ::GLboolean, const ::GLdouble *);
typedef void (*PFNGLUNIFORMMATRIX4X2DVPROC)(::GLint, ::GLsizei, ::GLboolean, const ::GLdouble *);
typedef void (*PFNGLUNIFORMMATRIX4X3DVPROC)(::GLint, ::GLsizei, ::GLboolean, const ::GLdouble *);
typedef void (*PFNGLGETUNIFORMDVPROC)(::GLuint, ::GLint, ::GLdouble *);
extern "C"
{
  ::GLint glGetSubroutineUniformLocation(::GLuint program, ::GLenum shadertype, const ::GLchar *name)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLuint glGetSubroutineIndex(::GLuint program, ::GLenum shadertype, const ::GLchar *name)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetActiveSubroutineUniformiv(::GLuint program, ::GLenum shadertype, ::GLuint index, ::GLenum pname, ::GLint *values)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetActiveSubroutineUniformName(::GLuint program, ::GLenum shadertype, ::GLuint index, ::GLsizei bufsize, ::GLsizei *length, ::GLchar *name)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetActiveSubroutineName(::GLuint program, ::GLenum shadertype, ::GLuint index, ::GLsizei bufsize, ::GLsizei *length, ::GLchar *name)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniformSubroutinesuiv(::GLenum shadertype, ::GLsizei count, const ::GLuint *indices)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetUniformSubroutineuiv(::GLenum shadertype, ::GLint location, ::GLuint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetProgramStageiv(::GLuint program, ::GLenum shadertype, ::GLenum pname, ::GLint *values)__attribute__((visibility("default")));
}
typedef ::GLint (*PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC)(::GLuint, ::GLenum, const ::GLchar *);
typedef ::GLuint (*PFNGLGETSUBROUTINEINDEXPROC)(::GLuint, ::GLenum, const ::GLchar *);
typedef void (*PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC)(::GLuint, ::GLenum, ::GLuint, ::GLenum, ::GLint *);
typedef void (*PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC)(::GLuint, ::GLenum, ::GLuint, ::GLsizei, ::GLsizei *, ::GLchar *);
typedef void (*PFNGLGETACTIVESUBROUTINENAMEPROC)(::GLuint, ::GLenum, ::GLuint, ::GLsizei, ::GLsizei *, ::GLchar *);
typedef void (*PFNGLUNIFORMSUBROUTINESUIVPROC)(::GLenum, ::GLsizei, const ::GLuint *);
typedef void (*PFNGLGETUNIFORMSUBROUTINEUIVPROC)(::GLenum, ::GLint, ::GLuint *);
typedef void (*PFNGLGETPROGRAMSTAGEIVPROC)(::GLuint, ::GLenum, ::GLenum, ::GLint *);
extern "C"
{
  void glPatchParameteri(::GLenum pname, ::GLint value)__attribute__((visibility("default")));
}
extern "C"
{
  void glPatchParameterfv(::GLenum pname, const ::GLfloat *values)__attribute__((visibility("default")));
}
typedef void (*PFNGLPATCHPARAMETERIPROC)(::GLenum, ::GLint);
typedef void (*PFNGLPATCHPARAMETERFVPROC)(::GLenum, const ::GLfloat *);
extern "C"
{
  void glBindTransformFeedback(::GLenum target, ::GLuint id)__attribute__((visibility("default")));
}
extern "C"
{
  void glDeleteTransformFeedbacks(::GLsizei n, const ::GLuint *ids)__attribute__((visibility("default")));
}
extern "C"
{
  void glGenTransformFeedbacks(::GLsizei n, ::GLuint *ids)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLboolean glIsTransformFeedback(::GLuint id)__attribute__((visibility("default")));
}
extern "C"
{
  void glPauseTransformFeedback()__attribute__((visibility("default")));
}
extern "C"
{
  void glResumeTransformFeedback()__attribute__((visibility("default")));
}
extern "C"
{
  void glDrawTransformFeedback(::GLenum mode, ::GLuint id)__attribute__((visibility("default")));
}
typedef void (*PFNGLBINDTRANSFORMFEEDBACKPROC)(::GLenum, ::GLuint);
typedef void (*PFNGLDELETETRANSFORMFEEDBACKSPROC)(::GLsizei, const ::GLuint *);
typedef void (*PFNGLGENTRANSFORMFEEDBACKSPROC)(::GLsizei, ::GLuint *);
typedef ::GLboolean (*PFNGLISTRANSFORMFEEDBACKPROC)(::GLuint);
typedef void (*PFNGLPAUSETRANSFORMFEEDBACKPROC)();
typedef void (*PFNGLRESUMETRANSFORMFEEDBACKPROC)();
typedef void (*PFNGLDRAWTRANSFORMFEEDBACKPROC)(::GLenum, ::GLuint);
extern "C"
{
  void glDrawTransformFeedbackStream(::GLenum mode, ::GLuint id, ::GLuint stream)__attribute__((visibility("default")));
}
extern "C"
{
  void glBeginQueryIndexed(::GLenum target, ::GLuint index, ::GLuint id)__attribute__((visibility("default")));
}
extern "C"
{
  void glEndQueryIndexed(::GLenum target, ::GLuint index)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetQueryIndexediv(::GLenum target, ::GLuint index, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
typedef void (*PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC)(::GLenum, ::GLuint, ::GLuint);
typedef void (*PFNGLBEGINQUERYINDEXEDPROC)(::GLenum, ::GLuint, ::GLuint);
typedef void (*PFNGLENDQUERYINDEXEDPROC)(::GLenum, ::GLuint);
typedef void (*PFNGLGETQUERYINDEXEDIVPROC)(::GLenum, ::GLuint, ::GLenum, ::GLint *);
extern "C"
{
  void glReleaseShaderCompiler()__attribute__((visibility("default")));
}
extern "C"
{
  void glShaderBinary(::GLsizei count, const ::GLuint *shaders, ::GLenum binaryformat, const ::GLvoid *binary, ::GLsizei length)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetShaderPrecisionFormat(::GLenum shadertype, ::GLenum precisiontype, ::GLint *range, ::GLint *precision)__attribute__((visibility("default")));
}
extern "C"
{
  void glDepthRangef(::GLclampf n, ::GLclampf f)__attribute__((visibility("default")));
}
extern "C"
{
  void glClearDepthf(::GLclampf d)__attribute__((visibility("default")));
}
typedef void (*PFNGLRELEASESHADERCOMPILERPROC)();
typedef void (*PFNGLSHADERBINARYPROC)(::GLsizei, const ::GLuint *, ::GLenum, const ::GLvoid *, ::GLsizei);
typedef void (*PFNGLGETSHADERPRECISIONFORMATPROC)(::GLenum, ::GLenum, ::GLint *, ::GLint *);
typedef void (*PFNGLDEPTHRANGEFPROC)(::GLclampf, ::GLclampf);
typedef void (*PFNGLCLEARDEPTHFPROC)(::GLclampf);
extern "C"
{
  void glGetProgramBinary(::GLuint program, ::GLsizei bufSize, ::GLsizei *length, ::GLenum *binaryFormat, ::GLvoid *binary)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramBinary(::GLuint program, ::GLenum binaryFormat, const ::GLvoid *binary, ::GLsizei length)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramParameteri(::GLuint program, ::GLenum pname, ::GLint value)__attribute__((visibility("default")));
}
typedef void (*PFNGLGETPROGRAMBINARYPROC)(::GLuint, ::GLsizei, ::GLsizei *, ::GLenum *, ::GLvoid *);
typedef void (*PFNGLPROGRAMBINARYPROC)(::GLuint, ::GLenum, const ::GLvoid *, ::GLsizei);
typedef void (*PFNGLPROGRAMPARAMETERIPROC)(::GLuint, ::GLenum, ::GLint);
extern "C"
{
  void glUseProgramStages(::GLuint pipeline, ::GLbitfield stages, ::GLuint program)__attribute__((visibility("default")));
}
extern "C"
{
  void glActiveShaderProgram(::GLuint pipeline, ::GLuint program)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLuint glCreateShaderProgramv(::GLenum type, ::GLsizei count, const ::GLchar **strings)__attribute__((visibility("default")));
}
extern "C"
{
  void glBindProgramPipeline(::GLuint pipeline)__attribute__((visibility("default")));
}
extern "C"
{
  void glDeleteProgramPipelines(::GLsizei n, const ::GLuint *pipelines)__attribute__((visibility("default")));
}
extern "C"
{
  void glGenProgramPipelines(::GLsizei n, ::GLuint *pipelines)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLboolean glIsProgramPipeline(::GLuint pipeline)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetProgramPipelineiv(::GLuint pipeline, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform1i(::GLuint program, ::GLint location, ::GLint v0)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform1iv(::GLuint program, ::GLint location, ::GLsizei count, const ::GLint *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform1f(::GLuint program, ::GLint location, ::GLfloat v0)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform1fv(::GLuint program, ::GLint location, ::GLsizei count, const ::GLfloat *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform1d(::GLuint program, ::GLint location, ::GLdouble v0)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform1dv(::GLuint program, ::GLint location, ::GLsizei count, const ::GLdouble *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform1ui(::GLuint program, ::GLint location, ::GLuint v0)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform1uiv(::GLuint program, ::GLint location, ::GLsizei count, const ::GLuint *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform2i(::GLuint program, ::GLint location, ::GLint v0, ::GLint v1)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform2iv(::GLuint program, ::GLint location, ::GLsizei count, const ::GLint *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform2f(::GLuint program, ::GLint location, ::GLfloat v0, ::GLfloat v1)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform2fv(::GLuint program, ::GLint location, ::GLsizei count, const ::GLfloat *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform2d(::GLuint program, ::GLint location, ::GLdouble v0, ::GLdouble v1)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform2dv(::GLuint program, ::GLint location, ::GLsizei count, const ::GLdouble *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform2ui(::GLuint program, ::GLint location, ::GLuint v0, ::GLuint v1)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform2uiv(::GLuint program, ::GLint location, ::GLsizei count, const ::GLuint *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform3i(::GLuint program, ::GLint location, ::GLint v0, ::GLint v1, ::GLint v2)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform3iv(::GLuint program, ::GLint location, ::GLsizei count, const ::GLint *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform3f(::GLuint program, ::GLint location, ::GLfloat v0, ::GLfloat v1, ::GLfloat v2)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform3fv(::GLuint program, ::GLint location, ::GLsizei count, const ::GLfloat *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform3d(::GLuint program, ::GLint location, ::GLdouble v0, ::GLdouble v1, ::GLdouble v2)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform3dv(::GLuint program, ::GLint location, ::GLsizei count, const ::GLdouble *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform3ui(::GLuint program, ::GLint location, ::GLuint v0, ::GLuint v1, ::GLuint v2)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform3uiv(::GLuint program, ::GLint location, ::GLsizei count, const ::GLuint *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform4i(::GLuint program, ::GLint location, ::GLint v0, ::GLint v1, ::GLint v2, ::GLint v3)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform4iv(::GLuint program, ::GLint location, ::GLsizei count, const ::GLint *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform4f(::GLuint program, ::GLint location, ::GLfloat v0, ::GLfloat v1, ::GLfloat v2, ::GLfloat v3)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform4fv(::GLuint program, ::GLint location, ::GLsizei count, const ::GLfloat *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform4d(::GLuint program, ::GLint location, ::GLdouble v0, ::GLdouble v1, ::GLdouble v2, ::GLdouble v3)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform4dv(::GLuint program, ::GLint location, ::GLsizei count, const ::GLdouble *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform4ui(::GLuint program, ::GLint location, ::GLuint v0, ::GLuint v1, ::GLuint v2, ::GLuint v3)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform4uiv(::GLuint program, ::GLint location, ::GLsizei count, const ::GLuint *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniformMatrix2fv(::GLuint program, ::GLint location, ::GLsizei count, ::GLboolean transpose, const ::GLfloat *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniformMatrix3fv(::GLuint program, ::GLint location, ::GLsizei count, ::GLboolean transpose, const ::GLfloat *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniformMatrix4fv(::GLuint program, ::GLint location, ::GLsizei count, ::GLboolean transpose, const ::GLfloat *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniformMatrix2dv(::GLuint program, ::GLint location, ::GLsizei count, ::GLboolean transpose, const ::GLdouble *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniformMatrix3dv(::GLuint program, ::GLint location, ::GLsizei count, ::GLboolean transpose, const ::GLdouble *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniformMatrix4dv(::GLuint program, ::GLint location, ::GLsizei count, ::GLboolean transpose, const ::GLdouble *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniformMatrix2x3fv(::GLuint program, ::GLint location, ::GLsizei count, ::GLboolean transpose, const ::GLfloat *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniformMatrix3x2fv(::GLuint program, ::GLint location, ::GLsizei count, ::GLboolean transpose, const ::GLfloat *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniformMatrix2x4fv(::GLuint program, ::GLint location, ::GLsizei count, ::GLboolean transpose, const ::GLfloat *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniformMatrix4x2fv(::GLuint program, ::GLint location, ::GLsizei count, ::GLboolean transpose, const ::GLfloat *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniformMatrix3x4fv(::GLuint program, ::GLint location, ::GLsizei count, ::GLboolean transpose, const ::GLfloat *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniformMatrix4x3fv(::GLuint program, ::GLint location, ::GLsizei count, ::GLboolean transpose, const ::GLfloat *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniformMatrix2x3dv(::GLuint program, ::GLint location, ::GLsizei count, ::GLboolean transpose, const ::GLdouble *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniformMatrix3x2dv(::GLuint program, ::GLint location, ::GLsizei count, ::GLboolean transpose, const ::GLdouble *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniformMatrix2x4dv(::GLuint program, ::GLint location, ::GLsizei count, ::GLboolean transpose, const ::GLdouble *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniformMatrix4x2dv(::GLuint program, ::GLint location, ::GLsizei count, ::GLboolean transpose, const ::GLdouble *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniformMatrix3x4dv(::GLuint program, ::GLint location, ::GLsizei count, ::GLboolean transpose, const ::GLdouble *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniformMatrix4x3dv(::GLuint program, ::GLint location, ::GLsizei count, ::GLboolean transpose, const ::GLdouble *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glValidateProgramPipeline(::GLuint pipeline)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetProgramPipelineInfoLog(::GLuint pipeline, ::GLsizei bufSize, ::GLsizei *length, ::GLchar *infoLog)__attribute__((visibility("default")));
}
typedef void (*PFNGLUSEPROGRAMSTAGESPROC)(::GLuint, ::GLbitfield, ::GLuint);
typedef void (*PFNGLACTIVESHADERPROGRAMPROC)(::GLuint, ::GLuint);
typedef ::GLuint (*PFNGLCREATESHADERPROGRAMVPROC)(::GLenum, ::GLsizei, const ::GLchar **);
typedef void (*PFNGLBINDPROGRAMPIPELINEPROC)(::GLuint);
typedef void (*PFNGLDELETEPROGRAMPIPELINESPROC)(::GLsizei, const ::GLuint *);
typedef void (*PFNGLGENPROGRAMPIPELINESPROC)(::GLsizei, ::GLuint *);
typedef ::GLboolean (*PFNGLISPROGRAMPIPELINEPROC)(::GLuint);
typedef void (*PFNGLGETPROGRAMPIPELINEIVPROC)(::GLuint, ::GLenum, ::GLint *);
typedef void (*PFNGLPROGRAMUNIFORM1IPROC)(::GLuint, ::GLint, ::GLint);
typedef void (*PFNGLPROGRAMUNIFORM1IVPROC)(::GLuint, ::GLint, ::GLsizei, const ::GLint *);
typedef void (*PFNGLPROGRAMUNIFORM1FPROC)(::GLuint, ::GLint, ::GLfloat);
typedef void (*PFNGLPROGRAMUNIFORM1FVPROC)(::GLuint, ::GLint, ::GLsizei, const ::GLfloat *);
typedef void (*PFNGLPROGRAMUNIFORM1DPROC)(::GLuint, ::GLint, ::GLdouble);
typedef void (*PFNGLPROGRAMUNIFORM1DVPROC)(::GLuint, ::GLint, ::GLsizei, const ::GLdouble *);
typedef void (*PFNGLPROGRAMUNIFORM1UIPROC)(::GLuint, ::GLint, ::GLuint);
typedef void (*PFNGLPROGRAMUNIFORM1UIVPROC)(::GLuint, ::GLint, ::GLsizei, const ::GLuint *);
typedef void (*PFNGLPROGRAMUNIFORM2IPROC)(::GLuint, ::GLint, ::GLint, ::GLint);
typedef void (*PFNGLPROGRAMUNIFORM2IVPROC)(::GLuint, ::GLint, ::GLsizei, const ::GLint *);
typedef void (*PFNGLPROGRAMUNIFORM2FPROC)(::GLuint, ::GLint, ::GLfloat, ::GLfloat);
typedef void (*PFNGLPROGRAMUNIFORM2FVPROC)(::GLuint, ::GLint, ::GLsizei, const ::GLfloat *);
typedef void (*PFNGLPROGRAMUNIFORM2DPROC)(::GLuint, ::GLint, ::GLdouble, ::GLdouble);
typedef void (*PFNGLPROGRAMUNIFORM2DVPROC)(::GLuint, ::GLint, ::GLsizei, const ::GLdouble *);
typedef void (*PFNGLPROGRAMUNIFORM2UIPROC)(::GLuint, ::GLint, ::GLuint, ::GLuint);
typedef void (*PFNGLPROGRAMUNIFORM2UIVPROC)(::GLuint, ::GLint, ::GLsizei, const ::GLuint *);
typedef void (*PFNGLPROGRAMUNIFORM3IPROC)(::GLuint, ::GLint, ::GLint, ::GLint, ::GLint);
typedef void (*PFNGLPROGRAMUNIFORM3IVPROC)(::GLuint, ::GLint, ::GLsizei, const ::GLint *);
typedef void (*PFNGLPROGRAMUNIFORM3FPROC)(::GLuint, ::GLint, ::GLfloat, ::GLfloat, ::GLfloat);
typedef void (*PFNGLPROGRAMUNIFORM3FVPROC)(::GLuint, ::GLint, ::GLsizei, const ::GLfloat *);
typedef void (*PFNGLPROGRAMUNIFORM3DPROC)(::GLuint, ::GLint, ::GLdouble, ::GLdouble, ::GLdouble);
typedef void (*PFNGLPROGRAMUNIFORM3DVPROC)(::GLuint, ::GLint, ::GLsizei, const ::GLdouble *);
typedef void (*PFNGLPROGRAMUNIFORM3UIPROC)(::GLuint, ::GLint, ::GLuint, ::GLuint, ::GLuint);
typedef void (*PFNGLPROGRAMUNIFORM3UIVPROC)(::GLuint, ::GLint, ::GLsizei, const ::GLuint *);
typedef void (*PFNGLPROGRAMUNIFORM4IPROC)(::GLuint, ::GLint, ::GLint, ::GLint, ::GLint, ::GLint);
typedef void (*PFNGLPROGRAMUNIFORM4IVPROC)(::GLuint, ::GLint, ::GLsizei, const ::GLint *);
typedef void (*PFNGLPROGRAMUNIFORM4FPROC)(::GLuint, ::GLint, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat);
typedef void (*PFNGLPROGRAMUNIFORM4FVPROC)(::GLuint, ::GLint, ::GLsizei, const ::GLfloat *);
typedef void (*PFNGLPROGRAMUNIFORM4DPROC)(::GLuint, ::GLint, ::GLdouble, ::GLdouble, ::GLdouble, ::GLdouble);
typedef void (*PFNGLPROGRAMUNIFORM4DVPROC)(::GLuint, ::GLint, ::GLsizei, const ::GLdouble *);
typedef void (*PFNGLPROGRAMUNIFORM4UIPROC)(::GLuint, ::GLint, ::GLuint, ::GLuint, ::GLuint, ::GLuint);
typedef void (*PFNGLPROGRAMUNIFORM4UIVPROC)(::GLuint, ::GLint, ::GLsizei, const ::GLuint *);
typedef void (*PFNGLPROGRAMUNIFORMMATRIX2FVPROC)(::GLuint, ::GLint, ::GLsizei, ::GLboolean, const ::GLfloat *);
typedef void (*PFNGLPROGRAMUNIFORMMATRIX3FVPROC)(::GLuint, ::GLint, ::GLsizei, ::GLboolean, const ::GLfloat *);
typedef void (*PFNGLPROGRAMUNIFORMMATRIX4FVPROC)(::GLuint, ::GLint, ::GLsizei, ::GLboolean, const ::GLfloat *);
typedef void (*PFNGLPROGRAMUNIFORMMATRIX2DVPROC)(::GLuint, ::GLint, ::GLsizei, ::GLboolean, const ::GLdouble *);
typedef void (*PFNGLPROGRAMUNIFORMMATRIX3DVPROC)(::GLuint, ::GLint, ::GLsizei, ::GLboolean, const ::GLdouble *);
typedef void (*PFNGLPROGRAMUNIFORMMATRIX4DVPROC)(::GLuint, ::GLint, ::GLsizei, ::GLboolean, const ::GLdouble *);
typedef void (*PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC)(::GLuint, ::GLint, ::GLsizei, ::GLboolean, const ::GLfloat *);
typedef void (*PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC)(::GLuint, ::GLint, ::GLsizei, ::GLboolean, const ::GLfloat *);
typedef void (*PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC)(::GLuint, ::GLint, ::GLsizei, ::GLboolean, const ::GLfloat *);
typedef void (*PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC)(::GLuint, ::GLint, ::GLsizei, ::GLboolean, const ::GLfloat *);
typedef void (*PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC)(::GLuint, ::GLint, ::GLsizei, ::GLboolean, const ::GLfloat *);
typedef void (*PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC)(::GLuint, ::GLint, ::GLsizei, ::GLboolean, const ::GLfloat *);
typedef void (*PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC)(::GLuint, ::GLint, ::GLsizei, ::GLboolean, const ::GLdouble *);
typedef void (*PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC)(::GLuint, ::GLint, ::GLsizei, ::GLboolean, const ::GLdouble *);
typedef void (*PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC)(::GLuint, ::GLint, ::GLsizei, ::GLboolean, const ::GLdouble *);
typedef void (*PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC)(::GLuint, ::GLint, ::GLsizei, ::GLboolean, const ::GLdouble *);
typedef void (*PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC)(::GLuint, ::GLint, ::GLsizei, ::GLboolean, const ::GLdouble *);
typedef void (*PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC)(::GLuint, ::GLint, ::GLsizei, ::GLboolean, const ::GLdouble *);
typedef void (*PFNGLVALIDATEPROGRAMPIPELINEPROC)(::GLuint);
typedef void (*PFNGLGETPROGRAMPIPELINEINFOLOGPROC)(::GLuint, ::GLsizei, ::GLsizei *, ::GLchar *);
extern "C"
{
  void glVertexAttribL1d(::GLuint index, ::GLdouble x)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribL2d(::GLuint index, ::GLdouble x, ::GLdouble y)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribL3d(::GLuint index, ::GLdouble x, ::GLdouble y, ::GLdouble z)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribL4d(::GLuint index, ::GLdouble x, ::GLdouble y, ::GLdouble z, ::GLdouble w)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribL1dv(::GLuint index, const ::GLdouble *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribL2dv(::GLuint index, const ::GLdouble *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribL3dv(::GLuint index, const ::GLdouble *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribL4dv(::GLuint index, const ::GLdouble *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribLPointer(::GLuint index, ::GLint size, ::GLenum type, ::GLsizei stride, const ::GLvoid *pointer)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetVertexAttribLdv(::GLuint index, ::GLenum pname, ::GLdouble *params)__attribute__((visibility("default")));
}
typedef void (*PFNGLVERTEXATTRIBL1DPROC)(::GLuint, ::GLdouble);
typedef void (*PFNGLVERTEXATTRIBL2DPROC)(::GLuint, ::GLdouble, ::GLdouble);
typedef void (*PFNGLVERTEXATTRIBL3DPROC)(::GLuint, ::GLdouble, ::GLdouble, ::GLdouble);
typedef void (*PFNGLVERTEXATTRIBL4DPROC)(::GLuint, ::GLdouble, ::GLdouble, ::GLdouble, ::GLdouble);
typedef void (*PFNGLVERTEXATTRIBL1DVPROC)(::GLuint, const ::GLdouble *);
typedef void (*PFNGLVERTEXATTRIBL2DVPROC)(::GLuint, const ::GLdouble *);
typedef void (*PFNGLVERTEXATTRIBL3DVPROC)(::GLuint, const ::GLdouble *);
typedef void (*PFNGLVERTEXATTRIBL4DVPROC)(::GLuint, const ::GLdouble *);
typedef void (*PFNGLVERTEXATTRIBLPOINTERPROC)(::GLuint, ::GLint, ::GLenum, ::GLsizei, const ::GLvoid *);
typedef void (*PFNGLGETVERTEXATTRIBLDVPROC)(::GLuint, ::GLenum, ::GLdouble *);
extern "C"
{
  void glViewportArrayv(::GLuint first, ::GLsizei count, const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glViewportIndexedf(::GLuint index, ::GLfloat x, ::GLfloat y, ::GLfloat w, ::GLfloat h)__attribute__((visibility("default")));
}
extern "C"
{
  void glViewportIndexedfv(::GLuint index, const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glScissorArrayv(::GLuint first, ::GLsizei count, const ::GLint *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glScissorIndexed(::GLuint index, ::GLint left, ::GLint bottom, ::GLsizei width, ::GLsizei height)__attribute__((visibility("default")));
}
extern "C"
{
  void glScissorIndexedv(::GLuint index, const ::GLint *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glDepthRangeArrayv(::GLuint first, ::GLsizei count, const ::GLclampd *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glDepthRangeIndexed(::GLuint index, ::GLclampd n, ::GLclampd f)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetFloati_v(::GLenum target, ::GLuint index, ::GLfloat *data)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetDoublei_v(::GLenum target, ::GLuint index, ::GLdouble *data)__attribute__((visibility("default")));
}
typedef void (*PFNGLVIEWPORTARRAYVPROC)(::GLuint, ::GLsizei, const ::GLfloat *);
typedef void (*PFNGLVIEWPORTINDEXEDFPROC)(::GLuint, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat);
typedef void (*PFNGLVIEWPORTINDEXEDFVPROC)(::GLuint, const ::GLfloat *);
typedef void (*PFNGLSCISSORARRAYVPROC)(::GLuint, ::GLsizei, const ::GLint *);
typedef void (*PFNGLSCISSORINDEXEDPROC)(::GLuint, ::GLint, ::GLint, ::GLsizei, ::GLsizei);
typedef void (*PFNGLSCISSORINDEXEDVPROC)(::GLuint, const ::GLint *);
typedef void (*PFNGLDEPTHRANGEARRAYVPROC)(::GLuint, ::GLsizei, const ::GLclampd *);
typedef void (*PFNGLDEPTHRANGEINDEXEDPROC)(::GLuint, ::GLclampd, ::GLclampd);
typedef void (*PFNGLGETFLOATI_VPROC)(::GLenum, ::GLuint, ::GLfloat *);
typedef void (*PFNGLGETDOUBLEI_VPROC)(::GLenum, ::GLuint, ::GLdouble *);
extern "C"
{
  ::GLsync glCreateSyncFromCLeventARB(::_cl_context *context, ::_cl_event *event, ::GLbitfield flags)__attribute__((visibility("default")));
}
typedef ::GLsync (*PFNGLCREATESYNCFROMCLEVENTARBPROC)(::_cl_context *, ::_cl_event *, ::GLbitfield);
extern "C"
{
  void glDebugMessageControlARB(::GLenum source, ::GLenum type, ::GLenum severity, ::GLsizei count, const ::GLuint *ids, ::GLboolean enabled)__attribute__((visibility("default")));
}
extern "C"
{
  void glDebugMessageInsertARB(::GLenum source, ::GLenum type, ::GLuint id, ::GLenum severity, ::GLsizei length, const ::GLchar *buf)__attribute__((visibility("default")));
}
extern "C"
{
  void glDebugMessageCallbackARB(::GLDEBUGPROCARB callback, const ::GLvoid *userParam)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLuint glGetDebugMessageLogARB(::GLuint count, ::GLsizei bufsize, ::GLenum *sources, ::GLenum *types, ::GLuint *ids, ::GLenum *severities, ::GLsizei *lengths, ::GLchar *messageLog)__attribute__((visibility("default")));
}
typedef void (*PFNGLDEBUGMESSAGECONTROLARBPROC)(::GLenum, ::GLenum, ::GLenum, ::GLsizei, const ::GLuint *, ::GLboolean);
typedef void (*PFNGLDEBUGMESSAGEINSERTARBPROC)(::GLenum, ::GLenum, ::GLuint, ::GLenum, ::GLsizei, const ::GLchar *);
typedef void (*PFNGLDEBUGMESSAGECALLBACKARBPROC)(::GLDEBUGPROCARB, const ::GLvoid *);
typedef ::GLuint (*PFNGLGETDEBUGMESSAGELOGARBPROC)(::GLuint, ::GLsizei, ::GLenum *, ::GLenum *, ::GLuint *, ::GLenum *, ::GLsizei *, ::GLchar *);
extern "C"
{
  ::GLenum glGetGraphicsResetStatusARB()__attribute__((visibility("default")));
}
extern "C"
{
  void glGetnMapdvARB(::GLenum target, ::GLenum query, ::GLsizei bufSize, ::GLdouble *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetnMapfvARB(::GLenum target, ::GLenum query, ::GLsizei bufSize, ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetnMapivARB(::GLenum target, ::GLenum query, ::GLsizei bufSize, ::GLint *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetnPixelMapfvARB(::GLenum map, ::GLsizei bufSize, ::GLfloat *values)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetnPixelMapuivARB(::GLenum map, ::GLsizei bufSize, ::GLuint *values)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetnPixelMapusvARB(::GLenum map, ::GLsizei bufSize, ::GLushort *values)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetnPolygonStippleARB(::GLsizei bufSize, ::GLubyte *pattern)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetnColorTableARB(::GLenum target, ::GLenum format, ::GLenum type, ::GLsizei bufSize, ::GLvoid *table)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetnConvolutionFilterARB(::GLenum target, ::GLenum format, ::GLenum type, ::GLsizei bufSize, ::GLvoid *image)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetnSeparableFilterARB(::GLenum target, ::GLenum format, ::GLenum type, ::GLsizei rowBufSize, ::GLvoid *row, ::GLsizei columnBufSize, ::GLvoid *column, ::GLvoid *span)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetnHistogramARB(::GLenum target, ::GLboolean reset, ::GLenum format, ::GLenum type, ::GLsizei bufSize, ::GLvoid *values)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetnMinmaxARB(::GLenum target, ::GLboolean reset, ::GLenum format, ::GLenum type, ::GLsizei bufSize, ::GLvoid *values)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetnTexImageARB(::GLenum target, ::GLint level, ::GLenum format, ::GLenum type, ::GLsizei bufSize, ::GLvoid *img)__attribute__((visibility("default")));
}
extern "C"
{
  void glReadnPixelsARB(::GLint x, ::GLint y, ::GLsizei width, ::GLsizei height, ::GLenum format, ::GLenum type, ::GLsizei bufSize, ::GLvoid *data)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetnCompressedTexImageARB(::GLenum target, ::GLint lod, ::GLsizei bufSize, ::GLvoid *img)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetnUniformfvARB(::GLuint program, ::GLint location, ::GLsizei bufSize, ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetnUniformivARB(::GLuint program, ::GLint location, ::GLsizei bufSize, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetnUniformuivARB(::GLuint program, ::GLint location, ::GLsizei bufSize, ::GLuint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetnUniformdvARB(::GLuint program, ::GLint location, ::GLsizei bufSize, ::GLdouble *params)__attribute__((visibility("default")));
}
typedef ::GLenum (*PFNGLGETGRAPHICSRESETSTATUSARBPROC)();
typedef void (*PFNGLGETNMAPDVARBPROC)(::GLenum, ::GLenum, ::GLsizei, ::GLdouble *);
typedef void (*PFNGLGETNMAPFVARBPROC)(::GLenum, ::GLenum, ::GLsizei, ::GLfloat *);
typedef void (*PFNGLGETNMAPIVARBPROC)(::GLenum, ::GLenum, ::GLsizei, ::GLint *);
typedef void (*PFNGLGETNPIXELMAPFVARBPROC)(::GLenum, ::GLsizei, ::GLfloat *);
typedef void (*PFNGLGETNPIXELMAPUIVARBPROC)(::GLenum, ::GLsizei, ::GLuint *);
typedef void (*PFNGLGETNPIXELMAPUSVARBPROC)(::GLenum, ::GLsizei, ::GLushort *);
typedef void (*PFNGLGETNPOLYGONSTIPPLEARBPROC)(::GLsizei, ::GLubyte *);
typedef void (*PFNGLGETNCOLORTABLEARBPROC)(::GLenum, ::GLenum, ::GLenum, ::GLsizei, ::GLvoid *);
typedef void (*PFNGLGETNCONVOLUTIONFILTERARBPROC)(::GLenum, ::GLenum, ::GLenum, ::GLsizei, ::GLvoid *);
typedef void (*PFNGLGETNSEPARABLEFILTERARBPROC)(::GLenum, ::GLenum, ::GLenum, ::GLsizei, ::GLvoid *, ::GLsizei, ::GLvoid *, ::GLvoid *);
typedef void (*PFNGLGETNHISTOGRAMARBPROC)(::GLenum, ::GLboolean, ::GLenum, ::GLenum, ::GLsizei, ::GLvoid *);
typedef void (*PFNGLGETNMINMAXARBPROC)(::GLenum, ::GLboolean, ::GLenum, ::GLenum, ::GLsizei, ::GLvoid *);
typedef void (*PFNGLGETNTEXIMAGEARBPROC)(::GLenum, ::GLint, ::GLenum, ::GLenum, ::GLsizei, ::GLvoid *);
typedef void (*PFNGLREADNPIXELSARBPROC)(::GLint, ::GLint, ::GLsizei, ::GLsizei, ::GLenum, ::GLenum, ::GLsizei, ::GLvoid *);
typedef void (*PFNGLGETNCOMPRESSEDTEXIMAGEARBPROC)(::GLenum, ::GLint, ::GLsizei, ::GLvoid *);
typedef void (*PFNGLGETNUNIFORMFVARBPROC)(::GLuint, ::GLint, ::GLsizei, ::GLfloat *);
typedef void (*PFNGLGETNUNIFORMIVARBPROC)(::GLuint, ::GLint, ::GLsizei, ::GLint *);
typedef void (*PFNGLGETNUNIFORMUIVARBPROC)(::GLuint, ::GLint, ::GLsizei, ::GLuint *);
typedef void (*PFNGLGETNUNIFORMDVARBPROC)(::GLuint, ::GLint, ::GLsizei, ::GLdouble *);
extern "C"
{
  void glBlendColorEXT(::GLclampf red, ::GLclampf green, ::GLclampf blue, ::GLclampf alpha)__attribute__((visibility("default")));
}
typedef void (*PFNGLBLENDCOLOREXTPROC)(::GLclampf, ::GLclampf, ::GLclampf, ::GLclampf);
extern "C"
{
  void glPolygonOffsetEXT(::GLfloat factor, ::GLfloat bias)__attribute__((visibility("default")));
}
typedef void (*PFNGLPOLYGONOFFSETEXTPROC)(::GLfloat, ::GLfloat);
extern "C"
{
  void glTexImage3DEXT(::GLenum target, ::GLint level, ::GLenum internalformat, ::GLsizei width, ::GLsizei height, ::GLsizei depth, ::GLint border, ::GLenum format, ::GLenum type, const ::GLvoid *pixels)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexSubImage3DEXT(::GLenum target, ::GLint level, ::GLint xoffset, ::GLint yoffset, ::GLint zoffset, ::GLsizei width, ::GLsizei height, ::GLsizei depth, ::GLenum format, ::GLenum type, const ::GLvoid *pixels)__attribute__((visibility("default")));
}
typedef void (*PFNGLTEXIMAGE3DEXTPROC)(::GLenum, ::GLint, ::GLenum, ::GLsizei, ::GLsizei, ::GLsizei, ::GLint, ::GLenum, ::GLenum, const ::GLvoid *);
typedef void (*PFNGLTEXSUBIMAGE3DEXTPROC)(::GLenum, ::GLint, ::GLint, ::GLint, ::GLint, ::GLsizei, ::GLsizei, ::GLsizei, ::GLenum, ::GLenum, const ::GLvoid *);
extern "C"
{
  void glGetTexFilterFuncSGIS(::GLenum target, ::GLenum filter, ::GLfloat *weights)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexFilterFuncSGIS(::GLenum target, ::GLenum filter, ::GLsizei n, const ::GLfloat *weights)__attribute__((visibility("default")));
}
typedef void (*PFNGLGETTEXFILTERFUNCSGISPROC)(::GLenum, ::GLenum, ::GLfloat *);
typedef void (*PFNGLTEXFILTERFUNCSGISPROC)(::GLenum, ::GLenum, ::GLsizei, const ::GLfloat *);
extern "C"
{
  void glTexSubImage1DEXT(::GLenum target, ::GLint level, ::GLint xoffset, ::GLsizei width, ::GLenum format, ::GLenum type, const ::GLvoid *pixels)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexSubImage2DEXT(::GLenum target, ::GLint level, ::GLint xoffset, ::GLint yoffset, ::GLsizei width, ::GLsizei height, ::GLenum format, ::GLenum type, const ::GLvoid *pixels)__attribute__((visibility("default")));
}
typedef void (*PFNGLTEXSUBIMAGE1DEXTPROC)(::GLenum, ::GLint, ::GLint, ::GLsizei, ::GLenum, ::GLenum, const ::GLvoid *);
typedef void (*PFNGLTEXSUBIMAGE2DEXTPROC)(::GLenum, ::GLint, ::GLint, ::GLint, ::GLsizei, ::GLsizei, ::GLenum, ::GLenum, const ::GLvoid *);
extern "C"
{
  void glCopyTexImage1DEXT(::GLenum target, ::GLint level, ::GLenum internalformat, ::GLint x, ::GLint y, ::GLsizei width, ::GLint border)__attribute__((visibility("default")));
}
extern "C"
{
  void glCopyTexImage2DEXT(::GLenum target, ::GLint level, ::GLenum internalformat, ::GLint x, ::GLint y, ::GLsizei width, ::GLsizei height, ::GLint border)__attribute__((visibility("default")));
}
extern "C"
{
  void glCopyTexSubImage1DEXT(::GLenum target, ::GLint level, ::GLint xoffset, ::GLint x, ::GLint y, ::GLsizei width)__attribute__((visibility("default")));
}
extern "C"
{
  void glCopyTexSubImage2DEXT(::GLenum target, ::GLint level, ::GLint xoffset, ::GLint yoffset, ::GLint x, ::GLint y, ::GLsizei width, ::GLsizei height)__attribute__((visibility("default")));
}
extern "C"
{
  void glCopyTexSubImage3DEXT(::GLenum target, ::GLint level, ::GLint xoffset, ::GLint yoffset, ::GLint zoffset, ::GLint x, ::GLint y, ::GLsizei width, ::GLsizei height)__attribute__((visibility("default")));
}
typedef void (*PFNGLCOPYTEXIMAGE1DEXTPROC)(::GLenum, ::GLint, ::GLenum, ::GLint, ::GLint, ::GLsizei, ::GLint);
typedef void (*PFNGLCOPYTEXIMAGE2DEXTPROC)(::GLenum, ::GLint, ::GLenum, ::GLint, ::GLint, ::GLsizei, ::GLsizei, ::GLint);
typedef void (*PFNGLCOPYTEXSUBIMAGE1DEXTPROC)(::GLenum, ::GLint, ::GLint, ::GLint, ::GLint, ::GLsizei);
typedef void (*PFNGLCOPYTEXSUBIMAGE2DEXTPROC)(::GLenum, ::GLint, ::GLint, ::GLint, ::GLint, ::GLint, ::GLsizei, ::GLsizei);
typedef void (*PFNGLCOPYTEXSUBIMAGE3DEXTPROC)(::GLenum, ::GLint, ::GLint, ::GLint, ::GLint, ::GLint, ::GLint, ::GLsizei, ::GLsizei);
extern "C"
{
  void glGetHistogramEXT(::GLenum target, ::GLboolean reset, ::GLenum format, ::GLenum type, ::GLvoid *values)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetHistogramParameterfvEXT(::GLenum target, ::GLenum pname, ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetHistogramParameterivEXT(::GLenum target, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetMinmaxEXT(::GLenum target, ::GLboolean reset, ::GLenum format, ::GLenum type, ::GLvoid *values)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetMinmaxParameterfvEXT(::GLenum target, ::GLenum pname, ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetMinmaxParameterivEXT(::GLenum target, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glHistogramEXT(::GLenum target, ::GLsizei width, ::GLenum internalformat, ::GLboolean sink)__attribute__((visibility("default")));
}
extern "C"
{
  void glMinmaxEXT(::GLenum target, ::GLenum internalformat, ::GLboolean sink)__attribute__((visibility("default")));
}
extern "C"
{
  void glResetHistogramEXT(::GLenum target)__attribute__((visibility("default")));
}
extern "C"
{
  void glResetMinmaxEXT(::GLenum target)__attribute__((visibility("default")));
}
typedef void (*PFNGLGETHISTOGRAMEXTPROC)(::GLenum, ::GLboolean, ::GLenum, ::GLenum, ::GLvoid *);
typedef void (*PFNGLGETHISTOGRAMPARAMETERFVEXTPROC)(::GLenum, ::GLenum, ::GLfloat *);
typedef void (*PFNGLGETHISTOGRAMPARAMETERIVEXTPROC)(::GLenum, ::GLenum, ::GLint *);
typedef void (*PFNGLGETMINMAXEXTPROC)(::GLenum, ::GLboolean, ::GLenum, ::GLenum, ::GLvoid *);
typedef void (*PFNGLGETMINMAXPARAMETERFVEXTPROC)(::GLenum, ::GLenum, ::GLfloat *);
typedef void (*PFNGLGETMINMAXPARAMETERIVEXTPROC)(::GLenum, ::GLenum, ::GLint *);
typedef void (*PFNGLHISTOGRAMEXTPROC)(::GLenum, ::GLsizei, ::GLenum, ::GLboolean);
typedef void (*PFNGLMINMAXEXTPROC)(::GLenum, ::GLenum, ::GLboolean);
typedef void (*PFNGLRESETHISTOGRAMEXTPROC)(::GLenum);
typedef void (*PFNGLRESETMINMAXEXTPROC)(::GLenum);
extern "C"
{
  void glConvolutionFilter1DEXT(::GLenum target, ::GLenum internalformat, ::GLsizei width, ::GLenum format, ::GLenum type, const ::GLvoid *image)__attribute__((visibility("default")));
}
extern "C"
{
  void glConvolutionFilter2DEXT(::GLenum target, ::GLenum internalformat, ::GLsizei width, ::GLsizei height, ::GLenum format, ::GLenum type, const ::GLvoid *image)__attribute__((visibility("default")));
}
extern "C"
{
  void glConvolutionParameterfEXT(::GLenum target, ::GLenum pname, ::GLfloat params)__attribute__((visibility("default")));
}
extern "C"
{
  void glConvolutionParameterfvEXT(::GLenum target, ::GLenum pname, const ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glConvolutionParameteriEXT(::GLenum target, ::GLenum pname, ::GLint params)__attribute__((visibility("default")));
}
extern "C"
{
  void glConvolutionParameterivEXT(::GLenum target, ::GLenum pname, const ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glCopyConvolutionFilter1DEXT(::GLenum target, ::GLenum internalformat, ::GLint x, ::GLint y, ::GLsizei width)__attribute__((visibility("default")));
}
extern "C"
{
  void glCopyConvolutionFilter2DEXT(::GLenum target, ::GLenum internalformat, ::GLint x, ::GLint y, ::GLsizei width, ::GLsizei height)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetConvolutionFilterEXT(::GLenum target, ::GLenum format, ::GLenum type, ::GLvoid *image)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetConvolutionParameterfvEXT(::GLenum target, ::GLenum pname, ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetConvolutionParameterivEXT(::GLenum target, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetSeparableFilterEXT(::GLenum target, ::GLenum format, ::GLenum type, ::GLvoid *row, ::GLvoid *column, ::GLvoid *span)__attribute__((visibility("default")));
}
extern "C"
{
  void glSeparableFilter2DEXT(::GLenum target, ::GLenum internalformat, ::GLsizei width, ::GLsizei height, ::GLenum format, ::GLenum type, const ::GLvoid *row, const ::GLvoid *column)__attribute__((visibility("default")));
}
typedef void (*PFNGLCONVOLUTIONFILTER1DEXTPROC)(::GLenum, ::GLenum, ::GLsizei, ::GLenum, ::GLenum, const ::GLvoid *);
typedef void (*PFNGLCONVOLUTIONFILTER2DEXTPROC)(::GLenum, ::GLenum, ::GLsizei, ::GLsizei, ::GLenum, ::GLenum, const ::GLvoid *);
typedef void (*PFNGLCONVOLUTIONPARAMETERFEXTPROC)(::GLenum, ::GLenum, ::GLfloat);
typedef void (*PFNGLCONVOLUTIONPARAMETERFVEXTPROC)(::GLenum, ::GLenum, const ::GLfloat *);
typedef void (*PFNGLCONVOLUTIONPARAMETERIEXTPROC)(::GLenum, ::GLenum, ::GLint);
typedef void (*PFNGLCONVOLUTIONPARAMETERIVEXTPROC)(::GLenum, ::GLenum, const ::GLint *);
typedef void (*PFNGLCOPYCONVOLUTIONFILTER1DEXTPROC)(::GLenum, ::GLenum, ::GLint, ::GLint, ::GLsizei);
typedef void (*PFNGLCOPYCONVOLUTIONFILTER2DEXTPROC)(::GLenum, ::GLenum, ::GLint, ::GLint, ::GLsizei, ::GLsizei);
typedef void (*PFNGLGETCONVOLUTIONFILTEREXTPROC)(::GLenum, ::GLenum, ::GLenum, ::GLvoid *);
typedef void (*PFNGLGETCONVOLUTIONPARAMETERFVEXTPROC)(::GLenum, ::GLenum, ::GLfloat *);
typedef void (*PFNGLGETCONVOLUTIONPARAMETERIVEXTPROC)(::GLenum, ::GLenum, ::GLint *);
typedef void (*PFNGLGETSEPARABLEFILTEREXTPROC)(::GLenum, ::GLenum, ::GLenum, ::GLvoid *, ::GLvoid *, ::GLvoid *);
typedef void (*PFNGLSEPARABLEFILTER2DEXTPROC)(::GLenum, ::GLenum, ::GLsizei, ::GLsizei, ::GLenum, ::GLenum, const ::GLvoid *, const ::GLvoid *);
extern "C"
{
  void glColorTableSGI(::GLenum target, ::GLenum internalformat, ::GLsizei width, ::GLenum format, ::GLenum type, const ::GLvoid *table)__attribute__((visibility("default")));
}
extern "C"
{
  void glColorTableParameterfvSGI(::GLenum target, ::GLenum pname, const ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glColorTableParameterivSGI(::GLenum target, ::GLenum pname, const ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glCopyColorTableSGI(::GLenum target, ::GLenum internalformat, ::GLint x, ::GLint y, ::GLsizei width)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetColorTableSGI(::GLenum target, ::GLenum format, ::GLenum type, ::GLvoid *table)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetColorTableParameterfvSGI(::GLenum target, ::GLenum pname, ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetColorTableParameterivSGI(::GLenum target, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
typedef void (*PFNGLCOLORTABLESGIPROC)(::GLenum, ::GLenum, ::GLsizei, ::GLenum, ::GLenum, const ::GLvoid *);
typedef void (*PFNGLCOLORTABLEPARAMETERFVSGIPROC)(::GLenum, ::GLenum, const ::GLfloat *);
typedef void (*PFNGLCOLORTABLEPARAMETERIVSGIPROC)(::GLenum, ::GLenum, const ::GLint *);
typedef void (*PFNGLCOPYCOLORTABLESGIPROC)(::GLenum, ::GLenum, ::GLint, ::GLint, ::GLsizei);
typedef void (*PFNGLGETCOLORTABLESGIPROC)(::GLenum, ::GLenum, ::GLenum, ::GLvoid *);
typedef void (*PFNGLGETCOLORTABLEPARAMETERFVSGIPROC)(::GLenum, ::GLenum, ::GLfloat *);
typedef void (*PFNGLGETCOLORTABLEPARAMETERIVSGIPROC)(::GLenum, ::GLenum, ::GLint *);
extern "C"
{
  void glPixelTexGenSGIX(::GLenum mode)__attribute__((visibility("default")));
}
typedef void (*PFNGLPIXELTEXGENSGIXPROC)(::GLenum);
extern "C"
{
  void glPixelTexGenParameteriSGIS(::GLenum pname, ::GLint param)__attribute__((visibility("default")));
}
extern "C"
{
  void glPixelTexGenParameterivSGIS(::GLenum pname, const ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glPixelTexGenParameterfSGIS(::GLenum pname, ::GLfloat param)__attribute__((visibility("default")));
}
extern "C"
{
  void glPixelTexGenParameterfvSGIS(::GLenum pname, const ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetPixelTexGenParameterivSGIS(::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetPixelTexGenParameterfvSGIS(::GLenum pname, ::GLfloat *params)__attribute__((visibility("default")));
}
typedef void (*PFNGLPIXELTEXGENPARAMETERISGISPROC)(::GLenum, ::GLint);
typedef void (*PFNGLPIXELTEXGENPARAMETERIVSGISPROC)(::GLenum, const ::GLint *);
typedef void (*PFNGLPIXELTEXGENPARAMETERFSGISPROC)(::GLenum, ::GLfloat);
typedef void (*PFNGLPIXELTEXGENPARAMETERFVSGISPROC)(::GLenum, const ::GLfloat *);
typedef void (*PFNGLGETPIXELTEXGENPARAMETERIVSGISPROC)(::GLenum, ::GLint *);
typedef void (*PFNGLGETPIXELTEXGENPARAMETERFVSGISPROC)(::GLenum, ::GLfloat *);
extern "C"
{
  void glTexImage4DSGIS(::GLenum target, ::GLint level, ::GLenum internalformat, ::GLsizei width, ::GLsizei height, ::GLsizei depth, ::GLsizei size4d, ::GLint border, ::GLenum format, ::GLenum type, const ::GLvoid *pixels)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexSubImage4DSGIS(::GLenum target, ::GLint level, ::GLint xoffset, ::GLint yoffset, ::GLint zoffset, ::GLint woffset, ::GLsizei width, ::GLsizei height, ::GLsizei depth, ::GLsizei size4d, ::GLenum format, ::GLenum type, const ::GLvoid *pixels)__attribute__((visibility("default")));
}
typedef void (*PFNGLTEXIMAGE4DSGISPROC)(::GLenum, ::GLint, ::GLenum, ::GLsizei, ::GLsizei, ::GLsizei, ::GLsizei, ::GLint, ::GLenum, ::GLenum, const ::GLvoid *);
typedef void (*PFNGLTEXSUBIMAGE4DSGISPROC)(::GLenum, ::GLint, ::GLint, ::GLint, ::GLint, ::GLint, ::GLsizei, ::GLsizei, ::GLsizei, ::GLsizei, ::GLenum, ::GLenum, const ::GLvoid *);
extern "C"
{
  ::GLboolean glAreTexturesResidentEXT(::GLsizei n, const ::GLuint *textures, ::GLboolean *residences)__attribute__((visibility("default")));
}
extern "C"
{
  void glBindTextureEXT(::GLenum target, ::GLuint texture)__attribute__((visibility("default")));
}
extern "C"
{
  void glDeleteTexturesEXT(::GLsizei n, const ::GLuint *textures)__attribute__((visibility("default")));
}
extern "C"
{
  void glGenTexturesEXT(::GLsizei n, ::GLuint *textures)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLboolean glIsTextureEXT(::GLuint texture)__attribute__((visibility("default")));
}
extern "C"
{
  void glPrioritizeTexturesEXT(::GLsizei n, const ::GLuint *textures, const ::GLclampf *priorities)__attribute__((visibility("default")));
}
typedef ::GLboolean (*PFNGLARETEXTURESRESIDENTEXTPROC)(::GLsizei, const ::GLuint *, ::GLboolean *);
typedef void (*PFNGLBINDTEXTUREEXTPROC)(::GLenum, ::GLuint);
typedef void (*PFNGLDELETETEXTURESEXTPROC)(::GLsizei, const ::GLuint *);
typedef void (*PFNGLGENTEXTURESEXTPROC)(::GLsizei, ::GLuint *);
typedef ::GLboolean (*PFNGLISTEXTUREEXTPROC)(::GLuint);
typedef void (*PFNGLPRIORITIZETEXTURESEXTPROC)(::GLsizei, const ::GLuint *, const ::GLclampf *);
extern "C"
{
  void glDetailTexFuncSGIS(::GLenum target, ::GLsizei n, const ::GLfloat *points)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetDetailTexFuncSGIS(::GLenum target, ::GLfloat *points)__attribute__((visibility("default")));
}
typedef void (*PFNGLDETAILTEXFUNCSGISPROC)(::GLenum, ::GLsizei, const ::GLfloat *);
typedef void (*PFNGLGETDETAILTEXFUNCSGISPROC)(::GLenum, ::GLfloat *);
extern "C"
{
  void glSharpenTexFuncSGIS(::GLenum target, ::GLsizei n, const ::GLfloat *points)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetSharpenTexFuncSGIS(::GLenum target, ::GLfloat *points)__attribute__((visibility("default")));
}
typedef void (*PFNGLSHARPENTEXFUNCSGISPROC)(::GLenum, ::GLsizei, const ::GLfloat *);
typedef void (*PFNGLGETSHARPENTEXFUNCSGISPROC)(::GLenum, ::GLfloat *);
extern "C"
{
  void glSampleMaskSGIS(::GLclampf value, ::GLboolean invert)__attribute__((visibility("default")));
}
extern "C"
{
  void glSamplePatternSGIS(::GLenum pattern)__attribute__((visibility("default")));
}
typedef void (*PFNGLSAMPLEMASKSGISPROC)(::GLclampf, ::GLboolean);
typedef void (*PFNGLSAMPLEPATTERNSGISPROC)(::GLenum);
extern "C"
{
  void glArrayElementEXT(::GLint i)__attribute__((visibility("default")));
}
extern "C"
{
  void glColorPointerEXT(::GLint size, ::GLenum type, ::GLsizei stride, ::GLsizei count, const ::GLvoid *pointer)__attribute__((visibility("default")));
}
extern "C"
{
  void glDrawArraysEXT(::GLenum mode, ::GLint first, ::GLsizei count)__attribute__((visibility("default")));
}
extern "C"
{
  void glEdgeFlagPointerEXT(::GLsizei stride, ::GLsizei count, const ::GLboolean *pointer)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetPointervEXT(::GLenum pname, ::GLvoid **params)__attribute__((visibility("default")));
}
extern "C"
{
  void glIndexPointerEXT(::GLenum type, ::GLsizei stride, ::GLsizei count, const ::GLvoid *pointer)__attribute__((visibility("default")));
}
extern "C"
{
  void glNormalPointerEXT(::GLenum type, ::GLsizei stride, ::GLsizei count, const ::GLvoid *pointer)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexCoordPointerEXT(::GLint size, ::GLenum type, ::GLsizei stride, ::GLsizei count, const ::GLvoid *pointer)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexPointerEXT(::GLint size, ::GLenum type, ::GLsizei stride, ::GLsizei count, const ::GLvoid *pointer)__attribute__((visibility("default")));
}
typedef void (*PFNGLARRAYELEMENTEXTPROC)(::GLint);
typedef void (*PFNGLCOLORPOINTEREXTPROC)(::GLint, ::GLenum, ::GLsizei, ::GLsizei, const ::GLvoid *);
typedef void (*PFNGLDRAWARRAYSEXTPROC)(::GLenum, ::GLint, ::GLsizei);
typedef void (*PFNGLEDGEFLAGPOINTEREXTPROC)(::GLsizei, ::GLsizei, const ::GLboolean *);
typedef void (*PFNGLGETPOINTERVEXTPROC)(::GLenum, ::GLvoid **);
typedef void (*PFNGLINDEXPOINTEREXTPROC)(::GLenum, ::GLsizei, ::GLsizei, const ::GLvoid *);
typedef void (*PFNGLNORMALPOINTEREXTPROC)(::GLenum, ::GLsizei, ::GLsizei, const ::GLvoid *);
typedef void (*PFNGLTEXCOORDPOINTEREXTPROC)(::GLint, ::GLenum, ::GLsizei, ::GLsizei, const ::GLvoid *);
typedef void (*PFNGLVERTEXPOINTEREXTPROC)(::GLint, ::GLenum, ::GLsizei, ::GLsizei, const ::GLvoid *);
extern "C"
{
  void glBlendEquationEXT(::GLenum mode)__attribute__((visibility("default")));
}
typedef void (*PFNGLBLENDEQUATIONEXTPROC)(::GLenum);
extern "C"
{
  void glSpriteParameterfSGIX(::GLenum pname, ::GLfloat param)__attribute__((visibility("default")));
}
extern "C"
{
  void glSpriteParameterfvSGIX(::GLenum pname, const ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glSpriteParameteriSGIX(::GLenum pname, ::GLint param)__attribute__((visibility("default")));
}
extern "C"
{
  void glSpriteParameterivSGIX(::GLenum pname, const ::GLint *params)__attribute__((visibility("default")));
}
typedef void (*PFNGLSPRITEPARAMETERFSGIXPROC)(::GLenum, ::GLfloat);
typedef void (*PFNGLSPRITEPARAMETERFVSGIXPROC)(::GLenum, const ::GLfloat *);
typedef void (*PFNGLSPRITEPARAMETERISGIXPROC)(::GLenum, ::GLint);
typedef void (*PFNGLSPRITEPARAMETERIVSGIXPROC)(::GLenum, const ::GLint *);
extern "C"
{
  void glPointParameterfEXT(::GLenum pname, ::GLfloat param)__attribute__((visibility("default")));
}
extern "C"
{
  void glPointParameterfvEXT(::GLenum pname, const ::GLfloat *params)__attribute__((visibility("default")));
}
typedef void (*PFNGLPOINTPARAMETERFEXTPROC)(::GLenum, ::GLfloat);
typedef void (*PFNGLPOINTPARAMETERFVEXTPROC)(::GLenum, const ::GLfloat *);
extern "C"
{
  void glPointParameterfSGIS(::GLenum pname, ::GLfloat param)__attribute__((visibility("default")));
}
extern "C"
{
  void glPointParameterfvSGIS(::GLenum pname, const ::GLfloat *params)__attribute__((visibility("default")));
}
typedef void (*PFNGLPOINTPARAMETERFSGISPROC)(::GLenum, ::GLfloat);
typedef void (*PFNGLPOINTPARAMETERFVSGISPROC)(::GLenum, const ::GLfloat *);
extern "C"
{
  ::GLint glGetInstrumentsSGIX()__attribute__((visibility("default")));
}
extern "C"
{
  void glInstrumentsBufferSGIX(::GLsizei size, ::GLint *buffer)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLint glPollInstrumentsSGIX(::GLint *marker_p)__attribute__((visibility("default")));
}
extern "C"
{
  void glReadInstrumentsSGIX(::GLint marker)__attribute__((visibility("default")));
}
extern "C"
{
  void glStartInstrumentsSGIX()__attribute__((visibility("default")));
}
extern "C"
{
  void glStopInstrumentsSGIX(::GLint marker)__attribute__((visibility("default")));
}
typedef ::GLint (*PFNGLGETINSTRUMENTSSGIXPROC)();
typedef void (*PFNGLINSTRUMENTSBUFFERSGIXPROC)(::GLsizei, ::GLint *);
typedef ::GLint (*PFNGLPOLLINSTRUMENTSSGIXPROC)(::GLint *);
typedef void (*PFNGLREADINSTRUMENTSSGIXPROC)(::GLint);
typedef void (*PFNGLSTARTINSTRUMENTSSGIXPROC)();
typedef void (*PFNGLSTOPINSTRUMENTSSGIXPROC)(::GLint);
extern "C"
{
  void glFrameZoomSGIX(::GLint factor)__attribute__((visibility("default")));
}
typedef void (*PFNGLFRAMEZOOMSGIXPROC)(::GLint);
extern "C"
{
  void glTagSampleBufferSGIX()__attribute__((visibility("default")));
}
typedef void (*PFNGLTAGSAMPLEBUFFERSGIXPROC)();
extern "C"
{
  void glDeformationMap3dSGIX(::GLenum target, ::GLdouble u1, ::GLdouble u2, ::GLint ustride, ::GLint uorder, ::GLdouble v1, ::GLdouble v2, ::GLint vstride, ::GLint vorder, ::GLdouble w1, ::GLdouble w2, ::GLint wstride, ::GLint worder, const ::GLdouble *points)__attribute__((visibility("default")));
}
extern "C"
{
  void glDeformationMap3fSGIX(::GLenum target, ::GLfloat u1, ::GLfloat u2, ::GLint ustride, ::GLint uorder, ::GLfloat v1, ::GLfloat v2, ::GLint vstride, ::GLint vorder, ::GLfloat w1, ::GLfloat w2, ::GLint wstride, ::GLint worder, const ::GLfloat *points)__attribute__((visibility("default")));
}
extern "C"
{
  void glDeformSGIX(::GLbitfield mask)__attribute__((visibility("default")));
}
extern "C"
{
  void glLoadIdentityDeformationMapSGIX(::GLbitfield mask)__attribute__((visibility("default")));
}
typedef void (*PFNGLDEFORMATIONMAP3DSGIXPROC)(::GLenum, ::GLdouble, ::GLdouble, ::GLint, ::GLint, ::GLdouble, ::GLdouble, ::GLint, ::GLint, ::GLdouble, ::GLdouble, ::GLint, ::GLint, const ::GLdouble *);
typedef void (*PFNGLDEFORMATIONMAP3FSGIXPROC)(::GLenum, ::GLfloat, ::GLfloat, ::GLint, ::GLint, ::GLfloat, ::GLfloat, ::GLint, ::GLint, ::GLfloat, ::GLfloat, ::GLint, ::GLint, const ::GLfloat *);
typedef void (*PFNGLDEFORMSGIXPROC)(::GLbitfield);
typedef void (*PFNGLLOADIDENTITYDEFORMATIONMAPSGIXPROC)(::GLbitfield);
extern "C"
{
  void glReferencePlaneSGIX(const ::GLdouble *equation)__attribute__((visibility("default")));
}
typedef void (*PFNGLREFERENCEPLANESGIXPROC)(const ::GLdouble *);
extern "C"
{
  void glFlushRasterSGIX()__attribute__((visibility("default")));
}
typedef void (*PFNGLFLUSHRASTERSGIXPROC)();
extern "C"
{
  void glFogFuncSGIS(::GLsizei n, const ::GLfloat *points)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetFogFuncSGIS(::GLfloat *points)__attribute__((visibility("default")));
}
typedef void (*PFNGLFOGFUNCSGISPROC)(::GLsizei, const ::GLfloat *);
typedef void (*PFNGLGETFOGFUNCSGISPROC)(::GLfloat *);
extern "C"
{
  void glImageTransformParameteriHP(::GLenum target, ::GLenum pname, ::GLint param)__attribute__((visibility("default")));
}
extern "C"
{
  void glImageTransformParameterfHP(::GLenum target, ::GLenum pname, ::GLfloat param)__attribute__((visibility("default")));
}
extern "C"
{
  void glImageTransformParameterivHP(::GLenum target, ::GLenum pname, const ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glImageTransformParameterfvHP(::GLenum target, ::GLenum pname, const ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetImageTransformParameterivHP(::GLenum target, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetImageTransformParameterfvHP(::GLenum target, ::GLenum pname, ::GLfloat *params)__attribute__((visibility("default")));
}
typedef void (*PFNGLIMAGETRANSFORMPARAMETERIHPPROC)(::GLenum, ::GLenum, ::GLint);
typedef void (*PFNGLIMAGETRANSFORMPARAMETERFHPPROC)(::GLenum, ::GLenum, ::GLfloat);
typedef void (*PFNGLIMAGETRANSFORMPARAMETERIVHPPROC)(::GLenum, ::GLenum, const ::GLint *);
typedef void (*PFNGLIMAGETRANSFORMPARAMETERFVHPPROC)(::GLenum, ::GLenum, const ::GLfloat *);
typedef void (*PFNGLGETIMAGETRANSFORMPARAMETERIVHPPROC)(::GLenum, ::GLenum, ::GLint *);
typedef void (*PFNGLGETIMAGETRANSFORMPARAMETERFVHPPROC)(::GLenum, ::GLenum, ::GLfloat *);
extern "C"
{
  void glColorSubTableEXT(::GLenum target, ::GLsizei start, ::GLsizei count, ::GLenum format, ::GLenum type, const ::GLvoid *data)__attribute__((visibility("default")));
}
extern "C"
{
  void glCopyColorSubTableEXT(::GLenum target, ::GLsizei start, ::GLint x, ::GLint y, ::GLsizei width)__attribute__((visibility("default")));
}
typedef void (*PFNGLCOLORSUBTABLEEXTPROC)(::GLenum, ::GLsizei, ::GLsizei, ::GLenum, ::GLenum, const ::GLvoid *);
typedef void (*PFNGLCOPYCOLORSUBTABLEEXTPROC)(::GLenum, ::GLsizei, ::GLint, ::GLint, ::GLsizei);
extern "C"
{
  void glHintPGI(::GLenum target, ::GLint mode)__attribute__((visibility("default")));
}
typedef void (*PFNGLHINTPGIPROC)(::GLenum, ::GLint);
extern "C"
{
  void glColorTableEXT(::GLenum target, ::GLenum internalFormat, ::GLsizei width, ::GLenum format, ::GLenum type, const ::GLvoid *table)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetColorTableEXT(::GLenum target, ::GLenum format, ::GLenum type, ::GLvoid *data)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetColorTableParameterivEXT(::GLenum target, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetColorTableParameterfvEXT(::GLenum target, ::GLenum pname, ::GLfloat *params)__attribute__((visibility("default")));
}
typedef void (*PFNGLCOLORTABLEEXTPROC)(::GLenum, ::GLenum, ::GLsizei, ::GLenum, ::GLenum, const ::GLvoid *);
typedef void (*PFNGLGETCOLORTABLEEXTPROC)(::GLenum, ::GLenum, ::GLenum, ::GLvoid *);
typedef void (*PFNGLGETCOLORTABLEPARAMETERIVEXTPROC)(::GLenum, ::GLenum, ::GLint *);
typedef void (*PFNGLGETCOLORTABLEPARAMETERFVEXTPROC)(::GLenum, ::GLenum, ::GLfloat *);
extern "C"
{
  void glGetListParameterfvSGIX(::GLuint list, ::GLenum pname, ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetListParameterivSGIX(::GLuint list, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glListParameterfSGIX(::GLuint list, ::GLenum pname, ::GLfloat param)__attribute__((visibility("default")));
}
extern "C"
{
  void glListParameterfvSGIX(::GLuint list, ::GLenum pname, const ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glListParameteriSGIX(::GLuint list, ::GLenum pname, ::GLint param)__attribute__((visibility("default")));
}
extern "C"
{
  void glListParameterivSGIX(::GLuint list, ::GLenum pname, const ::GLint *params)__attribute__((visibility("default")));
}
typedef void (*PFNGLGETLISTPARAMETERFVSGIXPROC)(::GLuint, ::GLenum, ::GLfloat *);
typedef void (*PFNGLGETLISTPARAMETERIVSGIXPROC)(::GLuint, ::GLenum, ::GLint *);
typedef void (*PFNGLLISTPARAMETERFSGIXPROC)(::GLuint, ::GLenum, ::GLfloat);
typedef void (*PFNGLLISTPARAMETERFVSGIXPROC)(::GLuint, ::GLenum, const ::GLfloat *);
typedef void (*PFNGLLISTPARAMETERISGIXPROC)(::GLuint, ::GLenum, ::GLint);
typedef void (*PFNGLLISTPARAMETERIVSGIXPROC)(::GLuint, ::GLenum, const ::GLint *);
extern "C"
{
  void glIndexMaterialEXT(::GLenum face, ::GLenum mode)__attribute__((visibility("default")));
}
typedef void (*PFNGLINDEXMATERIALEXTPROC)(::GLenum, ::GLenum);
extern "C"
{
  void glIndexFuncEXT(::GLenum func, ::GLclampf ref)__attribute__((visibility("default")));
}
typedef void (*PFNGLINDEXFUNCEXTPROC)(::GLenum, ::GLclampf);
extern "C"
{
  void glLockArraysEXT(::GLint first, ::GLsizei count)__attribute__((visibility("default")));
}
extern "C"
{
  void glUnlockArraysEXT()__attribute__((visibility("default")));
}
typedef void (*PFNGLLOCKARRAYSEXTPROC)(::GLint, ::GLsizei);
typedef void (*PFNGLUNLOCKARRAYSEXTPROC)();
extern "C"
{
  void glCullParameterdvEXT(::GLenum pname, ::GLdouble *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glCullParameterfvEXT(::GLenum pname, ::GLfloat *params)__attribute__((visibility("default")));
}
typedef void (*PFNGLCULLPARAMETERDVEXTPROC)(::GLenum, ::GLdouble *);
typedef void (*PFNGLCULLPARAMETERFVEXTPROC)(::GLenum, ::GLfloat *);
extern "C"
{
  void glFragmentColorMaterialSGIX(::GLenum face, ::GLenum mode)__attribute__((visibility("default")));
}
extern "C"
{
  void glFragmentLightfSGIX(::GLenum light, ::GLenum pname, ::GLfloat param)__attribute__((visibility("default")));
}
extern "C"
{
  void glFragmentLightfvSGIX(::GLenum light, ::GLenum pname, const ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glFragmentLightiSGIX(::GLenum light, ::GLenum pname, ::GLint param)__attribute__((visibility("default")));
}
extern "C"
{
  void glFragmentLightivSGIX(::GLenum light, ::GLenum pname, const ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glFragmentLightModelfSGIX(::GLenum pname, ::GLfloat param)__attribute__((visibility("default")));
}
extern "C"
{
  void glFragmentLightModelfvSGIX(::GLenum pname, const ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glFragmentLightModeliSGIX(::GLenum pname, ::GLint param)__attribute__((visibility("default")));
}
extern "C"
{
  void glFragmentLightModelivSGIX(::GLenum pname, const ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glFragmentMaterialfSGIX(::GLenum face, ::GLenum pname, ::GLfloat param)__attribute__((visibility("default")));
}
extern "C"
{
  void glFragmentMaterialfvSGIX(::GLenum face, ::GLenum pname, const ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glFragmentMaterialiSGIX(::GLenum face, ::GLenum pname, ::GLint param)__attribute__((visibility("default")));
}
extern "C"
{
  void glFragmentMaterialivSGIX(::GLenum face, ::GLenum pname, const ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetFragmentLightfvSGIX(::GLenum light, ::GLenum pname, ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetFragmentLightivSGIX(::GLenum light, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetFragmentMaterialfvSGIX(::GLenum face, ::GLenum pname, ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetFragmentMaterialivSGIX(::GLenum face, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glLightEnviSGIX(::GLenum pname, ::GLint param)__attribute__((visibility("default")));
}
typedef void (*PFNGLFRAGMENTCOLORMATERIALSGIXPROC)(::GLenum, ::GLenum);
typedef void (*PFNGLFRAGMENTLIGHTFSGIXPROC)(::GLenum, ::GLenum, ::GLfloat);
typedef void (*PFNGLFRAGMENTLIGHTFVSGIXPROC)(::GLenum, ::GLenum, const ::GLfloat *);
typedef void (*PFNGLFRAGMENTLIGHTISGIXPROC)(::GLenum, ::GLenum, ::GLint);
typedef void (*PFNGLFRAGMENTLIGHTIVSGIXPROC)(::GLenum, ::GLenum, const ::GLint *);
typedef void (*PFNGLFRAGMENTLIGHTMODELFSGIXPROC)(::GLenum, ::GLfloat);
typedef void (*PFNGLFRAGMENTLIGHTMODELFVSGIXPROC)(::GLenum, const ::GLfloat *);
typedef void (*PFNGLFRAGMENTLIGHTMODELISGIXPROC)(::GLenum, ::GLint);
typedef void (*PFNGLFRAGMENTLIGHTMODELIVSGIXPROC)(::GLenum, const ::GLint *);
typedef void (*PFNGLFRAGMENTMATERIALFSGIXPROC)(::GLenum, ::GLenum, ::GLfloat);
typedef void (*PFNGLFRAGMENTMATERIALFVSGIXPROC)(::GLenum, ::GLenum, const ::GLfloat *);
typedef void (*PFNGLFRAGMENTMATERIALISGIXPROC)(::GLenum, ::GLenum, ::GLint);
typedef void (*PFNGLFRAGMENTMATERIALIVSGIXPROC)(::GLenum, ::GLenum, const ::GLint *);
typedef void (*PFNGLGETFRAGMENTLIGHTFVSGIXPROC)(::GLenum, ::GLenum, ::GLfloat *);
typedef void (*PFNGLGETFRAGMENTLIGHTIVSGIXPROC)(::GLenum, ::GLenum, ::GLint *);
typedef void (*PFNGLGETFRAGMENTMATERIALFVSGIXPROC)(::GLenum, ::GLenum, ::GLfloat *);
typedef void (*PFNGLGETFRAGMENTMATERIALIVSGIXPROC)(::GLenum, ::GLenum, ::GLint *);
typedef void (*PFNGLLIGHTENVISGIXPROC)(::GLenum, ::GLint);
extern "C"
{
  void glDrawRangeElementsEXT(::GLenum mode, ::GLuint start, ::GLuint end, ::GLsizei count, ::GLenum type, const ::GLvoid *indices)__attribute__((visibility("default")));
}
typedef void (*PFNGLDRAWRANGEELEMENTSEXTPROC)(::GLenum, ::GLuint, ::GLuint, ::GLsizei, ::GLenum, const ::GLvoid *);
extern "C"
{
  void glApplyTextureEXT(::GLenum mode)__attribute__((visibility("default")));
}
extern "C"
{
  void glTextureLightEXT(::GLenum pname)__attribute__((visibility("default")));
}
extern "C"
{
  void glTextureMaterialEXT(::GLenum face, ::GLenum mode)__attribute__((visibility("default")));
}
typedef void (*PFNGLAPPLYTEXTUREEXTPROC)(::GLenum);
typedef void (*PFNGLTEXTURELIGHTEXTPROC)(::GLenum);
typedef void (*PFNGLTEXTUREMATERIALEXTPROC)(::GLenum, ::GLenum);
extern "C"
{
  void glAsyncMarkerSGIX(::GLuint marker)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLint glFinishAsyncSGIX(::GLuint *markerp)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLint glPollAsyncSGIX(::GLuint *markerp)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLuint glGenAsyncMarkersSGIX(::GLsizei range)__attribute__((visibility("default")));
}
extern "C"
{
  void glDeleteAsyncMarkersSGIX(::GLuint marker, ::GLsizei range)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLboolean glIsAsyncMarkerSGIX(::GLuint marker)__attribute__((visibility("default")));
}
typedef void (*PFNGLASYNCMARKERSGIXPROC)(::GLuint);
typedef ::GLint (*PFNGLFINISHASYNCSGIXPROC)(::GLuint *);
typedef ::GLint (*PFNGLPOLLASYNCSGIXPROC)(::GLuint *);
typedef ::GLuint (*PFNGLGENASYNCMARKERSSGIXPROC)(::GLsizei);
typedef void (*PFNGLDELETEASYNCMARKERSSGIXPROC)(::GLuint, ::GLsizei);
typedef ::GLboolean (*PFNGLISASYNCMARKERSGIXPROC)(::GLuint);
extern "C"
{
  void glVertexPointervINTEL(::GLint size, ::GLenum type, const ::GLvoid **pointer)__attribute__((visibility("default")));
}
extern "C"
{
  void glNormalPointervINTEL(::GLenum type, const ::GLvoid **pointer)__attribute__((visibility("default")));
}
extern "C"
{
  void glColorPointervINTEL(::GLint size, ::GLenum type, const ::GLvoid **pointer)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexCoordPointervINTEL(::GLint size, ::GLenum type, const ::GLvoid **pointer)__attribute__((visibility("default")));
}
typedef void (*PFNGLVERTEXPOINTERVINTELPROC)(::GLint, ::GLenum, const ::GLvoid **);
typedef void (*PFNGLNORMALPOINTERVINTELPROC)(::GLenum, const ::GLvoid **);
typedef void (*PFNGLCOLORPOINTERVINTELPROC)(::GLint, ::GLenum, const ::GLvoid **);
typedef void (*PFNGLTEXCOORDPOINTERVINTELPROC)(::GLint, ::GLenum, const ::GLvoid **);
extern "C"
{
  void glPixelTransformParameteriEXT(::GLenum target, ::GLenum pname, ::GLint param)__attribute__((visibility("default")));
}
extern "C"
{
  void glPixelTransformParameterfEXT(::GLenum target, ::GLenum pname, ::GLfloat param)__attribute__((visibility("default")));
}
extern "C"
{
  void glPixelTransformParameterivEXT(::GLenum target, ::GLenum pname, const ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glPixelTransformParameterfvEXT(::GLenum target, ::GLenum pname, const ::GLfloat *params)__attribute__((visibility("default")));
}
typedef void (*PFNGLPIXELTRANSFORMPARAMETERIEXTPROC)(::GLenum, ::GLenum, ::GLint);
typedef void (*PFNGLPIXELTRANSFORMPARAMETERFEXTPROC)(::GLenum, ::GLenum, ::GLfloat);
typedef void (*PFNGLPIXELTRANSFORMPARAMETERIVEXTPROC)(::GLenum, ::GLenum, const ::GLint *);
typedef void (*PFNGLPIXELTRANSFORMPARAMETERFVEXTPROC)(::GLenum, ::GLenum, const ::GLfloat *);
extern "C"
{
  void glSecondaryColor3bEXT(::GLbyte red, ::GLbyte green, ::GLbyte blue)__attribute__((visibility("default")));
}
extern "C"
{
  void glSecondaryColor3bvEXT(const ::GLbyte *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glSecondaryColor3dEXT(::GLdouble red, ::GLdouble green, ::GLdouble blue)__attribute__((visibility("default")));
}
extern "C"
{
  void glSecondaryColor3dvEXT(const ::GLdouble *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glSecondaryColor3fEXT(::GLfloat red, ::GLfloat green, ::GLfloat blue)__attribute__((visibility("default")));
}
extern "C"
{
  void glSecondaryColor3fvEXT(const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glSecondaryColor3iEXT(::GLint red, ::GLint green, ::GLint blue)__attribute__((visibility("default")));
}
extern "C"
{
  void glSecondaryColor3ivEXT(const ::GLint *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glSecondaryColor3sEXT(::GLshort red, ::GLshort green, ::GLshort blue)__attribute__((visibility("default")));
}
extern "C"
{
  void glSecondaryColor3svEXT(const ::GLshort *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glSecondaryColor3ubEXT(::GLubyte red, ::GLubyte green, ::GLubyte blue)__attribute__((visibility("default")));
}
extern "C"
{
  void glSecondaryColor3ubvEXT(const ::GLubyte *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glSecondaryColor3uiEXT(::GLuint red, ::GLuint green, ::GLuint blue)__attribute__((visibility("default")));
}
extern "C"
{
  void glSecondaryColor3uivEXT(const ::GLuint *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glSecondaryColor3usEXT(::GLushort red, ::GLushort green, ::GLushort blue)__attribute__((visibility("default")));
}
extern "C"
{
  void glSecondaryColor3usvEXT(const ::GLushort *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glSecondaryColorPointerEXT(::GLint size, ::GLenum type, ::GLsizei stride, const ::GLvoid *pointer)__attribute__((visibility("default")));
}
typedef void (*PFNGLSECONDARYCOLOR3BEXTPROC)(::GLbyte, ::GLbyte, ::GLbyte);
typedef void (*PFNGLSECONDARYCOLOR3BVEXTPROC)(const ::GLbyte *);
typedef void (*PFNGLSECONDARYCOLOR3DEXTPROC)(::GLdouble, ::GLdouble, ::GLdouble);
typedef void (*PFNGLSECONDARYCOLOR3DVEXTPROC)(const ::GLdouble *);
typedef void (*PFNGLSECONDARYCOLOR3FEXTPROC)(::GLfloat, ::GLfloat, ::GLfloat);
typedef void (*PFNGLSECONDARYCOLOR3FVEXTPROC)(const ::GLfloat *);
typedef void (*PFNGLSECONDARYCOLOR3IEXTPROC)(::GLint, ::GLint, ::GLint);
typedef void (*PFNGLSECONDARYCOLOR3IVEXTPROC)(const ::GLint *);
typedef void (*PFNGLSECONDARYCOLOR3SEXTPROC)(::GLshort, ::GLshort, ::GLshort);
typedef void (*PFNGLSECONDARYCOLOR3SVEXTPROC)(const ::GLshort *);
typedef void (*PFNGLSECONDARYCOLOR3UBEXTPROC)(::GLubyte, ::GLubyte, ::GLubyte);
typedef void (*PFNGLSECONDARYCOLOR3UBVEXTPROC)(const ::GLubyte *);
typedef void (*PFNGLSECONDARYCOLOR3UIEXTPROC)(::GLuint, ::GLuint, ::GLuint);
typedef void (*PFNGLSECONDARYCOLOR3UIVEXTPROC)(const ::GLuint *);
typedef void (*PFNGLSECONDARYCOLOR3USEXTPROC)(::GLushort, ::GLushort, ::GLushort);
typedef void (*PFNGLSECONDARYCOLOR3USVEXTPROC)(const ::GLushort *);
typedef void (*PFNGLSECONDARYCOLORPOINTEREXTPROC)(::GLint, ::GLenum, ::GLsizei, const ::GLvoid *);
extern "C"
{
  void glTextureNormalEXT(::GLenum mode)__attribute__((visibility("default")));
}
typedef void (*PFNGLTEXTURENORMALEXTPROC)(::GLenum);
extern "C"
{
  void glMultiDrawArraysEXT(::GLenum mode, const ::GLint *first, const ::GLsizei *count, ::GLsizei primcount)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiDrawElementsEXT(::GLenum mode, const ::GLsizei *count, ::GLenum type, const ::GLvoid **indices, ::GLsizei primcount)__attribute__((visibility("default")));
}
typedef void (*PFNGLMULTIDRAWARRAYSEXTPROC)(::GLenum, const ::GLint *, const ::GLsizei *, ::GLsizei);
typedef void (*PFNGLMULTIDRAWELEMENTSEXTPROC)(::GLenum, const ::GLsizei *, ::GLenum, const ::GLvoid **, ::GLsizei);
extern "C"
{
  void glFogCoordfEXT(::GLfloat coord)__attribute__((visibility("default")));
}
extern "C"
{
  void glFogCoordfvEXT(const ::GLfloat *coord)__attribute__((visibility("default")));
}
extern "C"
{
  void glFogCoorddEXT(::GLdouble coord)__attribute__((visibility("default")));
}
extern "C"
{
  void glFogCoorddvEXT(const ::GLdouble *coord)__attribute__((visibility("default")));
}
extern "C"
{
  void glFogCoordPointerEXT(::GLenum type, ::GLsizei stride, const ::GLvoid *pointer)__attribute__((visibility("default")));
}
typedef void (*PFNGLFOGCOORDFEXTPROC)(::GLfloat);
typedef void (*PFNGLFOGCOORDFVEXTPROC)(const ::GLfloat *);
typedef void (*PFNGLFOGCOORDDEXTPROC)(::GLdouble);
typedef void (*PFNGLFOGCOORDDVEXTPROC)(const ::GLdouble *);
typedef void (*PFNGLFOGCOORDPOINTEREXTPROC)(::GLenum, ::GLsizei, const ::GLvoid *);
extern "C"
{
  void glTangent3bEXT(::GLbyte tx, ::GLbyte ty, ::GLbyte tz)__attribute__((visibility("default")));
}
extern "C"
{
  void glTangent3bvEXT(const ::GLbyte *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glTangent3dEXT(::GLdouble tx, ::GLdouble ty, ::GLdouble tz)__attribute__((visibility("default")));
}
extern "C"
{
  void glTangent3dvEXT(const ::GLdouble *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glTangent3fEXT(::GLfloat tx, ::GLfloat ty, ::GLfloat tz)__attribute__((visibility("default")));
}
extern "C"
{
  void glTangent3fvEXT(const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glTangent3iEXT(::GLint tx, ::GLint ty, ::GLint tz)__attribute__((visibility("default")));
}
extern "C"
{
  void glTangent3ivEXT(const ::GLint *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glTangent3sEXT(::GLshort tx, ::GLshort ty, ::GLshort tz)__attribute__((visibility("default")));
}
extern "C"
{
  void glTangent3svEXT(const ::GLshort *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glBinormal3bEXT(::GLbyte bx, ::GLbyte by, ::GLbyte bz)__attribute__((visibility("default")));
}
extern "C"
{
  void glBinormal3bvEXT(const ::GLbyte *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glBinormal3dEXT(::GLdouble bx, ::GLdouble by, ::GLdouble bz)__attribute__((visibility("default")));
}
extern "C"
{
  void glBinormal3dvEXT(const ::GLdouble *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glBinormal3fEXT(::GLfloat bx, ::GLfloat by, ::GLfloat bz)__attribute__((visibility("default")));
}
extern "C"
{
  void glBinormal3fvEXT(const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glBinormal3iEXT(::GLint bx, ::GLint by, ::GLint bz)__attribute__((visibility("default")));
}
extern "C"
{
  void glBinormal3ivEXT(const ::GLint *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glBinormal3sEXT(::GLshort bx, ::GLshort by, ::GLshort bz)__attribute__((visibility("default")));
}
extern "C"
{
  void glBinormal3svEXT(const ::GLshort *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glTangentPointerEXT(::GLenum type, ::GLsizei stride, const ::GLvoid *pointer)__attribute__((visibility("default")));
}
extern "C"
{
  void glBinormalPointerEXT(::GLenum type, ::GLsizei stride, const ::GLvoid *pointer)__attribute__((visibility("default")));
}
typedef void (*PFNGLTANGENT3BEXTPROC)(::GLbyte, ::GLbyte, ::GLbyte);
typedef void (*PFNGLTANGENT3BVEXTPROC)(const ::GLbyte *);
typedef void (*PFNGLTANGENT3DEXTPROC)(::GLdouble, ::GLdouble, ::GLdouble);
typedef void (*PFNGLTANGENT3DVEXTPROC)(const ::GLdouble *);
typedef void (*PFNGLTANGENT3FEXTPROC)(::GLfloat, ::GLfloat, ::GLfloat);
typedef void (*PFNGLTANGENT3FVEXTPROC)(const ::GLfloat *);
typedef void (*PFNGLTANGENT3IEXTPROC)(::GLint, ::GLint, ::GLint);
typedef void (*PFNGLTANGENT3IVEXTPROC)(const ::GLint *);
typedef void (*PFNGLTANGENT3SEXTPROC)(::GLshort, ::GLshort, ::GLshort);
typedef void (*PFNGLTANGENT3SVEXTPROC)(const ::GLshort *);
typedef void (*PFNGLBINORMAL3BEXTPROC)(::GLbyte, ::GLbyte, ::GLbyte);
typedef void (*PFNGLBINORMAL3BVEXTPROC)(const ::GLbyte *);
typedef void (*PFNGLBINORMAL3DEXTPROC)(::GLdouble, ::GLdouble, ::GLdouble);
typedef void (*PFNGLBINORMAL3DVEXTPROC)(const ::GLdouble *);
typedef void (*PFNGLBINORMAL3FEXTPROC)(::GLfloat, ::GLfloat, ::GLfloat);
typedef void (*PFNGLBINORMAL3FVEXTPROC)(const ::GLfloat *);
typedef void (*PFNGLBINORMAL3IEXTPROC)(::GLint, ::GLint, ::GLint);
typedef void (*PFNGLBINORMAL3IVEXTPROC)(const ::GLint *);
typedef void (*PFNGLBINORMAL3SEXTPROC)(::GLshort, ::GLshort, ::GLshort);
typedef void (*PFNGLBINORMAL3SVEXTPROC)(const ::GLshort *);
typedef void (*PFNGLTANGENTPOINTEREXTPROC)(::GLenum, ::GLsizei, const ::GLvoid *);
typedef void (*PFNGLBINORMALPOINTEREXTPROC)(::GLenum, ::GLsizei, const ::GLvoid *);
extern "C"
{
  void glFinishTextureSUNX()__attribute__((visibility("default")));
}
typedef void (*PFNGLFINISHTEXTURESUNXPROC)();
extern "C"
{
  void glGlobalAlphaFactorbSUN(::GLbyte factor)__attribute__((visibility("default")));
}
extern "C"
{
  void glGlobalAlphaFactorsSUN(::GLshort factor)__attribute__((visibility("default")));
}
extern "C"
{
  void glGlobalAlphaFactoriSUN(::GLint factor)__attribute__((visibility("default")));
}
extern "C"
{
  void glGlobalAlphaFactorfSUN(::GLfloat factor)__attribute__((visibility("default")));
}
extern "C"
{
  void glGlobalAlphaFactordSUN(::GLdouble factor)__attribute__((visibility("default")));
}
extern "C"
{
  void glGlobalAlphaFactorubSUN(::GLubyte factor)__attribute__((visibility("default")));
}
extern "C"
{
  void glGlobalAlphaFactorusSUN(::GLushort factor)__attribute__((visibility("default")));
}
extern "C"
{
  void glGlobalAlphaFactoruiSUN(::GLuint factor)__attribute__((visibility("default")));
}
typedef void (*PFNGLGLOBALALPHAFACTORBSUNPROC)(::GLbyte);
typedef void (*PFNGLGLOBALALPHAFACTORSSUNPROC)(::GLshort);
typedef void (*PFNGLGLOBALALPHAFACTORISUNPROC)(::GLint);
typedef void (*PFNGLGLOBALALPHAFACTORFSUNPROC)(::GLfloat);
typedef void (*PFNGLGLOBALALPHAFACTORDSUNPROC)(::GLdouble);
typedef void (*PFNGLGLOBALALPHAFACTORUBSUNPROC)(::GLubyte);
typedef void (*PFNGLGLOBALALPHAFACTORUSSUNPROC)(::GLushort);
typedef void (*PFNGLGLOBALALPHAFACTORUISUNPROC)(::GLuint);
extern "C"
{
  void glReplacementCodeuiSUN(::GLuint code)__attribute__((visibility("default")));
}
extern "C"
{
  void glReplacementCodeusSUN(::GLushort code)__attribute__((visibility("default")));
}
extern "C"
{
  void glReplacementCodeubSUN(::GLubyte code)__attribute__((visibility("default")));
}
extern "C"
{
  void glReplacementCodeuivSUN(const ::GLuint *code)__attribute__((visibility("default")));
}
extern "C"
{
  void glReplacementCodeusvSUN(const ::GLushort *code)__attribute__((visibility("default")));
}
extern "C"
{
  void glReplacementCodeubvSUN(const ::GLubyte *code)__attribute__((visibility("default")));
}
extern "C"
{
  void glReplacementCodePointerSUN(::GLenum type, ::GLsizei stride, const ::GLvoid **pointer)__attribute__((visibility("default")));
}
typedef void (*PFNGLREPLACEMENTCODEUISUNPROC)(::GLuint);
typedef void (*PFNGLREPLACEMENTCODEUSSUNPROC)(::GLushort);
typedef void (*PFNGLREPLACEMENTCODEUBSUNPROC)(::GLubyte);
typedef void (*PFNGLREPLACEMENTCODEUIVSUNPROC)(const ::GLuint *);
typedef void (*PFNGLREPLACEMENTCODEUSVSUNPROC)(const ::GLushort *);
typedef void (*PFNGLREPLACEMENTCODEUBVSUNPROC)(const ::GLubyte *);
typedef void (*PFNGLREPLACEMENTCODEPOINTERSUNPROC)(::GLenum, ::GLsizei, const ::GLvoid **);
extern "C"
{
  void glColor4ubVertex2fSUN(::GLubyte r, ::GLubyte g, ::GLubyte b, ::GLubyte a, ::GLfloat x, ::GLfloat y)__attribute__((visibility("default")));
}
extern "C"
{
  void glColor4ubVertex2fvSUN(const ::GLubyte *c, const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glColor4ubVertex3fSUN(::GLubyte r, ::GLubyte g, ::GLubyte b, ::GLubyte a, ::GLfloat x, ::GLfloat y, ::GLfloat z)__attribute__((visibility("default")));
}
extern "C"
{
  void glColor4ubVertex3fvSUN(const ::GLubyte *c, const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glColor3fVertex3fSUN(::GLfloat r, ::GLfloat g, ::GLfloat b, ::GLfloat x, ::GLfloat y, ::GLfloat z)__attribute__((visibility("default")));
}
extern "C"
{
  void glColor3fVertex3fvSUN(const ::GLfloat *c, const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glNormal3fVertex3fSUN(::GLfloat nx, ::GLfloat ny, ::GLfloat nz, ::GLfloat x, ::GLfloat y, ::GLfloat z)__attribute__((visibility("default")));
}
extern "C"
{
  void glNormal3fVertex3fvSUN(const ::GLfloat *n, const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glColor4fNormal3fVertex3fSUN(::GLfloat r, ::GLfloat g, ::GLfloat b, ::GLfloat a, ::GLfloat nx, ::GLfloat ny, ::GLfloat nz, ::GLfloat x, ::GLfloat y, ::GLfloat z)__attribute__((visibility("default")));
}
extern "C"
{
  void glColor4fNormal3fVertex3fvSUN(const ::GLfloat *c, const ::GLfloat *n, const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexCoord2fVertex3fSUN(::GLfloat s, ::GLfloat t, ::GLfloat x, ::GLfloat y, ::GLfloat z)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexCoord2fVertex3fvSUN(const ::GLfloat *tc, const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexCoord4fVertex4fSUN(::GLfloat s, ::GLfloat t, ::GLfloat p, ::GLfloat q, ::GLfloat x, ::GLfloat y, ::GLfloat z, ::GLfloat w)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexCoord4fVertex4fvSUN(const ::GLfloat *tc, const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexCoord2fColor4ubVertex3fSUN(::GLfloat s, ::GLfloat t, ::GLubyte r, ::GLubyte g, ::GLubyte b, ::GLubyte a, ::GLfloat x, ::GLfloat y, ::GLfloat z)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexCoord2fColor4ubVertex3fvSUN(const ::GLfloat *tc, const ::GLubyte *c, const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexCoord2fColor3fVertex3fSUN(::GLfloat s, ::GLfloat t, ::GLfloat r, ::GLfloat g, ::GLfloat b, ::GLfloat x, ::GLfloat y, ::GLfloat z)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexCoord2fColor3fVertex3fvSUN(const ::GLfloat *tc, const ::GLfloat *c, const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexCoord2fNormal3fVertex3fSUN(::GLfloat s, ::GLfloat t, ::GLfloat nx, ::GLfloat ny, ::GLfloat nz, ::GLfloat x, ::GLfloat y, ::GLfloat z)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexCoord2fNormal3fVertex3fvSUN(const ::GLfloat *tc, const ::GLfloat *n, const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexCoord2fColor4fNormal3fVertex3fSUN(::GLfloat s, ::GLfloat t, ::GLfloat r, ::GLfloat g, ::GLfloat b, ::GLfloat a, ::GLfloat nx, ::GLfloat ny, ::GLfloat nz, ::GLfloat x, ::GLfloat y, ::GLfloat z)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexCoord2fColor4fNormal3fVertex3fvSUN(const ::GLfloat *tc, const ::GLfloat *c, const ::GLfloat *n, const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexCoord4fColor4fNormal3fVertex4fSUN(::GLfloat s, ::GLfloat t, ::GLfloat p, ::GLfloat q, ::GLfloat r, ::GLfloat g, ::GLfloat b, ::GLfloat a, ::GLfloat nx, ::GLfloat ny, ::GLfloat nz, ::GLfloat x, ::GLfloat y, ::GLfloat z, ::GLfloat w)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexCoord4fColor4fNormal3fVertex4fvSUN(const ::GLfloat *tc, const ::GLfloat *c, const ::GLfloat *n, const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glReplacementCodeuiVertex3fSUN(::GLuint rc, ::GLfloat x, ::GLfloat y, ::GLfloat z)__attribute__((visibility("default")));
}
extern "C"
{
  void glReplacementCodeuiVertex3fvSUN(const ::GLuint *rc, const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glReplacementCodeuiColor4ubVertex3fSUN(::GLuint rc, ::GLubyte r, ::GLubyte g, ::GLubyte b, ::GLubyte a, ::GLfloat x, ::GLfloat y, ::GLfloat z)__attribute__((visibility("default")));
}
extern "C"
{
  void glReplacementCodeuiColor4ubVertex3fvSUN(const ::GLuint *rc, const ::GLubyte *c, const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glReplacementCodeuiColor3fVertex3fSUN(::GLuint rc, ::GLfloat r, ::GLfloat g, ::GLfloat b, ::GLfloat x, ::GLfloat y, ::GLfloat z)__attribute__((visibility("default")));
}
extern "C"
{
  void glReplacementCodeuiColor3fVertex3fvSUN(const ::GLuint *rc, const ::GLfloat *c, const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glReplacementCodeuiNormal3fVertex3fSUN(::GLuint rc, ::GLfloat nx, ::GLfloat ny, ::GLfloat nz, ::GLfloat x, ::GLfloat y, ::GLfloat z)__attribute__((visibility("default")));
}
extern "C"
{
  void glReplacementCodeuiNormal3fVertex3fvSUN(const ::GLuint *rc, const ::GLfloat *n, const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glReplacementCodeuiColor4fNormal3fVertex3fSUN(::GLuint rc, ::GLfloat r, ::GLfloat g, ::GLfloat b, ::GLfloat a, ::GLfloat nx, ::GLfloat ny, ::GLfloat nz, ::GLfloat x, ::GLfloat y, ::GLfloat z)__attribute__((visibility("default")));
}
extern "C"
{
  void glReplacementCodeuiColor4fNormal3fVertex3fvSUN(const ::GLuint *rc, const ::GLfloat *c, const ::GLfloat *n, const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glReplacementCodeuiTexCoord2fVertex3fSUN(::GLuint rc, ::GLfloat s, ::GLfloat t, ::GLfloat x, ::GLfloat y, ::GLfloat z)__attribute__((visibility("default")));
}
extern "C"
{
  void glReplacementCodeuiTexCoord2fVertex3fvSUN(const ::GLuint *rc, const ::GLfloat *tc, const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN(::GLuint rc, ::GLfloat s, ::GLfloat t, ::GLfloat nx, ::GLfloat ny, ::GLfloat nz, ::GLfloat x, ::GLfloat y, ::GLfloat z)__attribute__((visibility("default")));
}
extern "C"
{
  void glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(const ::GLuint *rc, const ::GLfloat *tc, const ::GLfloat *n, const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN(::GLuint rc, ::GLfloat s, ::GLfloat t, ::GLfloat r, ::GLfloat g, ::GLfloat b, ::GLfloat a, ::GLfloat nx, ::GLfloat ny, ::GLfloat nz, ::GLfloat x, ::GLfloat y, ::GLfloat z)__attribute__((visibility("default")));
}
extern "C"
{
  void glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(const ::GLuint *rc, const ::GLfloat *tc, const ::GLfloat *c, const ::GLfloat *n, const ::GLfloat *v)__attribute__((visibility("default")));
}
typedef void (*PFNGLCOLOR4UBVERTEX2FSUNPROC)(::GLubyte, ::GLubyte, ::GLubyte, ::GLubyte, ::GLfloat, ::GLfloat);
typedef void (*PFNGLCOLOR4UBVERTEX2FVSUNPROC)(const ::GLubyte *, const ::GLfloat *);
typedef void (*PFNGLCOLOR4UBVERTEX3FSUNPROC)(::GLubyte, ::GLubyte, ::GLubyte, ::GLubyte, ::GLfloat, ::GLfloat, ::GLfloat);
typedef void (*PFNGLCOLOR4UBVERTEX3FVSUNPROC)(const ::GLubyte *, const ::GLfloat *);
typedef void (*PFNGLCOLOR3FVERTEX3FSUNPROC)(::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat);
typedef void (*PFNGLCOLOR3FVERTEX3FVSUNPROC)(const ::GLfloat *, const ::GLfloat *);
typedef void (*PFNGLNORMAL3FVERTEX3FSUNPROC)(::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat);
typedef void (*PFNGLNORMAL3FVERTEX3FVSUNPROC)(const ::GLfloat *, const ::GLfloat *);
typedef void (*PFNGLCOLOR4FNORMAL3FVERTEX3FSUNPROC)(::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat);
typedef void (*PFNGLCOLOR4FNORMAL3FVERTEX3FVSUNPROC)(const ::GLfloat *, const ::GLfloat *, const ::GLfloat *);
typedef void (*PFNGLTEXCOORD2FVERTEX3FSUNPROC)(::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat);
typedef void (*PFNGLTEXCOORD2FVERTEX3FVSUNPROC)(const ::GLfloat *, const ::GLfloat *);
typedef void (*PFNGLTEXCOORD4FVERTEX4FSUNPROC)(::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat);
typedef void (*PFNGLTEXCOORD4FVERTEX4FVSUNPROC)(const ::GLfloat *, const ::GLfloat *);
typedef void (*PFNGLTEXCOORD2FCOLOR4UBVERTEX3FSUNPROC)(::GLfloat, ::GLfloat, ::GLubyte, ::GLubyte, ::GLubyte, ::GLubyte, ::GLfloat, ::GLfloat, ::GLfloat);
typedef void (*PFNGLTEXCOORD2FCOLOR4UBVERTEX3FVSUNPROC)(const ::GLfloat *, const ::GLubyte *, const ::GLfloat *);
typedef void (*PFNGLTEXCOORD2FCOLOR3FVERTEX3FSUNPROC)(::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat);
typedef void (*PFNGLTEXCOORD2FCOLOR3FVERTEX3FVSUNPROC)(const ::GLfloat *, const ::GLfloat *, const ::GLfloat *);
typedef void (*PFNGLTEXCOORD2FNORMAL3FVERTEX3FSUNPROC)(::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat);
typedef void (*PFNGLTEXCOORD2FNORMAL3FVERTEX3FVSUNPROC)(const ::GLfloat *, const ::GLfloat *, const ::GLfloat *);
typedef void (*PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC)(::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat);
typedef void (*PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC)(const ::GLfloat *, const ::GLfloat *, const ::GLfloat *, const ::GLfloat *);
typedef void (*PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FSUNPROC)(::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat);
typedef void (*PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FVSUNPROC)(const ::GLfloat *, const ::GLfloat *, const ::GLfloat *, const ::GLfloat *);
typedef void (*PFNGLREPLACEMENTCODEUIVERTEX3FSUNPROC)(::GLuint, ::GLfloat, ::GLfloat, ::GLfloat);
typedef void (*PFNGLREPLACEMENTCODEUIVERTEX3FVSUNPROC)(const ::GLuint *, const ::GLfloat *);
typedef void (*PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FSUNPROC)(::GLuint, ::GLubyte, ::GLubyte, ::GLubyte, ::GLubyte, ::GLfloat, ::GLfloat, ::GLfloat);
typedef void (*PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FVSUNPROC)(const ::GLuint *, const ::GLubyte *, const ::GLfloat *);
typedef void (*PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FSUNPROC)(::GLuint, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat);
typedef void (*PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FVSUNPROC)(const ::GLuint *, const ::GLfloat *, const ::GLfloat *);
typedef void (*PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FSUNPROC)(::GLuint, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat);
typedef void (*PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FVSUNPROC)(const ::GLuint *, const ::GLfloat *, const ::GLfloat *);
typedef void (*PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FSUNPROC)(::GLuint, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat);
typedef void (*PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FVSUNPROC)(const ::GLuint *, const ::GLfloat *, const ::GLfloat *, const ::GLfloat *);
typedef void (*PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FSUNPROC)(::GLuint, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat);
typedef void (*PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FVSUNPROC)(const ::GLuint *, const ::GLfloat *, const ::GLfloat *);
typedef void (*PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FSUNPROC)(::GLuint, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat);
typedef void (*PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FVSUNPROC)(const ::GLuint *, const ::GLfloat *, const ::GLfloat *, const ::GLfloat *);
typedef void (*PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC)(::GLuint, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat);
typedef void (*PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC)(const ::GLuint *, const ::GLfloat *, const ::GLfloat *, const ::GLfloat *, const ::GLfloat *);
extern "C"
{
  void glBlendFuncSeparateEXT(::GLenum sfactorRGB, ::GLenum dfactorRGB, ::GLenum sfactorAlpha, ::GLenum dfactorAlpha)__attribute__((visibility("default")));
}
typedef void (*PFNGLBLENDFUNCSEPARATEEXTPROC)(::GLenum, ::GLenum, ::GLenum, ::GLenum);
extern "C"
{
  void glBlendFuncSeparateINGR(::GLenum sfactorRGB, ::GLenum dfactorRGB, ::GLenum sfactorAlpha, ::GLenum dfactorAlpha)__attribute__((visibility("default")));
}
typedef void (*PFNGLBLENDFUNCSEPARATEINGRPROC)(::GLenum, ::GLenum, ::GLenum, ::GLenum);
extern "C"
{
  void glVertexWeightfEXT(::GLfloat weight)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexWeightfvEXT(const ::GLfloat *weight)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexWeightPointerEXT(::GLsizei size, ::GLenum type, ::GLsizei stride, const ::GLvoid *pointer)__attribute__((visibility("default")));
}
typedef void (*PFNGLVERTEXWEIGHTFEXTPROC)(::GLfloat);
typedef void (*PFNGLVERTEXWEIGHTFVEXTPROC)(const ::GLfloat *);
typedef void (*PFNGLVERTEXWEIGHTPOINTEREXTPROC)(::GLsizei, ::GLenum, ::GLsizei, const ::GLvoid *);
extern "C"
{
  void glFlushVertexArrayRangeNV()__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexArrayRangeNV(::GLsizei length, const ::GLvoid *pointer)__attribute__((visibility("default")));
}
typedef void (*PFNGLFLUSHVERTEXARRAYRANGENVPROC)();
typedef void (*PFNGLVERTEXARRAYRANGENVPROC)(::GLsizei, const ::GLvoid *);
extern "C"
{
  void glCombinerParameterfvNV(::GLenum pname, const ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glCombinerParameterfNV(::GLenum pname, ::GLfloat param)__attribute__((visibility("default")));
}
extern "C"
{
  void glCombinerParameterivNV(::GLenum pname, const ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glCombinerParameteriNV(::GLenum pname, ::GLint param)__attribute__((visibility("default")));
}
extern "C"
{
  void glCombinerInputNV(::GLenum stage, ::GLenum portion, ::GLenum variable, ::GLenum input, ::GLenum mapping, ::GLenum componentUsage)__attribute__((visibility("default")));
}
extern "C"
{
  void glCombinerOutputNV(::GLenum stage, ::GLenum portion, ::GLenum abOutput, ::GLenum cdOutput, ::GLenum sumOutput, ::GLenum scale, ::GLenum bias, ::GLboolean abDotProduct, ::GLboolean cdDotProduct, ::GLboolean muxSum)__attribute__((visibility("default")));
}
extern "C"
{
  void glFinalCombinerInputNV(::GLenum variable, ::GLenum input, ::GLenum mapping, ::GLenum componentUsage)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetCombinerInputParameterfvNV(::GLenum stage, ::GLenum portion, ::GLenum variable, ::GLenum pname, ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetCombinerInputParameterivNV(::GLenum stage, ::GLenum portion, ::GLenum variable, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetCombinerOutputParameterfvNV(::GLenum stage, ::GLenum portion, ::GLenum pname, ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetCombinerOutputParameterivNV(::GLenum stage, ::GLenum portion, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetFinalCombinerInputParameterfvNV(::GLenum variable, ::GLenum pname, ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetFinalCombinerInputParameterivNV(::GLenum variable, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
typedef void (*PFNGLCOMBINERPARAMETERFVNVPROC)(::GLenum, const ::GLfloat *);
typedef void (*PFNGLCOMBINERPARAMETERFNVPROC)(::GLenum, ::GLfloat);
typedef void (*PFNGLCOMBINERPARAMETERIVNVPROC)(::GLenum, const ::GLint *);
typedef void (*PFNGLCOMBINERPARAMETERINVPROC)(::GLenum, ::GLint);
typedef void (*PFNGLCOMBINERINPUTNVPROC)(::GLenum, ::GLenum, ::GLenum, ::GLenum, ::GLenum, ::GLenum);
typedef void (*PFNGLCOMBINEROUTPUTNVPROC)(::GLenum, ::GLenum, ::GLenum, ::GLenum, ::GLenum, ::GLenum, ::GLenum, ::GLboolean, ::GLboolean, ::GLboolean);
typedef void (*PFNGLFINALCOMBINERINPUTNVPROC)(::GLenum, ::GLenum, ::GLenum, ::GLenum);
typedef void (*PFNGLGETCOMBINERINPUTPARAMETERFVNVPROC)(::GLenum, ::GLenum, ::GLenum, ::GLenum, ::GLfloat *);
typedef void (*PFNGLGETCOMBINERINPUTPARAMETERIVNVPROC)(::GLenum, ::GLenum, ::GLenum, ::GLenum, ::GLint *);
typedef void (*PFNGLGETCOMBINEROUTPUTPARAMETERFVNVPROC)(::GLenum, ::GLenum, ::GLenum, ::GLfloat *);
typedef void (*PFNGLGETCOMBINEROUTPUTPARAMETERIVNVPROC)(::GLenum, ::GLenum, ::GLenum, ::GLint *);
typedef void (*PFNGLGETFINALCOMBINERINPUTPARAMETERFVNVPROC)(::GLenum, ::GLenum, ::GLfloat *);
typedef void (*PFNGLGETFINALCOMBINERINPUTPARAMETERIVNVPROC)(::GLenum, ::GLenum, ::GLint *);
extern "C"
{
  void glResizeBuffersMESA()__attribute__((visibility("default")));
}
typedef void (*PFNGLRESIZEBUFFERSMESAPROC)();
extern "C"
{
  void glWindowPos2dMESA(::GLdouble x, ::GLdouble y)__attribute__((visibility("default")));
}
extern "C"
{
  void glWindowPos2dvMESA(const ::GLdouble *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glWindowPos2fMESA(::GLfloat x, ::GLfloat y)__attribute__((visibility("default")));
}
extern "C"
{
  void glWindowPos2fvMESA(const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glWindowPos2iMESA(::GLint x, ::GLint y)__attribute__((visibility("default")));
}
extern "C"
{
  void glWindowPos2ivMESA(const ::GLint *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glWindowPos2sMESA(::GLshort x, ::GLshort y)__attribute__((visibility("default")));
}
extern "C"
{
  void glWindowPos2svMESA(const ::GLshort *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glWindowPos3dMESA(::GLdouble x, ::GLdouble y, ::GLdouble z)__attribute__((visibility("default")));
}
extern "C"
{
  void glWindowPos3dvMESA(const ::GLdouble *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glWindowPos3fMESA(::GLfloat x, ::GLfloat y, ::GLfloat z)__attribute__((visibility("default")));
}
extern "C"
{
  void glWindowPos3fvMESA(const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glWindowPos3iMESA(::GLint x, ::GLint y, ::GLint z)__attribute__((visibility("default")));
}
extern "C"
{
  void glWindowPos3ivMESA(const ::GLint *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glWindowPos3sMESA(::GLshort x, ::GLshort y, ::GLshort z)__attribute__((visibility("default")));
}
extern "C"
{
  void glWindowPos3svMESA(const ::GLshort *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glWindowPos4dMESA(::GLdouble x, ::GLdouble y, ::GLdouble z, ::GLdouble w)__attribute__((visibility("default")));
}
extern "C"
{
  void glWindowPos4dvMESA(const ::GLdouble *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glWindowPos4fMESA(::GLfloat x, ::GLfloat y, ::GLfloat z, ::GLfloat w)__attribute__((visibility("default")));
}
extern "C"
{
  void glWindowPos4fvMESA(const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glWindowPos4iMESA(::GLint x, ::GLint y, ::GLint z, ::GLint w)__attribute__((visibility("default")));
}
extern "C"
{
  void glWindowPos4ivMESA(const ::GLint *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glWindowPos4sMESA(::GLshort x, ::GLshort y, ::GLshort z, ::GLshort w)__attribute__((visibility("default")));
}
extern "C"
{
  void glWindowPos4svMESA(const ::GLshort *v)__attribute__((visibility("default")));
}
typedef void (*PFNGLWINDOWPOS2DMESAPROC)(::GLdouble, ::GLdouble);
typedef void (*PFNGLWINDOWPOS2DVMESAPROC)(const ::GLdouble *);
typedef void (*PFNGLWINDOWPOS2FMESAPROC)(::GLfloat, ::GLfloat);
typedef void (*PFNGLWINDOWPOS2FVMESAPROC)(const ::GLfloat *);
typedef void (*PFNGLWINDOWPOS2IMESAPROC)(::GLint, ::GLint);
typedef void (*PFNGLWINDOWPOS2IVMESAPROC)(const ::GLint *);
typedef void (*PFNGLWINDOWPOS2SMESAPROC)(::GLshort, ::GLshort);
typedef void (*PFNGLWINDOWPOS2SVMESAPROC)(const ::GLshort *);
typedef void (*PFNGLWINDOWPOS3DMESAPROC)(::GLdouble, ::GLdouble, ::GLdouble);
typedef void (*PFNGLWINDOWPOS3DVMESAPROC)(const ::GLdouble *);
typedef void (*PFNGLWINDOWPOS3FMESAPROC)(::GLfloat, ::GLfloat, ::GLfloat);
typedef void (*PFNGLWINDOWPOS3FVMESAPROC)(const ::GLfloat *);
typedef void (*PFNGLWINDOWPOS3IMESAPROC)(::GLint, ::GLint, ::GLint);
typedef void (*PFNGLWINDOWPOS3IVMESAPROC)(const ::GLint *);
typedef void (*PFNGLWINDOWPOS3SMESAPROC)(::GLshort, ::GLshort, ::GLshort);
typedef void (*PFNGLWINDOWPOS3SVMESAPROC)(const ::GLshort *);
typedef void (*PFNGLWINDOWPOS4DMESAPROC)(::GLdouble, ::GLdouble, ::GLdouble, ::GLdouble);
typedef void (*PFNGLWINDOWPOS4DVMESAPROC)(const ::GLdouble *);
typedef void (*PFNGLWINDOWPOS4FMESAPROC)(::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat);
typedef void (*PFNGLWINDOWPOS4FVMESAPROC)(const ::GLfloat *);
typedef void (*PFNGLWINDOWPOS4IMESAPROC)(::GLint, ::GLint, ::GLint, ::GLint);
typedef void (*PFNGLWINDOWPOS4IVMESAPROC)(const ::GLint *);
typedef void (*PFNGLWINDOWPOS4SMESAPROC)(::GLshort, ::GLshort, ::GLshort, ::GLshort);
typedef void (*PFNGLWINDOWPOS4SVMESAPROC)(const ::GLshort *);
extern "C"
{
  void glMultiModeDrawArraysIBM(const ::GLenum *mode, const ::GLint *first, const ::GLsizei *count, ::GLsizei primcount, ::GLint modestride)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiModeDrawElementsIBM(const ::GLenum *mode, const ::GLsizei *count, ::GLenum type, const ::GLvoid *const *indices, ::GLsizei primcount, ::GLint modestride)__attribute__((visibility("default")));
}
typedef void (*PFNGLMULTIMODEDRAWARRAYSIBMPROC)(const ::GLenum *, const ::GLint *, const ::GLsizei *, ::GLsizei, ::GLint);
typedef void (*PFNGLMULTIMODEDRAWELEMENTSIBMPROC)(const ::GLenum *, const ::GLsizei *, ::GLenum, const ::GLvoid *const *, ::GLsizei, ::GLint);
extern "C"
{
  void glColorPointerListIBM(::GLint size, ::GLenum type, ::GLint stride, const ::GLvoid **pointer, ::GLint ptrstride)__attribute__((visibility("default")));
}
extern "C"
{
  void glSecondaryColorPointerListIBM(::GLint size, ::GLenum type, ::GLint stride, const ::GLvoid **pointer, ::GLint ptrstride)__attribute__((visibility("default")));
}
extern "C"
{
  void glEdgeFlagPointerListIBM(::GLint stride, const ::GLboolean **pointer, ::GLint ptrstride)__attribute__((visibility("default")));
}
extern "C"
{
  void glFogCoordPointerListIBM(::GLenum type, ::GLint stride, const ::GLvoid **pointer, ::GLint ptrstride)__attribute__((visibility("default")));
}
extern "C"
{
  void glIndexPointerListIBM(::GLenum type, ::GLint stride, const ::GLvoid **pointer, ::GLint ptrstride)__attribute__((visibility("default")));
}
extern "C"
{
  void glNormalPointerListIBM(::GLenum type, ::GLint stride, const ::GLvoid **pointer, ::GLint ptrstride)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexCoordPointerListIBM(::GLint size, ::GLenum type, ::GLint stride, const ::GLvoid **pointer, ::GLint ptrstride)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexPointerListIBM(::GLint size, ::GLenum type, ::GLint stride, const ::GLvoid **pointer, ::GLint ptrstride)__attribute__((visibility("default")));
}
typedef void (*PFNGLCOLORPOINTERLISTIBMPROC)(::GLint, ::GLenum, ::GLint, const ::GLvoid **, ::GLint);
typedef void (*PFNGLSECONDARYCOLORPOINTERLISTIBMPROC)(::GLint, ::GLenum, ::GLint, const ::GLvoid **, ::GLint);
typedef void (*PFNGLEDGEFLAGPOINTERLISTIBMPROC)(::GLint, const ::GLboolean **, ::GLint);
typedef void (*PFNGLFOGCOORDPOINTERLISTIBMPROC)(::GLenum, ::GLint, const ::GLvoid **, ::GLint);
typedef void (*PFNGLINDEXPOINTERLISTIBMPROC)(::GLenum, ::GLint, const ::GLvoid **, ::GLint);
typedef void (*PFNGLNORMALPOINTERLISTIBMPROC)(::GLenum, ::GLint, const ::GLvoid **, ::GLint);
typedef void (*PFNGLTEXCOORDPOINTERLISTIBMPROC)(::GLint, ::GLenum, ::GLint, const ::GLvoid **, ::GLint);
typedef void (*PFNGLVERTEXPOINTERLISTIBMPROC)(::GLint, ::GLenum, ::GLint, const ::GLvoid **, ::GLint);
extern "C"
{
  void glTbufferMask3DFX(::GLuint mask)__attribute__((visibility("default")));
}
typedef void (*PFNGLTBUFFERMASK3DFXPROC)(::GLuint);
extern "C"
{
  void glSampleMaskEXT(::GLclampf value, ::GLboolean invert)__attribute__((visibility("default")));
}
extern "C"
{
  void glSamplePatternEXT(::GLenum pattern)__attribute__((visibility("default")));
}
typedef void (*PFNGLSAMPLEMASKEXTPROC)(::GLclampf, ::GLboolean);
typedef void (*PFNGLSAMPLEPATTERNEXTPROC)(::GLenum);
extern "C"
{
  void glTextureColorMaskSGIS(::GLboolean red, ::GLboolean green, ::GLboolean blue, ::GLboolean alpha)__attribute__((visibility("default")));
}
typedef void (*PFNGLTEXTURECOLORMASKSGISPROC)(::GLboolean, ::GLboolean, ::GLboolean, ::GLboolean);
extern "C"
{
  void glIglooInterfaceSGIX(::GLenum pname, const ::GLvoid *params)__attribute__((visibility("default")));
}
typedef void (*PFNGLIGLOOINTERFACESGIXPROC)(::GLenum, const ::GLvoid *);
extern "C"
{
  void glDeleteFencesNV(::GLsizei n, const ::GLuint *fences)__attribute__((visibility("default")));
}
extern "C"
{
  void glGenFencesNV(::GLsizei n, ::GLuint *fences)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLboolean glIsFenceNV(::GLuint fence)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLboolean glTestFenceNV(::GLuint fence)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetFenceivNV(::GLuint fence, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glFinishFenceNV(::GLuint fence)__attribute__((visibility("default")));
}
extern "C"
{
  void glSetFenceNV(::GLuint fence, ::GLenum condition)__attribute__((visibility("default")));
}
typedef void (*PFNGLDELETEFENCESNVPROC)(::GLsizei, const ::GLuint *);
typedef void (*PFNGLGENFENCESNVPROC)(::GLsizei, ::GLuint *);
typedef ::GLboolean (*PFNGLISFENCENVPROC)(::GLuint);
typedef ::GLboolean (*PFNGLTESTFENCENVPROC)(::GLuint);
typedef void (*PFNGLGETFENCEIVNVPROC)(::GLuint, ::GLenum, ::GLint *);
typedef void (*PFNGLFINISHFENCENVPROC)(::GLuint);
typedef void (*PFNGLSETFENCENVPROC)(::GLuint, ::GLenum);
extern "C"
{
  void glMapControlPointsNV(::GLenum target, ::GLuint index, ::GLenum type, ::GLsizei ustride, ::GLsizei vstride, ::GLint uorder, ::GLint vorder, ::GLboolean packed, const ::GLvoid *points)__attribute__((visibility("default")));
}
extern "C"
{
  void glMapParameterivNV(::GLenum target, ::GLenum pname, const ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glMapParameterfvNV(::GLenum target, ::GLenum pname, const ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetMapControlPointsNV(::GLenum target, ::GLuint index, ::GLenum type, ::GLsizei ustride, ::GLsizei vstride, ::GLboolean packed, ::GLvoid *points)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetMapParameterivNV(::GLenum target, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetMapParameterfvNV(::GLenum target, ::GLenum pname, ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetMapAttribParameterivNV(::GLenum target, ::GLuint index, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetMapAttribParameterfvNV(::GLenum target, ::GLuint index, ::GLenum pname, ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glEvalMapsNV(::GLenum target, ::GLenum mode)__attribute__((visibility("default")));
}
typedef void (*PFNGLMAPCONTROLPOINTSNVPROC)(::GLenum, ::GLuint, ::GLenum, ::GLsizei, ::GLsizei, ::GLint, ::GLint, ::GLboolean, const ::GLvoid *);
typedef void (*PFNGLMAPPARAMETERIVNVPROC)(::GLenum, ::GLenum, const ::GLint *);
typedef void (*PFNGLMAPPARAMETERFVNVPROC)(::GLenum, ::GLenum, const ::GLfloat *);
typedef void (*PFNGLGETMAPCONTROLPOINTSNVPROC)(::GLenum, ::GLuint, ::GLenum, ::GLsizei, ::GLsizei, ::GLboolean, ::GLvoid *);
typedef void (*PFNGLGETMAPPARAMETERIVNVPROC)(::GLenum, ::GLenum, ::GLint *);
typedef void (*PFNGLGETMAPPARAMETERFVNVPROC)(::GLenum, ::GLenum, ::GLfloat *);
typedef void (*PFNGLGETMAPATTRIBPARAMETERIVNVPROC)(::GLenum, ::GLuint, ::GLenum, ::GLint *);
typedef void (*PFNGLGETMAPATTRIBPARAMETERFVNVPROC)(::GLenum, ::GLuint, ::GLenum, ::GLfloat *);
typedef void (*PFNGLEVALMAPSNVPROC)(::GLenum, ::GLenum);
extern "C"
{
  void glCombinerStageParameterfvNV(::GLenum stage, ::GLenum pname, const ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetCombinerStageParameterfvNV(::GLenum stage, ::GLenum pname, ::GLfloat *params)__attribute__((visibility("default")));
}
typedef void (*PFNGLCOMBINERSTAGEPARAMETERFVNVPROC)(::GLenum, ::GLenum, const ::GLfloat *);
typedef void (*PFNGLGETCOMBINERSTAGEPARAMETERFVNVPROC)(::GLenum, ::GLenum, ::GLfloat *);
extern "C"
{
  ::GLboolean glAreProgramsResidentNV(::GLsizei n, const ::GLuint *programs, ::GLboolean *residences)__attribute__((visibility("default")));
}
extern "C"
{
  void glBindProgramNV(::GLenum target, ::GLuint id)__attribute__((visibility("default")));
}
extern "C"
{
  void glDeleteProgramsNV(::GLsizei n, const ::GLuint *programs)__attribute__((visibility("default")));
}
extern "C"
{
  void glExecuteProgramNV(::GLenum target, ::GLuint id, const ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGenProgramsNV(::GLsizei n, ::GLuint *programs)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetProgramParameterdvNV(::GLenum target, ::GLuint index, ::GLenum pname, ::GLdouble *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetProgramParameterfvNV(::GLenum target, ::GLuint index, ::GLenum pname, ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetProgramivNV(::GLuint id, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetProgramStringNV(::GLuint id, ::GLenum pname, ::GLubyte *program)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetTrackMatrixivNV(::GLenum target, ::GLuint address, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetVertexAttribdvNV(::GLuint index, ::GLenum pname, ::GLdouble *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetVertexAttribfvNV(::GLuint index, ::GLenum pname, ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetVertexAttribivNV(::GLuint index, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetVertexAttribPointervNV(::GLuint index, ::GLenum pname, ::GLvoid **pointer)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLboolean glIsProgramNV(::GLuint id)__attribute__((visibility("default")));
}
extern "C"
{
  void glLoadProgramNV(::GLenum target, ::GLuint id, ::GLsizei len, const ::GLubyte *program)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramParameter4dNV(::GLenum target, ::GLuint index, ::GLdouble x, ::GLdouble y, ::GLdouble z, ::GLdouble w)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramParameter4dvNV(::GLenum target, ::GLuint index, const ::GLdouble *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramParameter4fNV(::GLenum target, ::GLuint index, ::GLfloat x, ::GLfloat y, ::GLfloat z, ::GLfloat w)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramParameter4fvNV(::GLenum target, ::GLuint index, const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramParameters4dvNV(::GLenum target, ::GLuint index, ::GLsizei count, const ::GLdouble *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramParameters4fvNV(::GLenum target, ::GLuint index, ::GLsizei count, const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glRequestResidentProgramsNV(::GLsizei n, const ::GLuint *programs)__attribute__((visibility("default")));
}
extern "C"
{
  void glTrackMatrixNV(::GLenum target, ::GLuint address, ::GLenum matrix, ::GLenum transform)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribPointerNV(::GLuint index, ::GLint fsize, ::GLenum type, ::GLsizei stride, const ::GLvoid *pointer)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib1dNV(::GLuint index, ::GLdouble x)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib1dvNV(::GLuint index, const ::GLdouble *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib1fNV(::GLuint index, ::GLfloat x)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib1fvNV(::GLuint index, const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib1sNV(::GLuint index, ::GLshort x)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib1svNV(::GLuint index, const ::GLshort *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib2dNV(::GLuint index, ::GLdouble x, ::GLdouble y)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib2dvNV(::GLuint index, const ::GLdouble *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib2fNV(::GLuint index, ::GLfloat x, ::GLfloat y)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib2fvNV(::GLuint index, const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib2sNV(::GLuint index, ::GLshort x, ::GLshort y)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib2svNV(::GLuint index, const ::GLshort *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib3dNV(::GLuint index, ::GLdouble x, ::GLdouble y, ::GLdouble z)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib3dvNV(::GLuint index, const ::GLdouble *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib3fNV(::GLuint index, ::GLfloat x, ::GLfloat y, ::GLfloat z)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib3fvNV(::GLuint index, const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib3sNV(::GLuint index, ::GLshort x, ::GLshort y, ::GLshort z)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib3svNV(::GLuint index, const ::GLshort *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib4dNV(::GLuint index, ::GLdouble x, ::GLdouble y, ::GLdouble z, ::GLdouble w)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib4dvNV(::GLuint index, const ::GLdouble *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib4fNV(::GLuint index, ::GLfloat x, ::GLfloat y, ::GLfloat z, ::GLfloat w)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib4fvNV(::GLuint index, const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib4sNV(::GLuint index, ::GLshort x, ::GLshort y, ::GLshort z, ::GLshort w)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib4svNV(::GLuint index, const ::GLshort *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib4ubNV(::GLuint index, ::GLubyte x, ::GLubyte y, ::GLubyte z, ::GLubyte w)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib4ubvNV(::GLuint index, const ::GLubyte *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribs1dvNV(::GLuint index, ::GLsizei count, const ::GLdouble *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribs1fvNV(::GLuint index, ::GLsizei count, const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribs1svNV(::GLuint index, ::GLsizei count, const ::GLshort *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribs2dvNV(::GLuint index, ::GLsizei count, const ::GLdouble *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribs2fvNV(::GLuint index, ::GLsizei count, const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribs2svNV(::GLuint index, ::GLsizei count, const ::GLshort *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribs3dvNV(::GLuint index, ::GLsizei count, const ::GLdouble *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribs3fvNV(::GLuint index, ::GLsizei count, const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribs3svNV(::GLuint index, ::GLsizei count, const ::GLshort *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribs4dvNV(::GLuint index, ::GLsizei count, const ::GLdouble *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribs4fvNV(::GLuint index, ::GLsizei count, const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribs4svNV(::GLuint index, ::GLsizei count, const ::GLshort *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribs4ubvNV(::GLuint index, ::GLsizei count, const ::GLubyte *v)__attribute__((visibility("default")));
}
typedef ::GLboolean (*PFNGLAREPROGRAMSRESIDENTNVPROC)(::GLsizei, const ::GLuint *, ::GLboolean *);
typedef void (*PFNGLBINDPROGRAMNVPROC)(::GLenum, ::GLuint);
typedef void (*PFNGLDELETEPROGRAMSNVPROC)(::GLsizei, const ::GLuint *);
typedef void (*PFNGLEXECUTEPROGRAMNVPROC)(::GLenum, ::GLuint, const ::GLfloat *);
typedef void (*PFNGLGENPROGRAMSNVPROC)(::GLsizei, ::GLuint *);
typedef void (*PFNGLGETPROGRAMPARAMETERDVNVPROC)(::GLenum, ::GLuint, ::GLenum, ::GLdouble *);
typedef void (*PFNGLGETPROGRAMPARAMETERFVNVPROC)(::GLenum, ::GLuint, ::GLenum, ::GLfloat *);
typedef void (*PFNGLGETPROGRAMIVNVPROC)(::GLuint, ::GLenum, ::GLint *);
typedef void (*PFNGLGETPROGRAMSTRINGNVPROC)(::GLuint, ::GLenum, ::GLubyte *);
typedef void (*PFNGLGETTRACKMATRIXIVNVPROC)(::GLenum, ::GLuint, ::GLenum, ::GLint *);
typedef void (*PFNGLGETVERTEXATTRIBDVNVPROC)(::GLuint, ::GLenum, ::GLdouble *);
typedef void (*PFNGLGETVERTEXATTRIBFVNVPROC)(::GLuint, ::GLenum, ::GLfloat *);
typedef void (*PFNGLGETVERTEXATTRIBIVNVPROC)(::GLuint, ::GLenum, ::GLint *);
typedef void (*PFNGLGETVERTEXATTRIBPOINTERVNVPROC)(::GLuint, ::GLenum, ::GLvoid **);
typedef ::GLboolean (*PFNGLISPROGRAMNVPROC)(::GLuint);
typedef void (*PFNGLLOADPROGRAMNVPROC)(::GLenum, ::GLuint, ::GLsizei, const ::GLubyte *);
typedef void (*PFNGLPROGRAMPARAMETER4DNVPROC)(::GLenum, ::GLuint, ::GLdouble, ::GLdouble, ::GLdouble, ::GLdouble);
typedef void (*PFNGLPROGRAMPARAMETER4DVNVPROC)(::GLenum, ::GLuint, const ::GLdouble *);
typedef void (*PFNGLPROGRAMPARAMETER4FNVPROC)(::GLenum, ::GLuint, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat);
typedef void (*PFNGLPROGRAMPARAMETER4FVNVPROC)(::GLenum, ::GLuint, const ::GLfloat *);
typedef void (*PFNGLPROGRAMPARAMETERS4DVNVPROC)(::GLenum, ::GLuint, ::GLsizei, const ::GLdouble *);
typedef void (*PFNGLPROGRAMPARAMETERS4FVNVPROC)(::GLenum, ::GLuint, ::GLsizei, const ::GLfloat *);
typedef void (*PFNGLREQUESTRESIDENTPROGRAMSNVPROC)(::GLsizei, const ::GLuint *);
typedef void (*PFNGLTRACKMATRIXNVPROC)(::GLenum, ::GLuint, ::GLenum, ::GLenum);
typedef void (*PFNGLVERTEXATTRIBPOINTERNVPROC)(::GLuint, ::GLint, ::GLenum, ::GLsizei, const ::GLvoid *);
typedef void (*PFNGLVERTEXATTRIB1DNVPROC)(::GLuint, ::GLdouble);
typedef void (*PFNGLVERTEXATTRIB1DVNVPROC)(::GLuint, const ::GLdouble *);
typedef void (*PFNGLVERTEXATTRIB1FNVPROC)(::GLuint, ::GLfloat);
typedef void (*PFNGLVERTEXATTRIB1FVNVPROC)(::GLuint, const ::GLfloat *);
typedef void (*PFNGLVERTEXATTRIB1SNVPROC)(::GLuint, ::GLshort);
typedef void (*PFNGLVERTEXATTRIB1SVNVPROC)(::GLuint, const ::GLshort *);
typedef void (*PFNGLVERTEXATTRIB2DNVPROC)(::GLuint, ::GLdouble, ::GLdouble);
typedef void (*PFNGLVERTEXATTRIB2DVNVPROC)(::GLuint, const ::GLdouble *);
typedef void (*PFNGLVERTEXATTRIB2FNVPROC)(::GLuint, ::GLfloat, ::GLfloat);
typedef void (*PFNGLVERTEXATTRIB2FVNVPROC)(::GLuint, const ::GLfloat *);
typedef void (*PFNGLVERTEXATTRIB2SNVPROC)(::GLuint, ::GLshort, ::GLshort);
typedef void (*PFNGLVERTEXATTRIB2SVNVPROC)(::GLuint, const ::GLshort *);
typedef void (*PFNGLVERTEXATTRIB3DNVPROC)(::GLuint, ::GLdouble, ::GLdouble, ::GLdouble);
typedef void (*PFNGLVERTEXATTRIB3DVNVPROC)(::GLuint, const ::GLdouble *);
typedef void (*PFNGLVERTEXATTRIB3FNVPROC)(::GLuint, ::GLfloat, ::GLfloat, ::GLfloat);
typedef void (*PFNGLVERTEXATTRIB3FVNVPROC)(::GLuint, const ::GLfloat *);
typedef void (*PFNGLVERTEXATTRIB3SNVPROC)(::GLuint, ::GLshort, ::GLshort, ::GLshort);
typedef void (*PFNGLVERTEXATTRIB3SVNVPROC)(::GLuint, const ::GLshort *);
typedef void (*PFNGLVERTEXATTRIB4DNVPROC)(::GLuint, ::GLdouble, ::GLdouble, ::GLdouble, ::GLdouble);
typedef void (*PFNGLVERTEXATTRIB4DVNVPROC)(::GLuint, const ::GLdouble *);
typedef void (*PFNGLVERTEXATTRIB4FNVPROC)(::GLuint, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat);
typedef void (*PFNGLVERTEXATTRIB4FVNVPROC)(::GLuint, const ::GLfloat *);
typedef void (*PFNGLVERTEXATTRIB4SNVPROC)(::GLuint, ::GLshort, ::GLshort, ::GLshort, ::GLshort);
typedef void (*PFNGLVERTEXATTRIB4SVNVPROC)(::GLuint, const ::GLshort *);
typedef void (*PFNGLVERTEXATTRIB4UBNVPROC)(::GLuint, ::GLubyte, ::GLubyte, ::GLubyte, ::GLubyte);
typedef void (*PFNGLVERTEXATTRIB4UBVNVPROC)(::GLuint, const ::GLubyte *);
typedef void (*PFNGLVERTEXATTRIBS1DVNVPROC)(::GLuint, ::GLsizei, const ::GLdouble *);
typedef void (*PFNGLVERTEXATTRIBS1FVNVPROC)(::GLuint, ::GLsizei, const ::GLfloat *);
typedef void (*PFNGLVERTEXATTRIBS1SVNVPROC)(::GLuint, ::GLsizei, const ::GLshort *);
typedef void (*PFNGLVERTEXATTRIBS2DVNVPROC)(::GLuint, ::GLsizei, const ::GLdouble *);
typedef void (*PFNGLVERTEXATTRIBS2FVNVPROC)(::GLuint, ::GLsizei, const ::GLfloat *);
typedef void (*PFNGLVERTEXATTRIBS2SVNVPROC)(::GLuint, ::GLsizei, const ::GLshort *);
typedef void (*PFNGLVERTEXATTRIBS3DVNVPROC)(::GLuint, ::GLsizei, const ::GLdouble *);
typedef void (*PFNGLVERTEXATTRIBS3FVNVPROC)(::GLuint, ::GLsizei, const ::GLfloat *);
typedef void (*PFNGLVERTEXATTRIBS3SVNVPROC)(::GLuint, ::GLsizei, const ::GLshort *);
typedef void (*PFNGLVERTEXATTRIBS4DVNVPROC)(::GLuint, ::GLsizei, const ::GLdouble *);
typedef void (*PFNGLVERTEXATTRIBS4FVNVPROC)(::GLuint, ::GLsizei, const ::GLfloat *);
typedef void (*PFNGLVERTEXATTRIBS4SVNVPROC)(::GLuint, ::GLsizei, const ::GLshort *);
typedef void (*PFNGLVERTEXATTRIBS4UBVNVPROC)(::GLuint, ::GLsizei, const ::GLubyte *);
extern "C"
{
  void glTexBumpParameterivATI(::GLenum pname, const ::GLint *param)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexBumpParameterfvATI(::GLenum pname, const ::GLfloat *param)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetTexBumpParameterivATI(::GLenum pname, ::GLint *param)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetTexBumpParameterfvATI(::GLenum pname, ::GLfloat *param)__attribute__((visibility("default")));
}
typedef void (*PFNGLTEXBUMPPARAMETERIVATIPROC)(::GLenum, const ::GLint *);
typedef void (*PFNGLTEXBUMPPARAMETERFVATIPROC)(::GLenum, const ::GLfloat *);
typedef void (*PFNGLGETTEXBUMPPARAMETERIVATIPROC)(::GLenum, ::GLint *);
typedef void (*PFNGLGETTEXBUMPPARAMETERFVATIPROC)(::GLenum, ::GLfloat *);
extern "C"
{
  ::GLuint glGenFragmentShadersATI(::GLuint range)__attribute__((visibility("default")));
}
extern "C"
{
  void glBindFragmentShaderATI(::GLuint id)__attribute__((visibility("default")));
}
extern "C"
{
  void glDeleteFragmentShaderATI(::GLuint id)__attribute__((visibility("default")));
}
extern "C"
{
  void glBeginFragmentShaderATI()__attribute__((visibility("default")));
}
extern "C"
{
  void glEndFragmentShaderATI()__attribute__((visibility("default")));
}
extern "C"
{
  void glPassTexCoordATI(::GLuint dst, ::GLuint coord, ::GLenum swizzle)__attribute__((visibility("default")));
}
extern "C"
{
  void glSampleMapATI(::GLuint dst, ::GLuint interp, ::GLenum swizzle)__attribute__((visibility("default")));
}
extern "C"
{
  void glColorFragmentOp1ATI(::GLenum op, ::GLuint dst, ::GLuint dstMask, ::GLuint dstMod, ::GLuint arg1, ::GLuint arg1Rep, ::GLuint arg1Mod)__attribute__((visibility("default")));
}
extern "C"
{
  void glColorFragmentOp2ATI(::GLenum op, ::GLuint dst, ::GLuint dstMask, ::GLuint dstMod, ::GLuint arg1, ::GLuint arg1Rep, ::GLuint arg1Mod, ::GLuint arg2, ::GLuint arg2Rep, ::GLuint arg2Mod)__attribute__((visibility("default")));
}
extern "C"
{
  void glColorFragmentOp3ATI(::GLenum op, ::GLuint dst, ::GLuint dstMask, ::GLuint dstMod, ::GLuint arg1, ::GLuint arg1Rep, ::GLuint arg1Mod, ::GLuint arg2, ::GLuint arg2Rep, ::GLuint arg2Mod, ::GLuint arg3, ::GLuint arg3Rep, ::GLuint arg3Mod)__attribute__((visibility("default")));
}
extern "C"
{
  void glAlphaFragmentOp1ATI(::GLenum op, ::GLuint dst, ::GLuint dstMod, ::GLuint arg1, ::GLuint arg1Rep, ::GLuint arg1Mod)__attribute__((visibility("default")));
}
extern "C"
{
  void glAlphaFragmentOp2ATI(::GLenum op, ::GLuint dst, ::GLuint dstMod, ::GLuint arg1, ::GLuint arg1Rep, ::GLuint arg1Mod, ::GLuint arg2, ::GLuint arg2Rep, ::GLuint arg2Mod)__attribute__((visibility("default")));
}
extern "C"
{
  void glAlphaFragmentOp3ATI(::GLenum op, ::GLuint dst, ::GLuint dstMod, ::GLuint arg1, ::GLuint arg1Rep, ::GLuint arg1Mod, ::GLuint arg2, ::GLuint arg2Rep, ::GLuint arg2Mod, ::GLuint arg3, ::GLuint arg3Rep, ::GLuint arg3Mod)__attribute__((visibility("default")));
}
extern "C"
{
  void glSetFragmentShaderConstantATI(::GLuint dst, const ::GLfloat *value)__attribute__((visibility("default")));
}
typedef ::GLuint (*PFNGLGENFRAGMENTSHADERSATIPROC)(::GLuint);
typedef void (*PFNGLBINDFRAGMENTSHADERATIPROC)(::GLuint);
typedef void (*PFNGLDELETEFRAGMENTSHADERATIPROC)(::GLuint);
typedef void (*PFNGLBEGINFRAGMENTSHADERATIPROC)();
typedef void (*PFNGLENDFRAGMENTSHADERATIPROC)();
typedef void (*PFNGLPASSTEXCOORDATIPROC)(::GLuint, ::GLuint, ::GLenum);
typedef void (*PFNGLSAMPLEMAPATIPROC)(::GLuint, ::GLuint, ::GLenum);
typedef void (*PFNGLCOLORFRAGMENTOP1ATIPROC)(::GLenum, ::GLuint, ::GLuint, ::GLuint, ::GLuint, ::GLuint, ::GLuint);
typedef void (*PFNGLCOLORFRAGMENTOP2ATIPROC)(::GLenum, ::GLuint, ::GLuint, ::GLuint, ::GLuint, ::GLuint, ::GLuint, ::GLuint, ::GLuint, ::GLuint);
typedef void (*PFNGLCOLORFRAGMENTOP3ATIPROC)(::GLenum, ::GLuint, ::GLuint, ::GLuint, ::GLuint, ::GLuint, ::GLuint, ::GLuint, ::GLuint, ::GLuint, ::GLuint, ::GLuint, ::GLuint);
typedef void (*PFNGLALPHAFRAGMENTOP1ATIPROC)(::GLenum, ::GLuint, ::GLuint, ::GLuint, ::GLuint, ::GLuint);
typedef void (*PFNGLALPHAFRAGMENTOP2ATIPROC)(::GLenum, ::GLuint, ::GLuint, ::GLuint, ::GLuint, ::GLuint, ::GLuint, ::GLuint, ::GLuint);
typedef void (*PFNGLALPHAFRAGMENTOP3ATIPROC)(::GLenum, ::GLuint, ::GLuint, ::GLuint, ::GLuint, ::GLuint, ::GLuint, ::GLuint, ::GLuint, ::GLuint, ::GLuint, ::GLuint);
typedef void (*PFNGLSETFRAGMENTSHADERCONSTANTATIPROC)(::GLuint, const ::GLfloat *);
extern "C"
{
  void glPNTrianglesiATI(::GLenum pname, ::GLint param)__attribute__((visibility("default")));
}
extern "C"
{
  void glPNTrianglesfATI(::GLenum pname, ::GLfloat param)__attribute__((visibility("default")));
}
typedef void (*PFNGLPNTRIANGLESIATIPROC)(::GLenum, ::GLint);
typedef void (*PFNGLPNTRIANGLESFATIPROC)(::GLenum, ::GLfloat);
extern "C"
{
  ::GLuint glNewObjectBufferATI(::GLsizei size, const ::GLvoid *pointer, ::GLenum usage)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLboolean glIsObjectBufferATI(::GLuint buffer)__attribute__((visibility("default")));
}
extern "C"
{
  void glUpdateObjectBufferATI(::GLuint buffer, ::GLuint offset, ::GLsizei size, const ::GLvoid *pointer, ::GLenum preserve)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetObjectBufferfvATI(::GLuint buffer, ::GLenum pname, ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetObjectBufferivATI(::GLuint buffer, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glFreeObjectBufferATI(::GLuint buffer)__attribute__((visibility("default")));
}
extern "C"
{
  void glArrayObjectATI(::GLenum array, ::GLint size, ::GLenum type, ::GLsizei stride, ::GLuint buffer, ::GLuint offset)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetArrayObjectfvATI(::GLenum array, ::GLenum pname, ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetArrayObjectivATI(::GLenum array, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glVariantArrayObjectATI(::GLuint id, ::GLenum type, ::GLsizei stride, ::GLuint buffer, ::GLuint offset)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetVariantArrayObjectfvATI(::GLuint id, ::GLenum pname, ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetVariantArrayObjectivATI(::GLuint id, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
typedef ::GLuint (*PFNGLNEWOBJECTBUFFERATIPROC)(::GLsizei, const ::GLvoid *, ::GLenum);
typedef ::GLboolean (*PFNGLISOBJECTBUFFERATIPROC)(::GLuint);
typedef void (*PFNGLUPDATEOBJECTBUFFERATIPROC)(::GLuint, ::GLuint, ::GLsizei, const ::GLvoid *, ::GLenum);
typedef void (*PFNGLGETOBJECTBUFFERFVATIPROC)(::GLuint, ::GLenum, ::GLfloat *);
typedef void (*PFNGLGETOBJECTBUFFERIVATIPROC)(::GLuint, ::GLenum, ::GLint *);
typedef void (*PFNGLFREEOBJECTBUFFERATIPROC)(::GLuint);
typedef void (*PFNGLARRAYOBJECTATIPROC)(::GLenum, ::GLint, ::GLenum, ::GLsizei, ::GLuint, ::GLuint);
typedef void (*PFNGLGETARRAYOBJECTFVATIPROC)(::GLenum, ::GLenum, ::GLfloat *);
typedef void (*PFNGLGETARRAYOBJECTIVATIPROC)(::GLenum, ::GLenum, ::GLint *);
typedef void (*PFNGLVARIANTARRAYOBJECTATIPROC)(::GLuint, ::GLenum, ::GLsizei, ::GLuint, ::GLuint);
typedef void (*PFNGLGETVARIANTARRAYOBJECTFVATIPROC)(::GLuint, ::GLenum, ::GLfloat *);
typedef void (*PFNGLGETVARIANTARRAYOBJECTIVATIPROC)(::GLuint, ::GLenum, ::GLint *);
extern "C"
{
  void glBeginVertexShaderEXT()__attribute__((visibility("default")));
}
extern "C"
{
  void glEndVertexShaderEXT()__attribute__((visibility("default")));
}
extern "C"
{
  void glBindVertexShaderEXT(::GLuint id)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLuint glGenVertexShadersEXT(::GLuint range)__attribute__((visibility("default")));
}
extern "C"
{
  void glDeleteVertexShaderEXT(::GLuint id)__attribute__((visibility("default")));
}
extern "C"
{
  void glShaderOp1EXT(::GLenum op, ::GLuint res, ::GLuint arg1)__attribute__((visibility("default")));
}
extern "C"
{
  void glShaderOp2EXT(::GLenum op, ::GLuint res, ::GLuint arg1, ::GLuint arg2)__attribute__((visibility("default")));
}
extern "C"
{
  void glShaderOp3EXT(::GLenum op, ::GLuint res, ::GLuint arg1, ::GLuint arg2, ::GLuint arg3)__attribute__((visibility("default")));
}
extern "C"
{
  void glSwizzleEXT(::GLuint res, ::GLuint in, ::GLenum outX, ::GLenum outY, ::GLenum outZ, ::GLenum outW)__attribute__((visibility("default")));
}
extern "C"
{
  void glWriteMaskEXT(::GLuint res, ::GLuint in, ::GLenum outX, ::GLenum outY, ::GLenum outZ, ::GLenum outW)__attribute__((visibility("default")));
}
extern "C"
{
  void glInsertComponentEXT(::GLuint res, ::GLuint src, ::GLuint num)__attribute__((visibility("default")));
}
extern "C"
{
  void glExtractComponentEXT(::GLuint res, ::GLuint src, ::GLuint num)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLuint glGenSymbolsEXT(::GLenum datatype, ::GLenum storagetype, ::GLenum range, ::GLuint components)__attribute__((visibility("default")));
}
extern "C"
{
  void glSetInvariantEXT(::GLuint id, ::GLenum type, const ::GLvoid *addr)__attribute__((visibility("default")));
}
extern "C"
{
  void glSetLocalConstantEXT(::GLuint id, ::GLenum type, const ::GLvoid *addr)__attribute__((visibility("default")));
}
extern "C"
{
  void glVariantbvEXT(::GLuint id, const ::GLbyte *addr)__attribute__((visibility("default")));
}
extern "C"
{
  void glVariantsvEXT(::GLuint id, const ::GLshort *addr)__attribute__((visibility("default")));
}
extern "C"
{
  void glVariantivEXT(::GLuint id, const ::GLint *addr)__attribute__((visibility("default")));
}
extern "C"
{
  void glVariantfvEXT(::GLuint id, const ::GLfloat *addr)__attribute__((visibility("default")));
}
extern "C"
{
  void glVariantdvEXT(::GLuint id, const ::GLdouble *addr)__attribute__((visibility("default")));
}
extern "C"
{
  void glVariantubvEXT(::GLuint id, const ::GLubyte *addr)__attribute__((visibility("default")));
}
extern "C"
{
  void glVariantusvEXT(::GLuint id, const ::GLushort *addr)__attribute__((visibility("default")));
}
extern "C"
{
  void glVariantuivEXT(::GLuint id, const ::GLuint *addr)__attribute__((visibility("default")));
}
extern "C"
{
  void glVariantPointerEXT(::GLuint id, ::GLenum type, ::GLuint stride, const ::GLvoid *addr)__attribute__((visibility("default")));
}
extern "C"
{
  void glEnableVariantClientStateEXT(::GLuint id)__attribute__((visibility("default")));
}
extern "C"
{
  void glDisableVariantClientStateEXT(::GLuint id)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLuint glBindLightParameterEXT(::GLenum light, ::GLenum value)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLuint glBindMaterialParameterEXT(::GLenum face, ::GLenum value)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLuint glBindTexGenParameterEXT(::GLenum unit, ::GLenum coord, ::GLenum value)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLuint glBindTextureUnitParameterEXT(::GLenum unit, ::GLenum value)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLuint glBindParameterEXT(::GLenum value)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLboolean glIsVariantEnabledEXT(::GLuint id, ::GLenum cap)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetVariantBooleanvEXT(::GLuint id, ::GLenum value, ::GLboolean *data)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetVariantIntegervEXT(::GLuint id, ::GLenum value, ::GLint *data)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetVariantFloatvEXT(::GLuint id, ::GLenum value, ::GLfloat *data)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetVariantPointervEXT(::GLuint id, ::GLenum value, ::GLvoid **data)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetInvariantBooleanvEXT(::GLuint id, ::GLenum value, ::GLboolean *data)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetInvariantIntegervEXT(::GLuint id, ::GLenum value, ::GLint *data)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetInvariantFloatvEXT(::GLuint id, ::GLenum value, ::GLfloat *data)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetLocalConstantBooleanvEXT(::GLuint id, ::GLenum value, ::GLboolean *data)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetLocalConstantIntegervEXT(::GLuint id, ::GLenum value, ::GLint *data)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetLocalConstantFloatvEXT(::GLuint id, ::GLenum value, ::GLfloat *data)__attribute__((visibility("default")));
}
typedef void (*PFNGLBEGINVERTEXSHADEREXTPROC)();
typedef void (*PFNGLENDVERTEXSHADEREXTPROC)();
typedef void (*PFNGLBINDVERTEXSHADEREXTPROC)(::GLuint);
typedef ::GLuint (*PFNGLGENVERTEXSHADERSEXTPROC)(::GLuint);
typedef void (*PFNGLDELETEVERTEXSHADEREXTPROC)(::GLuint);
typedef void (*PFNGLSHADEROP1EXTPROC)(::GLenum, ::GLuint, ::GLuint);
typedef void (*PFNGLSHADEROP2EXTPROC)(::GLenum, ::GLuint, ::GLuint, ::GLuint);
typedef void (*PFNGLSHADEROP3EXTPROC)(::GLenum, ::GLuint, ::GLuint, ::GLuint, ::GLuint);
typedef void (*PFNGLSWIZZLEEXTPROC)(::GLuint, ::GLuint, ::GLenum, ::GLenum, ::GLenum, ::GLenum);
typedef void (*PFNGLWRITEMASKEXTPROC)(::GLuint, ::GLuint, ::GLenum, ::GLenum, ::GLenum, ::GLenum);
typedef void (*PFNGLINSERTCOMPONENTEXTPROC)(::GLuint, ::GLuint, ::GLuint);
typedef void (*PFNGLEXTRACTCOMPONENTEXTPROC)(::GLuint, ::GLuint, ::GLuint);
typedef ::GLuint (*PFNGLGENSYMBOLSEXTPROC)(::GLenum, ::GLenum, ::GLenum, ::GLuint);
typedef void (*PFNGLSETINVARIANTEXTPROC)(::GLuint, ::GLenum, const ::GLvoid *);
typedef void (*PFNGLSETLOCALCONSTANTEXTPROC)(::GLuint, ::GLenum, const ::GLvoid *);
typedef void (*PFNGLVARIANTBVEXTPROC)(::GLuint, const ::GLbyte *);
typedef void (*PFNGLVARIANTSVEXTPROC)(::GLuint, const ::GLshort *);
typedef void (*PFNGLVARIANTIVEXTPROC)(::GLuint, const ::GLint *);
typedef void (*PFNGLVARIANTFVEXTPROC)(::GLuint, const ::GLfloat *);
typedef void (*PFNGLVARIANTDVEXTPROC)(::GLuint, const ::GLdouble *);
typedef void (*PFNGLVARIANTUBVEXTPROC)(::GLuint, const ::GLubyte *);
typedef void (*PFNGLVARIANTUSVEXTPROC)(::GLuint, const ::GLushort *);
typedef void (*PFNGLVARIANTUIVEXTPROC)(::GLuint, const ::GLuint *);
typedef void (*PFNGLVARIANTPOINTEREXTPROC)(::GLuint, ::GLenum, ::GLuint, const ::GLvoid *);
typedef void (*PFNGLENABLEVARIANTCLIENTSTATEEXTPROC)(::GLuint);
typedef void (*PFNGLDISABLEVARIANTCLIENTSTATEEXTPROC)(::GLuint);
typedef ::GLuint (*PFNGLBINDLIGHTPARAMETEREXTPROC)(::GLenum, ::GLenum);
typedef ::GLuint (*PFNGLBINDMATERIALPARAMETEREXTPROC)(::GLenum, ::GLenum);
typedef ::GLuint (*PFNGLBINDTEXGENPARAMETEREXTPROC)(::GLenum, ::GLenum, ::GLenum);
typedef ::GLuint (*PFNGLBINDTEXTUREUNITPARAMETEREXTPROC)(::GLenum, ::GLenum);
typedef ::GLuint (*PFNGLBINDPARAMETEREXTPROC)(::GLenum);
typedef ::GLboolean (*PFNGLISVARIANTENABLEDEXTPROC)(::GLuint, ::GLenum);
typedef void (*PFNGLGETVARIANTBOOLEANVEXTPROC)(::GLuint, ::GLenum, ::GLboolean *);
typedef void (*PFNGLGETVARIANTINTEGERVEXTPROC)(::GLuint, ::GLenum, ::GLint *);
typedef void (*PFNGLGETVARIANTFLOATVEXTPROC)(::GLuint, ::GLenum, ::GLfloat *);
typedef void (*PFNGLGETVARIANTPOINTERVEXTPROC)(::GLuint, ::GLenum, ::GLvoid **);
typedef void (*PFNGLGETINVARIANTBOOLEANVEXTPROC)(::GLuint, ::GLenum, ::GLboolean *);
typedef void (*PFNGLGETINVARIANTINTEGERVEXTPROC)(::GLuint, ::GLenum, ::GLint *);
typedef void (*PFNGLGETINVARIANTFLOATVEXTPROC)(::GLuint, ::GLenum, ::GLfloat *);
typedef void (*PFNGLGETLOCALCONSTANTBOOLEANVEXTPROC)(::GLuint, ::GLenum, ::GLboolean *);
typedef void (*PFNGLGETLOCALCONSTANTINTEGERVEXTPROC)(::GLuint, ::GLenum, ::GLint *);
typedef void (*PFNGLGETLOCALCONSTANTFLOATVEXTPROC)(::GLuint, ::GLenum, ::GLfloat *);
extern "C"
{
  void glVertexStream1sATI(::GLenum stream, ::GLshort x)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexStream1svATI(::GLenum stream, const ::GLshort *coords)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexStream1iATI(::GLenum stream, ::GLint x)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexStream1ivATI(::GLenum stream, const ::GLint *coords)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexStream1fATI(::GLenum stream, ::GLfloat x)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexStream1fvATI(::GLenum stream, const ::GLfloat *coords)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexStream1dATI(::GLenum stream, ::GLdouble x)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexStream1dvATI(::GLenum stream, const ::GLdouble *coords)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexStream2sATI(::GLenum stream, ::GLshort x, ::GLshort y)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexStream2svATI(::GLenum stream, const ::GLshort *coords)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexStream2iATI(::GLenum stream, ::GLint x, ::GLint y)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexStream2ivATI(::GLenum stream, const ::GLint *coords)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexStream2fATI(::GLenum stream, ::GLfloat x, ::GLfloat y)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexStream2fvATI(::GLenum stream, const ::GLfloat *coords)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexStream2dATI(::GLenum stream, ::GLdouble x, ::GLdouble y)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexStream2dvATI(::GLenum stream, const ::GLdouble *coords)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexStream3sATI(::GLenum stream, ::GLshort x, ::GLshort y, ::GLshort z)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexStream3svATI(::GLenum stream, const ::GLshort *coords)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexStream3iATI(::GLenum stream, ::GLint x, ::GLint y, ::GLint z)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexStream3ivATI(::GLenum stream, const ::GLint *coords)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexStream3fATI(::GLenum stream, ::GLfloat x, ::GLfloat y, ::GLfloat z)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexStream3fvATI(::GLenum stream, const ::GLfloat *coords)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexStream3dATI(::GLenum stream, ::GLdouble x, ::GLdouble y, ::GLdouble z)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexStream3dvATI(::GLenum stream, const ::GLdouble *coords)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexStream4sATI(::GLenum stream, ::GLshort x, ::GLshort y, ::GLshort z, ::GLshort w)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexStream4svATI(::GLenum stream, const ::GLshort *coords)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexStream4iATI(::GLenum stream, ::GLint x, ::GLint y, ::GLint z, ::GLint w)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexStream4ivATI(::GLenum stream, const ::GLint *coords)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexStream4fATI(::GLenum stream, ::GLfloat x, ::GLfloat y, ::GLfloat z, ::GLfloat w)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexStream4fvATI(::GLenum stream, const ::GLfloat *coords)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexStream4dATI(::GLenum stream, ::GLdouble x, ::GLdouble y, ::GLdouble z, ::GLdouble w)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexStream4dvATI(::GLenum stream, const ::GLdouble *coords)__attribute__((visibility("default")));
}
extern "C"
{
  void glNormalStream3bATI(::GLenum stream, ::GLbyte nx, ::GLbyte ny, ::GLbyte nz)__attribute__((visibility("default")));
}
extern "C"
{
  void glNormalStream3bvATI(::GLenum stream, const ::GLbyte *coords)__attribute__((visibility("default")));
}
extern "C"
{
  void glNormalStream3sATI(::GLenum stream, ::GLshort nx, ::GLshort ny, ::GLshort nz)__attribute__((visibility("default")));
}
extern "C"
{
  void glNormalStream3svATI(::GLenum stream, const ::GLshort *coords)__attribute__((visibility("default")));
}
extern "C"
{
  void glNormalStream3iATI(::GLenum stream, ::GLint nx, ::GLint ny, ::GLint nz)__attribute__((visibility("default")));
}
extern "C"
{
  void glNormalStream3ivATI(::GLenum stream, const ::GLint *coords)__attribute__((visibility("default")));
}
extern "C"
{
  void glNormalStream3fATI(::GLenum stream, ::GLfloat nx, ::GLfloat ny, ::GLfloat nz)__attribute__((visibility("default")));
}
extern "C"
{
  void glNormalStream3fvATI(::GLenum stream, const ::GLfloat *coords)__attribute__((visibility("default")));
}
extern "C"
{
  void glNormalStream3dATI(::GLenum stream, ::GLdouble nx, ::GLdouble ny, ::GLdouble nz)__attribute__((visibility("default")));
}
extern "C"
{
  void glNormalStream3dvATI(::GLenum stream, const ::GLdouble *coords)__attribute__((visibility("default")));
}
extern "C"
{
  void glClientActiveVertexStreamATI(::GLenum stream)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexBlendEnviATI(::GLenum pname, ::GLint param)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexBlendEnvfATI(::GLenum pname, ::GLfloat param)__attribute__((visibility("default")));
}
typedef void (*PFNGLVERTEXSTREAM1SATIPROC)(::GLenum, ::GLshort);
typedef void (*PFNGLVERTEXSTREAM1SVATIPROC)(::GLenum, const ::GLshort *);
typedef void (*PFNGLVERTEXSTREAM1IATIPROC)(::GLenum, ::GLint);
typedef void (*PFNGLVERTEXSTREAM1IVATIPROC)(::GLenum, const ::GLint *);
typedef void (*PFNGLVERTEXSTREAM1FATIPROC)(::GLenum, ::GLfloat);
typedef void (*PFNGLVERTEXSTREAM1FVATIPROC)(::GLenum, const ::GLfloat *);
typedef void (*PFNGLVERTEXSTREAM1DATIPROC)(::GLenum, ::GLdouble);
typedef void (*PFNGLVERTEXSTREAM1DVATIPROC)(::GLenum, const ::GLdouble *);
typedef void (*PFNGLVERTEXSTREAM2SATIPROC)(::GLenum, ::GLshort, ::GLshort);
typedef void (*PFNGLVERTEXSTREAM2SVATIPROC)(::GLenum, const ::GLshort *);
typedef void (*PFNGLVERTEXSTREAM2IATIPROC)(::GLenum, ::GLint, ::GLint);
typedef void (*PFNGLVERTEXSTREAM2IVATIPROC)(::GLenum, const ::GLint *);
typedef void (*PFNGLVERTEXSTREAM2FATIPROC)(::GLenum, ::GLfloat, ::GLfloat);
typedef void (*PFNGLVERTEXSTREAM2FVATIPROC)(::GLenum, const ::GLfloat *);
typedef void (*PFNGLVERTEXSTREAM2DATIPROC)(::GLenum, ::GLdouble, ::GLdouble);
typedef void (*PFNGLVERTEXSTREAM2DVATIPROC)(::GLenum, const ::GLdouble *);
typedef void (*PFNGLVERTEXSTREAM3SATIPROC)(::GLenum, ::GLshort, ::GLshort, ::GLshort);
typedef void (*PFNGLVERTEXSTREAM3SVATIPROC)(::GLenum, const ::GLshort *);
typedef void (*PFNGLVERTEXSTREAM3IATIPROC)(::GLenum, ::GLint, ::GLint, ::GLint);
typedef void (*PFNGLVERTEXSTREAM3IVATIPROC)(::GLenum, const ::GLint *);
typedef void (*PFNGLVERTEXSTREAM3FATIPROC)(::GLenum, ::GLfloat, ::GLfloat, ::GLfloat);
typedef void (*PFNGLVERTEXSTREAM3FVATIPROC)(::GLenum, const ::GLfloat *);
typedef void (*PFNGLVERTEXSTREAM3DATIPROC)(::GLenum, ::GLdouble, ::GLdouble, ::GLdouble);
typedef void (*PFNGLVERTEXSTREAM3DVATIPROC)(::GLenum, const ::GLdouble *);
typedef void (*PFNGLVERTEXSTREAM4SATIPROC)(::GLenum, ::GLshort, ::GLshort, ::GLshort, ::GLshort);
typedef void (*PFNGLVERTEXSTREAM4SVATIPROC)(::GLenum, const ::GLshort *);
typedef void (*PFNGLVERTEXSTREAM4IATIPROC)(::GLenum, ::GLint, ::GLint, ::GLint, ::GLint);
typedef void (*PFNGLVERTEXSTREAM4IVATIPROC)(::GLenum, const ::GLint *);
typedef void (*PFNGLVERTEXSTREAM4FATIPROC)(::GLenum, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat);
typedef void (*PFNGLVERTEXSTREAM4FVATIPROC)(::GLenum, const ::GLfloat *);
typedef void (*PFNGLVERTEXSTREAM4DATIPROC)(::GLenum, ::GLdouble, ::GLdouble, ::GLdouble, ::GLdouble);
typedef void (*PFNGLVERTEXSTREAM4DVATIPROC)(::GLenum, const ::GLdouble *);
typedef void (*PFNGLNORMALSTREAM3BATIPROC)(::GLenum, ::GLbyte, ::GLbyte, ::GLbyte);
typedef void (*PFNGLNORMALSTREAM3BVATIPROC)(::GLenum, const ::GLbyte *);
typedef void (*PFNGLNORMALSTREAM3SATIPROC)(::GLenum, ::GLshort, ::GLshort, ::GLshort);
typedef void (*PFNGLNORMALSTREAM3SVATIPROC)(::GLenum, const ::GLshort *);
typedef void (*PFNGLNORMALSTREAM3IATIPROC)(::GLenum, ::GLint, ::GLint, ::GLint);
typedef void (*PFNGLNORMALSTREAM3IVATIPROC)(::GLenum, const ::GLint *);
typedef void (*PFNGLNORMALSTREAM3FATIPROC)(::GLenum, ::GLfloat, ::GLfloat, ::GLfloat);
typedef void (*PFNGLNORMALSTREAM3FVATIPROC)(::GLenum, const ::GLfloat *);
typedef void (*PFNGLNORMALSTREAM3DATIPROC)(::GLenum, ::GLdouble, ::GLdouble, ::GLdouble);
typedef void (*PFNGLNORMALSTREAM3DVATIPROC)(::GLenum, const ::GLdouble *);
typedef void (*PFNGLCLIENTACTIVEVERTEXSTREAMATIPROC)(::GLenum);
typedef void (*PFNGLVERTEXBLENDENVIATIPROC)(::GLenum, ::GLint);
typedef void (*PFNGLVERTEXBLENDENVFATIPROC)(::GLenum, ::GLfloat);
extern "C"
{
  void glElementPointerATI(::GLenum type, const ::GLvoid *pointer)__attribute__((visibility("default")));
}
extern "C"
{
  void glDrawElementArrayATI(::GLenum mode, ::GLsizei count)__attribute__((visibility("default")));
}
extern "C"
{
  void glDrawRangeElementArrayATI(::GLenum mode, ::GLuint start, ::GLuint end, ::GLsizei count)__attribute__((visibility("default")));
}
typedef void (*PFNGLELEMENTPOINTERATIPROC)(::GLenum, const ::GLvoid *);
typedef void (*PFNGLDRAWELEMENTARRAYATIPROC)(::GLenum, ::GLsizei);
typedef void (*PFNGLDRAWRANGEELEMENTARRAYATIPROC)(::GLenum, ::GLuint, ::GLuint, ::GLsizei);
extern "C"
{
  void glDrawMeshArraysSUN(::GLenum mode, ::GLint first, ::GLsizei count, ::GLsizei width)__attribute__((visibility("default")));
}
typedef void (*PFNGLDRAWMESHARRAYSSUNPROC)(::GLenum, ::GLint, ::GLsizei, ::GLsizei);
extern "C"
{
  void glGenOcclusionQueriesNV(::GLsizei n, ::GLuint *ids)__attribute__((visibility("default")));
}
extern "C"
{
  void glDeleteOcclusionQueriesNV(::GLsizei n, const ::GLuint *ids)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLboolean glIsOcclusionQueryNV(::GLuint id)__attribute__((visibility("default")));
}
extern "C"
{
  void glBeginOcclusionQueryNV(::GLuint id)__attribute__((visibility("default")));
}
extern "C"
{
  void glEndOcclusionQueryNV()__attribute__((visibility("default")));
}
extern "C"
{
  void glGetOcclusionQueryivNV(::GLuint id, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetOcclusionQueryuivNV(::GLuint id, ::GLenum pname, ::GLuint *params)__attribute__((visibility("default")));
}
typedef void (*PFNGLGENOCCLUSIONQUERIESNVPROC)(::GLsizei, ::GLuint *);
typedef void (*PFNGLDELETEOCCLUSIONQUERIESNVPROC)(::GLsizei, const ::GLuint *);
typedef ::GLboolean (*PFNGLISOCCLUSIONQUERYNVPROC)(::GLuint);
typedef void (*PFNGLBEGINOCCLUSIONQUERYNVPROC)(::GLuint);
typedef void (*PFNGLENDOCCLUSIONQUERYNVPROC)();
typedef void (*PFNGLGETOCCLUSIONQUERYIVNVPROC)(::GLuint, ::GLenum, ::GLint *);
typedef void (*PFNGLGETOCCLUSIONQUERYUIVNVPROC)(::GLuint, ::GLenum, ::GLuint *);
extern "C"
{
  void glPointParameteriNV(::GLenum pname, ::GLint param)__attribute__((visibility("default")));
}
extern "C"
{
  void glPointParameterivNV(::GLenum pname, const ::GLint *params)__attribute__((visibility("default")));
}
typedef void (*PFNGLPOINTPARAMETERINVPROC)(::GLenum, ::GLint);
typedef void (*PFNGLPOINTPARAMETERIVNVPROC)(::GLenum, const ::GLint *);
extern "C"
{
  void glActiveStencilFaceEXT(::GLenum face)__attribute__((visibility("default")));
}
typedef void (*PFNGLACTIVESTENCILFACEEXTPROC)(::GLenum);
extern "C"
{
  void glElementPointerAPPLE(::GLenum type, const ::GLvoid *pointer)__attribute__((visibility("default")));
}
extern "C"
{
  void glDrawElementArrayAPPLE(::GLenum mode, ::GLint first, ::GLsizei count)__attribute__((visibility("default")));
}
extern "C"
{
  void glDrawRangeElementArrayAPPLE(::GLenum mode, ::GLuint start, ::GLuint end, ::GLint first, ::GLsizei count)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiDrawElementArrayAPPLE(::GLenum mode, const ::GLint *first, const ::GLsizei *count, ::GLsizei primcount)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiDrawRangeElementArrayAPPLE(::GLenum mode, ::GLuint start, ::GLuint end, const ::GLint *first, const ::GLsizei *count, ::GLsizei primcount)__attribute__((visibility("default")));
}
typedef void (*PFNGLELEMENTPOINTERAPPLEPROC)(::GLenum, const ::GLvoid *);
typedef void (*PFNGLDRAWELEMENTARRAYAPPLEPROC)(::GLenum, ::GLint, ::GLsizei);
typedef void (*PFNGLDRAWRANGEELEMENTARRAYAPPLEPROC)(::GLenum, ::GLuint, ::GLuint, ::GLint, ::GLsizei);
typedef void (*PFNGLMULTIDRAWELEMENTARRAYAPPLEPROC)(::GLenum, const ::GLint *, const ::GLsizei *, ::GLsizei);
typedef void (*PFNGLMULTIDRAWRANGEELEMENTARRAYAPPLEPROC)(::GLenum, ::GLuint, ::GLuint, const ::GLint *, const ::GLsizei *, ::GLsizei);
extern "C"
{
  void glGenFencesAPPLE(::GLsizei n, ::GLuint *fences)__attribute__((visibility("default")));
}
extern "C"
{
  void glDeleteFencesAPPLE(::GLsizei n, const ::GLuint *fences)__attribute__((visibility("default")));
}
extern "C"
{
  void glSetFenceAPPLE(::GLuint fence)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLboolean glIsFenceAPPLE(::GLuint fence)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLboolean glTestFenceAPPLE(::GLuint fence)__attribute__((visibility("default")));
}
extern "C"
{
  void glFinishFenceAPPLE(::GLuint fence)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLboolean glTestObjectAPPLE(::GLenum object, ::GLuint name)__attribute__((visibility("default")));
}
extern "C"
{
  void glFinishObjectAPPLE(::GLenum object, ::GLint name)__attribute__((visibility("default")));
}
typedef void (*PFNGLGENFENCESAPPLEPROC)(::GLsizei, ::GLuint *);
typedef void (*PFNGLDELETEFENCESAPPLEPROC)(::GLsizei, const ::GLuint *);
typedef void (*PFNGLSETFENCEAPPLEPROC)(::GLuint);
typedef ::GLboolean (*PFNGLISFENCEAPPLEPROC)(::GLuint);
typedef ::GLboolean (*PFNGLTESTFENCEAPPLEPROC)(::GLuint);
typedef void (*PFNGLFINISHFENCEAPPLEPROC)(::GLuint);
typedef ::GLboolean (*PFNGLTESTOBJECTAPPLEPROC)(::GLenum, ::GLuint);
typedef void (*PFNGLFINISHOBJECTAPPLEPROC)(::GLenum, ::GLint);
extern "C"
{
  void glBindVertexArrayAPPLE(::GLuint array)__attribute__((visibility("default")));
}
extern "C"
{
  void glDeleteVertexArraysAPPLE(::GLsizei n, const ::GLuint *arrays)__attribute__((visibility("default")));
}
extern "C"
{
  void glGenVertexArraysAPPLE(::GLsizei n, ::GLuint *arrays)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLboolean glIsVertexArrayAPPLE(::GLuint array)__attribute__((visibility("default")));
}
typedef void (*PFNGLBINDVERTEXARRAYAPPLEPROC)(::GLuint);
typedef void (*PFNGLDELETEVERTEXARRAYSAPPLEPROC)(::GLsizei, const ::GLuint *);
typedef void (*PFNGLGENVERTEXARRAYSAPPLEPROC)(::GLsizei, ::GLuint *);
typedef ::GLboolean (*PFNGLISVERTEXARRAYAPPLEPROC)(::GLuint);
extern "C"
{
  void glVertexArrayRangeAPPLE(::GLsizei length, ::GLvoid *pointer)__attribute__((visibility("default")));
}
extern "C"
{
  void glFlushVertexArrayRangeAPPLE(::GLsizei length, ::GLvoid *pointer)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexArrayParameteriAPPLE(::GLenum pname, ::GLint param)__attribute__((visibility("default")));
}
typedef void (*PFNGLVERTEXARRAYRANGEAPPLEPROC)(::GLsizei, ::GLvoid *);
typedef void (*PFNGLFLUSHVERTEXARRAYRANGEAPPLEPROC)(::GLsizei, ::GLvoid *);
typedef void (*PFNGLVERTEXARRAYPARAMETERIAPPLEPROC)(::GLenum, ::GLint);
extern "C"
{
  void glDrawBuffersATI(::GLsizei n, const ::GLenum *bufs)__attribute__((visibility("default")));
}
typedef void (*PFNGLDRAWBUFFERSATIPROC)(::GLsizei, const ::GLenum *);
extern "C"
{
  void glProgramNamedParameter4fNV(::GLuint id, ::GLsizei len, const ::GLubyte *name, ::GLfloat x, ::GLfloat y, ::GLfloat z, ::GLfloat w)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramNamedParameter4dNV(::GLuint id, ::GLsizei len, const ::GLubyte *name, ::GLdouble x, ::GLdouble y, ::GLdouble z, ::GLdouble w)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramNamedParameter4fvNV(::GLuint id, ::GLsizei len, const ::GLubyte *name, const ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramNamedParameter4dvNV(::GLuint id, ::GLsizei len, const ::GLubyte *name, const ::GLdouble *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetProgramNamedParameterfvNV(::GLuint id, ::GLsizei len, const ::GLubyte *name, ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetProgramNamedParameterdvNV(::GLuint id, ::GLsizei len, const ::GLubyte *name, ::GLdouble *params)__attribute__((visibility("default")));
}
typedef void (*PFNGLPROGRAMNAMEDPARAMETER4FNVPROC)(::GLuint, ::GLsizei, const ::GLubyte *, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat);
typedef void (*PFNGLPROGRAMNAMEDPARAMETER4DNVPROC)(::GLuint, ::GLsizei, const ::GLubyte *, ::GLdouble, ::GLdouble, ::GLdouble, ::GLdouble);
typedef void (*PFNGLPROGRAMNAMEDPARAMETER4FVNVPROC)(::GLuint, ::GLsizei, const ::GLubyte *, const ::GLfloat *);
typedef void (*PFNGLPROGRAMNAMEDPARAMETER4DVNVPROC)(::GLuint, ::GLsizei, const ::GLubyte *, const ::GLdouble *);
typedef void (*PFNGLGETPROGRAMNAMEDPARAMETERFVNVPROC)(::GLuint, ::GLsizei, const ::GLubyte *, ::GLfloat *);
typedef void (*PFNGLGETPROGRAMNAMEDPARAMETERDVNVPROC)(::GLuint, ::GLsizei, const ::GLubyte *, ::GLdouble *);
extern "C"
{
  void glVertex2hNV(::GLhalfNV x, ::GLhalfNV y)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertex2hvNV(const ::GLhalfNV *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertex3hNV(::GLhalfNV x, ::GLhalfNV y, ::GLhalfNV z)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertex3hvNV(const ::GLhalfNV *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertex4hNV(::GLhalfNV x, ::GLhalfNV y, ::GLhalfNV z, ::GLhalfNV w)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertex4hvNV(const ::GLhalfNV *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glNormal3hNV(::GLhalfNV nx, ::GLhalfNV ny, ::GLhalfNV nz)__attribute__((visibility("default")));
}
extern "C"
{
  void glNormal3hvNV(const ::GLhalfNV *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glColor3hNV(::GLhalfNV red, ::GLhalfNV green, ::GLhalfNV blue)__attribute__((visibility("default")));
}
extern "C"
{
  void glColor3hvNV(const ::GLhalfNV *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glColor4hNV(::GLhalfNV red, ::GLhalfNV green, ::GLhalfNV blue, ::GLhalfNV alpha)__attribute__((visibility("default")));
}
extern "C"
{
  void glColor4hvNV(const ::GLhalfNV *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexCoord1hNV(::GLhalfNV s)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexCoord1hvNV(const ::GLhalfNV *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexCoord2hNV(::GLhalfNV s, ::GLhalfNV t)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexCoord2hvNV(const ::GLhalfNV *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexCoord3hNV(::GLhalfNV s, ::GLhalfNV t, ::GLhalfNV r)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexCoord3hvNV(const ::GLhalfNV *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexCoord4hNV(::GLhalfNV s, ::GLhalfNV t, ::GLhalfNV r, ::GLhalfNV q)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexCoord4hvNV(const ::GLhalfNV *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord1hNV(::GLenum target, ::GLhalfNV s)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord1hvNV(::GLenum target, const ::GLhalfNV *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord2hNV(::GLenum target, ::GLhalfNV s, ::GLhalfNV t)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord2hvNV(::GLenum target, const ::GLhalfNV *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord3hNV(::GLenum target, ::GLhalfNV s, ::GLhalfNV t, ::GLhalfNV r)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord3hvNV(::GLenum target, const ::GLhalfNV *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord4hNV(::GLenum target, ::GLhalfNV s, ::GLhalfNV t, ::GLhalfNV r, ::GLhalfNV q)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoord4hvNV(::GLenum target, const ::GLhalfNV *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glFogCoordhNV(::GLhalfNV fog)__attribute__((visibility("default")));
}
extern "C"
{
  void glFogCoordhvNV(const ::GLhalfNV *fog)__attribute__((visibility("default")));
}
extern "C"
{
  void glSecondaryColor3hNV(::GLhalfNV red, ::GLhalfNV green, ::GLhalfNV blue)__attribute__((visibility("default")));
}
extern "C"
{
  void glSecondaryColor3hvNV(const ::GLhalfNV *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexWeighthNV(::GLhalfNV weight)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexWeighthvNV(const ::GLhalfNV *weight)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib1hNV(::GLuint index, ::GLhalfNV x)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib1hvNV(::GLuint index, const ::GLhalfNV *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib2hNV(::GLuint index, ::GLhalfNV x, ::GLhalfNV y)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib2hvNV(::GLuint index, const ::GLhalfNV *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib3hNV(::GLuint index, ::GLhalfNV x, ::GLhalfNV y, ::GLhalfNV z)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib3hvNV(::GLuint index, const ::GLhalfNV *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib4hNV(::GLuint index, ::GLhalfNV x, ::GLhalfNV y, ::GLhalfNV z, ::GLhalfNV w)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttrib4hvNV(::GLuint index, const ::GLhalfNV *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribs1hvNV(::GLuint index, ::GLsizei n, const ::GLhalfNV *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribs2hvNV(::GLuint index, ::GLsizei n, const ::GLhalfNV *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribs3hvNV(::GLuint index, ::GLsizei n, const ::GLhalfNV *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribs4hvNV(::GLuint index, ::GLsizei n, const ::GLhalfNV *v)__attribute__((visibility("default")));
}
typedef void (*PFNGLVERTEX2HNVPROC)(::GLhalfNV, ::GLhalfNV);
typedef void (*PFNGLVERTEX2HVNVPROC)(const ::GLhalfNV *);
typedef void (*PFNGLVERTEX3HNVPROC)(::GLhalfNV, ::GLhalfNV, ::GLhalfNV);
typedef void (*PFNGLVERTEX3HVNVPROC)(const ::GLhalfNV *);
typedef void (*PFNGLVERTEX4HNVPROC)(::GLhalfNV, ::GLhalfNV, ::GLhalfNV, ::GLhalfNV);
typedef void (*PFNGLVERTEX4HVNVPROC)(const ::GLhalfNV *);
typedef void (*PFNGLNORMAL3HNVPROC)(::GLhalfNV, ::GLhalfNV, ::GLhalfNV);
typedef void (*PFNGLNORMAL3HVNVPROC)(const ::GLhalfNV *);
typedef void (*PFNGLCOLOR3HNVPROC)(::GLhalfNV, ::GLhalfNV, ::GLhalfNV);
typedef void (*PFNGLCOLOR3HVNVPROC)(const ::GLhalfNV *);
typedef void (*PFNGLCOLOR4HNVPROC)(::GLhalfNV, ::GLhalfNV, ::GLhalfNV, ::GLhalfNV);
typedef void (*PFNGLCOLOR4HVNVPROC)(const ::GLhalfNV *);
typedef void (*PFNGLTEXCOORD1HNVPROC)(::GLhalfNV);
typedef void (*PFNGLTEXCOORD1HVNVPROC)(const ::GLhalfNV *);
typedef void (*PFNGLTEXCOORD2HNVPROC)(::GLhalfNV, ::GLhalfNV);
typedef void (*PFNGLTEXCOORD2HVNVPROC)(const ::GLhalfNV *);
typedef void (*PFNGLTEXCOORD3HNVPROC)(::GLhalfNV, ::GLhalfNV, ::GLhalfNV);
typedef void (*PFNGLTEXCOORD3HVNVPROC)(const ::GLhalfNV *);
typedef void (*PFNGLTEXCOORD4HNVPROC)(::GLhalfNV, ::GLhalfNV, ::GLhalfNV, ::GLhalfNV);
typedef void (*PFNGLTEXCOORD4HVNVPROC)(const ::GLhalfNV *);
typedef void (*PFNGLMULTITEXCOORD1HNVPROC)(::GLenum, ::GLhalfNV);
typedef void (*PFNGLMULTITEXCOORD1HVNVPROC)(::GLenum, const ::GLhalfNV *);
typedef void (*PFNGLMULTITEXCOORD2HNVPROC)(::GLenum, ::GLhalfNV, ::GLhalfNV);
typedef void (*PFNGLMULTITEXCOORD2HVNVPROC)(::GLenum, const ::GLhalfNV *);
typedef void (*PFNGLMULTITEXCOORD3HNVPROC)(::GLenum, ::GLhalfNV, ::GLhalfNV, ::GLhalfNV);
typedef void (*PFNGLMULTITEXCOORD3HVNVPROC)(::GLenum, const ::GLhalfNV *);
typedef void (*PFNGLMULTITEXCOORD4HNVPROC)(::GLenum, ::GLhalfNV, ::GLhalfNV, ::GLhalfNV, ::GLhalfNV);
typedef void (*PFNGLMULTITEXCOORD4HVNVPROC)(::GLenum, const ::GLhalfNV *);
typedef void (*PFNGLFOGCOORDHNVPROC)(::GLhalfNV);
typedef void (*PFNGLFOGCOORDHVNVPROC)(const ::GLhalfNV *);
typedef void (*PFNGLSECONDARYCOLOR3HNVPROC)(::GLhalfNV, ::GLhalfNV, ::GLhalfNV);
typedef void (*PFNGLSECONDARYCOLOR3HVNVPROC)(const ::GLhalfNV *);
typedef void (*PFNGLVERTEXWEIGHTHNVPROC)(::GLhalfNV);
typedef void (*PFNGLVERTEXWEIGHTHVNVPROC)(const ::GLhalfNV *);
typedef void (*PFNGLVERTEXATTRIB1HNVPROC)(::GLuint, ::GLhalfNV);
typedef void (*PFNGLVERTEXATTRIB1HVNVPROC)(::GLuint, const ::GLhalfNV *);
typedef void (*PFNGLVERTEXATTRIB2HNVPROC)(::GLuint, ::GLhalfNV, ::GLhalfNV);
typedef void (*PFNGLVERTEXATTRIB2HVNVPROC)(::GLuint, const ::GLhalfNV *);
typedef void (*PFNGLVERTEXATTRIB3HNVPROC)(::GLuint, ::GLhalfNV, ::GLhalfNV, ::GLhalfNV);
typedef void (*PFNGLVERTEXATTRIB3HVNVPROC)(::GLuint, const ::GLhalfNV *);
typedef void (*PFNGLVERTEXATTRIB4HNVPROC)(::GLuint, ::GLhalfNV, ::GLhalfNV, ::GLhalfNV, ::GLhalfNV);
typedef void (*PFNGLVERTEXATTRIB4HVNVPROC)(::GLuint, const ::GLhalfNV *);
typedef void (*PFNGLVERTEXATTRIBS1HVNVPROC)(::GLuint, ::GLsizei, const ::GLhalfNV *);
typedef void (*PFNGLVERTEXATTRIBS2HVNVPROC)(::GLuint, ::GLsizei, const ::GLhalfNV *);
typedef void (*PFNGLVERTEXATTRIBS3HVNVPROC)(::GLuint, ::GLsizei, const ::GLhalfNV *);
typedef void (*PFNGLVERTEXATTRIBS4HVNVPROC)(::GLuint, ::GLsizei, const ::GLhalfNV *);
extern "C"
{
  void glPixelDataRangeNV(::GLenum target, ::GLsizei length, ::GLvoid *pointer)__attribute__((visibility("default")));
}
extern "C"
{
  void glFlushPixelDataRangeNV(::GLenum target)__attribute__((visibility("default")));
}
typedef void (*PFNGLPIXELDATARANGENVPROC)(::GLenum, ::GLsizei, ::GLvoid *);
typedef void (*PFNGLFLUSHPIXELDATARANGENVPROC)(::GLenum);
extern "C"
{
  void glPrimitiveRestartNV()__attribute__((visibility("default")));
}
extern "C"
{
  void glPrimitiveRestartIndexNV(::GLuint index)__attribute__((visibility("default")));
}
typedef void (*PFNGLPRIMITIVERESTARTNVPROC)();
typedef void (*PFNGLPRIMITIVERESTARTINDEXNVPROC)(::GLuint);
extern "C"
{
  ::GLvoid *glMapObjectBufferATI(::GLuint buffer)__attribute__((visibility("default")));
}
extern "C"
{
  void glUnmapObjectBufferATI(::GLuint buffer)__attribute__((visibility("default")));
}
typedef ::GLvoid *(*PFNGLMAPOBJECTBUFFERATIPROC)(::GLuint);
typedef void (*PFNGLUNMAPOBJECTBUFFERATIPROC)(::GLuint);
extern "C"
{
  void glStencilOpSeparateATI(::GLenum face, ::GLenum sfail, ::GLenum dpfail, ::GLenum dppass)__attribute__((visibility("default")));
}
extern "C"
{
  void glStencilFuncSeparateATI(::GLenum frontfunc, ::GLenum backfunc, ::GLint ref, ::GLuint mask)__attribute__((visibility("default")));
}
typedef void (*PFNGLSTENCILOPSEPARATEATIPROC)(::GLenum, ::GLenum, ::GLenum, ::GLenum);
typedef void (*PFNGLSTENCILFUNCSEPARATEATIPROC)(::GLenum, ::GLenum, ::GLint, ::GLuint);
extern "C"
{
  void glVertexAttribArrayObjectATI(::GLuint index, ::GLint size, ::GLenum type, ::GLboolean normalized, ::GLsizei stride, ::GLuint buffer, ::GLuint offset)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetVertexAttribArrayObjectfvATI(::GLuint index, ::GLenum pname, ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetVertexAttribArrayObjectivATI(::GLuint index, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
typedef void (*PFNGLVERTEXATTRIBARRAYOBJECTATIPROC)(::GLuint, ::GLint, ::GLenum, ::GLboolean, ::GLsizei, ::GLuint, ::GLuint);
typedef void (*PFNGLGETVERTEXATTRIBARRAYOBJECTFVATIPROC)(::GLuint, ::GLenum, ::GLfloat *);
typedef void (*PFNGLGETVERTEXATTRIBARRAYOBJECTIVATIPROC)(::GLuint, ::GLenum, ::GLint *);
extern "C"
{
  void glDepthBoundsEXT(::GLclampd zmin, ::GLclampd zmax)__attribute__((visibility("default")));
}
typedef void (*PFNGLDEPTHBOUNDSEXTPROC)(::GLclampd, ::GLclampd);
extern "C"
{
  void glBlendEquationSeparateEXT(::GLenum modeRGB, ::GLenum modeAlpha)__attribute__((visibility("default")));
}
typedef void (*PFNGLBLENDEQUATIONSEPARATEEXTPROC)(::GLenum, ::GLenum);
extern "C"
{
  ::GLboolean glIsRenderbufferEXT(::GLuint renderbuffer)__attribute__((visibility("default")));
}
extern "C"
{
  void glBindRenderbufferEXT(::GLenum target, ::GLuint renderbuffer)__attribute__((visibility("default")));
}
extern "C"
{
  void glDeleteRenderbuffersEXT(::GLsizei n, const ::GLuint *renderbuffers)__attribute__((visibility("default")));
}
extern "C"
{
  void glGenRenderbuffersEXT(::GLsizei n, ::GLuint *renderbuffers)__attribute__((visibility("default")));
}
extern "C"
{
  void glRenderbufferStorageEXT(::GLenum target, ::GLenum internalformat, ::GLsizei width, ::GLsizei height)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetRenderbufferParameterivEXT(::GLenum target, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLboolean glIsFramebufferEXT(::GLuint framebuffer)__attribute__((visibility("default")));
}
extern "C"
{
  void glBindFramebufferEXT(::GLenum target, ::GLuint framebuffer)__attribute__((visibility("default")));
}
extern "C"
{
  void glDeleteFramebuffersEXT(::GLsizei n, const ::GLuint *framebuffers)__attribute__((visibility("default")));
}
extern "C"
{
  void glGenFramebuffersEXT(::GLsizei n, ::GLuint *framebuffers)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLenum glCheckFramebufferStatusEXT(::GLenum target)__attribute__((visibility("default")));
}
extern "C"
{
  void glFramebufferTexture1DEXT(::GLenum target, ::GLenum attachment, ::GLenum textarget, ::GLuint texture, ::GLint level)__attribute__((visibility("default")));
}
extern "C"
{
  void glFramebufferTexture2DEXT(::GLenum target, ::GLenum attachment, ::GLenum textarget, ::GLuint texture, ::GLint level)__attribute__((visibility("default")));
}
extern "C"
{
  void glFramebufferTexture3DEXT(::GLenum target, ::GLenum attachment, ::GLenum textarget, ::GLuint texture, ::GLint level, ::GLint zoffset)__attribute__((visibility("default")));
}
extern "C"
{
  void glFramebufferRenderbufferEXT(::GLenum target, ::GLenum attachment, ::GLenum renderbuffertarget, ::GLuint renderbuffer)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetFramebufferAttachmentParameterivEXT(::GLenum target, ::GLenum attachment, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGenerateMipmapEXT(::GLenum target)__attribute__((visibility("default")));
}
typedef ::GLboolean (*PFNGLISRENDERBUFFEREXTPROC)(::GLuint);
typedef void (*PFNGLBINDRENDERBUFFEREXTPROC)(::GLenum, ::GLuint);
typedef void (*PFNGLDELETERENDERBUFFERSEXTPROC)(::GLsizei, const ::GLuint *);
typedef void (*PFNGLGENRENDERBUFFERSEXTPROC)(::GLsizei, ::GLuint *);
typedef void (*PFNGLRENDERBUFFERSTORAGEEXTPROC)(::GLenum, ::GLenum, ::GLsizei, ::GLsizei);
typedef void (*PFNGLGETRENDERBUFFERPARAMETERIVEXTPROC)(::GLenum, ::GLenum, ::GLint *);
typedef ::GLboolean (*PFNGLISFRAMEBUFFEREXTPROC)(::GLuint);
typedef void (*PFNGLBINDFRAMEBUFFEREXTPROC)(::GLenum, ::GLuint);
typedef void (*PFNGLDELETEFRAMEBUFFERSEXTPROC)(::GLsizei, const ::GLuint *);
typedef void (*PFNGLGENFRAMEBUFFERSEXTPROC)(::GLsizei, ::GLuint *);
typedef ::GLenum (*PFNGLCHECKFRAMEBUFFERSTATUSEXTPROC)(::GLenum);
typedef void (*PFNGLFRAMEBUFFERTEXTURE1DEXTPROC)(::GLenum, ::GLenum, ::GLenum, ::GLuint, ::GLint);
typedef void (*PFNGLFRAMEBUFFERTEXTURE2DEXTPROC)(::GLenum, ::GLenum, ::GLenum, ::GLuint, ::GLint);
typedef void (*PFNGLFRAMEBUFFERTEXTURE3DEXTPROC)(::GLenum, ::GLenum, ::GLenum, ::GLuint, ::GLint, ::GLint);
typedef void (*PFNGLFRAMEBUFFERRENDERBUFFEREXTPROC)(::GLenum, ::GLenum, ::GLenum, ::GLuint);
typedef void (*PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC)(::GLenum, ::GLenum, ::GLenum, ::GLint *);
typedef void (*PFNGLGENERATEMIPMAPEXTPROC)(::GLenum);
extern "C"
{
  void glStringMarkerGREMEDY(::GLsizei len, const ::GLvoid *string)__attribute__((visibility("default")));
}
typedef void (*PFNGLSTRINGMARKERGREMEDYPROC)(::GLsizei, const ::GLvoid *);
extern "C"
{
  void glStencilClearTagEXT(::GLsizei stencilTagBits, ::GLuint stencilClearTag)__attribute__((visibility("default")));
}
typedef void (*PFNGLSTENCILCLEARTAGEXTPROC)(::GLsizei, ::GLuint);
extern "C"
{
  void glBlitFramebufferEXT(::GLint srcX0, ::GLint srcY0, ::GLint srcX1, ::GLint srcY1, ::GLint dstX0, ::GLint dstY0, ::GLint dstX1, ::GLint dstY1, ::GLbitfield mask, ::GLenum filter)__attribute__((visibility("default")));
}
typedef void (*PFNGLBLITFRAMEBUFFEREXTPROC)(::GLint, ::GLint, ::GLint, ::GLint, ::GLint, ::GLint, ::GLint, ::GLint, ::GLbitfield, ::GLenum);
extern "C"
{
  void glRenderbufferStorageMultisampleEXT(::GLenum target, ::GLsizei samples, ::GLenum internalformat, ::GLsizei width, ::GLsizei height)__attribute__((visibility("default")));
}
typedef void (*PFNGLRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC)(::GLenum, ::GLsizei, ::GLenum, ::GLsizei, ::GLsizei);
extern "C"
{
  void glGetQueryObjecti64vEXT(::GLuint id, ::GLenum pname, ::GLint64EXT *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetQueryObjectui64vEXT(::GLuint id, ::GLenum pname, ::GLuint64EXT *params)__attribute__((visibility("default")));
}
typedef void (*PFNGLGETQUERYOBJECTI64VEXTPROC)(::GLuint, ::GLenum, ::GLint64EXT *);
typedef void (*PFNGLGETQUERYOBJECTUI64VEXTPROC)(::GLuint, ::GLenum, ::GLuint64EXT *);
extern "C"
{
  void glProgramEnvParameters4fvEXT(::GLenum target, ::GLuint index, ::GLsizei count, const ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramLocalParameters4fvEXT(::GLenum target, ::GLuint index, ::GLsizei count, const ::GLfloat *params)__attribute__((visibility("default")));
}
typedef void (*PFNGLPROGRAMENVPARAMETERS4FVEXTPROC)(::GLenum, ::GLuint, ::GLsizei, const ::GLfloat *);
typedef void (*PFNGLPROGRAMLOCALPARAMETERS4FVEXTPROC)(::GLenum, ::GLuint, ::GLsizei, const ::GLfloat *);
extern "C"
{
  void glBufferParameteriAPPLE(::GLenum target, ::GLenum pname, ::GLint param)__attribute__((visibility("default")));
}
extern "C"
{
  void glFlushMappedBufferRangeAPPLE(::GLenum target, ::GLintptr offset, ::GLsizeiptr size)__attribute__((visibility("default")));
}
typedef void (*PFNGLBUFFERPARAMETERIAPPLEPROC)(::GLenum, ::GLenum, ::GLint);
typedef void (*PFNGLFLUSHMAPPEDBUFFERRANGEAPPLEPROC)(::GLenum, ::GLintptr, ::GLsizeiptr);
extern "C"
{
  void glProgramLocalParameterI4iNV(::GLenum target, ::GLuint index, ::GLint x, ::GLint y, ::GLint z, ::GLint w)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramLocalParameterI4ivNV(::GLenum target, ::GLuint index, const ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramLocalParametersI4ivNV(::GLenum target, ::GLuint index, ::GLsizei count, const ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramLocalParameterI4uiNV(::GLenum target, ::GLuint index, ::GLuint x, ::GLuint y, ::GLuint z, ::GLuint w)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramLocalParameterI4uivNV(::GLenum target, ::GLuint index, const ::GLuint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramLocalParametersI4uivNV(::GLenum target, ::GLuint index, ::GLsizei count, const ::GLuint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramEnvParameterI4iNV(::GLenum target, ::GLuint index, ::GLint x, ::GLint y, ::GLint z, ::GLint w)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramEnvParameterI4ivNV(::GLenum target, ::GLuint index, const ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramEnvParametersI4ivNV(::GLenum target, ::GLuint index, ::GLsizei count, const ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramEnvParameterI4uiNV(::GLenum target, ::GLuint index, ::GLuint x, ::GLuint y, ::GLuint z, ::GLuint w)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramEnvParameterI4uivNV(::GLenum target, ::GLuint index, const ::GLuint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramEnvParametersI4uivNV(::GLenum target, ::GLuint index, ::GLsizei count, const ::GLuint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetProgramLocalParameterIivNV(::GLenum target, ::GLuint index, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetProgramLocalParameterIuivNV(::GLenum target, ::GLuint index, ::GLuint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetProgramEnvParameterIivNV(::GLenum target, ::GLuint index, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetProgramEnvParameterIuivNV(::GLenum target, ::GLuint index, ::GLuint *params)__attribute__((visibility("default")));
}
typedef void (*PFNGLPROGRAMLOCALPARAMETERI4INVPROC)(::GLenum, ::GLuint, ::GLint, ::GLint, ::GLint, ::GLint);
typedef void (*PFNGLPROGRAMLOCALPARAMETERI4IVNVPROC)(::GLenum, ::GLuint, const ::GLint *);
typedef void (*PFNGLPROGRAMLOCALPARAMETERSI4IVNVPROC)(::GLenum, ::GLuint, ::GLsizei, const ::GLint *);
typedef void (*PFNGLPROGRAMLOCALPARAMETERI4UINVPROC)(::GLenum, ::GLuint, ::GLuint, ::GLuint, ::GLuint, ::GLuint);
typedef void (*PFNGLPROGRAMLOCALPARAMETERI4UIVNVPROC)(::GLenum, ::GLuint, const ::GLuint *);
typedef void (*PFNGLPROGRAMLOCALPARAMETERSI4UIVNVPROC)(::GLenum, ::GLuint, ::GLsizei, const ::GLuint *);
typedef void (*PFNGLPROGRAMENVPARAMETERI4INVPROC)(::GLenum, ::GLuint, ::GLint, ::GLint, ::GLint, ::GLint);
typedef void (*PFNGLPROGRAMENVPARAMETERI4IVNVPROC)(::GLenum, ::GLuint, const ::GLint *);
typedef void (*PFNGLPROGRAMENVPARAMETERSI4IVNVPROC)(::GLenum, ::GLuint, ::GLsizei, const ::GLint *);
typedef void (*PFNGLPROGRAMENVPARAMETERI4UINVPROC)(::GLenum, ::GLuint, ::GLuint, ::GLuint, ::GLuint, ::GLuint);
typedef void (*PFNGLPROGRAMENVPARAMETERI4UIVNVPROC)(::GLenum, ::GLuint, const ::GLuint *);
typedef void (*PFNGLPROGRAMENVPARAMETERSI4UIVNVPROC)(::GLenum, ::GLuint, ::GLsizei, const ::GLuint *);
typedef void (*PFNGLGETPROGRAMLOCALPARAMETERIIVNVPROC)(::GLenum, ::GLuint, ::GLint *);
typedef void (*PFNGLGETPROGRAMLOCALPARAMETERIUIVNVPROC)(::GLenum, ::GLuint, ::GLuint *);
typedef void (*PFNGLGETPROGRAMENVPARAMETERIIVNVPROC)(::GLenum, ::GLuint, ::GLint *);
typedef void (*PFNGLGETPROGRAMENVPARAMETERIUIVNVPROC)(::GLenum, ::GLuint, ::GLuint *);
extern "C"
{
  void glProgramVertexLimitNV(::GLenum target, ::GLint limit)__attribute__((visibility("default")));
}
extern "C"
{
  void glFramebufferTextureEXT(::GLenum target, ::GLenum attachment, ::GLuint texture, ::GLint level)__attribute__((visibility("default")));
}
extern "C"
{
  void glFramebufferTextureLayerEXT(::GLenum target, ::GLenum attachment, ::GLuint texture, ::GLint level, ::GLint layer)__attribute__((visibility("default")));
}
extern "C"
{
  void glFramebufferTextureFaceEXT(::GLenum target, ::GLenum attachment, ::GLuint texture, ::GLint level, ::GLenum face)__attribute__((visibility("default")));
}
typedef void (*PFNGLPROGRAMVERTEXLIMITNVPROC)(::GLenum, ::GLint);
typedef void (*PFNGLFRAMEBUFFERTEXTUREEXTPROC)(::GLenum, ::GLenum, ::GLuint, ::GLint);
typedef void (*PFNGLFRAMEBUFFERTEXTURELAYEREXTPROC)(::GLenum, ::GLenum, ::GLuint, ::GLint, ::GLint);
typedef void (*PFNGLFRAMEBUFFERTEXTUREFACEEXTPROC)(::GLenum, ::GLenum, ::GLuint, ::GLint, ::GLenum);
extern "C"
{
  void glProgramParameteriEXT(::GLuint program, ::GLenum pname, ::GLint value)__attribute__((visibility("default")));
}
typedef void (*PFNGLPROGRAMPARAMETERIEXTPROC)(::GLuint, ::GLenum, ::GLint);
extern "C"
{
  void glVertexAttribI1iEXT(::GLuint index, ::GLint x)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribI2iEXT(::GLuint index, ::GLint x, ::GLint y)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribI3iEXT(::GLuint index, ::GLint x, ::GLint y, ::GLint z)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribI4iEXT(::GLuint index, ::GLint x, ::GLint y, ::GLint z, ::GLint w)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribI1uiEXT(::GLuint index, ::GLuint x)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribI2uiEXT(::GLuint index, ::GLuint x, ::GLuint y)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribI3uiEXT(::GLuint index, ::GLuint x, ::GLuint y, ::GLuint z)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribI4uiEXT(::GLuint index, ::GLuint x, ::GLuint y, ::GLuint z, ::GLuint w)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribI1ivEXT(::GLuint index, const ::GLint *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribI2ivEXT(::GLuint index, const ::GLint *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribI3ivEXT(::GLuint index, const ::GLint *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribI4ivEXT(::GLuint index, const ::GLint *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribI1uivEXT(::GLuint index, const ::GLuint *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribI2uivEXT(::GLuint index, const ::GLuint *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribI3uivEXT(::GLuint index, const ::GLuint *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribI4uivEXT(::GLuint index, const ::GLuint *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribI4bvEXT(::GLuint index, const ::GLbyte *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribI4svEXT(::GLuint index, const ::GLshort *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribI4ubvEXT(::GLuint index, const ::GLubyte *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribI4usvEXT(::GLuint index, const ::GLushort *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribIPointerEXT(::GLuint index, ::GLint size, ::GLenum type, ::GLsizei stride, const ::GLvoid *pointer)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetVertexAttribIivEXT(::GLuint index, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetVertexAttribIuivEXT(::GLuint index, ::GLenum pname, ::GLuint *params)__attribute__((visibility("default")));
}
typedef void (*PFNGLVERTEXATTRIBI1IEXTPROC)(::GLuint, ::GLint);
typedef void (*PFNGLVERTEXATTRIBI2IEXTPROC)(::GLuint, ::GLint, ::GLint);
typedef void (*PFNGLVERTEXATTRIBI3IEXTPROC)(::GLuint, ::GLint, ::GLint, ::GLint);
typedef void (*PFNGLVERTEXATTRIBI4IEXTPROC)(::GLuint, ::GLint, ::GLint, ::GLint, ::GLint);
typedef void (*PFNGLVERTEXATTRIBI1UIEXTPROC)(::GLuint, ::GLuint);
typedef void (*PFNGLVERTEXATTRIBI2UIEXTPROC)(::GLuint, ::GLuint, ::GLuint);
typedef void (*PFNGLVERTEXATTRIBI3UIEXTPROC)(::GLuint, ::GLuint, ::GLuint, ::GLuint);
typedef void (*PFNGLVERTEXATTRIBI4UIEXTPROC)(::GLuint, ::GLuint, ::GLuint, ::GLuint, ::GLuint);
typedef void (*PFNGLVERTEXATTRIBI1IVEXTPROC)(::GLuint, const ::GLint *);
typedef void (*PFNGLVERTEXATTRIBI2IVEXTPROC)(::GLuint, const ::GLint *);
typedef void (*PFNGLVERTEXATTRIBI3IVEXTPROC)(::GLuint, const ::GLint *);
typedef void (*PFNGLVERTEXATTRIBI4IVEXTPROC)(::GLuint, const ::GLint *);
typedef void (*PFNGLVERTEXATTRIBI1UIVEXTPROC)(::GLuint, const ::GLuint *);
typedef void (*PFNGLVERTEXATTRIBI2UIVEXTPROC)(::GLuint, const ::GLuint *);
typedef void (*PFNGLVERTEXATTRIBI3UIVEXTPROC)(::GLuint, const ::GLuint *);
typedef void (*PFNGLVERTEXATTRIBI4UIVEXTPROC)(::GLuint, const ::GLuint *);
typedef void (*PFNGLVERTEXATTRIBI4BVEXTPROC)(::GLuint, const ::GLbyte *);
typedef void (*PFNGLVERTEXATTRIBI4SVEXTPROC)(::GLuint, const ::GLshort *);
typedef void (*PFNGLVERTEXATTRIBI4UBVEXTPROC)(::GLuint, const ::GLubyte *);
typedef void (*PFNGLVERTEXATTRIBI4USVEXTPROC)(::GLuint, const ::GLushort *);
typedef void (*PFNGLVERTEXATTRIBIPOINTEREXTPROC)(::GLuint, ::GLint, ::GLenum, ::GLsizei, const ::GLvoid *);
typedef void (*PFNGLGETVERTEXATTRIBIIVEXTPROC)(::GLuint, ::GLenum, ::GLint *);
typedef void (*PFNGLGETVERTEXATTRIBIUIVEXTPROC)(::GLuint, ::GLenum, ::GLuint *);
extern "C"
{
  void glGetUniformuivEXT(::GLuint program, ::GLint location, ::GLuint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glBindFragDataLocationEXT(::GLuint program, ::GLuint color, const ::GLchar *name)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLint glGetFragDataLocationEXT(::GLuint program, const ::GLchar *name)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform1uiEXT(::GLint location, ::GLuint v0)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform2uiEXT(::GLint location, ::GLuint v0, ::GLuint v1)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform3uiEXT(::GLint location, ::GLuint v0, ::GLuint v1, ::GLuint v2)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform4uiEXT(::GLint location, ::GLuint v0, ::GLuint v1, ::GLuint v2, ::GLuint v3)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform1uivEXT(::GLint location, ::GLsizei count, const ::GLuint *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform2uivEXT(::GLint location, ::GLsizei count, const ::GLuint *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform3uivEXT(::GLint location, ::GLsizei count, const ::GLuint *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform4uivEXT(::GLint location, ::GLsizei count, const ::GLuint *value)__attribute__((visibility("default")));
}
typedef void (*PFNGLGETUNIFORMUIVEXTPROC)(::GLuint, ::GLint, ::GLuint *);
typedef void (*PFNGLBINDFRAGDATALOCATIONEXTPROC)(::GLuint, ::GLuint, const ::GLchar *);
typedef ::GLint (*PFNGLGETFRAGDATALOCATIONEXTPROC)(::GLuint, const ::GLchar *);
typedef void (*PFNGLUNIFORM1UIEXTPROC)(::GLint, ::GLuint);
typedef void (*PFNGLUNIFORM2UIEXTPROC)(::GLint, ::GLuint, ::GLuint);
typedef void (*PFNGLUNIFORM3UIEXTPROC)(::GLint, ::GLuint, ::GLuint, ::GLuint);
typedef void (*PFNGLUNIFORM4UIEXTPROC)(::GLint, ::GLuint, ::GLuint, ::GLuint, ::GLuint);
typedef void (*PFNGLUNIFORM1UIVEXTPROC)(::GLint, ::GLsizei, const ::GLuint *);
typedef void (*PFNGLUNIFORM2UIVEXTPROC)(::GLint, ::GLsizei, const ::GLuint *);
typedef void (*PFNGLUNIFORM3UIVEXTPROC)(::GLint, ::GLsizei, const ::GLuint *);
typedef void (*PFNGLUNIFORM4UIVEXTPROC)(::GLint, ::GLsizei, const ::GLuint *);
extern "C"
{
  void glDrawArraysInstancedEXT(::GLenum mode, ::GLint start, ::GLsizei count, ::GLsizei primcount)__attribute__((visibility("default")));
}
extern "C"
{
  void glDrawElementsInstancedEXT(::GLenum mode, ::GLsizei count, ::GLenum type, const ::GLvoid *indices, ::GLsizei primcount)__attribute__((visibility("default")));
}
typedef void (*PFNGLDRAWARRAYSINSTANCEDEXTPROC)(::GLenum, ::GLint, ::GLsizei, ::GLsizei);
typedef void (*PFNGLDRAWELEMENTSINSTANCEDEXTPROC)(::GLenum, ::GLsizei, ::GLenum, const ::GLvoid *, ::GLsizei);
extern "C"
{
  void glTexBufferEXT(::GLenum target, ::GLenum internalformat, ::GLuint buffer)__attribute__((visibility("default")));
}
typedef void (*PFNGLTEXBUFFEREXTPROC)(::GLenum, ::GLenum, ::GLuint);
extern "C"
{
  void glDepthRangedNV(::GLdouble zNear, ::GLdouble zFar)__attribute__((visibility("default")));
}
extern "C"
{
  void glClearDepthdNV(::GLdouble depth)__attribute__((visibility("default")));
}
extern "C"
{
  void glDepthBoundsdNV(::GLdouble zmin, ::GLdouble zmax)__attribute__((visibility("default")));
}
typedef void (*PFNGLDEPTHRANGEDNVPROC)(::GLdouble, ::GLdouble);
typedef void (*PFNGLCLEARDEPTHDNVPROC)(::GLdouble);
typedef void (*PFNGLDEPTHBOUNDSDNVPROC)(::GLdouble, ::GLdouble);
extern "C"
{
  void glRenderbufferStorageMultisampleCoverageNV(::GLenum target, ::GLsizei coverageSamples, ::GLsizei colorSamples, ::GLenum internalformat, ::GLsizei width, ::GLsizei height)__attribute__((visibility("default")));
}
typedef void (*PFNGLRENDERBUFFERSTORAGEMULTISAMPLECOVERAGENVPROC)(::GLenum, ::GLsizei, ::GLsizei, ::GLenum, ::GLsizei, ::GLsizei);
extern "C"
{
  void glProgramBufferParametersfvNV(::GLenum target, ::GLuint buffer, ::GLuint index, ::GLsizei count, const ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramBufferParametersIivNV(::GLenum target, ::GLuint buffer, ::GLuint index, ::GLsizei count, const ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramBufferParametersIuivNV(::GLenum target, ::GLuint buffer, ::GLuint index, ::GLsizei count, const ::GLuint *params)__attribute__((visibility("default")));
}
typedef void (*PFNGLPROGRAMBUFFERPARAMETERSFVNVPROC)(::GLenum, ::GLuint, ::GLuint, ::GLsizei, const ::GLfloat *);
typedef void (*PFNGLPROGRAMBUFFERPARAMETERSIIVNVPROC)(::GLenum, ::GLuint, ::GLuint, ::GLsizei, const ::GLint *);
typedef void (*PFNGLPROGRAMBUFFERPARAMETERSIUIVNVPROC)(::GLenum, ::GLuint, ::GLuint, ::GLsizei, const ::GLuint *);
extern "C"
{
  void glColorMaskIndexedEXT(::GLuint index, ::GLboolean r, ::GLboolean g, ::GLboolean b, ::GLboolean a)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetBooleanIndexedvEXT(::GLenum target, ::GLuint index, ::GLboolean *data)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetIntegerIndexedvEXT(::GLenum target, ::GLuint index, ::GLint *data)__attribute__((visibility("default")));
}
extern "C"
{
  void glEnableIndexedEXT(::GLenum target, ::GLuint index)__attribute__((visibility("default")));
}
extern "C"
{
  void glDisableIndexedEXT(::GLenum target, ::GLuint index)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLboolean glIsEnabledIndexedEXT(::GLenum target, ::GLuint index)__attribute__((visibility("default")));
}
typedef void (*PFNGLCOLORMASKINDEXEDEXTPROC)(::GLuint, ::GLboolean, ::GLboolean, ::GLboolean, ::GLboolean);
typedef void (*PFNGLGETBOOLEANINDEXEDVEXTPROC)(::GLenum, ::GLuint, ::GLboolean *);
typedef void (*PFNGLGETINTEGERINDEXEDVEXTPROC)(::GLenum, ::GLuint, ::GLint *);
typedef void (*PFNGLENABLEINDEXEDEXTPROC)(::GLenum, ::GLuint);
typedef void (*PFNGLDISABLEINDEXEDEXTPROC)(::GLenum, ::GLuint);
typedef ::GLboolean (*PFNGLISENABLEDINDEXEDEXTPROC)(::GLenum, ::GLuint);
extern "C"
{
  void glBeginTransformFeedbackNV(::GLenum primitiveMode)__attribute__((visibility("default")));
}
extern "C"
{
  void glEndTransformFeedbackNV()__attribute__((visibility("default")));
}
extern "C"
{
  void glTransformFeedbackAttribsNV(::GLuint count, const ::GLint *attribs, ::GLenum bufferMode)__attribute__((visibility("default")));
}
extern "C"
{
  void glBindBufferRangeNV(::GLenum target, ::GLuint index, ::GLuint buffer, ::GLintptr offset, ::GLsizeiptr size)__attribute__((visibility("default")));
}
extern "C"
{
  void glBindBufferOffsetNV(::GLenum target, ::GLuint index, ::GLuint buffer, ::GLintptr offset)__attribute__((visibility("default")));
}
extern "C"
{
  void glBindBufferBaseNV(::GLenum target, ::GLuint index, ::GLuint buffer)__attribute__((visibility("default")));
}
extern "C"
{
  void glTransformFeedbackVaryingsNV(::GLuint program, ::GLsizei count, const ::GLint *locations, ::GLenum bufferMode)__attribute__((visibility("default")));
}
extern "C"
{
  void glActiveVaryingNV(::GLuint program, const ::GLchar *name)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLint glGetVaryingLocationNV(::GLuint program, const ::GLchar *name)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetActiveVaryingNV(::GLuint program, ::GLuint index, ::GLsizei bufSize, ::GLsizei *length, ::GLsizei *size, ::GLenum *type, ::GLchar *name)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetTransformFeedbackVaryingNV(::GLuint program, ::GLuint index, ::GLint *location)__attribute__((visibility("default")));
}
extern "C"
{
  void glTransformFeedbackStreamAttribsNV(::GLsizei count, const ::GLint *attribs, ::GLsizei nbuffers, const ::GLint *bufstreams, ::GLenum bufferMode)__attribute__((visibility("default")));
}
typedef void (*PFNGLBEGINTRANSFORMFEEDBACKNVPROC)(::GLenum);
typedef void (*PFNGLENDTRANSFORMFEEDBACKNVPROC)();
typedef void (*PFNGLTRANSFORMFEEDBACKATTRIBSNVPROC)(::GLuint, const ::GLint *, ::GLenum);
typedef void (*PFNGLBINDBUFFERRANGENVPROC)(::GLenum, ::GLuint, ::GLuint, ::GLintptr, ::GLsizeiptr);
typedef void (*PFNGLBINDBUFFEROFFSETNVPROC)(::GLenum, ::GLuint, ::GLuint, ::GLintptr);
typedef void (*PFNGLBINDBUFFERBASENVPROC)(::GLenum, ::GLuint, ::GLuint);
typedef void (*PFNGLTRANSFORMFEEDBACKVARYINGSNVPROC)(::GLuint, ::GLsizei, const ::GLint *, ::GLenum);
typedef void (*PFNGLACTIVEVARYINGNVPROC)(::GLuint, const ::GLchar *);
typedef ::GLint (*PFNGLGETVARYINGLOCATIONNVPROC)(::GLuint, const ::GLchar *);
typedef void (*PFNGLGETACTIVEVARYINGNVPROC)(::GLuint, ::GLuint, ::GLsizei, ::GLsizei *, ::GLsizei *, ::GLenum *, ::GLchar *);
typedef void (*PFNGLGETTRANSFORMFEEDBACKVARYINGNVPROC)(::GLuint, ::GLuint, ::GLint *);
typedef void (*PFNGLTRANSFORMFEEDBACKSTREAMATTRIBSNVPROC)(::GLsizei, const ::GLint *, ::GLsizei, const ::GLint *, ::GLenum);
extern "C"
{
  void glUniformBufferEXT(::GLuint program, ::GLint location, ::GLuint buffer)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLint glGetUniformBufferSizeEXT(::GLuint program, ::GLint location)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLintptr glGetUniformOffsetEXT(::GLuint program, ::GLint location)__attribute__((visibility("default")));
}
typedef void (*PFNGLUNIFORMBUFFEREXTPROC)(::GLuint, ::GLint, ::GLuint);
typedef ::GLint (*PFNGLGETUNIFORMBUFFERSIZEEXTPROC)(::GLuint, ::GLint);
typedef ::GLintptr (*PFNGLGETUNIFORMOFFSETEXTPROC)(::GLuint, ::GLint);
extern "C"
{
  void glTexParameterIivEXT(::GLenum target, ::GLenum pname, const ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexParameterIuivEXT(::GLenum target, ::GLenum pname, const ::GLuint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetTexParameterIivEXT(::GLenum target, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetTexParameterIuivEXT(::GLenum target, ::GLenum pname, ::GLuint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glClearColorIiEXT(::GLint red, ::GLint green, ::GLint blue, ::GLint alpha)__attribute__((visibility("default")));
}
extern "C"
{
  void glClearColorIuiEXT(::GLuint red, ::GLuint green, ::GLuint blue, ::GLuint alpha)__attribute__((visibility("default")));
}
typedef void (*PFNGLTEXPARAMETERIIVEXTPROC)(::GLenum, ::GLenum, const ::GLint *);
typedef void (*PFNGLTEXPARAMETERIUIVEXTPROC)(::GLenum, ::GLenum, const ::GLuint *);
typedef void (*PFNGLGETTEXPARAMETERIIVEXTPROC)(::GLenum, ::GLenum, ::GLint *);
typedef void (*PFNGLGETTEXPARAMETERIUIVEXTPROC)(::GLenum, ::GLenum, ::GLuint *);
typedef void (*PFNGLCLEARCOLORIIEXTPROC)(::GLint, ::GLint, ::GLint, ::GLint);
typedef void (*PFNGLCLEARCOLORIUIEXTPROC)(::GLuint, ::GLuint, ::GLuint, ::GLuint);
extern "C"
{
  void glFrameTerminatorGREMEDY()__attribute__((visibility("default")));
}
typedef void (*PFNGLFRAMETERMINATORGREMEDYPROC)();
extern "C"
{
  void glBeginConditionalRenderNV(::GLuint id, ::GLenum mode)__attribute__((visibility("default")));
}
extern "C"
{
  void glEndConditionalRenderNV()__attribute__((visibility("default")));
}
typedef void (*PFNGLBEGINCONDITIONALRENDERNVPROC)(::GLuint, ::GLenum);
typedef void (*PFNGLENDCONDITIONALRENDERNVPROC)();
extern "C"
{
  void glPresentFrameKeyedNV(::GLuint video_slot, ::GLuint64EXT minPresentTime, ::GLuint beginPresentTimeId, ::GLuint presentDurationId, ::GLenum type, ::GLenum target0, ::GLuint fill0, ::GLuint key0, ::GLenum target1, ::GLuint fill1, ::GLuint key1)__attribute__((visibility("default")));
}
extern "C"
{
  void glPresentFrameDualFillNV(::GLuint video_slot, ::GLuint64EXT minPresentTime, ::GLuint beginPresentTimeId, ::GLuint presentDurationId, ::GLenum type, ::GLenum target0, ::GLuint fill0, ::GLenum target1, ::GLuint fill1, ::GLenum target2, ::GLuint fill2, ::GLenum target3, ::GLuint fill3)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetVideoivNV(::GLuint video_slot, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetVideouivNV(::GLuint video_slot, ::GLenum pname, ::GLuint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetVideoi64vNV(::GLuint video_slot, ::GLenum pname, ::GLint64EXT *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetVideoui64vNV(::GLuint video_slot, ::GLenum pname, ::GLuint64EXT *params)__attribute__((visibility("default")));
}
typedef void (*PFNGLPRESENTFRAMEKEYEDNVPROC)(::GLuint, ::GLuint64EXT, ::GLuint, ::GLuint, ::GLenum, ::GLenum, ::GLuint, ::GLuint, ::GLenum, ::GLuint, ::GLuint);
typedef void (*PFNGLPRESENTFRAMEDUALFILLNVPROC)(::GLuint, ::GLuint64EXT, ::GLuint, ::GLuint, ::GLenum, ::GLenum, ::GLuint, ::GLenum, ::GLuint, ::GLenum, ::GLuint, ::GLenum, ::GLuint);
typedef void (*PFNGLGETVIDEOIVNVPROC)(::GLuint, ::GLenum, ::GLint *);
typedef void (*PFNGLGETVIDEOUIVNVPROC)(::GLuint, ::GLenum, ::GLuint *);
typedef void (*PFNGLGETVIDEOI64VNVPROC)(::GLuint, ::GLenum, ::GLint64EXT *);
typedef void (*PFNGLGETVIDEOUI64VNVPROC)(::GLuint, ::GLenum, ::GLuint64EXT *);
extern "C"
{
  void glBeginTransformFeedbackEXT(::GLenum primitiveMode)__attribute__((visibility("default")));
}
extern "C"
{
  void glEndTransformFeedbackEXT()__attribute__((visibility("default")));
}
extern "C"
{
  void glBindBufferRangeEXT(::GLenum target, ::GLuint index, ::GLuint buffer, ::GLintptr offset, ::GLsizeiptr size)__attribute__((visibility("default")));
}
extern "C"
{
  void glBindBufferOffsetEXT(::GLenum target, ::GLuint index, ::GLuint buffer, ::GLintptr offset)__attribute__((visibility("default")));
}
extern "C"
{
  void glBindBufferBaseEXT(::GLenum target, ::GLuint index, ::GLuint buffer)__attribute__((visibility("default")));
}
extern "C"
{
  void glTransformFeedbackVaryingsEXT(::GLuint program, ::GLsizei count, const ::GLchar **varyings, ::GLenum bufferMode)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetTransformFeedbackVaryingEXT(::GLuint program, ::GLuint index, ::GLsizei bufSize, ::GLsizei *length, ::GLsizei *size, ::GLenum *type, ::GLchar *name)__attribute__((visibility("default")));
}
typedef void (*PFNGLBEGINTRANSFORMFEEDBACKEXTPROC)(::GLenum);
typedef void (*PFNGLENDTRANSFORMFEEDBACKEXTPROC)();
typedef void (*PFNGLBINDBUFFERRANGEEXTPROC)(::GLenum, ::GLuint, ::GLuint, ::GLintptr, ::GLsizeiptr);
typedef void (*PFNGLBINDBUFFEROFFSETEXTPROC)(::GLenum, ::GLuint, ::GLuint, ::GLintptr);
typedef void (*PFNGLBINDBUFFERBASEEXTPROC)(::GLenum, ::GLuint, ::GLuint);
typedef void (*PFNGLTRANSFORMFEEDBACKVARYINGSEXTPROC)(::GLuint, ::GLsizei, const ::GLchar **, ::GLenum);
typedef void (*PFNGLGETTRANSFORMFEEDBACKVARYINGEXTPROC)(::GLuint, ::GLuint, ::GLsizei, ::GLsizei *, ::GLsizei *, ::GLenum *, ::GLchar *);
extern "C"
{
  void glClientAttribDefaultEXT(::GLbitfield mask)__attribute__((visibility("default")));
}
extern "C"
{
  void glPushClientAttribDefaultEXT(::GLbitfield mask)__attribute__((visibility("default")));
}
extern "C"
{
  void glMatrixLoadfEXT(::GLenum mode, const ::GLfloat *m)__attribute__((visibility("default")));
}
extern "C"
{
  void glMatrixLoaddEXT(::GLenum mode, const ::GLdouble *m)__attribute__((visibility("default")));
}
extern "C"
{
  void glMatrixMultfEXT(::GLenum mode, const ::GLfloat *m)__attribute__((visibility("default")));
}
extern "C"
{
  void glMatrixMultdEXT(::GLenum mode, const ::GLdouble *m)__attribute__((visibility("default")));
}
extern "C"
{
  void glMatrixLoadIdentityEXT(::GLenum mode)__attribute__((visibility("default")));
}
extern "C"
{
  void glMatrixRotatefEXT(::GLenum mode, ::GLfloat angle, ::GLfloat x, ::GLfloat y, ::GLfloat z)__attribute__((visibility("default")));
}
extern "C"
{
  void glMatrixRotatedEXT(::GLenum mode, ::GLdouble angle, ::GLdouble x, ::GLdouble y, ::GLdouble z)__attribute__((visibility("default")));
}
extern "C"
{
  void glMatrixScalefEXT(::GLenum mode, ::GLfloat x, ::GLfloat y, ::GLfloat z)__attribute__((visibility("default")));
}
extern "C"
{
  void glMatrixScaledEXT(::GLenum mode, ::GLdouble x, ::GLdouble y, ::GLdouble z)__attribute__((visibility("default")));
}
extern "C"
{
  void glMatrixTranslatefEXT(::GLenum mode, ::GLfloat x, ::GLfloat y, ::GLfloat z)__attribute__((visibility("default")));
}
extern "C"
{
  void glMatrixTranslatedEXT(::GLenum mode, ::GLdouble x, ::GLdouble y, ::GLdouble z)__attribute__((visibility("default")));
}
extern "C"
{
  void glMatrixFrustumEXT(::GLenum mode, ::GLdouble left, ::GLdouble right, ::GLdouble bottom, ::GLdouble top, ::GLdouble zNear, ::GLdouble zFar)__attribute__((visibility("default")));
}
extern "C"
{
  void glMatrixOrthoEXT(::GLenum mode, ::GLdouble left, ::GLdouble right, ::GLdouble bottom, ::GLdouble top, ::GLdouble zNear, ::GLdouble zFar)__attribute__((visibility("default")));
}
extern "C"
{
  void glMatrixPopEXT(::GLenum mode)__attribute__((visibility("default")));
}
extern "C"
{
  void glMatrixPushEXT(::GLenum mode)__attribute__((visibility("default")));
}
extern "C"
{
  void glMatrixLoadTransposefEXT(::GLenum mode, const ::GLfloat *m)__attribute__((visibility("default")));
}
extern "C"
{
  void glMatrixLoadTransposedEXT(::GLenum mode, const ::GLdouble *m)__attribute__((visibility("default")));
}
extern "C"
{
  void glMatrixMultTransposefEXT(::GLenum mode, const ::GLfloat *m)__attribute__((visibility("default")));
}
extern "C"
{
  void glMatrixMultTransposedEXT(::GLenum mode, const ::GLdouble *m)__attribute__((visibility("default")));
}
extern "C"
{
  void glTextureParameterfEXT(::GLuint texture, ::GLenum target, ::GLenum pname, ::GLfloat param)__attribute__((visibility("default")));
}
extern "C"
{
  void glTextureParameterfvEXT(::GLuint texture, ::GLenum target, ::GLenum pname, const ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glTextureParameteriEXT(::GLuint texture, ::GLenum target, ::GLenum pname, ::GLint param)__attribute__((visibility("default")));
}
extern "C"
{
  void glTextureParameterivEXT(::GLuint texture, ::GLenum target, ::GLenum pname, const ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glTextureImage1DEXT(::GLuint texture, ::GLenum target, ::GLint level, ::GLenum internalformat, ::GLsizei width, ::GLint border, ::GLenum format, ::GLenum type, const ::GLvoid *pixels)__attribute__((visibility("default")));
}
extern "C"
{
  void glTextureImage2DEXT(::GLuint texture, ::GLenum target, ::GLint level, ::GLenum internalformat, ::GLsizei width, ::GLsizei height, ::GLint border, ::GLenum format, ::GLenum type, const ::GLvoid *pixels)__attribute__((visibility("default")));
}
extern "C"
{
  void glTextureSubImage1DEXT(::GLuint texture, ::GLenum target, ::GLint level, ::GLint xoffset, ::GLsizei width, ::GLenum format, ::GLenum type, const ::GLvoid *pixels)__attribute__((visibility("default")));
}
extern "C"
{
  void glTextureSubImage2DEXT(::GLuint texture, ::GLenum target, ::GLint level, ::GLint xoffset, ::GLint yoffset, ::GLsizei width, ::GLsizei height, ::GLenum format, ::GLenum type, const ::GLvoid *pixels)__attribute__((visibility("default")));
}
extern "C"
{
  void glCopyTextureImage1DEXT(::GLuint texture, ::GLenum target, ::GLint level, ::GLenum internalformat, ::GLint x, ::GLint y, ::GLsizei width, ::GLint border)__attribute__((visibility("default")));
}
extern "C"
{
  void glCopyTextureImage2DEXT(::GLuint texture, ::GLenum target, ::GLint level, ::GLenum internalformat, ::GLint x, ::GLint y, ::GLsizei width, ::GLsizei height, ::GLint border)__attribute__((visibility("default")));
}
extern "C"
{
  void glCopyTextureSubImage1DEXT(::GLuint texture, ::GLenum target, ::GLint level, ::GLint xoffset, ::GLint x, ::GLint y, ::GLsizei width)__attribute__((visibility("default")));
}
extern "C"
{
  void glCopyTextureSubImage2DEXT(::GLuint texture, ::GLenum target, ::GLint level, ::GLint xoffset, ::GLint yoffset, ::GLint x, ::GLint y, ::GLsizei width, ::GLsizei height)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetTextureImageEXT(::GLuint texture, ::GLenum target, ::GLint level, ::GLenum format, ::GLenum type, ::GLvoid *pixels)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetTextureParameterfvEXT(::GLuint texture, ::GLenum target, ::GLenum pname, ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetTextureParameterivEXT(::GLuint texture, ::GLenum target, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetTextureLevelParameterfvEXT(::GLuint texture, ::GLenum target, ::GLint level, ::GLenum pname, ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetTextureLevelParameterivEXT(::GLuint texture, ::GLenum target, ::GLint level, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glTextureImage3DEXT(::GLuint texture, ::GLenum target, ::GLint level, ::GLenum internalformat, ::GLsizei width, ::GLsizei height, ::GLsizei depth, ::GLint border, ::GLenum format, ::GLenum type, const ::GLvoid *pixels)__attribute__((visibility("default")));
}
extern "C"
{
  void glTextureSubImage3DEXT(::GLuint texture, ::GLenum target, ::GLint level, ::GLint xoffset, ::GLint yoffset, ::GLint zoffset, ::GLsizei width, ::GLsizei height, ::GLsizei depth, ::GLenum format, ::GLenum type, const ::GLvoid *pixels)__attribute__((visibility("default")));
}
extern "C"
{
  void glCopyTextureSubImage3DEXT(::GLuint texture, ::GLenum target, ::GLint level, ::GLint xoffset, ::GLint yoffset, ::GLint zoffset, ::GLint x, ::GLint y, ::GLsizei width, ::GLsizei height)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexParameterfEXT(::GLenum texunit, ::GLenum target, ::GLenum pname, ::GLfloat param)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexParameterfvEXT(::GLenum texunit, ::GLenum target, ::GLenum pname, const ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexParameteriEXT(::GLenum texunit, ::GLenum target, ::GLenum pname, ::GLint param)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexParameterivEXT(::GLenum texunit, ::GLenum target, ::GLenum pname, const ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexImage1DEXT(::GLenum texunit, ::GLenum target, ::GLint level, ::GLenum internalformat, ::GLsizei width, ::GLint border, ::GLenum format, ::GLenum type, const ::GLvoid *pixels)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexImage2DEXT(::GLenum texunit, ::GLenum target, ::GLint level, ::GLenum internalformat, ::GLsizei width, ::GLsizei height, ::GLint border, ::GLenum format, ::GLenum type, const ::GLvoid *pixels)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexSubImage1DEXT(::GLenum texunit, ::GLenum target, ::GLint level, ::GLint xoffset, ::GLsizei width, ::GLenum format, ::GLenum type, const ::GLvoid *pixels)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexSubImage2DEXT(::GLenum texunit, ::GLenum target, ::GLint level, ::GLint xoffset, ::GLint yoffset, ::GLsizei width, ::GLsizei height, ::GLenum format, ::GLenum type, const ::GLvoid *pixels)__attribute__((visibility("default")));
}
extern "C"
{
  void glCopyMultiTexImage1DEXT(::GLenum texunit, ::GLenum target, ::GLint level, ::GLenum internalformat, ::GLint x, ::GLint y, ::GLsizei width, ::GLint border)__attribute__((visibility("default")));
}
extern "C"
{
  void glCopyMultiTexImage2DEXT(::GLenum texunit, ::GLenum target, ::GLint level, ::GLenum internalformat, ::GLint x, ::GLint y, ::GLsizei width, ::GLsizei height, ::GLint border)__attribute__((visibility("default")));
}
extern "C"
{
  void glCopyMultiTexSubImage1DEXT(::GLenum texunit, ::GLenum target, ::GLint level, ::GLint xoffset, ::GLint x, ::GLint y, ::GLsizei width)__attribute__((visibility("default")));
}
extern "C"
{
  void glCopyMultiTexSubImage2DEXT(::GLenum texunit, ::GLenum target, ::GLint level, ::GLint xoffset, ::GLint yoffset, ::GLint x, ::GLint y, ::GLsizei width, ::GLsizei height)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetMultiTexImageEXT(::GLenum texunit, ::GLenum target, ::GLint level, ::GLenum format, ::GLenum type, ::GLvoid *pixels)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetMultiTexParameterfvEXT(::GLenum texunit, ::GLenum target, ::GLenum pname, ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetMultiTexParameterivEXT(::GLenum texunit, ::GLenum target, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetMultiTexLevelParameterfvEXT(::GLenum texunit, ::GLenum target, ::GLint level, ::GLenum pname, ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetMultiTexLevelParameterivEXT(::GLenum texunit, ::GLenum target, ::GLint level, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexImage3DEXT(::GLenum texunit, ::GLenum target, ::GLint level, ::GLenum internalformat, ::GLsizei width, ::GLsizei height, ::GLsizei depth, ::GLint border, ::GLenum format, ::GLenum type, const ::GLvoid *pixels)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexSubImage3DEXT(::GLenum texunit, ::GLenum target, ::GLint level, ::GLint xoffset, ::GLint yoffset, ::GLint zoffset, ::GLsizei width, ::GLsizei height, ::GLsizei depth, ::GLenum format, ::GLenum type, const ::GLvoid *pixels)__attribute__((visibility("default")));
}
extern "C"
{
  void glCopyMultiTexSubImage3DEXT(::GLenum texunit, ::GLenum target, ::GLint level, ::GLint xoffset, ::GLint yoffset, ::GLint zoffset, ::GLint x, ::GLint y, ::GLsizei width, ::GLsizei height)__attribute__((visibility("default")));
}
extern "C"
{
  void glBindMultiTextureEXT(::GLenum texunit, ::GLenum target, ::GLuint texture)__attribute__((visibility("default")));
}
extern "C"
{
  void glEnableClientStateIndexedEXT(::GLenum array, ::GLuint index)__attribute__((visibility("default")));
}
extern "C"
{
  void glDisableClientStateIndexedEXT(::GLenum array, ::GLuint index)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexCoordPointerEXT(::GLenum texunit, ::GLint size, ::GLenum type, ::GLsizei stride, const ::GLvoid *pointer)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexEnvfEXT(::GLenum texunit, ::GLenum target, ::GLenum pname, ::GLfloat param)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexEnvfvEXT(::GLenum texunit, ::GLenum target, ::GLenum pname, const ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexEnviEXT(::GLenum texunit, ::GLenum target, ::GLenum pname, ::GLint param)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexEnvivEXT(::GLenum texunit, ::GLenum target, ::GLenum pname, const ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexGendEXT(::GLenum texunit, ::GLenum coord, ::GLenum pname, ::GLdouble param)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexGendvEXT(::GLenum texunit, ::GLenum coord, ::GLenum pname, const ::GLdouble *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexGenfEXT(::GLenum texunit, ::GLenum coord, ::GLenum pname, ::GLfloat param)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexGenfvEXT(::GLenum texunit, ::GLenum coord, ::GLenum pname, const ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexGeniEXT(::GLenum texunit, ::GLenum coord, ::GLenum pname, ::GLint param)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexGenivEXT(::GLenum texunit, ::GLenum coord, ::GLenum pname, const ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetMultiTexEnvfvEXT(::GLenum texunit, ::GLenum target, ::GLenum pname, ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetMultiTexEnvivEXT(::GLenum texunit, ::GLenum target, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetMultiTexGendvEXT(::GLenum texunit, ::GLenum coord, ::GLenum pname, ::GLdouble *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetMultiTexGenfvEXT(::GLenum texunit, ::GLenum coord, ::GLenum pname, ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetMultiTexGenivEXT(::GLenum texunit, ::GLenum coord, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetFloatIndexedvEXT(::GLenum target, ::GLuint index, ::GLfloat *data)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetDoubleIndexedvEXT(::GLenum target, ::GLuint index, ::GLdouble *data)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetPointerIndexedvEXT(::GLenum target, ::GLuint index, ::GLvoid **data)__attribute__((visibility("default")));
}
extern "C"
{
  void glCompressedTextureImage3DEXT(::GLuint texture, ::GLenum target, ::GLint level, ::GLenum internalformat, ::GLsizei width, ::GLsizei height, ::GLsizei depth, ::GLint border, ::GLsizei imageSize, const ::GLvoid *bits)__attribute__((visibility("default")));
}
extern "C"
{
  void glCompressedTextureImage2DEXT(::GLuint texture, ::GLenum target, ::GLint level, ::GLenum internalformat, ::GLsizei width, ::GLsizei height, ::GLint border, ::GLsizei imageSize, const ::GLvoid *bits)__attribute__((visibility("default")));
}
extern "C"
{
  void glCompressedTextureImage1DEXT(::GLuint texture, ::GLenum target, ::GLint level, ::GLenum internalformat, ::GLsizei width, ::GLint border, ::GLsizei imageSize, const ::GLvoid *bits)__attribute__((visibility("default")));
}
extern "C"
{
  void glCompressedTextureSubImage3DEXT(::GLuint texture, ::GLenum target, ::GLint level, ::GLint xoffset, ::GLint yoffset, ::GLint zoffset, ::GLsizei width, ::GLsizei height, ::GLsizei depth, ::GLenum format, ::GLsizei imageSize, const ::GLvoid *bits)__attribute__((visibility("default")));
}
extern "C"
{
  void glCompressedTextureSubImage2DEXT(::GLuint texture, ::GLenum target, ::GLint level, ::GLint xoffset, ::GLint yoffset, ::GLsizei width, ::GLsizei height, ::GLenum format, ::GLsizei imageSize, const ::GLvoid *bits)__attribute__((visibility("default")));
}
extern "C"
{
  void glCompressedTextureSubImage1DEXT(::GLuint texture, ::GLenum target, ::GLint level, ::GLint xoffset, ::GLsizei width, ::GLenum format, ::GLsizei imageSize, const ::GLvoid *bits)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetCompressedTextureImageEXT(::GLuint texture, ::GLenum target, ::GLint lod, ::GLvoid *img)__attribute__((visibility("default")));
}
extern "C"
{
  void glCompressedMultiTexImage3DEXT(::GLenum texunit, ::GLenum target, ::GLint level, ::GLenum internalformat, ::GLsizei width, ::GLsizei height, ::GLsizei depth, ::GLint border, ::GLsizei imageSize, const ::GLvoid *bits)__attribute__((visibility("default")));
}
extern "C"
{
  void glCompressedMultiTexImage2DEXT(::GLenum texunit, ::GLenum target, ::GLint level, ::GLenum internalformat, ::GLsizei width, ::GLsizei height, ::GLint border, ::GLsizei imageSize, const ::GLvoid *bits)__attribute__((visibility("default")));
}
extern "C"
{
  void glCompressedMultiTexImage1DEXT(::GLenum texunit, ::GLenum target, ::GLint level, ::GLenum internalformat, ::GLsizei width, ::GLint border, ::GLsizei imageSize, const ::GLvoid *bits)__attribute__((visibility("default")));
}
extern "C"
{
  void glCompressedMultiTexSubImage3DEXT(::GLenum texunit, ::GLenum target, ::GLint level, ::GLint xoffset, ::GLint yoffset, ::GLint zoffset, ::GLsizei width, ::GLsizei height, ::GLsizei depth, ::GLenum format, ::GLsizei imageSize, const ::GLvoid *bits)__attribute__((visibility("default")));
}
extern "C"
{
  void glCompressedMultiTexSubImage2DEXT(::GLenum texunit, ::GLenum target, ::GLint level, ::GLint xoffset, ::GLint yoffset, ::GLsizei width, ::GLsizei height, ::GLenum format, ::GLsizei imageSize, const ::GLvoid *bits)__attribute__((visibility("default")));
}
extern "C"
{
  void glCompressedMultiTexSubImage1DEXT(::GLenum texunit, ::GLenum target, ::GLint level, ::GLint xoffset, ::GLsizei width, ::GLenum format, ::GLsizei imageSize, const ::GLvoid *bits)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetCompressedMultiTexImageEXT(::GLenum texunit, ::GLenum target, ::GLint lod, ::GLvoid *img)__attribute__((visibility("default")));
}
extern "C"
{
  void glNamedProgramStringEXT(::GLuint program, ::GLenum target, ::GLenum format, ::GLsizei len, const ::GLvoid *string)__attribute__((visibility("default")));
}
extern "C"
{
  void glNamedProgramLocalParameter4dEXT(::GLuint program, ::GLenum target, ::GLuint index, ::GLdouble x, ::GLdouble y, ::GLdouble z, ::GLdouble w)__attribute__((visibility("default")));
}
extern "C"
{
  void glNamedProgramLocalParameter4dvEXT(::GLuint program, ::GLenum target, ::GLuint index, const ::GLdouble *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glNamedProgramLocalParameter4fEXT(::GLuint program, ::GLenum target, ::GLuint index, ::GLfloat x, ::GLfloat y, ::GLfloat z, ::GLfloat w)__attribute__((visibility("default")));
}
extern "C"
{
  void glNamedProgramLocalParameter4fvEXT(::GLuint program, ::GLenum target, ::GLuint index, const ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetNamedProgramLocalParameterdvEXT(::GLuint program, ::GLenum target, ::GLuint index, ::GLdouble *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetNamedProgramLocalParameterfvEXT(::GLuint program, ::GLenum target, ::GLuint index, ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetNamedProgramivEXT(::GLuint program, ::GLenum target, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetNamedProgramStringEXT(::GLuint program, ::GLenum target, ::GLenum pname, ::GLvoid *string)__attribute__((visibility("default")));
}
extern "C"
{
  void glNamedProgramLocalParameters4fvEXT(::GLuint program, ::GLenum target, ::GLuint index, ::GLsizei count, const ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glNamedProgramLocalParameterI4iEXT(::GLuint program, ::GLenum target, ::GLuint index, ::GLint x, ::GLint y, ::GLint z, ::GLint w)__attribute__((visibility("default")));
}
extern "C"
{
  void glNamedProgramLocalParameterI4ivEXT(::GLuint program, ::GLenum target, ::GLuint index, const ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glNamedProgramLocalParametersI4ivEXT(::GLuint program, ::GLenum target, ::GLuint index, ::GLsizei count, const ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glNamedProgramLocalParameterI4uiEXT(::GLuint program, ::GLenum target, ::GLuint index, ::GLuint x, ::GLuint y, ::GLuint z, ::GLuint w)__attribute__((visibility("default")));
}
extern "C"
{
  void glNamedProgramLocalParameterI4uivEXT(::GLuint program, ::GLenum target, ::GLuint index, const ::GLuint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glNamedProgramLocalParametersI4uivEXT(::GLuint program, ::GLenum target, ::GLuint index, ::GLsizei count, const ::GLuint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetNamedProgramLocalParameterIivEXT(::GLuint program, ::GLenum target, ::GLuint index, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetNamedProgramLocalParameterIuivEXT(::GLuint program, ::GLenum target, ::GLuint index, ::GLuint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glTextureParameterIivEXT(::GLuint texture, ::GLenum target, ::GLenum pname, const ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glTextureParameterIuivEXT(::GLuint texture, ::GLenum target, ::GLenum pname, const ::GLuint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetTextureParameterIivEXT(::GLuint texture, ::GLenum target, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetTextureParameterIuivEXT(::GLuint texture, ::GLenum target, ::GLenum pname, ::GLuint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexParameterIivEXT(::GLenum texunit, ::GLenum target, ::GLenum pname, const ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexParameterIuivEXT(::GLenum texunit, ::GLenum target, ::GLenum pname, const ::GLuint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetMultiTexParameterIivEXT(::GLenum texunit, ::GLenum target, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetMultiTexParameterIuivEXT(::GLenum texunit, ::GLenum target, ::GLenum pname, ::GLuint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform1fEXT(::GLuint program, ::GLint location, ::GLfloat v0)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform2fEXT(::GLuint program, ::GLint location, ::GLfloat v0, ::GLfloat v1)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform3fEXT(::GLuint program, ::GLint location, ::GLfloat v0, ::GLfloat v1, ::GLfloat v2)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform4fEXT(::GLuint program, ::GLint location, ::GLfloat v0, ::GLfloat v1, ::GLfloat v2, ::GLfloat v3)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform1iEXT(::GLuint program, ::GLint location, ::GLint v0)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform2iEXT(::GLuint program, ::GLint location, ::GLint v0, ::GLint v1)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform3iEXT(::GLuint program, ::GLint location, ::GLint v0, ::GLint v1, ::GLint v2)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform4iEXT(::GLuint program, ::GLint location, ::GLint v0, ::GLint v1, ::GLint v2, ::GLint v3)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform1fvEXT(::GLuint program, ::GLint location, ::GLsizei count, const ::GLfloat *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform2fvEXT(::GLuint program, ::GLint location, ::GLsizei count, const ::GLfloat *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform3fvEXT(::GLuint program, ::GLint location, ::GLsizei count, const ::GLfloat *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform4fvEXT(::GLuint program, ::GLint location, ::GLsizei count, const ::GLfloat *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform1ivEXT(::GLuint program, ::GLint location, ::GLsizei count, const ::GLint *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform2ivEXT(::GLuint program, ::GLint location, ::GLsizei count, const ::GLint *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform3ivEXT(::GLuint program, ::GLint location, ::GLsizei count, const ::GLint *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform4ivEXT(::GLuint program, ::GLint location, ::GLsizei count, const ::GLint *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniformMatrix2fvEXT(::GLuint program, ::GLint location, ::GLsizei count, ::GLboolean transpose, const ::GLfloat *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniformMatrix3fvEXT(::GLuint program, ::GLint location, ::GLsizei count, ::GLboolean transpose, const ::GLfloat *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniformMatrix4fvEXT(::GLuint program, ::GLint location, ::GLsizei count, ::GLboolean transpose, const ::GLfloat *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniformMatrix2x3fvEXT(::GLuint program, ::GLint location, ::GLsizei count, ::GLboolean transpose, const ::GLfloat *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniformMatrix3x2fvEXT(::GLuint program, ::GLint location, ::GLsizei count, ::GLboolean transpose, const ::GLfloat *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniformMatrix2x4fvEXT(::GLuint program, ::GLint location, ::GLsizei count, ::GLboolean transpose, const ::GLfloat *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniformMatrix4x2fvEXT(::GLuint program, ::GLint location, ::GLsizei count, ::GLboolean transpose, const ::GLfloat *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniformMatrix3x4fvEXT(::GLuint program, ::GLint location, ::GLsizei count, ::GLboolean transpose, const ::GLfloat *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniformMatrix4x3fvEXT(::GLuint program, ::GLint location, ::GLsizei count, ::GLboolean transpose, const ::GLfloat *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform1uiEXT(::GLuint program, ::GLint location, ::GLuint v0)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform2uiEXT(::GLuint program, ::GLint location, ::GLuint v0, ::GLuint v1)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform3uiEXT(::GLuint program, ::GLint location, ::GLuint v0, ::GLuint v1, ::GLuint v2)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform4uiEXT(::GLuint program, ::GLint location, ::GLuint v0, ::GLuint v1, ::GLuint v2, ::GLuint v3)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform1uivEXT(::GLuint program, ::GLint location, ::GLsizei count, const ::GLuint *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform2uivEXT(::GLuint program, ::GLint location, ::GLsizei count, const ::GLuint *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform3uivEXT(::GLuint program, ::GLint location, ::GLsizei count, const ::GLuint *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform4uivEXT(::GLuint program, ::GLint location, ::GLsizei count, const ::GLuint *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glNamedBufferDataEXT(::GLuint buffer, ::GLsizeiptr size, const ::GLvoid *data, ::GLenum usage)__attribute__((visibility("default")));
}
extern "C"
{
  void glNamedBufferSubDataEXT(::GLuint buffer, ::GLintptr offset, ::GLsizeiptr size, const ::GLvoid *data)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLvoid *glMapNamedBufferEXT(::GLuint buffer, ::GLenum access)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLboolean glUnmapNamedBufferEXT(::GLuint buffer)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLvoid *glMapNamedBufferRangeEXT(::GLuint buffer, ::GLintptr offset, ::GLsizeiptr length, ::GLbitfield access)__attribute__((visibility("default")));
}
extern "C"
{
  void glFlushMappedNamedBufferRangeEXT(::GLuint buffer, ::GLintptr offset, ::GLsizeiptr length)__attribute__((visibility("default")));
}
extern "C"
{
  void glNamedCopyBufferSubDataEXT(::GLuint readBuffer, ::GLuint writeBuffer, ::GLintptr readOffset, ::GLintptr writeOffset, ::GLsizeiptr size)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetNamedBufferParameterivEXT(::GLuint buffer, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetNamedBufferPointervEXT(::GLuint buffer, ::GLenum pname, ::GLvoid **params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetNamedBufferSubDataEXT(::GLuint buffer, ::GLintptr offset, ::GLsizeiptr size, ::GLvoid *data)__attribute__((visibility("default")));
}
extern "C"
{
  void glTextureBufferEXT(::GLuint texture, ::GLenum target, ::GLenum internalformat, ::GLuint buffer)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexBufferEXT(::GLenum texunit, ::GLenum target, ::GLenum internalformat, ::GLuint buffer)__attribute__((visibility("default")));
}
extern "C"
{
  void glNamedRenderbufferStorageEXT(::GLuint renderbuffer, ::GLenum internalformat, ::GLsizei width, ::GLsizei height)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetNamedRenderbufferParameterivEXT(::GLuint renderbuffer, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLenum glCheckNamedFramebufferStatusEXT(::GLuint framebuffer, ::GLenum target)__attribute__((visibility("default")));
}
extern "C"
{
  void glNamedFramebufferTexture1DEXT(::GLuint framebuffer, ::GLenum attachment, ::GLenum textarget, ::GLuint texture, ::GLint level)__attribute__((visibility("default")));
}
extern "C"
{
  void glNamedFramebufferTexture2DEXT(::GLuint framebuffer, ::GLenum attachment, ::GLenum textarget, ::GLuint texture, ::GLint level)__attribute__((visibility("default")));
}
extern "C"
{
  void glNamedFramebufferTexture3DEXT(::GLuint framebuffer, ::GLenum attachment, ::GLenum textarget, ::GLuint texture, ::GLint level, ::GLint zoffset)__attribute__((visibility("default")));
}
extern "C"
{
  void glNamedFramebufferRenderbufferEXT(::GLuint framebuffer, ::GLenum attachment, ::GLenum renderbuffertarget, ::GLuint renderbuffer)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetNamedFramebufferAttachmentParameterivEXT(::GLuint framebuffer, ::GLenum attachment, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGenerateTextureMipmapEXT(::GLuint texture, ::GLenum target)__attribute__((visibility("default")));
}
extern "C"
{
  void glGenerateMultiTexMipmapEXT(::GLenum texunit, ::GLenum target)__attribute__((visibility("default")));
}
extern "C"
{
  void glFramebufferDrawBufferEXT(::GLuint framebuffer, ::GLenum mode)__attribute__((visibility("default")));
}
extern "C"
{
  void glFramebufferDrawBuffersEXT(::GLuint framebuffer, ::GLsizei n, const ::GLenum *bufs)__attribute__((visibility("default")));
}
extern "C"
{
  void glFramebufferReadBufferEXT(::GLuint framebuffer, ::GLenum mode)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetFramebufferParameterivEXT(::GLuint framebuffer, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glNamedRenderbufferStorageMultisampleEXT(::GLuint renderbuffer, ::GLsizei samples, ::GLenum internalformat, ::GLsizei width, ::GLsizei height)__attribute__((visibility("default")));
}
extern "C"
{
  void glNamedRenderbufferStorageMultisampleCoverageEXT(::GLuint renderbuffer, ::GLsizei coverageSamples, ::GLsizei colorSamples, ::GLenum internalformat, ::GLsizei width, ::GLsizei height)__attribute__((visibility("default")));
}
extern "C"
{
  void glNamedFramebufferTextureEXT(::GLuint framebuffer, ::GLenum attachment, ::GLuint texture, ::GLint level)__attribute__((visibility("default")));
}
extern "C"
{
  void glNamedFramebufferTextureLayerEXT(::GLuint framebuffer, ::GLenum attachment, ::GLuint texture, ::GLint level, ::GLint layer)__attribute__((visibility("default")));
}
extern "C"
{
  void glNamedFramebufferTextureFaceEXT(::GLuint framebuffer, ::GLenum attachment, ::GLuint texture, ::GLint level, ::GLenum face)__attribute__((visibility("default")));
}
extern "C"
{
  void glTextureRenderbufferEXT(::GLuint texture, ::GLenum target, ::GLuint renderbuffer)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiTexRenderbufferEXT(::GLenum texunit, ::GLenum target, ::GLuint renderbuffer)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform1dEXT(::GLuint program, ::GLint location, ::GLdouble x)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform2dEXT(::GLuint program, ::GLint location, ::GLdouble x, ::GLdouble y)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform3dEXT(::GLuint program, ::GLint location, ::GLdouble x, ::GLdouble y, ::GLdouble z)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform4dEXT(::GLuint program, ::GLint location, ::GLdouble x, ::GLdouble y, ::GLdouble z, ::GLdouble w)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform1dvEXT(::GLuint program, ::GLint location, ::GLsizei count, const ::GLdouble *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform2dvEXT(::GLuint program, ::GLint location, ::GLsizei count, const ::GLdouble *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform3dvEXT(::GLuint program, ::GLint location, ::GLsizei count, const ::GLdouble *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform4dvEXT(::GLuint program, ::GLint location, ::GLsizei count, const ::GLdouble *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniformMatrix2dvEXT(::GLuint program, ::GLint location, ::GLsizei count, ::GLboolean transpose, const ::GLdouble *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniformMatrix3dvEXT(::GLuint program, ::GLint location, ::GLsizei count, ::GLboolean transpose, const ::GLdouble *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniformMatrix4dvEXT(::GLuint program, ::GLint location, ::GLsizei count, ::GLboolean transpose, const ::GLdouble *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniformMatrix2x3dvEXT(::GLuint program, ::GLint location, ::GLsizei count, ::GLboolean transpose, const ::GLdouble *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniformMatrix2x4dvEXT(::GLuint program, ::GLint location, ::GLsizei count, ::GLboolean transpose, const ::GLdouble *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniformMatrix3x2dvEXT(::GLuint program, ::GLint location, ::GLsizei count, ::GLboolean transpose, const ::GLdouble *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniformMatrix3x4dvEXT(::GLuint program, ::GLint location, ::GLsizei count, ::GLboolean transpose, const ::GLdouble *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniformMatrix4x2dvEXT(::GLuint program, ::GLint location, ::GLsizei count, ::GLboolean transpose, const ::GLdouble *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniformMatrix4x3dvEXT(::GLuint program, ::GLint location, ::GLsizei count, ::GLboolean transpose, const ::GLdouble *value)__attribute__((visibility("default")));
}
typedef void (*PFNGLCLIENTATTRIBDEFAULTEXTPROC)(::GLbitfield);
typedef void (*PFNGLPUSHCLIENTATTRIBDEFAULTEXTPROC)(::GLbitfield);
typedef void (*PFNGLMATRIXLOADFEXTPROC)(::GLenum, const ::GLfloat *);
typedef void (*PFNGLMATRIXLOADDEXTPROC)(::GLenum, const ::GLdouble *);
typedef void (*PFNGLMATRIXMULTFEXTPROC)(::GLenum, const ::GLfloat *);
typedef void (*PFNGLMATRIXMULTDEXTPROC)(::GLenum, const ::GLdouble *);
typedef void (*PFNGLMATRIXLOADIDENTITYEXTPROC)(::GLenum);
typedef void (*PFNGLMATRIXROTATEFEXTPROC)(::GLenum, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat);
typedef void (*PFNGLMATRIXROTATEDEXTPROC)(::GLenum, ::GLdouble, ::GLdouble, ::GLdouble, ::GLdouble);
typedef void (*PFNGLMATRIXSCALEFEXTPROC)(::GLenum, ::GLfloat, ::GLfloat, ::GLfloat);
typedef void (*PFNGLMATRIXSCALEDEXTPROC)(::GLenum, ::GLdouble, ::GLdouble, ::GLdouble);
typedef void (*PFNGLMATRIXTRANSLATEFEXTPROC)(::GLenum, ::GLfloat, ::GLfloat, ::GLfloat);
typedef void (*PFNGLMATRIXTRANSLATEDEXTPROC)(::GLenum, ::GLdouble, ::GLdouble, ::GLdouble);
typedef void (*PFNGLMATRIXFRUSTUMEXTPROC)(::GLenum, ::GLdouble, ::GLdouble, ::GLdouble, ::GLdouble, ::GLdouble, ::GLdouble);
typedef void (*PFNGLMATRIXORTHOEXTPROC)(::GLenum, ::GLdouble, ::GLdouble, ::GLdouble, ::GLdouble, ::GLdouble, ::GLdouble);
typedef void (*PFNGLMATRIXPOPEXTPROC)(::GLenum);
typedef void (*PFNGLMATRIXPUSHEXTPROC)(::GLenum);
typedef void (*PFNGLMATRIXLOADTRANSPOSEFEXTPROC)(::GLenum, const ::GLfloat *);
typedef void (*PFNGLMATRIXLOADTRANSPOSEDEXTPROC)(::GLenum, const ::GLdouble *);
typedef void (*PFNGLMATRIXMULTTRANSPOSEFEXTPROC)(::GLenum, const ::GLfloat *);
typedef void (*PFNGLMATRIXMULTTRANSPOSEDEXTPROC)(::GLenum, const ::GLdouble *);
typedef void (*PFNGLTEXTUREPARAMETERFEXTPROC)(::GLuint, ::GLenum, ::GLenum, ::GLfloat);
typedef void (*PFNGLTEXTUREPARAMETERFVEXTPROC)(::GLuint, ::GLenum, ::GLenum, const ::GLfloat *);
typedef void (*PFNGLTEXTUREPARAMETERIEXTPROC)(::GLuint, ::GLenum, ::GLenum, ::GLint);
typedef void (*PFNGLTEXTUREPARAMETERIVEXTPROC)(::GLuint, ::GLenum, ::GLenum, const ::GLint *);
typedef void (*PFNGLTEXTUREIMAGE1DEXTPROC)(::GLuint, ::GLenum, ::GLint, ::GLenum, ::GLsizei, ::GLint, ::GLenum, ::GLenum, const ::GLvoid *);
typedef void (*PFNGLTEXTUREIMAGE2DEXTPROC)(::GLuint, ::GLenum, ::GLint, ::GLenum, ::GLsizei, ::GLsizei, ::GLint, ::GLenum, ::GLenum, const ::GLvoid *);
typedef void (*PFNGLTEXTURESUBIMAGE1DEXTPROC)(::GLuint, ::GLenum, ::GLint, ::GLint, ::GLsizei, ::GLenum, ::GLenum, const ::GLvoid *);
typedef void (*PFNGLTEXTURESUBIMAGE2DEXTPROC)(::GLuint, ::GLenum, ::GLint, ::GLint, ::GLint, ::GLsizei, ::GLsizei, ::GLenum, ::GLenum, const ::GLvoid *);
typedef void (*PFNGLCOPYTEXTUREIMAGE1DEXTPROC)(::GLuint, ::GLenum, ::GLint, ::GLenum, ::GLint, ::GLint, ::GLsizei, ::GLint);
typedef void (*PFNGLCOPYTEXTUREIMAGE2DEXTPROC)(::GLuint, ::GLenum, ::GLint, ::GLenum, ::GLint, ::GLint, ::GLsizei, ::GLsizei, ::GLint);
typedef void (*PFNGLCOPYTEXTURESUBIMAGE1DEXTPROC)(::GLuint, ::GLenum, ::GLint, ::GLint, ::GLint, ::GLint, ::GLsizei);
typedef void (*PFNGLCOPYTEXTURESUBIMAGE2DEXTPROC)(::GLuint, ::GLenum, ::GLint, ::GLint, ::GLint, ::GLint, ::GLint, ::GLsizei, ::GLsizei);
typedef void (*PFNGLGETTEXTUREIMAGEEXTPROC)(::GLuint, ::GLenum, ::GLint, ::GLenum, ::GLenum, ::GLvoid *);
typedef void (*PFNGLGETTEXTUREPARAMETERFVEXTPROC)(::GLuint, ::GLenum, ::GLenum, ::GLfloat *);
typedef void (*PFNGLGETTEXTUREPARAMETERIVEXTPROC)(::GLuint, ::GLenum, ::GLenum, ::GLint *);
typedef void (*PFNGLGETTEXTURELEVELPARAMETERFVEXTPROC)(::GLuint, ::GLenum, ::GLint, ::GLenum, ::GLfloat *);
typedef void (*PFNGLGETTEXTURELEVELPARAMETERIVEXTPROC)(::GLuint, ::GLenum, ::GLint, ::GLenum, ::GLint *);
typedef void (*PFNGLTEXTUREIMAGE3DEXTPROC)(::GLuint, ::GLenum, ::GLint, ::GLenum, ::GLsizei, ::GLsizei, ::GLsizei, ::GLint, ::GLenum, ::GLenum, const ::GLvoid *);
typedef void (*PFNGLTEXTURESUBIMAGE3DEXTPROC)(::GLuint, ::GLenum, ::GLint, ::GLint, ::GLint, ::GLint, ::GLsizei, ::GLsizei, ::GLsizei, ::GLenum, ::GLenum, const ::GLvoid *);
typedef void (*PFNGLCOPYTEXTURESUBIMAGE3DEXTPROC)(::GLuint, ::GLenum, ::GLint, ::GLint, ::GLint, ::GLint, ::GLint, ::GLint, ::GLsizei, ::GLsizei);
typedef void (*PFNGLMULTITEXPARAMETERFEXTPROC)(::GLenum, ::GLenum, ::GLenum, ::GLfloat);
typedef void (*PFNGLMULTITEXPARAMETERFVEXTPROC)(::GLenum, ::GLenum, ::GLenum, const ::GLfloat *);
typedef void (*PFNGLMULTITEXPARAMETERIEXTPROC)(::GLenum, ::GLenum, ::GLenum, ::GLint);
typedef void (*PFNGLMULTITEXPARAMETERIVEXTPROC)(::GLenum, ::GLenum, ::GLenum, const ::GLint *);
typedef void (*PFNGLMULTITEXIMAGE1DEXTPROC)(::GLenum, ::GLenum, ::GLint, ::GLenum, ::GLsizei, ::GLint, ::GLenum, ::GLenum, const ::GLvoid *);
typedef void (*PFNGLMULTITEXIMAGE2DEXTPROC)(::GLenum, ::GLenum, ::GLint, ::GLenum, ::GLsizei, ::GLsizei, ::GLint, ::GLenum, ::GLenum, const ::GLvoid *);
typedef void (*PFNGLMULTITEXSUBIMAGE1DEXTPROC)(::GLenum, ::GLenum, ::GLint, ::GLint, ::GLsizei, ::GLenum, ::GLenum, const ::GLvoid *);
typedef void (*PFNGLMULTITEXSUBIMAGE2DEXTPROC)(::GLenum, ::GLenum, ::GLint, ::GLint, ::GLint, ::GLsizei, ::GLsizei, ::GLenum, ::GLenum, const ::GLvoid *);
typedef void (*PFNGLCOPYMULTITEXIMAGE1DEXTPROC)(::GLenum, ::GLenum, ::GLint, ::GLenum, ::GLint, ::GLint, ::GLsizei, ::GLint);
typedef void (*PFNGLCOPYMULTITEXIMAGE2DEXTPROC)(::GLenum, ::GLenum, ::GLint, ::GLenum, ::GLint, ::GLint, ::GLsizei, ::GLsizei, ::GLint);
typedef void (*PFNGLCOPYMULTITEXSUBIMAGE1DEXTPROC)(::GLenum, ::GLenum, ::GLint, ::GLint, ::GLint, ::GLint, ::GLsizei);
typedef void (*PFNGLCOPYMULTITEXSUBIMAGE2DEXTPROC)(::GLenum, ::GLenum, ::GLint, ::GLint, ::GLint, ::GLint, ::GLint, ::GLsizei, ::GLsizei);
typedef void (*PFNGLGETMULTITEXIMAGEEXTPROC)(::GLenum, ::GLenum, ::GLint, ::GLenum, ::GLenum, ::GLvoid *);
typedef void (*PFNGLGETMULTITEXPARAMETERFVEXTPROC)(::GLenum, ::GLenum, ::GLenum, ::GLfloat *);
typedef void (*PFNGLGETMULTITEXPARAMETERIVEXTPROC)(::GLenum, ::GLenum, ::GLenum, ::GLint *);
typedef void (*PFNGLGETMULTITEXLEVELPARAMETERFVEXTPROC)(::GLenum, ::GLenum, ::GLint, ::GLenum, ::GLfloat *);
typedef void (*PFNGLGETMULTITEXLEVELPARAMETERIVEXTPROC)(::GLenum, ::GLenum, ::GLint, ::GLenum, ::GLint *);
typedef void (*PFNGLMULTITEXIMAGE3DEXTPROC)(::GLenum, ::GLenum, ::GLint, ::GLenum, ::GLsizei, ::GLsizei, ::GLsizei, ::GLint, ::GLenum, ::GLenum, const ::GLvoid *);
typedef void (*PFNGLMULTITEXSUBIMAGE3DEXTPROC)(::GLenum, ::GLenum, ::GLint, ::GLint, ::GLint, ::GLint, ::GLsizei, ::GLsizei, ::GLsizei, ::GLenum, ::GLenum, const ::GLvoid *);
typedef void (*PFNGLCOPYMULTITEXSUBIMAGE3DEXTPROC)(::GLenum, ::GLenum, ::GLint, ::GLint, ::GLint, ::GLint, ::GLint, ::GLint, ::GLsizei, ::GLsizei);
typedef void (*PFNGLBINDMULTITEXTUREEXTPROC)(::GLenum, ::GLenum, ::GLuint);
typedef void (*PFNGLENABLECLIENTSTATEINDEXEDEXTPROC)(::GLenum, ::GLuint);
typedef void (*PFNGLDISABLECLIENTSTATEINDEXEDEXTPROC)(::GLenum, ::GLuint);
typedef void (*PFNGLMULTITEXCOORDPOINTEREXTPROC)(::GLenum, ::GLint, ::GLenum, ::GLsizei, const ::GLvoid *);
typedef void (*PFNGLMULTITEXENVFEXTPROC)(::GLenum, ::GLenum, ::GLenum, ::GLfloat);
typedef void (*PFNGLMULTITEXENVFVEXTPROC)(::GLenum, ::GLenum, ::GLenum, const ::GLfloat *);
typedef void (*PFNGLMULTITEXENVIEXTPROC)(::GLenum, ::GLenum, ::GLenum, ::GLint);
typedef void (*PFNGLMULTITEXENVIVEXTPROC)(::GLenum, ::GLenum, ::GLenum, const ::GLint *);
typedef void (*PFNGLMULTITEXGENDEXTPROC)(::GLenum, ::GLenum, ::GLenum, ::GLdouble);
typedef void (*PFNGLMULTITEXGENDVEXTPROC)(::GLenum, ::GLenum, ::GLenum, const ::GLdouble *);
typedef void (*PFNGLMULTITEXGENFEXTPROC)(::GLenum, ::GLenum, ::GLenum, ::GLfloat);
typedef void (*PFNGLMULTITEXGENFVEXTPROC)(::GLenum, ::GLenum, ::GLenum, const ::GLfloat *);
typedef void (*PFNGLMULTITEXGENIEXTPROC)(::GLenum, ::GLenum, ::GLenum, ::GLint);
typedef void (*PFNGLMULTITEXGENIVEXTPROC)(::GLenum, ::GLenum, ::GLenum, const ::GLint *);
typedef void (*PFNGLGETMULTITEXENVFVEXTPROC)(::GLenum, ::GLenum, ::GLenum, ::GLfloat *);
typedef void (*PFNGLGETMULTITEXENVIVEXTPROC)(::GLenum, ::GLenum, ::GLenum, ::GLint *);
typedef void (*PFNGLGETMULTITEXGENDVEXTPROC)(::GLenum, ::GLenum, ::GLenum, ::GLdouble *);
typedef void (*PFNGLGETMULTITEXGENFVEXTPROC)(::GLenum, ::GLenum, ::GLenum, ::GLfloat *);
typedef void (*PFNGLGETMULTITEXGENIVEXTPROC)(::GLenum, ::GLenum, ::GLenum, ::GLint *);
typedef void (*PFNGLGETFLOATINDEXEDVEXTPROC)(::GLenum, ::GLuint, ::GLfloat *);
typedef void (*PFNGLGETDOUBLEINDEXEDVEXTPROC)(::GLenum, ::GLuint, ::GLdouble *);
typedef void (*PFNGLGETPOINTERINDEXEDVEXTPROC)(::GLenum, ::GLuint, ::GLvoid **);
typedef void (*PFNGLCOMPRESSEDTEXTUREIMAGE3DEXTPROC)(::GLuint, ::GLenum, ::GLint, ::GLenum, ::GLsizei, ::GLsizei, ::GLsizei, ::GLint, ::GLsizei, const ::GLvoid *);
typedef void (*PFNGLCOMPRESSEDTEXTUREIMAGE2DEXTPROC)(::GLuint, ::GLenum, ::GLint, ::GLenum, ::GLsizei, ::GLsizei, ::GLint, ::GLsizei, const ::GLvoid *);
typedef void (*PFNGLCOMPRESSEDTEXTUREIMAGE1DEXTPROC)(::GLuint, ::GLenum, ::GLint, ::GLenum, ::GLsizei, ::GLint, ::GLsizei, const ::GLvoid *);
typedef void (*PFNGLCOMPRESSEDTEXTURESUBIMAGE3DEXTPROC)(::GLuint, ::GLenum, ::GLint, ::GLint, ::GLint, ::GLint, ::GLsizei, ::GLsizei, ::GLsizei, ::GLenum, ::GLsizei, const ::GLvoid *);
typedef void (*PFNGLCOMPRESSEDTEXTURESUBIMAGE2DEXTPROC)(::GLuint, ::GLenum, ::GLint, ::GLint, ::GLint, ::GLsizei, ::GLsizei, ::GLenum, ::GLsizei, const ::GLvoid *);
typedef void (*PFNGLCOMPRESSEDTEXTURESUBIMAGE1DEXTPROC)(::GLuint, ::GLenum, ::GLint, ::GLint, ::GLsizei, ::GLenum, ::GLsizei, const ::GLvoid *);
typedef void (*PFNGLGETCOMPRESSEDTEXTUREIMAGEEXTPROC)(::GLuint, ::GLenum, ::GLint, ::GLvoid *);
typedef void (*PFNGLCOMPRESSEDMULTITEXIMAGE3DEXTPROC)(::GLenum, ::GLenum, ::GLint, ::GLenum, ::GLsizei, ::GLsizei, ::GLsizei, ::GLint, ::GLsizei, const ::GLvoid *);
typedef void (*PFNGLCOMPRESSEDMULTITEXIMAGE2DEXTPROC)(::GLenum, ::GLenum, ::GLint, ::GLenum, ::GLsizei, ::GLsizei, ::GLint, ::GLsizei, const ::GLvoid *);
typedef void (*PFNGLCOMPRESSEDMULTITEXIMAGE1DEXTPROC)(::GLenum, ::GLenum, ::GLint, ::GLenum, ::GLsizei, ::GLint, ::GLsizei, const ::GLvoid *);
typedef void (*PFNGLCOMPRESSEDMULTITEXSUBIMAGE3DEXTPROC)(::GLenum, ::GLenum, ::GLint, ::GLint, ::GLint, ::GLint, ::GLsizei, ::GLsizei, ::GLsizei, ::GLenum, ::GLsizei, const ::GLvoid *);
typedef void (*PFNGLCOMPRESSEDMULTITEXSUBIMAGE2DEXTPROC)(::GLenum, ::GLenum, ::GLint, ::GLint, ::GLint, ::GLsizei, ::GLsizei, ::GLenum, ::GLsizei, const ::GLvoid *);
typedef void (*PFNGLCOMPRESSEDMULTITEXSUBIMAGE1DEXTPROC)(::GLenum, ::GLenum, ::GLint, ::GLint, ::GLsizei, ::GLenum, ::GLsizei, const ::GLvoid *);
typedef void (*PFNGLGETCOMPRESSEDMULTITEXIMAGEEXTPROC)(::GLenum, ::GLenum, ::GLint, ::GLvoid *);
typedef void (*PFNGLNAMEDPROGRAMSTRINGEXTPROC)(::GLuint, ::GLenum, ::GLenum, ::GLsizei, const ::GLvoid *);
typedef void (*PFNGLNAMEDPROGRAMLOCALPARAMETER4DEXTPROC)(::GLuint, ::GLenum, ::GLuint, ::GLdouble, ::GLdouble, ::GLdouble, ::GLdouble);
typedef void (*PFNGLNAMEDPROGRAMLOCALPARAMETER4DVEXTPROC)(::GLuint, ::GLenum, ::GLuint, const ::GLdouble *);
typedef void (*PFNGLNAMEDPROGRAMLOCALPARAMETER4FEXTPROC)(::GLuint, ::GLenum, ::GLuint, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat);
typedef void (*PFNGLNAMEDPROGRAMLOCALPARAMETER4FVEXTPROC)(::GLuint, ::GLenum, ::GLuint, const ::GLfloat *);
typedef void (*PFNGLGETNAMEDPROGRAMLOCALPARAMETERDVEXTPROC)(::GLuint, ::GLenum, ::GLuint, ::GLdouble *);
typedef void (*PFNGLGETNAMEDPROGRAMLOCALPARAMETERFVEXTPROC)(::GLuint, ::GLenum, ::GLuint, ::GLfloat *);
typedef void (*PFNGLGETNAMEDPROGRAMIVEXTPROC)(::GLuint, ::GLenum, ::GLenum, ::GLint *);
typedef void (*PFNGLGETNAMEDPROGRAMSTRINGEXTPROC)(::GLuint, ::GLenum, ::GLenum, ::GLvoid *);
typedef void (*PFNGLNAMEDPROGRAMLOCALPARAMETERS4FVEXTPROC)(::GLuint, ::GLenum, ::GLuint, ::GLsizei, const ::GLfloat *);
typedef void (*PFNGLNAMEDPROGRAMLOCALPARAMETERI4IEXTPROC)(::GLuint, ::GLenum, ::GLuint, ::GLint, ::GLint, ::GLint, ::GLint);
typedef void (*PFNGLNAMEDPROGRAMLOCALPARAMETERI4IVEXTPROC)(::GLuint, ::GLenum, ::GLuint, const ::GLint *);
typedef void (*PFNGLNAMEDPROGRAMLOCALPARAMETERSI4IVEXTPROC)(::GLuint, ::GLenum, ::GLuint, ::GLsizei, const ::GLint *);
typedef void (*PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIEXTPROC)(::GLuint, ::GLenum, ::GLuint, ::GLuint, ::GLuint, ::GLuint, ::GLuint);
typedef void (*PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIVEXTPROC)(::GLuint, ::GLenum, ::GLuint, const ::GLuint *);
typedef void (*PFNGLNAMEDPROGRAMLOCALPARAMETERSI4UIVEXTPROC)(::GLuint, ::GLenum, ::GLuint, ::GLsizei, const ::GLuint *);
typedef void (*PFNGLGETNAMEDPROGRAMLOCALPARAMETERIIVEXTPROC)(::GLuint, ::GLenum, ::GLuint, ::GLint *);
typedef void (*PFNGLGETNAMEDPROGRAMLOCALPARAMETERIUIVEXTPROC)(::GLuint, ::GLenum, ::GLuint, ::GLuint *);
typedef void (*PFNGLTEXTUREPARAMETERIIVEXTPROC)(::GLuint, ::GLenum, ::GLenum, const ::GLint *);
typedef void (*PFNGLTEXTUREPARAMETERIUIVEXTPROC)(::GLuint, ::GLenum, ::GLenum, const ::GLuint *);
typedef void (*PFNGLGETTEXTUREPARAMETERIIVEXTPROC)(::GLuint, ::GLenum, ::GLenum, ::GLint *);
typedef void (*PFNGLGETTEXTUREPARAMETERIUIVEXTPROC)(::GLuint, ::GLenum, ::GLenum, ::GLuint *);
typedef void (*PFNGLMULTITEXPARAMETERIIVEXTPROC)(::GLenum, ::GLenum, ::GLenum, const ::GLint *);
typedef void (*PFNGLMULTITEXPARAMETERIUIVEXTPROC)(::GLenum, ::GLenum, ::GLenum, const ::GLuint *);
typedef void (*PFNGLGETMULTITEXPARAMETERIIVEXTPROC)(::GLenum, ::GLenum, ::GLenum, ::GLint *);
typedef void (*PFNGLGETMULTITEXPARAMETERIUIVEXTPROC)(::GLenum, ::GLenum, ::GLenum, ::GLuint *);
typedef void (*PFNGLPROGRAMUNIFORM1FEXTPROC)(::GLuint, ::GLint, ::GLfloat);
typedef void (*PFNGLPROGRAMUNIFORM2FEXTPROC)(::GLuint, ::GLint, ::GLfloat, ::GLfloat);
typedef void (*PFNGLPROGRAMUNIFORM3FEXTPROC)(::GLuint, ::GLint, ::GLfloat, ::GLfloat, ::GLfloat);
typedef void (*PFNGLPROGRAMUNIFORM4FEXTPROC)(::GLuint, ::GLint, ::GLfloat, ::GLfloat, ::GLfloat, ::GLfloat);
typedef void (*PFNGLPROGRAMUNIFORM1IEXTPROC)(::GLuint, ::GLint, ::GLint);
typedef void (*PFNGLPROGRAMUNIFORM2IEXTPROC)(::GLuint, ::GLint, ::GLint, ::GLint);
typedef void (*PFNGLPROGRAMUNIFORM3IEXTPROC)(::GLuint, ::GLint, ::GLint, ::GLint, ::GLint);
typedef void (*PFNGLPROGRAMUNIFORM4IEXTPROC)(::GLuint, ::GLint, ::GLint, ::GLint, ::GLint, ::GLint);
typedef void (*PFNGLPROGRAMUNIFORM1FVEXTPROC)(::GLuint, ::GLint, ::GLsizei, const ::GLfloat *);
typedef void (*PFNGLPROGRAMUNIFORM2FVEXTPROC)(::GLuint, ::GLint, ::GLsizei, const ::GLfloat *);
typedef void (*PFNGLPROGRAMUNIFORM3FVEXTPROC)(::GLuint, ::GLint, ::GLsizei, const ::GLfloat *);
typedef void (*PFNGLPROGRAMUNIFORM4FVEXTPROC)(::GLuint, ::GLint, ::GLsizei, const ::GLfloat *);
typedef void (*PFNGLPROGRAMUNIFORM1IVEXTPROC)(::GLuint, ::GLint, ::GLsizei, const ::GLint *);
typedef void (*PFNGLPROGRAMUNIFORM2IVEXTPROC)(::GLuint, ::GLint, ::GLsizei, const ::GLint *);
typedef void (*PFNGLPROGRAMUNIFORM3IVEXTPROC)(::GLuint, ::GLint, ::GLsizei, const ::GLint *);
typedef void (*PFNGLPROGRAMUNIFORM4IVEXTPROC)(::GLuint, ::GLint, ::GLsizei, const ::GLint *);
typedef void (*PFNGLPROGRAMUNIFORMMATRIX2FVEXTPROC)(::GLuint, ::GLint, ::GLsizei, ::GLboolean, const ::GLfloat *);
typedef void (*PFNGLPROGRAMUNIFORMMATRIX3FVEXTPROC)(::GLuint, ::GLint, ::GLsizei, ::GLboolean, const ::GLfloat *);
typedef void (*PFNGLPROGRAMUNIFORMMATRIX4FVEXTPROC)(::GLuint, ::GLint, ::GLsizei, ::GLboolean, const ::GLfloat *);
typedef void (*PFNGLPROGRAMUNIFORMMATRIX2X3FVEXTPROC)(::GLuint, ::GLint, ::GLsizei, ::GLboolean, const ::GLfloat *);
typedef void (*PFNGLPROGRAMUNIFORMMATRIX3X2FVEXTPROC)(::GLuint, ::GLint, ::GLsizei, ::GLboolean, const ::GLfloat *);
typedef void (*PFNGLPROGRAMUNIFORMMATRIX2X4FVEXTPROC)(::GLuint, ::GLint, ::GLsizei, ::GLboolean, const ::GLfloat *);
typedef void (*PFNGLPROGRAMUNIFORMMATRIX4X2FVEXTPROC)(::GLuint, ::GLint, ::GLsizei, ::GLboolean, const ::GLfloat *);
typedef void (*PFNGLPROGRAMUNIFORMMATRIX3X4FVEXTPROC)(::GLuint, ::GLint, ::GLsizei, ::GLboolean, const ::GLfloat *);
typedef void (*PFNGLPROGRAMUNIFORMMATRIX4X3FVEXTPROC)(::GLuint, ::GLint, ::GLsizei, ::GLboolean, const ::GLfloat *);
typedef void (*PFNGLPROGRAMUNIFORM1UIEXTPROC)(::GLuint, ::GLint, ::GLuint);
typedef void (*PFNGLPROGRAMUNIFORM2UIEXTPROC)(::GLuint, ::GLint, ::GLuint, ::GLuint);
typedef void (*PFNGLPROGRAMUNIFORM3UIEXTPROC)(::GLuint, ::GLint, ::GLuint, ::GLuint, ::GLuint);
typedef void (*PFNGLPROGRAMUNIFORM4UIEXTPROC)(::GLuint, ::GLint, ::GLuint, ::GLuint, ::GLuint, ::GLuint);
typedef void (*PFNGLPROGRAMUNIFORM1UIVEXTPROC)(::GLuint, ::GLint, ::GLsizei, const ::GLuint *);
typedef void (*PFNGLPROGRAMUNIFORM2UIVEXTPROC)(::GLuint, ::GLint, ::GLsizei, const ::GLuint *);
typedef void (*PFNGLPROGRAMUNIFORM3UIVEXTPROC)(::GLuint, ::GLint, ::GLsizei, const ::GLuint *);
typedef void (*PFNGLPROGRAMUNIFORM4UIVEXTPROC)(::GLuint, ::GLint, ::GLsizei, const ::GLuint *);
typedef void (*PFNGLNAMEDBUFFERDATAEXTPROC)(::GLuint, ::GLsizeiptr, const ::GLvoid *, ::GLenum);
typedef void (*PFNGLNAMEDBUFFERSUBDATAEXTPROC)(::GLuint, ::GLintptr, ::GLsizeiptr, const ::GLvoid *);
typedef ::GLvoid *(*PFNGLMAPNAMEDBUFFEREXTPROC)(::GLuint, ::GLenum);
typedef ::GLboolean (*PFNGLUNMAPNAMEDBUFFEREXTPROC)(::GLuint);
typedef ::GLvoid *(*PFNGLMAPNAMEDBUFFERRANGEEXTPROC)(::GLuint, ::GLintptr, ::GLsizeiptr, ::GLbitfield);
typedef void (*PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEEXTPROC)(::GLuint, ::GLintptr, ::GLsizeiptr);
typedef void (*PFNGLNAMEDCOPYBUFFERSUBDATAEXTPROC)(::GLuint, ::GLuint, ::GLintptr, ::GLintptr, ::GLsizeiptr);
typedef void (*PFNGLGETNAMEDBUFFERPARAMETERIVEXTPROC)(::GLuint, ::GLenum, ::GLint *);
typedef void (*PFNGLGETNAMEDBUFFERPOINTERVEXTPROC)(::GLuint, ::GLenum, ::GLvoid **);
typedef void (*PFNGLGETNAMEDBUFFERSUBDATAEXTPROC)(::GLuint, ::GLintptr, ::GLsizeiptr, ::GLvoid *);
typedef void (*PFNGLTEXTUREBUFFEREXTPROC)(::GLuint, ::GLenum, ::GLenum, ::GLuint);
typedef void (*PFNGLMULTITEXBUFFEREXTPROC)(::GLenum, ::GLenum, ::GLenum, ::GLuint);
typedef void (*PFNGLNAMEDRENDERBUFFERSTORAGEEXTPROC)(::GLuint, ::GLenum, ::GLsizei, ::GLsizei);
typedef void (*PFNGLGETNAMEDRENDERBUFFERPARAMETERIVEXTPROC)(::GLuint, ::GLenum, ::GLint *);
typedef ::GLenum (*PFNGLCHECKNAMEDFRAMEBUFFERSTATUSEXTPROC)(::GLuint, ::GLenum);
typedef void (*PFNGLNAMEDFRAMEBUFFERTEXTURE1DEXTPROC)(::GLuint, ::GLenum, ::GLenum, ::GLuint, ::GLint);
typedef void (*PFNGLNAMEDFRAMEBUFFERTEXTURE2DEXTPROC)(::GLuint, ::GLenum, ::GLenum, ::GLuint, ::GLint);
typedef void (*PFNGLNAMEDFRAMEBUFFERTEXTURE3DEXTPROC)(::GLuint, ::GLenum, ::GLenum, ::GLuint, ::GLint, ::GLint);
typedef void (*PFNGLNAMEDFRAMEBUFFERRENDERBUFFEREXTPROC)(::GLuint, ::GLenum, ::GLenum, ::GLuint);
typedef void (*PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC)(::GLuint, ::GLenum, ::GLenum, ::GLint *);
typedef void (*PFNGLGENERATETEXTUREMIPMAPEXTPROC)(::GLuint, ::GLenum);
typedef void (*PFNGLGENERATEMULTITEXMIPMAPEXTPROC)(::GLenum, ::GLenum);
typedef void (*PFNGLFRAMEBUFFERDRAWBUFFEREXTPROC)(::GLuint, ::GLenum);
typedef void (*PFNGLFRAMEBUFFERDRAWBUFFERSEXTPROC)(::GLuint, ::GLsizei, const ::GLenum *);
typedef void (*PFNGLFRAMEBUFFERREADBUFFEREXTPROC)(::GLuint, ::GLenum);
typedef void (*PFNGLGETFRAMEBUFFERPARAMETERIVEXTPROC)(::GLuint, ::GLenum, ::GLint *);
typedef void (*PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC)(::GLuint, ::GLsizei, ::GLenum, ::GLsizei, ::GLsizei);
typedef void (*PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLECOVERAGEEXTPROC)(::GLuint, ::GLsizei, ::GLsizei, ::GLenum, ::GLsizei, ::GLsizei);
typedef void (*PFNGLNAMEDFRAMEBUFFERTEXTUREEXTPROC)(::GLuint, ::GLenum, ::GLuint, ::GLint);
typedef void (*PFNGLNAMEDFRAMEBUFFERTEXTURELAYEREXTPROC)(::GLuint, ::GLenum, ::GLuint, ::GLint, ::GLint);
typedef void (*PFNGLNAMEDFRAMEBUFFERTEXTUREFACEEXTPROC)(::GLuint, ::GLenum, ::GLuint, ::GLint, ::GLenum);
typedef void (*PFNGLTEXTURERENDERBUFFEREXTPROC)(::GLuint, ::GLenum, ::GLuint);
typedef void (*PFNGLMULTITEXRENDERBUFFEREXTPROC)(::GLenum, ::GLenum, ::GLuint);
typedef void (*PFNGLPROGRAMUNIFORM1DEXTPROC)(::GLuint, ::GLint, ::GLdouble);
typedef void (*PFNGLPROGRAMUNIFORM2DEXTPROC)(::GLuint, ::GLint, ::GLdouble, ::GLdouble);
typedef void (*PFNGLPROGRAMUNIFORM3DEXTPROC)(::GLuint, ::GLint, ::GLdouble, ::GLdouble, ::GLdouble);
typedef void (*PFNGLPROGRAMUNIFORM4DEXTPROC)(::GLuint, ::GLint, ::GLdouble, ::GLdouble, ::GLdouble, ::GLdouble);
typedef void (*PFNGLPROGRAMUNIFORM1DVEXTPROC)(::GLuint, ::GLint, ::GLsizei, const ::GLdouble *);
typedef void (*PFNGLPROGRAMUNIFORM2DVEXTPROC)(::GLuint, ::GLint, ::GLsizei, const ::GLdouble *);
typedef void (*PFNGLPROGRAMUNIFORM3DVEXTPROC)(::GLuint, ::GLint, ::GLsizei, const ::GLdouble *);
typedef void (*PFNGLPROGRAMUNIFORM4DVEXTPROC)(::GLuint, ::GLint, ::GLsizei, const ::GLdouble *);
typedef void (*PFNGLPROGRAMUNIFORMMATRIX2DVEXTPROC)(::GLuint, ::GLint, ::GLsizei, ::GLboolean, const ::GLdouble *);
typedef void (*PFNGLPROGRAMUNIFORMMATRIX3DVEXTPROC)(::GLuint, ::GLint, ::GLsizei, ::GLboolean, const ::GLdouble *);
typedef void (*PFNGLPROGRAMUNIFORMMATRIX4DVEXTPROC)(::GLuint, ::GLint, ::GLsizei, ::GLboolean, const ::GLdouble *);
typedef void (*PFNGLPROGRAMUNIFORMMATRIX2X3DVEXTPROC)(::GLuint, ::GLint, ::GLsizei, ::GLboolean, const ::GLdouble *);
typedef void (*PFNGLPROGRAMUNIFORMMATRIX2X4DVEXTPROC)(::GLuint, ::GLint, ::GLsizei, ::GLboolean, const ::GLdouble *);
typedef void (*PFNGLPROGRAMUNIFORMMATRIX3X2DVEXTPROC)(::GLuint, ::GLint, ::GLsizei, ::GLboolean, const ::GLdouble *);
typedef void (*PFNGLPROGRAMUNIFORMMATRIX3X4DVEXTPROC)(::GLuint, ::GLint, ::GLsizei, ::GLboolean, const ::GLdouble *);
typedef void (*PFNGLPROGRAMUNIFORMMATRIX4X2DVEXTPROC)(::GLuint, ::GLint, ::GLsizei, ::GLboolean, const ::GLdouble *);
typedef void (*PFNGLPROGRAMUNIFORMMATRIX4X3DVEXTPROC)(::GLuint, ::GLint, ::GLsizei, ::GLboolean, const ::GLdouble *);
extern "C"
{
  void glGetMultisamplefvNV(::GLenum pname, ::GLuint index, ::GLfloat *val)__attribute__((visibility("default")));
}
extern "C"
{
  void glSampleMaskIndexedNV(::GLuint index, ::GLbitfield mask)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexRenderbufferNV(::GLenum target, ::GLuint renderbuffer)__attribute__((visibility("default")));
}
typedef void (*PFNGLGETMULTISAMPLEFVNVPROC)(::GLenum, ::GLuint, ::GLfloat *);
typedef void (*PFNGLSAMPLEMASKINDEXEDNVPROC)(::GLuint, ::GLbitfield);
typedef void (*PFNGLTEXRENDERBUFFERNVPROC)(::GLenum, ::GLuint);
extern "C"
{
  void glBindTransformFeedbackNV(::GLenum target, ::GLuint id)__attribute__((visibility("default")));
}
extern "C"
{
  void glDeleteTransformFeedbacksNV(::GLsizei n, const ::GLuint *ids)__attribute__((visibility("default")));
}
extern "C"
{
  void glGenTransformFeedbacksNV(::GLsizei n, ::GLuint *ids)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLboolean glIsTransformFeedbackNV(::GLuint id)__attribute__((visibility("default")));
}
extern "C"
{
  void glPauseTransformFeedbackNV()__attribute__((visibility("default")));
}
extern "C"
{
  void glResumeTransformFeedbackNV()__attribute__((visibility("default")));
}
extern "C"
{
  void glDrawTransformFeedbackNV(::GLenum mode, ::GLuint id)__attribute__((visibility("default")));
}
typedef void (*PFNGLBINDTRANSFORMFEEDBACKNVPROC)(::GLenum, ::GLuint);
typedef void (*PFNGLDELETETRANSFORMFEEDBACKSNVPROC)(::GLsizei, const ::GLuint *);
typedef void (*PFNGLGENTRANSFORMFEEDBACKSNVPROC)(::GLsizei, ::GLuint *);
typedef ::GLboolean (*PFNGLISTRANSFORMFEEDBACKNVPROC)(::GLuint);
typedef void (*PFNGLPAUSETRANSFORMFEEDBACKNVPROC)();
typedef void (*PFNGLRESUMETRANSFORMFEEDBACKNVPROC)();
typedef void (*PFNGLDRAWTRANSFORMFEEDBACKNVPROC)(::GLenum, ::GLuint);
extern "C"
{
  void glGetPerfMonitorGroupsAMD(::GLint *numGroups, ::GLsizei groupsSize, ::GLuint *groups)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetPerfMonitorCountersAMD(::GLuint group, ::GLint *numCounters, ::GLint *maxActiveCounters, ::GLsizei counterSize, ::GLuint *counters)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetPerfMonitorGroupStringAMD(::GLuint group, ::GLsizei bufSize, ::GLsizei *length, ::GLchar *groupString)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetPerfMonitorCounterStringAMD(::GLuint group, ::GLuint counter, ::GLsizei bufSize, ::GLsizei *length, ::GLchar *counterString)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetPerfMonitorCounterInfoAMD(::GLuint group, ::GLuint counter, ::GLenum pname, ::GLvoid *data)__attribute__((visibility("default")));
}
extern "C"
{
  void glGenPerfMonitorsAMD(::GLsizei n, ::GLuint *monitors)__attribute__((visibility("default")));
}
extern "C"
{
  void glDeletePerfMonitorsAMD(::GLsizei n, ::GLuint *monitors)__attribute__((visibility("default")));
}
extern "C"
{
  void glSelectPerfMonitorCountersAMD(::GLuint monitor, ::GLboolean enable, ::GLuint group, ::GLint numCounters, ::GLuint *counterList)__attribute__((visibility("default")));
}
extern "C"
{
  void glBeginPerfMonitorAMD(::GLuint monitor)__attribute__((visibility("default")));
}
extern "C"
{
  void glEndPerfMonitorAMD(::GLuint monitor)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetPerfMonitorCounterDataAMD(::GLuint monitor, ::GLenum pname, ::GLsizei dataSize, ::GLuint *data, ::GLint *bytesWritten)__attribute__((visibility("default")));
}
typedef void (*PFNGLGETPERFMONITORGROUPSAMDPROC)(::GLint *, ::GLsizei, ::GLuint *);
typedef void (*PFNGLGETPERFMONITORCOUNTERSAMDPROC)(::GLuint, ::GLint *, ::GLint *, ::GLsizei, ::GLuint *);
typedef void (*PFNGLGETPERFMONITORGROUPSTRINGAMDPROC)(::GLuint, ::GLsizei, ::GLsizei *, ::GLchar *);
typedef void (*PFNGLGETPERFMONITORCOUNTERSTRINGAMDPROC)(::GLuint, ::GLuint, ::GLsizei, ::GLsizei *, ::GLchar *);
typedef void (*PFNGLGETPERFMONITORCOUNTERINFOAMDPROC)(::GLuint, ::GLuint, ::GLenum, ::GLvoid *);
typedef void (*PFNGLGENPERFMONITORSAMDPROC)(::GLsizei, ::GLuint *);
typedef void (*PFNGLDELETEPERFMONITORSAMDPROC)(::GLsizei, ::GLuint *);
typedef void (*PFNGLSELECTPERFMONITORCOUNTERSAMDPROC)(::GLuint, ::GLboolean, ::GLuint, ::GLint, ::GLuint *);
typedef void (*PFNGLBEGINPERFMONITORAMDPROC)(::GLuint);
typedef void (*PFNGLENDPERFMONITORAMDPROC)(::GLuint);
typedef void (*PFNGLGETPERFMONITORCOUNTERDATAAMDPROC)(::GLuint, ::GLenum, ::GLsizei, ::GLuint *, ::GLint *);
extern "C"
{
  void glTessellationFactorAMD(::GLfloat factor)__attribute__((visibility("default")));
}
extern "C"
{
  void glTessellationModeAMD(::GLenum mode)__attribute__((visibility("default")));
}
typedef void (*PFNGLTESSELLATIONFACTORAMDPROC)(::GLfloat);
typedef void (*PFNGLTESSELLATIONMODEAMDPROC)(::GLenum);
extern "C"
{
  void glProvokingVertexEXT(::GLenum mode)__attribute__((visibility("default")));
}
typedef void (*PFNGLPROVOKINGVERTEXEXTPROC)(::GLenum);
extern "C"
{
  void glBlendFuncIndexedAMD(::GLuint buf, ::GLenum src, ::GLenum dst)__attribute__((visibility("default")));
}
extern "C"
{
  void glBlendFuncSeparateIndexedAMD(::GLuint buf, ::GLenum srcRGB, ::GLenum dstRGB, ::GLenum srcAlpha, ::GLenum dstAlpha)__attribute__((visibility("default")));
}
extern "C"
{
  void glBlendEquationIndexedAMD(::GLuint buf, ::GLenum mode)__attribute__((visibility("default")));
}
extern "C"
{
  void glBlendEquationSeparateIndexedAMD(::GLuint buf, ::GLenum modeRGB, ::GLenum modeAlpha)__attribute__((visibility("default")));
}
typedef void (*PFNGLBLENDFUNCINDEXEDAMDPROC)(::GLuint, ::GLenum, ::GLenum);
typedef void (*PFNGLBLENDFUNCSEPARATEINDEXEDAMDPROC)(::GLuint, ::GLenum, ::GLenum, ::GLenum, ::GLenum);
typedef void (*PFNGLBLENDEQUATIONINDEXEDAMDPROC)(::GLuint, ::GLenum);
typedef void (*PFNGLBLENDEQUATIONSEPARATEINDEXEDAMDPROC)(::GLuint, ::GLenum, ::GLenum);
extern "C"
{
  void glTextureRangeAPPLE(::GLenum target, ::GLsizei length, const ::GLvoid *pointer)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetTexParameterPointervAPPLE(::GLenum target, ::GLenum pname, ::GLvoid **params)__attribute__((visibility("default")));
}
typedef void (*PFNGLTEXTURERANGEAPPLEPROC)(::GLenum, ::GLsizei, const ::GLvoid *);
typedef void (*PFNGLGETTEXPARAMETERPOINTERVAPPLEPROC)(::GLenum, ::GLenum, ::GLvoid **);
extern "C"
{
  void glEnableVertexAttribAPPLE(::GLuint index, ::GLenum pname)__attribute__((visibility("default")));
}
extern "C"
{
  void glDisableVertexAttribAPPLE(::GLuint index, ::GLenum pname)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLboolean glIsVertexAttribEnabledAPPLE(::GLuint index, ::GLenum pname)__attribute__((visibility("default")));
}
extern "C"
{
  void glMapVertexAttrib1dAPPLE(::GLuint index, ::GLuint size, ::GLdouble u1, ::GLdouble u2, ::GLint stride, ::GLint order, const ::GLdouble *points)__attribute__((visibility("default")));
}
extern "C"
{
  void glMapVertexAttrib1fAPPLE(::GLuint index, ::GLuint size, ::GLfloat u1, ::GLfloat u2, ::GLint stride, ::GLint order, const ::GLfloat *points)__attribute__((visibility("default")));
}
extern "C"
{
  void glMapVertexAttrib2dAPPLE(::GLuint index, ::GLuint size, ::GLdouble u1, ::GLdouble u2, ::GLint ustride, ::GLint uorder, ::GLdouble v1, ::GLdouble v2, ::GLint vstride, ::GLint vorder, const ::GLdouble *points)__attribute__((visibility("default")));
}
extern "C"
{
  void glMapVertexAttrib2fAPPLE(::GLuint index, ::GLuint size, ::GLfloat u1, ::GLfloat u2, ::GLint ustride, ::GLint uorder, ::GLfloat v1, ::GLfloat v2, ::GLint vstride, ::GLint vorder, const ::GLfloat *points)__attribute__((visibility("default")));
}
typedef void (*PFNGLENABLEVERTEXATTRIBAPPLEPROC)(::GLuint, ::GLenum);
typedef void (*PFNGLDISABLEVERTEXATTRIBAPPLEPROC)(::GLuint, ::GLenum);
typedef ::GLboolean (*PFNGLISVERTEXATTRIBENABLEDAPPLEPROC)(::GLuint, ::GLenum);
typedef void (*PFNGLMAPVERTEXATTRIB1DAPPLEPROC)(::GLuint, ::GLuint, ::GLdouble, ::GLdouble, ::GLint, ::GLint, const ::GLdouble *);
typedef void (*PFNGLMAPVERTEXATTRIB1FAPPLEPROC)(::GLuint, ::GLuint, ::GLfloat, ::GLfloat, ::GLint, ::GLint, const ::GLfloat *);
typedef void (*PFNGLMAPVERTEXATTRIB2DAPPLEPROC)(::GLuint, ::GLuint, ::GLdouble, ::GLdouble, ::GLint, ::GLint, ::GLdouble, ::GLdouble, ::GLint, ::GLint, const ::GLdouble *);
typedef void (*PFNGLMAPVERTEXATTRIB2FAPPLEPROC)(::GLuint, ::GLuint, ::GLfloat, ::GLfloat, ::GLint, ::GLint, ::GLfloat, ::GLfloat, ::GLint, ::GLint, const ::GLfloat *);
extern "C"
{
  ::GLenum glObjectPurgeableAPPLE(::GLenum objectType, ::GLuint name, ::GLenum option)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLenum glObjectUnpurgeableAPPLE(::GLenum objectType, ::GLuint name, ::GLenum option)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetObjectParameterivAPPLE(::GLenum objectType, ::GLuint name, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
typedef ::GLenum (*PFNGLOBJECTPURGEABLEAPPLEPROC)(::GLenum, ::GLuint, ::GLenum);
typedef ::GLenum (*PFNGLOBJECTUNPURGEABLEAPPLEPROC)(::GLenum, ::GLuint, ::GLenum);
typedef void (*PFNGLGETOBJECTPARAMETERIVAPPLEPROC)(::GLenum, ::GLuint, ::GLenum, ::GLint *);
extern "C"
{
  void glBeginVideoCaptureNV(::GLuint video_capture_slot)__attribute__((visibility("default")));
}
extern "C"
{
  void glBindVideoCaptureStreamBufferNV(::GLuint video_capture_slot, ::GLuint stream, ::GLenum frame_region, ::GLintptrARB offset)__attribute__((visibility("default")));
}
extern "C"
{
  void glBindVideoCaptureStreamTextureNV(::GLuint video_capture_slot, ::GLuint stream, ::GLenum frame_region, ::GLenum target, ::GLuint texture)__attribute__((visibility("default")));
}
extern "C"
{
  void glEndVideoCaptureNV(::GLuint video_capture_slot)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetVideoCaptureivNV(::GLuint video_capture_slot, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetVideoCaptureStreamivNV(::GLuint video_capture_slot, ::GLuint stream, ::GLenum pname, ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetVideoCaptureStreamfvNV(::GLuint video_capture_slot, ::GLuint stream, ::GLenum pname, ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetVideoCaptureStreamdvNV(::GLuint video_capture_slot, ::GLuint stream, ::GLenum pname, ::GLdouble *params)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLenum glVideoCaptureNV(::GLuint video_capture_slot, ::GLuint *sequence_num, ::GLuint64EXT *capture_time)__attribute__((visibility("default")));
}
extern "C"
{
  void glVideoCaptureStreamParameterivNV(::GLuint video_capture_slot, ::GLuint stream, ::GLenum pname, const ::GLint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glVideoCaptureStreamParameterfvNV(::GLuint video_capture_slot, ::GLuint stream, ::GLenum pname, const ::GLfloat *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glVideoCaptureStreamParameterdvNV(::GLuint video_capture_slot, ::GLuint stream, ::GLenum pname, const ::GLdouble *params)__attribute__((visibility("default")));
}
typedef void (*PFNGLBEGINVIDEOCAPTURENVPROC)(::GLuint);
typedef void (*PFNGLBINDVIDEOCAPTURESTREAMBUFFERNVPROC)(::GLuint, ::GLuint, ::GLenum, ::GLintptrARB);
typedef void (*PFNGLBINDVIDEOCAPTURESTREAMTEXTURENVPROC)(::GLuint, ::GLuint, ::GLenum, ::GLenum, ::GLuint);
typedef void (*PFNGLENDVIDEOCAPTURENVPROC)(::GLuint);
typedef void (*PFNGLGETVIDEOCAPTUREIVNVPROC)(::GLuint, ::GLenum, ::GLint *);
typedef void (*PFNGLGETVIDEOCAPTURESTREAMIVNVPROC)(::GLuint, ::GLuint, ::GLenum, ::GLint *);
typedef void (*PFNGLGETVIDEOCAPTURESTREAMFVNVPROC)(::GLuint, ::GLuint, ::GLenum, ::GLfloat *);
typedef void (*PFNGLGETVIDEOCAPTURESTREAMDVNVPROC)(::GLuint, ::GLuint, ::GLenum, ::GLdouble *);
typedef ::GLenum (*PFNGLVIDEOCAPTURENVPROC)(::GLuint, ::GLuint *, ::GLuint64EXT *);
typedef void (*PFNGLVIDEOCAPTURESTREAMPARAMETERIVNVPROC)(::GLuint, ::GLuint, ::GLenum, const ::GLint *);
typedef void (*PFNGLVIDEOCAPTURESTREAMPARAMETERFVNVPROC)(::GLuint, ::GLuint, ::GLenum, const ::GLfloat *);
typedef void (*PFNGLVIDEOCAPTURESTREAMPARAMETERDVNVPROC)(::GLuint, ::GLuint, ::GLenum, const ::GLdouble *);
extern "C"
{
  void glCopyImageSubDataNV(::GLuint srcName, ::GLenum srcTarget, ::GLint srcLevel, ::GLint srcX, ::GLint srcY, ::GLint srcZ, ::GLuint dstName, ::GLenum dstTarget, ::GLint dstLevel, ::GLint dstX, ::GLint dstY, ::GLint dstZ, ::GLsizei width, ::GLsizei height, ::GLsizei depth)__attribute__((visibility("default")));
}
typedef void (*PFNGLCOPYIMAGESUBDATANVPROC)(::GLuint, ::GLenum, ::GLint, ::GLint, ::GLint, ::GLint, ::GLuint, ::GLenum, ::GLint, ::GLint, ::GLint, ::GLint, ::GLsizei, ::GLsizei, ::GLsizei);
extern "C"
{
  void glUseShaderProgramEXT(::GLenum type, ::GLuint program)__attribute__((visibility("default")));
}
extern "C"
{
  void glActiveProgramEXT(::GLuint program)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLuint glCreateShaderProgramEXT(::GLenum type, const ::GLchar *string)__attribute__((visibility("default")));
}
typedef void (*PFNGLUSESHADERPROGRAMEXTPROC)(::GLenum, ::GLuint);
typedef void (*PFNGLACTIVEPROGRAMEXTPROC)(::GLuint);
typedef ::GLuint (*PFNGLCREATESHADERPROGRAMEXTPROC)(::GLenum, const ::GLchar *);
extern "C"
{
  void glMakeBufferResidentNV(::GLenum target, ::GLenum access)__attribute__((visibility("default")));
}
extern "C"
{
  void glMakeBufferNonResidentNV(::GLenum target)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLboolean glIsBufferResidentNV(::GLenum target)__attribute__((visibility("default")));
}
extern "C"
{
  void glMakeNamedBufferResidentNV(::GLuint buffer, ::GLenum access)__attribute__((visibility("default")));
}
extern "C"
{
  void glMakeNamedBufferNonResidentNV(::GLuint buffer)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLboolean glIsNamedBufferResidentNV(::GLuint buffer)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetBufferParameterui64vNV(::GLenum target, ::GLenum pname, ::GLuint64EXT *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetNamedBufferParameterui64vNV(::GLuint buffer, ::GLenum pname, ::GLuint64EXT *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetIntegerui64vNV(::GLenum value, ::GLuint64EXT *result)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniformui64NV(::GLint location, ::GLuint64EXT value)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniformui64vNV(::GLint location, ::GLsizei count, const ::GLuint64EXT *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetUniformui64vNV(::GLuint program, ::GLint location, ::GLuint64EXT *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniformui64NV(::GLuint program, ::GLint location, ::GLuint64EXT value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniformui64vNV(::GLuint program, ::GLint location, ::GLsizei count, const ::GLuint64EXT *value)__attribute__((visibility("default")));
}
typedef void (*PFNGLMAKEBUFFERRESIDENTNVPROC)(::GLenum, ::GLenum);
typedef void (*PFNGLMAKEBUFFERNONRESIDENTNVPROC)(::GLenum);
typedef ::GLboolean (*PFNGLISBUFFERRESIDENTNVPROC)(::GLenum);
typedef void (*PFNGLMAKENAMEDBUFFERRESIDENTNVPROC)(::GLuint, ::GLenum);
typedef void (*PFNGLMAKENAMEDBUFFERNONRESIDENTNVPROC)(::GLuint);
typedef ::GLboolean (*PFNGLISNAMEDBUFFERRESIDENTNVPROC)(::GLuint);
typedef void (*PFNGLGETBUFFERPARAMETERUI64VNVPROC)(::GLenum, ::GLenum, ::GLuint64EXT *);
typedef void (*PFNGLGETNAMEDBUFFERPARAMETERUI64VNVPROC)(::GLuint, ::GLenum, ::GLuint64EXT *);
typedef void (*PFNGLGETINTEGERUI64VNVPROC)(::GLenum, ::GLuint64EXT *);
typedef void (*PFNGLUNIFORMUI64NVPROC)(::GLint, ::GLuint64EXT);
typedef void (*PFNGLUNIFORMUI64VNVPROC)(::GLint, ::GLsizei, const ::GLuint64EXT *);
typedef void (*PFNGLGETUNIFORMUI64VNVPROC)(::GLuint, ::GLint, ::GLuint64EXT *);
typedef void (*PFNGLPROGRAMUNIFORMUI64NVPROC)(::GLuint, ::GLint, ::GLuint64EXT);
typedef void (*PFNGLPROGRAMUNIFORMUI64VNVPROC)(::GLuint, ::GLint, ::GLsizei, const ::GLuint64EXT *);
extern "C"
{
  void glBufferAddressRangeNV(::GLenum pname, ::GLuint index, ::GLuint64EXT address, ::GLsizeiptr length)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexFormatNV(::GLint size, ::GLenum type, ::GLsizei stride)__attribute__((visibility("default")));
}
extern "C"
{
  void glNormalFormatNV(::GLenum type, ::GLsizei stride)__attribute__((visibility("default")));
}
extern "C"
{
  void glColorFormatNV(::GLint size, ::GLenum type, ::GLsizei stride)__attribute__((visibility("default")));
}
extern "C"
{
  void glIndexFormatNV(::GLenum type, ::GLsizei stride)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexCoordFormatNV(::GLint size, ::GLenum type, ::GLsizei stride)__attribute__((visibility("default")));
}
extern "C"
{
  void glEdgeFlagFormatNV(::GLsizei stride)__attribute__((visibility("default")));
}
extern "C"
{
  void glSecondaryColorFormatNV(::GLint size, ::GLenum type, ::GLsizei stride)__attribute__((visibility("default")));
}
extern "C"
{
  void glFogCoordFormatNV(::GLenum type, ::GLsizei stride)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribFormatNV(::GLuint index, ::GLint size, ::GLenum type, ::GLboolean normalized, ::GLsizei stride)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribIFormatNV(::GLuint index, ::GLint size, ::GLenum type, ::GLsizei stride)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetIntegerui64i_vNV(::GLenum value, ::GLuint index, ::GLuint64EXT *result)__attribute__((visibility("default")));
}
typedef void (*PFNGLBUFFERADDRESSRANGENVPROC)(::GLenum, ::GLuint, ::GLuint64EXT, ::GLsizeiptr);
typedef void (*PFNGLVERTEXFORMATNVPROC)(::GLint, ::GLenum, ::GLsizei);
typedef void (*PFNGLNORMALFORMATNVPROC)(::GLenum, ::GLsizei);
typedef void (*PFNGLCOLORFORMATNVPROC)(::GLint, ::GLenum, ::GLsizei);
typedef void (*PFNGLINDEXFORMATNVPROC)(::GLenum, ::GLsizei);
typedef void (*PFNGLTEXCOORDFORMATNVPROC)(::GLint, ::GLenum, ::GLsizei);
typedef void (*PFNGLEDGEFLAGFORMATNVPROC)(::GLsizei);
typedef void (*PFNGLSECONDARYCOLORFORMATNVPROC)(::GLint, ::GLenum, ::GLsizei);
typedef void (*PFNGLFOGCOORDFORMATNVPROC)(::GLenum, ::GLsizei);
typedef void (*PFNGLVERTEXATTRIBFORMATNVPROC)(::GLuint, ::GLint, ::GLenum, ::GLboolean, ::GLsizei);
typedef void (*PFNGLVERTEXATTRIBIFORMATNVPROC)(::GLuint, ::GLint, ::GLenum, ::GLsizei);
typedef void (*PFNGLGETINTEGERUI64I_VNVPROC)(::GLenum, ::GLuint, ::GLuint64EXT *);
extern "C"
{
  void glTextureBarrierNV()__attribute__((visibility("default")));
}
typedef void (*PFNGLTEXTUREBARRIERNVPROC)();
extern "C"
{
  void glBindImageTextureEXT(::GLuint index, ::GLuint texture, ::GLint level, ::GLboolean layered, ::GLint layer, ::GLenum access, ::GLint format)__attribute__((visibility("default")));
}
extern "C"
{
  void glMemoryBarrierEXT(::GLbitfield barriers)__attribute__((visibility("default")));
}
typedef void (*PFNGLBINDIMAGETEXTUREEXTPROC)(::GLuint, ::GLuint, ::GLint, ::GLboolean, ::GLint, ::GLenum, ::GLint);
typedef void (*PFNGLMEMORYBARRIEREXTPROC)(::GLbitfield);
extern "C"
{
  void glVertexAttribL1dEXT(::GLuint index, ::GLdouble x)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribL2dEXT(::GLuint index, ::GLdouble x, ::GLdouble y)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribL3dEXT(::GLuint index, ::GLdouble x, ::GLdouble y, ::GLdouble z)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribL4dEXT(::GLuint index, ::GLdouble x, ::GLdouble y, ::GLdouble z, ::GLdouble w)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribL1dvEXT(::GLuint index, const ::GLdouble *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribL2dvEXT(::GLuint index, const ::GLdouble *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribL3dvEXT(::GLuint index, const ::GLdouble *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribL4dvEXT(::GLuint index, const ::GLdouble *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribLPointerEXT(::GLuint index, ::GLint size, ::GLenum type, ::GLsizei stride, const ::GLvoid *pointer)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetVertexAttribLdvEXT(::GLuint index, ::GLenum pname, ::GLdouble *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexArrayVertexAttribLOffsetEXT(::GLuint vaobj, ::GLuint buffer, ::GLuint index, ::GLint size, ::GLenum type, ::GLsizei stride, ::GLintptr offset)__attribute__((visibility("default")));
}
typedef void (*PFNGLVERTEXATTRIBL1DEXTPROC)(::GLuint, ::GLdouble);
typedef void (*PFNGLVERTEXATTRIBL2DEXTPROC)(::GLuint, ::GLdouble, ::GLdouble);
typedef void (*PFNGLVERTEXATTRIBL3DEXTPROC)(::GLuint, ::GLdouble, ::GLdouble, ::GLdouble);
typedef void (*PFNGLVERTEXATTRIBL4DEXTPROC)(::GLuint, ::GLdouble, ::GLdouble, ::GLdouble, ::GLdouble);
typedef void (*PFNGLVERTEXATTRIBL1DVEXTPROC)(::GLuint, const ::GLdouble *);
typedef void (*PFNGLVERTEXATTRIBL2DVEXTPROC)(::GLuint, const ::GLdouble *);
typedef void (*PFNGLVERTEXATTRIBL3DVEXTPROC)(::GLuint, const ::GLdouble *);
typedef void (*PFNGLVERTEXATTRIBL4DVEXTPROC)(::GLuint, const ::GLdouble *);
typedef void (*PFNGLVERTEXATTRIBLPOINTEREXTPROC)(::GLuint, ::GLint, ::GLenum, ::GLsizei, const ::GLvoid *);
typedef void (*PFNGLGETVERTEXATTRIBLDVEXTPROC)(::GLuint, ::GLenum, ::GLdouble *);
typedef void (*PFNGLVERTEXARRAYVERTEXATTRIBLOFFSETEXTPROC)(::GLuint, ::GLuint, ::GLuint, ::GLint, ::GLenum, ::GLsizei, ::GLintptr);
extern "C"
{
  void glProgramSubroutineParametersuivNV(::GLenum target, ::GLsizei count, const ::GLuint *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetProgramSubroutineParameteruivNV(::GLenum target, ::GLuint index, ::GLuint *param)__attribute__((visibility("default")));
}
typedef void (*PFNGLPROGRAMSUBROUTINEPARAMETERSUIVNVPROC)(::GLenum, ::GLsizei, const ::GLuint *);
typedef void (*PFNGLGETPROGRAMSUBROUTINEPARAMETERUIVNVPROC)(::GLenum, ::GLuint, ::GLuint *);
extern "C"
{
  void glUniform1i64NV(::GLint location, ::GLint64EXT x)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform2i64NV(::GLint location, ::GLint64EXT x, ::GLint64EXT y)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform3i64NV(::GLint location, ::GLint64EXT x, ::GLint64EXT y, ::GLint64EXT z)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform4i64NV(::GLint location, ::GLint64EXT x, ::GLint64EXT y, ::GLint64EXT z, ::GLint64EXT w)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform1i64vNV(::GLint location, ::GLsizei count, const ::GLint64EXT *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform2i64vNV(::GLint location, ::GLsizei count, const ::GLint64EXT *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform3i64vNV(::GLint location, ::GLsizei count, const ::GLint64EXT *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform4i64vNV(::GLint location, ::GLsizei count, const ::GLint64EXT *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform1ui64NV(::GLint location, ::GLuint64EXT x)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform2ui64NV(::GLint location, ::GLuint64EXT x, ::GLuint64EXT y)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform3ui64NV(::GLint location, ::GLuint64EXT x, ::GLuint64EXT y, ::GLuint64EXT z)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform4ui64NV(::GLint location, ::GLuint64EXT x, ::GLuint64EXT y, ::GLuint64EXT z, ::GLuint64EXT w)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform1ui64vNV(::GLint location, ::GLsizei count, const ::GLuint64EXT *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform2ui64vNV(::GLint location, ::GLsizei count, const ::GLuint64EXT *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform3ui64vNV(::GLint location, ::GLsizei count, const ::GLuint64EXT *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glUniform4ui64vNV(::GLint location, ::GLsizei count, const ::GLuint64EXT *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetUniformi64vNV(::GLuint program, ::GLint location, ::GLint64EXT *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform1i64NV(::GLuint program, ::GLint location, ::GLint64EXT x)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform2i64NV(::GLuint program, ::GLint location, ::GLint64EXT x, ::GLint64EXT y)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform3i64NV(::GLuint program, ::GLint location, ::GLint64EXT x, ::GLint64EXT y, ::GLint64EXT z)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform4i64NV(::GLuint program, ::GLint location, ::GLint64EXT x, ::GLint64EXT y, ::GLint64EXT z, ::GLint64EXT w)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform1i64vNV(::GLuint program, ::GLint location, ::GLsizei count, const ::GLint64EXT *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform2i64vNV(::GLuint program, ::GLint location, ::GLsizei count, const ::GLint64EXT *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform3i64vNV(::GLuint program, ::GLint location, ::GLsizei count, const ::GLint64EXT *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform4i64vNV(::GLuint program, ::GLint location, ::GLsizei count, const ::GLint64EXT *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform1ui64NV(::GLuint program, ::GLint location, ::GLuint64EXT x)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform2ui64NV(::GLuint program, ::GLint location, ::GLuint64EXT x, ::GLuint64EXT y)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform3ui64NV(::GLuint program, ::GLint location, ::GLuint64EXT x, ::GLuint64EXT y, ::GLuint64EXT z)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform4ui64NV(::GLuint program, ::GLint location, ::GLuint64EXT x, ::GLuint64EXT y, ::GLuint64EXT z, ::GLuint64EXT w)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform1ui64vNV(::GLuint program, ::GLint location, ::GLsizei count, const ::GLuint64EXT *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform2ui64vNV(::GLuint program, ::GLint location, ::GLsizei count, const ::GLuint64EXT *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform3ui64vNV(::GLuint program, ::GLint location, ::GLsizei count, const ::GLuint64EXT *value)__attribute__((visibility("default")));
}
extern "C"
{
  void glProgramUniform4ui64vNV(::GLuint program, ::GLint location, ::GLsizei count, const ::GLuint64EXT *value)__attribute__((visibility("default")));
}
typedef void (*PFNGLUNIFORM1I64NVPROC)(::GLint, ::GLint64EXT);
typedef void (*PFNGLUNIFORM2I64NVPROC)(::GLint, ::GLint64EXT, ::GLint64EXT);
typedef void (*PFNGLUNIFORM3I64NVPROC)(::GLint, ::GLint64EXT, ::GLint64EXT, ::GLint64EXT);
typedef void (*PFNGLUNIFORM4I64NVPROC)(::GLint, ::GLint64EXT, ::GLint64EXT, ::GLint64EXT, ::GLint64EXT);
typedef void (*PFNGLUNIFORM1I64VNVPROC)(::GLint, ::GLsizei, const ::GLint64EXT *);
typedef void (*PFNGLUNIFORM2I64VNVPROC)(::GLint, ::GLsizei, const ::GLint64EXT *);
typedef void (*PFNGLUNIFORM3I64VNVPROC)(::GLint, ::GLsizei, const ::GLint64EXT *);
typedef void (*PFNGLUNIFORM4I64VNVPROC)(::GLint, ::GLsizei, const ::GLint64EXT *);
typedef void (*PFNGLUNIFORM1UI64NVPROC)(::GLint, ::GLuint64EXT);
typedef void (*PFNGLUNIFORM2UI64NVPROC)(::GLint, ::GLuint64EXT, ::GLuint64EXT);
typedef void (*PFNGLUNIFORM3UI64NVPROC)(::GLint, ::GLuint64EXT, ::GLuint64EXT, ::GLuint64EXT);
typedef void (*PFNGLUNIFORM4UI64NVPROC)(::GLint, ::GLuint64EXT, ::GLuint64EXT, ::GLuint64EXT, ::GLuint64EXT);
typedef void (*PFNGLUNIFORM1UI64VNVPROC)(::GLint, ::GLsizei, const ::GLuint64EXT *);
typedef void (*PFNGLUNIFORM2UI64VNVPROC)(::GLint, ::GLsizei, const ::GLuint64EXT *);
typedef void (*PFNGLUNIFORM3UI64VNVPROC)(::GLint, ::GLsizei, const ::GLuint64EXT *);
typedef void (*PFNGLUNIFORM4UI64VNVPROC)(::GLint, ::GLsizei, const ::GLuint64EXT *);
typedef void (*PFNGLGETUNIFORMI64VNVPROC)(::GLuint, ::GLint, ::GLint64EXT *);
typedef void (*PFNGLPROGRAMUNIFORM1I64NVPROC)(::GLuint, ::GLint, ::GLint64EXT);
typedef void (*PFNGLPROGRAMUNIFORM2I64NVPROC)(::GLuint, ::GLint, ::GLint64EXT, ::GLint64EXT);
typedef void (*PFNGLPROGRAMUNIFORM3I64NVPROC)(::GLuint, ::GLint, ::GLint64EXT, ::GLint64EXT, ::GLint64EXT);
typedef void (*PFNGLPROGRAMUNIFORM4I64NVPROC)(::GLuint, ::GLint, ::GLint64EXT, ::GLint64EXT, ::GLint64EXT, ::GLint64EXT);
typedef void (*PFNGLPROGRAMUNIFORM1I64VNVPROC)(::GLuint, ::GLint, ::GLsizei, const ::GLint64EXT *);
typedef void (*PFNGLPROGRAMUNIFORM2I64VNVPROC)(::GLuint, ::GLint, ::GLsizei, const ::GLint64EXT *);
typedef void (*PFNGLPROGRAMUNIFORM3I64VNVPROC)(::GLuint, ::GLint, ::GLsizei, const ::GLint64EXT *);
typedef void (*PFNGLPROGRAMUNIFORM4I64VNVPROC)(::GLuint, ::GLint, ::GLsizei, const ::GLint64EXT *);
typedef void (*PFNGLPROGRAMUNIFORM1UI64NVPROC)(::GLuint, ::GLint, ::GLuint64EXT);
typedef void (*PFNGLPROGRAMUNIFORM2UI64NVPROC)(::GLuint, ::GLint, ::GLuint64EXT, ::GLuint64EXT);
typedef void (*PFNGLPROGRAMUNIFORM3UI64NVPROC)(::GLuint, ::GLint, ::GLuint64EXT, ::GLuint64EXT, ::GLuint64EXT);
typedef void (*PFNGLPROGRAMUNIFORM4UI64NVPROC)(::GLuint, ::GLint, ::GLuint64EXT, ::GLuint64EXT, ::GLuint64EXT, ::GLuint64EXT);
typedef void (*PFNGLPROGRAMUNIFORM1UI64VNVPROC)(::GLuint, ::GLint, ::GLsizei, const ::GLuint64EXT *);
typedef void (*PFNGLPROGRAMUNIFORM2UI64VNVPROC)(::GLuint, ::GLint, ::GLsizei, const ::GLuint64EXT *);
typedef void (*PFNGLPROGRAMUNIFORM3UI64VNVPROC)(::GLuint, ::GLint, ::GLsizei, const ::GLuint64EXT *);
typedef void (*PFNGLPROGRAMUNIFORM4UI64VNVPROC)(::GLuint, ::GLint, ::GLsizei, const ::GLuint64EXT *);
extern "C"
{
  void glVertexAttribL1i64NV(::GLuint index, ::GLint64EXT x)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribL2i64NV(::GLuint index, ::GLint64EXT x, ::GLint64EXT y)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribL3i64NV(::GLuint index, ::GLint64EXT x, ::GLint64EXT y, ::GLint64EXT z)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribL4i64NV(::GLuint index, ::GLint64EXT x, ::GLint64EXT y, ::GLint64EXT z, ::GLint64EXT w)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribL1i64vNV(::GLuint index, const ::GLint64EXT *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribL2i64vNV(::GLuint index, const ::GLint64EXT *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribL3i64vNV(::GLuint index, const ::GLint64EXT *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribL4i64vNV(::GLuint index, const ::GLint64EXT *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribL1ui64NV(::GLuint index, ::GLuint64EXT x)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribL2ui64NV(::GLuint index, ::GLuint64EXT x, ::GLuint64EXT y)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribL3ui64NV(::GLuint index, ::GLuint64EXT x, ::GLuint64EXT y, ::GLuint64EXT z)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribL4ui64NV(::GLuint index, ::GLuint64EXT x, ::GLuint64EXT y, ::GLuint64EXT z, ::GLuint64EXT w)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribL1ui64vNV(::GLuint index, const ::GLuint64EXT *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribL2ui64vNV(::GLuint index, const ::GLuint64EXT *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribL3ui64vNV(::GLuint index, const ::GLuint64EXT *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribL4ui64vNV(::GLuint index, const ::GLuint64EXT *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetVertexAttribLi64vNV(::GLuint index, ::GLenum pname, ::GLint64EXT *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetVertexAttribLui64vNV(::GLuint index, ::GLenum pname, ::GLuint64EXT *params)__attribute__((visibility("default")));
}
extern "C"
{
  void glVertexAttribLFormatNV(::GLuint index, ::GLint size, ::GLenum type, ::GLsizei stride)__attribute__((visibility("default")));
}
typedef void (*PFNGLVERTEXATTRIBL1I64NVPROC)(::GLuint, ::GLint64EXT);
typedef void (*PFNGLVERTEXATTRIBL2I64NVPROC)(::GLuint, ::GLint64EXT, ::GLint64EXT);
typedef void (*PFNGLVERTEXATTRIBL3I64NVPROC)(::GLuint, ::GLint64EXT, ::GLint64EXT, ::GLint64EXT);
typedef void (*PFNGLVERTEXATTRIBL4I64NVPROC)(::GLuint, ::GLint64EXT, ::GLint64EXT, ::GLint64EXT, ::GLint64EXT);
typedef void (*PFNGLVERTEXATTRIBL1I64VNVPROC)(::GLuint, const ::GLint64EXT *);
typedef void (*PFNGLVERTEXATTRIBL2I64VNVPROC)(::GLuint, const ::GLint64EXT *);
typedef void (*PFNGLVERTEXATTRIBL3I64VNVPROC)(::GLuint, const ::GLint64EXT *);
typedef void (*PFNGLVERTEXATTRIBL4I64VNVPROC)(::GLuint, const ::GLint64EXT *);
typedef void (*PFNGLVERTEXATTRIBL1UI64NVPROC)(::GLuint, ::GLuint64EXT);
typedef void (*PFNGLVERTEXATTRIBL2UI64NVPROC)(::GLuint, ::GLuint64EXT, ::GLuint64EXT);
typedef void (*PFNGLVERTEXATTRIBL3UI64NVPROC)(::GLuint, ::GLuint64EXT, ::GLuint64EXT, ::GLuint64EXT);
typedef void (*PFNGLVERTEXATTRIBL4UI64NVPROC)(::GLuint, ::GLuint64EXT, ::GLuint64EXT, ::GLuint64EXT, ::GLuint64EXT);
typedef void (*PFNGLVERTEXATTRIBL1UI64VNVPROC)(::GLuint, const ::GLuint64EXT *);
typedef void (*PFNGLVERTEXATTRIBL2UI64VNVPROC)(::GLuint, const ::GLuint64EXT *);
typedef void (*PFNGLVERTEXATTRIBL3UI64VNVPROC)(::GLuint, const ::GLuint64EXT *);
typedef void (*PFNGLVERTEXATTRIBL4UI64VNVPROC)(::GLuint, const ::GLuint64EXT *);
typedef void (*PFNGLGETVERTEXATTRIBLI64VNVPROC)(::GLuint, ::GLenum, ::GLint64EXT *);
typedef void (*PFNGLGETVERTEXATTRIBLUI64VNVPROC)(::GLuint, ::GLenum, ::GLuint64EXT *);
typedef void (*PFNGLVERTEXATTRIBLFORMATNVPROC)(::GLuint, ::GLint, ::GLenum, ::GLsizei);
extern "C"
{
  void glGenNamesAMD(::GLenum identifier, ::GLuint num, ::GLuint *names)__attribute__((visibility("default")));
}
extern "C"
{
  void glDeleteNamesAMD(::GLenum identifier, ::GLuint num, const ::GLuint *names)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLboolean glIsNameAMD(::GLenum identifier, ::GLuint name)__attribute__((visibility("default")));
}
typedef void (*PFNGLGENNAMESAMDPROC)(::GLenum, ::GLuint, ::GLuint *);
typedef void (*PFNGLDELETENAMESAMDPROC)(::GLenum, ::GLuint, const ::GLuint *);
typedef ::GLboolean (*PFNGLISNAMEAMDPROC)(::GLenum, ::GLuint);
extern "C"
{
  void glDebugMessageEnableAMD(::GLenum category, ::GLenum severity, ::GLsizei count, const ::GLuint *ids, ::GLboolean enabled)__attribute__((visibility("default")));
}
extern "C"
{
  void glDebugMessageInsertAMD(::GLenum category, ::GLenum severity, ::GLuint id, ::GLsizei length, const ::GLchar *buf)__attribute__((visibility("default")));
}
extern "C"
{
  void glDebugMessageCallbackAMD(::GLDEBUGPROCAMD callback, ::GLvoid *userParam)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLuint glGetDebugMessageLogAMD(::GLuint count, ::GLsizei bufsize, ::GLenum *categories, ::GLuint *severities, ::GLuint *ids, ::GLsizei *lengths, ::GLchar *message)__attribute__((visibility("default")));
}
typedef void (*PFNGLDEBUGMESSAGEENABLEAMDPROC)(::GLenum, ::GLenum, ::GLsizei, const ::GLuint *, ::GLboolean);
typedef void (*PFNGLDEBUGMESSAGEINSERTAMDPROC)(::GLenum, ::GLenum, ::GLuint, ::GLsizei, const ::GLchar *);
typedef void (*PFNGLDEBUGMESSAGECALLBACKAMDPROC)(::GLDEBUGPROCAMD, ::GLvoid *);
typedef ::GLuint (*PFNGLGETDEBUGMESSAGELOGAMDPROC)(::GLuint, ::GLsizei, ::GLenum *, ::GLuint *, ::GLuint *, ::GLsizei *, ::GLchar *);
extern "C"
{
  void glVDPAUInitNV(const ::GLvoid *vdpDevice, const ::GLvoid *getProcAddress)__attribute__((visibility("default")));
}
extern "C"
{
  void glVDPAUFiniNV()__attribute__((visibility("default")));
}
extern "C"
{
  ::GLvdpauSurfaceNV glVDPAURegisterVideoSurfaceNV(::GLvoid *vdpSurface, ::GLenum target, ::GLsizei numTextureNames, const ::GLuint *textureNames)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLvdpauSurfaceNV glVDPAURegisterOutputSurfaceNV(::GLvoid *vdpSurface, ::GLenum target, ::GLsizei numTextureNames, const ::GLuint *textureNames)__attribute__((visibility("default")));
}
extern "C"
{
  void glVDPAUIsSurfaceNV(::GLvdpauSurfaceNV surface)__attribute__((visibility("default")));
}
extern "C"
{
  void glVDPAUUnregisterSurfaceNV(::GLvdpauSurfaceNV surface)__attribute__((visibility("default")));
}
extern "C"
{
  void glVDPAUGetSurfaceivNV(::GLvdpauSurfaceNV surface, ::GLenum pname, ::GLsizei bufSize, ::GLsizei *length, ::GLint *values)__attribute__((visibility("default")));
}
extern "C"
{
  void glVDPAUSurfaceAccessNV(::GLvdpauSurfaceNV surface, ::GLenum access)__attribute__((visibility("default")));
}
extern "C"
{
  void glVDPAUMapSurfacesNV(::GLsizei numSurfaces, const ::GLvdpauSurfaceNV *surfaces)__attribute__((visibility("default")));
}
extern "C"
{
  void glVDPAUUnmapSurfacesNV(::GLsizei numSurface, const ::GLvdpauSurfaceNV *surfaces)__attribute__((visibility("default")));
}
typedef void (*PFNGLVDPAUINITNVPROC)(const ::GLvoid *, const ::GLvoid *);
typedef void (*PFNGLVDPAUFININVPROC)();
typedef ::GLvdpauSurfaceNV (*PFNGLVDPAUREGISTERVIDEOSURFACENVPROC)(::GLvoid *, ::GLenum, ::GLsizei, const ::GLuint *);
typedef ::GLvdpauSurfaceNV (*PFNGLVDPAUREGISTEROUTPUTSURFACENVPROC)(::GLvoid *, ::GLenum, ::GLsizei, const ::GLuint *);
typedef void (*PFNGLVDPAUISSURFACENVPROC)(::GLvdpauSurfaceNV);
typedef void (*PFNGLVDPAUUNREGISTERSURFACENVPROC)(::GLvdpauSurfaceNV);
typedef void (*PFNGLVDPAUGETSURFACEIVNVPROC)(::GLvdpauSurfaceNV, ::GLenum, ::GLsizei, ::GLsizei *, ::GLint *);
typedef void (*PFNGLVDPAUSURFACEACCESSNVPROC)(::GLvdpauSurfaceNV, ::GLenum);
typedef void (*PFNGLVDPAUMAPSURFACESNVPROC)(::GLsizei, const ::GLvdpauSurfaceNV *);
typedef void (*PFNGLVDPAUUNMAPSURFACESNVPROC)(::GLsizei, const ::GLvdpauSurfaceNV *);
extern "C"
{
  void glTexImage2DMultisampleCoverageNV(::GLenum target, ::GLsizei coverageSamples, ::GLsizei colorSamples, ::GLint internalFormat, ::GLsizei width, ::GLsizei height, ::GLboolean fixedSampleLocations)__attribute__((visibility("default")));
}
extern "C"
{
  void glTexImage3DMultisampleCoverageNV(::GLenum target, ::GLsizei coverageSamples, ::GLsizei colorSamples, ::GLint internalFormat, ::GLsizei width, ::GLsizei height, ::GLsizei depth, ::GLboolean fixedSampleLocations)__attribute__((visibility("default")));
}
extern "C"
{
  void glTextureImage2DMultisampleNV(::GLuint texture, ::GLenum target, ::GLsizei samples, ::GLint internalFormat, ::GLsizei width, ::GLsizei height, ::GLboolean fixedSampleLocations)__attribute__((visibility("default")));
}
extern "C"
{
  void glTextureImage3DMultisampleNV(::GLuint texture, ::GLenum target, ::GLsizei samples, ::GLint internalFormat, ::GLsizei width, ::GLsizei height, ::GLsizei depth, ::GLboolean fixedSampleLocations)__attribute__((visibility("default")));
}
extern "C"
{
  void glTextureImage2DMultisampleCoverageNV(::GLuint texture, ::GLenum target, ::GLsizei coverageSamples, ::GLsizei colorSamples, ::GLint internalFormat, ::GLsizei width, ::GLsizei height, ::GLboolean fixedSampleLocations)__attribute__((visibility("default")));
}
extern "C"
{
  void glTextureImage3DMultisampleCoverageNV(::GLuint texture, ::GLenum target, ::GLsizei coverageSamples, ::GLsizei colorSamples, ::GLint internalFormat, ::GLsizei width, ::GLsizei height, ::GLsizei depth, ::GLboolean fixedSampleLocations)__attribute__((visibility("default")));
}
typedef void (*PFNGLTEXIMAGE2DMULTISAMPLECOVERAGENVPROC)(::GLenum, ::GLsizei, ::GLsizei, ::GLint, ::GLsizei, ::GLsizei, ::GLboolean);
typedef void (*PFNGLTEXIMAGE3DMULTISAMPLECOVERAGENVPROC)(::GLenum, ::GLsizei, ::GLsizei, ::GLint, ::GLsizei, ::GLsizei, ::GLsizei, ::GLboolean);
typedef void (*PFNGLTEXTUREIMAGE2DMULTISAMPLENVPROC)(::GLuint, ::GLenum, ::GLsizei, ::GLint, ::GLsizei, ::GLsizei, ::GLboolean);
typedef void (*PFNGLTEXTUREIMAGE3DMULTISAMPLENVPROC)(::GLuint, ::GLenum, ::GLsizei, ::GLint, ::GLsizei, ::GLsizei, ::GLsizei, ::GLboolean);
typedef void (*PFNGLTEXTUREIMAGE2DMULTISAMPLECOVERAGENVPROC)(::GLuint, ::GLenum, ::GLsizei, ::GLsizei, ::GLint, ::GLsizei, ::GLsizei, ::GLboolean);
typedef void (*PFNGLTEXTUREIMAGE3DMULTISAMPLECOVERAGENVPROC)(::GLuint, ::GLenum, ::GLsizei, ::GLsizei, ::GLint, ::GLsizei, ::GLsizei, ::GLsizei, ::GLboolean);
extern "C"
{
  void glSetMultisamplefvAMD(::GLenum pname, ::GLuint index, const ::GLfloat *val)__attribute__((visibility("default")));
}
typedef void (*PFNGLSETMULTISAMPLEFVAMDPROC)(::GLenum, ::GLuint, const ::GLfloat *);
extern "C"
{
  ::GLsync glImportSyncEXT(::GLenum external_sync_type, ::GLintptr external_sync, ::GLbitfield flags)__attribute__((visibility("default")));
}
typedef ::GLsync (*PFNGLIMPORTSYNCEXTPROC)(::GLenum, ::GLintptr, ::GLbitfield);
extern "C"
{
  void glMultiDrawArraysIndirectAMD(::GLenum mode, const ::GLvoid *indirect, ::GLsizei primcount, ::GLsizei stride)__attribute__((visibility("default")));
}
extern "C"
{
  void glMultiDrawElementsIndirectAMD(::GLenum mode, ::GLenum type, const ::GLvoid *indirect, ::GLsizei primcount, ::GLsizei stride)__attribute__((visibility("default")));
}
typedef void (*PFNGLMULTIDRAWARRAYSINDIRECTAMDPROC)(::GLenum, const ::GLvoid *, ::GLsizei, ::GLsizei);
typedef void (*PFNGLMULTIDRAWELEMENTSINDIRECTAMDPROC)(::GLenum, ::GLenum, const ::GLvoid *, ::GLsizei, ::GLsizei);
extern "C"
{
  ::GLhandleARB glCreateDebugObjectMESA()__attribute__((visibility("default")));
}
extern "C"
{
  void glClearDebugLogMESA(::GLhandleARB obj, ::GLenum logType, ::GLenum shaderType)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetDebugLogMESA(::GLhandleARB obj, ::GLenum logType, ::GLenum shaderType, ::GLsizei maxLength, ::GLsizei *length, ::GLcharARB *debugLog)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLsizei glGetDebugLogLengthMESA(::GLhandleARB obj, ::GLenum logType, ::GLenum shaderType)__attribute__((visibility("default")));
}
typedef void (*GLprogramcallbackMESA)(::GLenum, ::GLvoid *);
extern "C"
{
  void glProgramCallbackMESA(::GLenum target, ::GLprogramcallbackMESA callback, ::GLvoid *data)__attribute__((visibility("default")));
}
extern "C"
{
  void glGetProgramRegisterfvMESA(::GLenum target, ::GLsizei len, const ::GLubyte *name, ::GLfloat *v)__attribute__((visibility("default")));
}
extern "C"
{
  void glBlendEquationSeparateATI(::GLenum modeRGB, ::GLenum modeA)__attribute__((visibility("default")));
}
typedef void (*PFNGLBLENDEQUATIONSEPARATEATIPROC)(::GLenum, ::GLenum);
typedef void *GLeglImageOES;
extern "C"
{
  void glEGLImageTargetTexture2DOES(::GLenum target, ::GLeglImageOES image)__attribute__((visibility("default")));
}
extern "C"
{
  void glEGLImageTargetRenderbufferStorageOES(::GLenum target, ::GLeglImageOES image)__attribute__((visibility("default")));
}
typedef void (*PFNGLEGLIMAGETARGETTEXTURE2DOESPROC)(::GLenum, ::GLeglImageOES);
typedef void (*PFNGLEGLIMAGETARGETRENDERBUFFERSTORAGEOESPROC)(::GLenum, ::GLeglImageOES);
class GLUnurbs;
class GLUquadric;
class GLUtesselator;
typedef ::GLUnurbs GLUnurbsObj;
typedef ::GLUquadric GLUquadricObj;
typedef ::GLUtesselator GLUtesselatorObj;
typedef ::GLUtesselator GLUtriangulatorObj;
typedef void (*_GLUfuncptr)();
extern "C"
{
  void gluBeginCurve(::GLUnurbs *nurb)__attribute__((visibility("default")));
}
extern "C"
{
  void gluBeginPolygon(::GLUtesselator *tess)__attribute__((visibility("default")));
}
extern "C"
{
  void gluBeginSurface(::GLUnurbs *nurb)__attribute__((visibility("default")));
}
extern "C"
{
  void gluBeginTrim(::GLUnurbs *nurb)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLint gluBuild1DMipmapLevels(::GLenum target, ::GLint internalFormat, ::GLsizei width, ::GLenum format, ::GLenum type, ::GLint level, ::GLint base, ::GLint max, const void *data)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLint gluBuild1DMipmaps(::GLenum target, ::GLint internalFormat, ::GLsizei width, ::GLenum format, ::GLenum type, const void *data)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLint gluBuild2DMipmapLevels(::GLenum target, ::GLint internalFormat, ::GLsizei width, ::GLsizei height, ::GLenum format, ::GLenum type, ::GLint level, ::GLint base, ::GLint max, const void *data)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLint gluBuild2DMipmaps(::GLenum target, ::GLint internalFormat, ::GLsizei width, ::GLsizei height, ::GLenum format, ::GLenum type, const void *data)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLint gluBuild3DMipmapLevels(::GLenum target, ::GLint internalFormat, ::GLsizei width, ::GLsizei height, ::GLsizei depth, ::GLenum format, ::GLenum type, ::GLint level, ::GLint base, ::GLint max, const void *data)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLint gluBuild3DMipmaps(::GLenum target, ::GLint internalFormat, ::GLsizei width, ::GLsizei height, ::GLsizei depth, ::GLenum format, ::GLenum type, const void *data)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLboolean gluCheckExtension(const ::GLubyte *extName, const ::GLubyte *extString)__attribute__((visibility("default")));
}
extern "C"
{
  void gluCylinder(::GLUquadric *quad, ::GLdouble base, ::GLdouble top, ::GLdouble height, ::GLint slices, ::GLint stacks)__attribute__((visibility("default")));
}
extern "C"
{
  void gluDeleteNurbsRenderer(::GLUnurbs *nurb)__attribute__((visibility("default")));
}
extern "C"
{
  void gluDeleteQuadric(::GLUquadric *quad)__attribute__((visibility("default")));
}
extern "C"
{
  void gluDeleteTess(::GLUtesselator *tess)__attribute__((visibility("default")));
}
extern "C"
{
  void gluDisk(::GLUquadric *quad, ::GLdouble inner, ::GLdouble outer, ::GLint slices, ::GLint loops)__attribute__((visibility("default")));
}
extern "C"
{
  void gluEndCurve(::GLUnurbs *nurb)__attribute__((visibility("default")));
}
extern "C"
{
  void gluEndPolygon(::GLUtesselator *tess)__attribute__((visibility("default")));
}
extern "C"
{
  void gluEndSurface(::GLUnurbs *nurb)__attribute__((visibility("default")));
}
extern "C"
{
  void gluEndTrim(::GLUnurbs *nurb)__attribute__((visibility("default")));
}
extern "C"
{
  const ::GLubyte *gluErrorString(::GLenum error)__attribute__((visibility("default")));
}
extern "C"
{
  void gluGetNurbsProperty(::GLUnurbs *nurb, ::GLenum property, ::GLfloat *data)__attribute__((visibility("default")));
}
extern "C"
{
  const ::GLubyte *gluGetString(::GLenum name)__attribute__((visibility("default")));
}
extern "C"
{
  void gluGetTessProperty(::GLUtesselator *tess, ::GLenum which, ::GLdouble *data)__attribute__((visibility("default")));
}
extern "C"
{
  void gluLoadSamplingMatrices(::GLUnurbs *nurb, const ::GLfloat *model, const ::GLfloat *perspective, const ::GLint *view)__attribute__((visibility("default")));
}
extern "C"
{
  void gluLookAt(::GLdouble eyeX, ::GLdouble eyeY, ::GLdouble eyeZ, ::GLdouble centerX, ::GLdouble centerY, ::GLdouble centerZ, ::GLdouble upX, ::GLdouble upY, ::GLdouble upZ)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLUnurbs *gluNewNurbsRenderer()__attribute__((visibility("default")));
}
extern "C"
{
  ::GLUquadric *gluNewQuadric()__attribute__((visibility("default")));
}
extern "C"
{
  ::GLUtesselator *gluNewTess()__attribute__((visibility("default")));
}
extern "C"
{
  void gluNextContour(::GLUtesselator *tess, ::GLenum type)__attribute__((visibility("default")));
}
extern "C"
{
  void gluNurbsCallback(::GLUnurbs *nurb, ::GLenum which, ::_GLUfuncptr CallBackFunc)__attribute__((visibility("default")));
}
extern "C"
{
  void gluNurbsCallbackData(::GLUnurbs *nurb, ::GLvoid *userData)__attribute__((visibility("default")));
}
extern "C"
{
  void gluNurbsCallbackDataEXT(::GLUnurbs *nurb, ::GLvoid *userData)__attribute__((visibility("default")));
}
extern "C"
{
  void gluNurbsCurve(::GLUnurbs *nurb, ::GLint knotCount, ::GLfloat *knots, ::GLint stride, ::GLfloat *control, ::GLint order, ::GLenum type)__attribute__((visibility("default")));
}
extern "C"
{
  void gluNurbsProperty(::GLUnurbs *nurb, ::GLenum property, ::GLfloat value)__attribute__((visibility("default")));
}
extern "C"
{
  void gluNurbsSurface(::GLUnurbs *nurb, ::GLint sKnotCount, ::GLfloat *sKnots, ::GLint tKnotCount, ::GLfloat *tKnots, ::GLint sStride, ::GLint tStride, ::GLfloat *control, ::GLint sOrder, ::GLint tOrder, ::GLenum type)__attribute__((visibility("default")));
}
extern "C"
{
  void gluOrtho2D(::GLdouble left, ::GLdouble right, ::GLdouble bottom, ::GLdouble top)__attribute__((visibility("default")));
}
extern "C"
{
  void gluPartialDisk(::GLUquadric *quad, ::GLdouble inner, ::GLdouble outer, ::GLint slices, ::GLint loops, ::GLdouble start, ::GLdouble sweep)__attribute__((visibility("default")));
}
extern "C"
{
  void gluPerspective(::GLdouble fovy, ::GLdouble aspect, ::GLdouble zNear, ::GLdouble zFar)__attribute__((visibility("default")));
}
extern "C"
{
  void gluPickMatrix(::GLdouble x, ::GLdouble y, ::GLdouble delX, ::GLdouble delY, ::GLint *viewport)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLint gluProject(::GLdouble objX, ::GLdouble objY, ::GLdouble objZ, const ::GLdouble *model, const ::GLdouble *proj, const ::GLint *view, ::GLdouble *winX, ::GLdouble *winY, ::GLdouble *winZ)__attribute__((visibility("default")));
}
extern "C"
{
  void gluPwlCurve(::GLUnurbs *nurb, ::GLint count, ::GLfloat *data, ::GLint stride, ::GLenum type)__attribute__((visibility("default")));
}
extern "C"
{
  void gluQuadricCallback(::GLUquadric *quad, ::GLenum which, ::_GLUfuncptr CallBackFunc)__attribute__((visibility("default")));
}
extern "C"
{
  void gluQuadricDrawStyle(::GLUquadric *quad, ::GLenum draw)__attribute__((visibility("default")));
}
extern "C"
{
  void gluQuadricNormals(::GLUquadric *quad, ::GLenum normal)__attribute__((visibility("default")));
}
extern "C"
{
  void gluQuadricOrientation(::GLUquadric *quad, ::GLenum orientation)__attribute__((visibility("default")));
}
extern "C"
{
  void gluQuadricTexture(::GLUquadric *quad, ::GLboolean texture)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLint gluScaleImage(::GLenum format, ::GLsizei wIn, ::GLsizei hIn, ::GLenum typeIn, const void *dataIn, ::GLsizei wOut, ::GLsizei hOut, ::GLenum typeOut, ::GLvoid *dataOut)__attribute__((visibility("default")));
}
extern "C"
{
  void gluSphere(::GLUquadric *quad, ::GLdouble radius, ::GLint slices, ::GLint stacks)__attribute__((visibility("default")));
}
extern "C"
{
  void gluTessBeginContour(::GLUtesselator *tess)__attribute__((visibility("default")));
}
extern "C"
{
  void gluTessBeginPolygon(::GLUtesselator *tess, ::GLvoid *data)__attribute__((visibility("default")));
}
extern "C"
{
  void gluTessCallback(::GLUtesselator *tess, ::GLenum which, ::_GLUfuncptr CallBackFunc)__attribute__((visibility("default")));
}
extern "C"
{
  void gluTessEndContour(::GLUtesselator *tess)__attribute__((visibility("default")));
}
extern "C"
{
  void gluTessEndPolygon(::GLUtesselator *tess)__attribute__((visibility("default")));
}
extern "C"
{
  void gluTessNormal(::GLUtesselator *tess, ::GLdouble valueX, ::GLdouble valueY, ::GLdouble valueZ)__attribute__((visibility("default")));
}
extern "C"
{
  void gluTessProperty(::GLUtesselator *tess, ::GLenum which, ::GLdouble data)__attribute__((visibility("default")));
}
extern "C"
{
  void gluTessVertex(::GLUtesselator *tess, ::GLdouble *location, ::GLvoid *data)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLint gluUnProject(::GLdouble winX, ::GLdouble winY, ::GLdouble winZ, const ::GLdouble *model, const ::GLdouble *proj, const ::GLint *view, ::GLdouble *objX, ::GLdouble *objY, ::GLdouble *objZ)__attribute__((visibility("default")));
}
extern "C"
{
  ::GLint gluUnProject4(::GLdouble winX, ::GLdouble winY, ::GLdouble winZ, ::GLdouble clipW, const ::GLdouble *model, const ::GLdouble *proj, const ::GLint *view, ::GLdouble nearVal, ::GLdouble farVal, ::GLdouble *objX, ::GLdouble *objY, ::GLdouble *objZ, ::GLdouble *objW)__attribute__((visibility("default")));
}
extern "C"
{
  extern void *glutStrokeRoman;
}
extern "C"
{
  extern void *glutStrokeMonoRoman;
}
extern "C"
{
  extern void *glutBitmap9By15;
}
extern "C"
{
  extern void *glutBitmap8By13;
}
extern "C"
{
  extern void *glutBitmapTimesRoman10;
}
extern "C"
{
  extern void *glutBitmapTimesRoman24;
}
extern "C"
{
  extern void *glutBitmapHelvetica10;
}
extern "C"
{
  extern void *glutBitmapHelvetica12;
}
extern "C"
{
  extern void *glutBitmapHelvetica18;
}
extern "C"
{
  void glutInit(int *pargc, char **argv);
}
extern "C"
{
  void glutInitWindowPosition(int x, int y);
}
extern "C"
{
  void glutInitWindowSize(int width, int height);
}
extern "C"
{
  void glutInitDisplayMode(unsigned int displayMode);
}
extern "C"
{
  void glutInitDisplayString(const char *displayMode);
}
extern "C"
{
  void glutMainLoop();
}
extern "C"
{
  int glutCreateWindow(const char *title);
}
extern "C"
{
  int glutCreateSubWindow(int window, int x, int y, int width, int height);
}
extern "C"
{
  void glutDestroyWindow(int window);
}
extern "C"
{
  void glutSetWindow(int window);
}
extern "C"
{
  int glutGetWindow();
}
extern "C"
{
  void glutSetWindowTitle(const char *title);
}
extern "C"
{
  void glutSetIconTitle(const char *title);
}
extern "C"
{
  void glutReshapeWindow(int width, int height);
}
extern "C"
{
  void glutPositionWindow(int x, int y);
}
extern "C"
{
  void glutShowWindow();
}
extern "C"
{
  void glutHideWindow();
}
extern "C"
{
  void glutIconifyWindow();
}
extern "C"
{
  void glutPushWindow();
}
extern "C"
{
  void glutPopWindow();
}
extern "C"
{
  void glutFullScreen();
}
extern "C"
{
  void glutPostWindowRedisplay(int window);
}
extern "C"
{
  void glutPostRedisplay();
}
extern "C"
{
  void glutSwapBuffers();
}
extern "C"
{
  void glutWarpPointer(int x, int y);
}
extern "C"
{
  void glutSetCursor(int cursor);
}
extern "C"
{
  void glutEstablishOverlay();
}
extern "C"
{
  void glutRemoveOverlay();
}
extern "C"
{
  void glutUseLayer(::GLenum layer);
}
extern "C"
{
  void glutPostOverlayRedisplay();
}
extern "C"
{
  void glutPostWindowOverlayRedisplay(int window);
}
extern "C"
{
  void glutShowOverlay();
}
extern "C"
{
  void glutHideOverlay();
}
extern "C"
{
  int glutCreateMenu(void (*callback)(int));
}
extern "C"
{
  void glutDestroyMenu(int menu);
}
extern "C"
{
  int glutGetMenu();
}
extern "C"
{
  void glutSetMenu(int menu);
}
extern "C"
{
  void glutAddMenuEntry(const char *label, int value);
}
extern "C"
{
  void glutAddSubMenu(const char *label, int subMenu);
}
extern "C"
{
  void glutChangeToMenuEntry(int item, const char *label, int value);
}
extern "C"
{
  void glutChangeToSubMenu(int item, const char *label, int value);
}
extern "C"
{
  void glutRemoveMenuItem(int item);
}
extern "C"
{
  void glutAttachMenu(int button);
}
extern "C"
{
  void glutDetachMenu(int button);
}
extern "C"
{
  void glutTimerFunc(unsigned int time, void (*callback)(int), int value);
}
extern "C"
{
  void glutIdleFunc(void (*callback)());
}
extern "C"
{
  void glutKeyboardFunc(void (*callback)(unsigned char, int, int));
}
extern "C"
{
  void glutSpecialFunc(void (*callback)(int, int, int));
}
extern "C"
{
  void glutReshapeFunc(void (*callback)(int, int));
}
extern "C"
{
  void glutVisibilityFunc(void (*callback)(int));
}
extern "C"
{
  void glutDisplayFunc(void (*callback)());
}
extern "C"
{
  void glutMouseFunc(void (*callback)(int, int, int, int));
}
extern "C"
{
  void glutMotionFunc(void (*callback)(int, int));
}
extern "C"
{
  void glutPassiveMotionFunc(void (*callback)(int, int));
}
extern "C"
{
  void glutEntryFunc(void (*callback)(int));
}
extern "C"
{
  void glutKeyboardUpFunc(void (*callback)(unsigned char, int, int));
}
extern "C"
{
  void glutSpecialUpFunc(void (*callback)(int, int, int));
}
extern "C"
{
  void glutJoystickFunc(void (*callback)(unsigned int, int, int, int), int pollInterval);
}
extern "C"
{
  void glutMenuStateFunc(void (*callback)(int));
}
extern "C"
{
  void glutMenuStatusFunc(void (*callback)(int, int, int));
}
extern "C"
{
  void glutOverlayDisplayFunc(void (*callback)());
}
extern "C"
{
  void glutWindowStatusFunc(void (*callback)(int));
}
extern "C"
{
  void glutSpaceballMotionFunc(void (*callback)(int, int, int));
}
extern "C"
{
  void glutSpaceballRotateFunc(void (*callback)(int, int, int));
}
extern "C"
{
  void glutSpaceballButtonFunc(void (*callback)(int, int));
}
extern "C"
{
  void glutButtonBoxFunc(void (*callback)(int, int));
}
extern "C"
{
  void glutDialsFunc(void (*callback)(int, int));
}
extern "C"
{
  void glutTabletMotionFunc(void (*callback)(int, int));
}
extern "C"
{
  void glutTabletButtonFunc(void (*callback)(int, int, int, int));
}
extern "C"
{
  int glutGet(::GLenum query);
}
extern "C"
{
  int glutDeviceGet(::GLenum query);
}
extern "C"
{
  int glutGetModifiers();
}
extern "C"
{
  int glutLayerGet(::GLenum query);
}
extern "C"
{
  void glutBitmapCharacter(void *font, int character);
}
extern "C"
{
  int glutBitmapWidth(void *font, int character);
}
extern "C"
{
  void glutStrokeCharacter(void *font, int character);
}
extern "C"
{
  int glutStrokeWidth(void *font, int character);
}
extern "C"
{
  int glutBitmapLength(void *font, const unsigned char *string);
}
extern "C"
{
  int glutStrokeLength(void *font, const unsigned char *string);
}
extern "C"
{
  void glutWireCube(::GLdouble size);
}
extern "C"
{
  void glutSolidCube(::GLdouble size);
}
extern "C"
{
  void glutWireSphere(::GLdouble radius, ::GLint slices, ::GLint stacks);
}
extern "C"
{
  void glutSolidSphere(::GLdouble radius, ::GLint slices, ::GLint stacks);
}
extern "C"
{
  void glutWireCone(::GLdouble base, ::GLdouble height, ::GLint slices, ::GLint stacks);
}
extern "C"
{
  void glutSolidCone(::GLdouble base, ::GLdouble height, ::GLint slices, ::GLint stacks);
}
extern "C"
{
  void glutWireTorus(::GLdouble innerRadius, ::GLdouble outerRadius, ::GLint sides, ::GLint rings);
}
extern "C"
{
  void glutSolidTorus(::GLdouble innerRadius, ::GLdouble outerRadius, ::GLint sides, ::GLint rings);
}
extern "C"
{
  void glutWireDodecahedron();
}
extern "C"
{
  void glutSolidDodecahedron();
}
extern "C"
{
  void glutWireOctahedron();
}
extern "C"
{
  void glutSolidOctahedron();
}
extern "C"
{
  void glutWireTetrahedron();
}
extern "C"
{
  void glutSolidTetrahedron();
}
extern "C"
{
  void glutWireIcosahedron();
}
extern "C"
{
  void glutSolidIcosahedron();
}
extern "C"
{
  void glutWireTeapot(::GLdouble size);
}
extern "C"
{
  void glutSolidTeapot(::GLdouble size);
}
extern "C"
{
  void glutGameModeString(const char *string);
}
extern "C"
{
  int glutEnterGameMode();
}
extern "C"
{
  void glutLeaveGameMode();
}
extern "C"
{
  int glutGameModeGet(::GLenum query);
}
extern "C"
{
  int glutVideoResizeGet(::GLenum query);
}
extern "C"
{
  void glutSetupVideoResizing();
}
extern "C"
{
  void glutStopVideoResizing();
}
extern "C"
{
  void glutVideoResize(int x, int y, int width, int height);
}
extern "C"
{
  void glutVideoPan(int x, int y, int width, int height);
}
extern "C"
{
  void glutSetColor(int color, ::GLfloat red, ::GLfloat green, ::GLfloat blue);
}
extern "C"
{
  ::GLfloat glutGetColor(int color, int component);
}
extern "C"
{
  void glutCopyColormap(int window);
}
extern "C"
{
  void glutIgnoreKeyRepeat(int ignore);
}
extern "C"
{
  void glutSetKeyRepeat(int repeatMode);
}
extern "C"
{
  void glutForceJoystickFunc();
}
extern "C"
{
  int glutExtensionSupported(const char *extension);
}
extern "C"
{
  void glutReportErrors();
}
using namespace ::std;
namespace LRT {
  typedef ::RTTL::RTVec2i vec2i;
  typedef ::RTTL::RTVec2f vec2f;
  struct  RGBAucharFrameBuffer
  {
      struct Options;
      struct  Options
      {
          static bool usePBOs;
          static bool useMemoryFB;
          static ::LRT::vec2i defaultRes;
      };
      ::LRT::vec2i res;
      unsigned char *fb;
      inline RGBAucharFrameBuffer()
        : res(0, 0), fb(0L)
      {
      }
      inline void writeBlock(const int x0, const int y0, const int dx, const int dy, const ::sse_i *four4x8PixelsEach) const __attribute__((always_inline));
      inline void prefetchBlock(const int x0, const int y0, const int dx, const int dy) const __attribute__((always_inline));
      static ::LRT::RGBAucharFrameBuffer *create();
      virtual inline void resize(int newX, int newY)
      {
        newX = ::std::max /* <int> */ (32, ::nextMultipleOf<4 /* , int  */ >(newX));
        newY = ::std::max /* <int> */ (32, ::nextMultipleOf<4 /* , int  */ >(newY));
        ::LRT::vec2i newRes((newX), (newY));
        if ((*this).res != newRes)
          {
            (*this).res = newRes;
          }
      }
      virtual void startNewFrame() = 0 ;
      virtual void doneWithFrame() = 0 ;
      virtual void display() = 0 ;
  };
  typedef ::LRT::RGBAucharFrameBuffer FrameBuffer;
  inline __attribute__((always_inline)) void RGBAucharFrameBuffer::writeBlock(const int x0, const int y0, const int dx, const int dy, const ::sse_i *four4x8PixelsEach) const 
  {
    unsigned int *const fb_as_int32((unsigned int *)(*this).fb);
    if (__builtin_expect(dx == 8 && dy == 8, 1))
      {
        unsigned int *start((unsigned int *)&fb_as_int32[y0 * (*this).res.x + x0]);
#pragma unroll(8)
        for (int y = 0; y < 8; (y++, start += (*this).res.x))
          {
            ::_mm_stream_ps((float *)&start[0], ::cast(four4x8PixelsEach[y * 2 + 0]));
            ::_mm_stream_ps((float *)&start[4], ::cast(four4x8PixelsEach[y * 2 + 1]));
          }
        return ;
      }
    else
      {
        ::std::cout << dx << " " << dy << ::std::endl<char, ::std::char_traits<char> >;
      }
  }
  inline __attribute__((always_inline)) void RGBAucharFrameBuffer::prefetchBlock(const int x0, const int y0, const int dx, const int dy) const 
  {
    unsigned int *const fb_as_int32((unsigned int *)(*this).fb);
    if (__builtin_expect(dx == 8 && dy == 8, 1))
      {
        unsigned int *start((unsigned int *)&fb_as_int32[y0 * (*this).res.x + x0]);
#pragma unroll(8)
        return ;
      }
  }
  struct  OpenGLTextureRGBA8FB : ::LRT::RGBAucharFrameBuffer
  {
      static const int FRAME_BUFFER_MODE = 32993;
      ::GLuint fbTextureID;
      ::LRT::vec2i fbTextureRes;
      ::LRT::vec2f fbTexCoords;
      inline OpenGLTextureRGBA8FB()
      {
        ::glGenTextures(1, &(*this).fbTextureID);
        ::glBindTexture(3553, (*this).fbTextureID);
        (*this).fbTextureRes = ::RTTL::RTVec_t<2, int, 0>(0, 0);
      }
      virtual void resize(int newX, int newY);
      virtual inline void startNewFrame()
      {
      }
      virtual void doneWithFrame() = 0 ;
      virtual void display();
  };
  struct  BufferedOpenGLTextureRGBA8FB : ::LRT::OpenGLTextureRGBA8FB
  {
      int allocedSize;
      inline BufferedOpenGLTextureRGBA8FB()
        : ::LRT::OpenGLTextureRGBA8FB(), allocedSize(0)
      {
      }
      virtual void resize(int newX, int newY);
      virtual void doneWithFrame();
  };
  struct  PBOFrameBuffer : ::LRT::OpenGLTextureRGBA8FB
  {
      static ::LRT::PBOFrameBuffer *create();
      ::GLuint fbPBO;
      PBOFrameBuffer();
      virtual void resize(int newX, int newY);
      virtual void startNewFrame();
      virtual void doneWithFrame();
  };
}
using namespace ::RTTL;
class  Camera
{
  public:
    float angle;
    ::RTTL::Matrix4x4 matrix;
    inline Camera()
    {
    }
    inline __attribute__((always_inline)) void initMatrix(const ::RTTL::RTVec3f &origin, const ::RTTL::RTVec3f &direction, const ::RTTL::RTVec3f &up, const float viewAngle)
    {
      ::RTTL::RTVec3f ex((direction ^ up));
      ex.::RTTL::RTVec_t<3, float, 0>::normalize();
      ::RTTL::RTVec3f ez((ex ^ direction));
      ez.::RTTL::RTVec_t<3, float, 0>::normalize();
      ::RTTL::RTVec3f ey((direction));
      ey.::RTTL::RTVec_t<3, float, 0>::normalize();
      (*this).matrix.::RTTL::Matrix4x4::setCol(0, ey);
      (*this).matrix.::RTTL::Matrix4x4::setCol(1, ex);
      (*this).matrix.::RTTL::Matrix4x4::setCol(2, ez);
      (*this).matrix.::RTTL::Matrix4x4::setCol(3, origin);
      (*this).angle = viewAngle;
    }
    inline __attribute__((always_inline)) void rotateGlobal(::RTTL::RTVec3f dir, float angle)
    {
      ::RTTL::Matrix4x4 rot;
      rot.::RTTL::Matrix4x4::setIdentity();
      rot.::RTTL::Matrix4x4::setRotationPart(dir, angle);
      ::RTTL::Matrix4x4 m1(((*this).matrix));
      ::RTTL::RTVec3f pos(((*this).matrix.::RTTL::Matrix4x4::getCol(3)));
      (*this).matrix = rot * m1;
      (*this).matrix.::RTTL::Matrix4x4::setCol(3, pos);
    }
    inline __attribute__((always_inline)) void rotateLocal(::RTTL::RTVec3f dir, float angle)
    {
      ::RTTL::Matrix4x4 rot;
      rot.::RTTL::Matrix4x4::setIdentity();
      rot.::RTTL::Matrix4x4::setRotationPart(dir, angle);
      ::RTTL::Matrix4x4 m1(((*this).matrix));
      (*this).matrix = m1 * rot;
    }
    inline __attribute__((always_inline)) void moveLocal(::RTTL::RTVec3f dir)
    {
      ::RTTL::Matrix4x4 move;
      move.::RTTL::Matrix4x4::setIdentity();
      move.::RTTL::Matrix4x4::setTranslationPart(dir);
      ::RTTL::Matrix4x4 m1(((*this).matrix));
      (*this).matrix = m1 * move;
    }
    inline __attribute__((always_inline)) ::RTTL::RTVec3f getOrigin()
    {
      return (*this).matrix.::RTTL::Matrix4x4::getCol(3);
    }
    inline __attribute__((always_inline)) ::RTTL::RTVec3f getDirection()
    {
      return (*this).matrix.::RTTL::Matrix4x4::getCol(0);
    }
    inline __attribute__((always_inline)) ::RTTL::RTVec3f getUp()
    {
      return (*this).matrix.::RTTL::Matrix4x4::getCol(2);
    }
    inline __attribute__((always_inline)) void setOrigin(::RTTL::RTVec3f v)
    {
      return (*this).matrix.::RTTL::Matrix4x4::setCol(3, v);
    }
    inline __attribute__((always_inline)) void setDirection(::RTTL::RTVec3f v)
    {
      return (*this).matrix.::RTTL::Matrix4x4::setCol(0, v);
    }
    inline __attribute__((always_inline)) void setUp(::RTTL::RTVec3f v)
    {
      return (*this).matrix.::RTTL::Matrix4x4::setCol(2, v);
    }
    inline __attribute__((always_inline)) float getAngle()
    {
      return (*this).angle;
    }
};
namespace RTTL {
  class  RTMaterial
  {
    public:
      ::RTTL::RTVec3f m_diffuse;
      float m_transparency;
      ::RTTL::RTVec3f m_specular;
      float m_shininess;
      ::RTTL::RTVec3f m_ambient;
      int m_textureId;
      inline RTMaterial()
      {
        (*this).m_diffuse = ::RTTL::RTVec_t<3, float, 0>(5.000000000000000000000000e-01f, 5.000000000000000000000000e-01f, 5.000000000000000000000000e-01f);
        (*this).m_transparency = 0.000000000000000000000000e+00f;
        (*this).m_specular = ::RTTL::RTVec_t<3, float, 0>(0.000000000000000000000000e+00f, 0.000000000000000000000000e+00f, 0.000000000000000000000000e+00f);
        (*this).m_shininess = 0.000000000000000000000000e+00f;
        (*this).m_ambient = ::RTTL::RTVec_t<3, float, 0>(0.000000000000000000000000e+00f, 0.000000000000000000000000e+00f, 0.000000000000000000000000e+00f);
        (*this).m_textureId =  -1;
      }
      inline __attribute__((always_inline)) ::sse_f &ambient() const 
      {
        return *((::sse_f *)&(*this).m_ambient);
      }
      inline __attribute__((always_inline)) ::sse_f &diffuse() const 
      {
        return *((::sse_f *)&(*this).m_diffuse);
      }
      inline __attribute__((always_inline)) ::sse_f &specular() const 
      {
        return *((::sse_f *)&(*this).m_specular);
      }
      static inline __attribute__((always_inline)) void getDiffuse(const ::sse_i id4, const ::RTTL::RTMaterial *const mat, ::RTTL::RTVec_t<3, ::sse_f, 0> &dest)
      {
        const ::RTTL::RTMaterial &mat0(mat[((int *)&id4)[0]]);
        const ::RTTL::RTMaterial &mat1(mat[((int *)&id4)[1]]);
        const ::RTTL::RTMaterial &mat2(mat[((int *)&id4)[2]]);
        const ::RTTL::RTMaterial &mat3(mat[((int *)&id4)[3]]);
        dest.::RTTL::RTVec_t<3, ::sse_f, 0>::operator [](0) = ::_mm_setr_ps(mat0.m_diffuse.::RTTL::RTVec_t<3, float, 0>::operator [](0), mat1.m_diffuse.::RTTL::RTVec_t<3, float, 0>::operator [](0), mat2.m_diffuse.::RTTL::RTVec_t<3, float, 0>::operator [](0), mat3.m_diffuse.::RTTL::RTVec_t<3, float, 0>::operator [](0));
        dest.::RTTL::RTVec_t<3, ::sse_f, 0>::operator [](1) = ::_mm_setr_ps(mat0.m_diffuse.::RTTL::RTVec_t<3, float, 0>::operator [](1), mat1.m_diffuse.::RTTL::RTVec_t<3, float, 0>::operator [](1), mat2.m_diffuse.::RTTL::RTVec_t<3, float, 0>::operator [](1), mat3.m_diffuse.::RTTL::RTVec_t<3, float, 0>::operator [](1));
        dest.::RTTL::RTVec_t<3, ::sse_f, 0>::operator [](2) = ::_mm_setr_ps(mat0.m_diffuse.::RTTL::RTVec_t<3, float, 0>::operator [](2), mat1.m_diffuse.::RTTL::RTVec_t<3, float, 0>::operator [](2), mat2.m_diffuse.::RTTL::RTVec_t<3, float, 0>::operator [](2), mat3.m_diffuse.::RTTL::RTVec_t<3, float, 0>::operator [](2));
      }
  };
}
class  ImagePPM
{
  public:
    inline ImagePPM(const char *fileName)
    {
      const char __MERCURIUM_PRETTY_FUNCTION__[35] = "::ImagePPM::ImagePPM(const char *)";
      ::FILE *input(::fopen(fileName, "r"));
      if (!input)
        {
          ::std::cerr << "FATAL: " << "Error couldn\'t open " << fileName << "(in " << __MERCURIUM_PRETTY_FUNCTION__ << ")" << ::std::endl<char, ::std::char_traits<char> >;
          ::exit(1);
        }
      ;
      char buf[128];
      char line_buf[1024];
      ::fscanf(input, "%s", buf);
      int c(::fgetc(input));
      while (c == '#' || ::isspace(c))
        {
          if (c == '#')
            {
              ::fgets(line_buf, sizeof(char (&)[1024]), input);
            }
          c = ::fgetc(input);
        }
      ::ungetc(c, input);
      ::fscanf(input, "%u %u %u", &(*this).m_width, &(*this).m_height, &(*this).m_maxColor);
      ::fgetc(input);
      ::printf("Loading texture %s : %dx%d\n", fileName, (*this).m_width, (*this).m_height);
      if ((*this).m_width == 0 || (*this).m_height == 0)
        {
          ::std::cerr << "FATAL: " << "Texture had zero width or height" << "(in " << __MERCURIUM_PRETTY_FUNCTION__ << ")" << ::std::endl<char, ::std::char_traits<char> >;
          ::exit(1);
        }
      ;
      (*this).m_data = ::aligned_malloc<unsigned char>((*this).m_width * (*this).m_height * 3);
      if (!::strcmp(buf, "P3"))
        {
          int r;
          int g;
          int b;
          for (int y = (*this).m_height - 1; y >= 0; y--)
            {
              for (int x = 0; x < (*this).m_width; x++)
                {
                  ::fscanf(input, "%i %i %i", &r, &g, &b);
                  int index(y * (*this).m_width + x);
                  (*this).m_data[3 * index + 0] = r;
                  (*this).m_data[3 * index + 1] = g;
                  (*this).m_data[3 * index + 2] = b;
                }
            }
        }
      else
        {
          unsigned char r;
          unsigned char g;
          unsigned char b;
          for (int y = (*this).m_height - 1; y >= 0; y--)
            {
              for (int x = 0; x < (*this).m_width; x++)
                {
                  r = ::fgetc(input);
                  g = ::fgetc(input);
                  b = ::fgetc(input);
                  int index(y * (*this).m_width + x);
                  (*this).m_data[3 * index + 0] = r;
                  (*this).m_data[3 * index + 1] = g;
                  (*this).m_data[3 * index + 2] = b;
                }
            }
        }
      ::fclose(input);
    }
    inline ~ImagePPM()
    {
      if ((*this).m_data)
        {
          ::aligned_free /* <unsigned char> */ ((*this).m_data);
        }
    }
    inline int width()
    {
      return (*this).m_width;
    }
    inline int height()
    {
      return (*this).m_height;
    }
    inline unsigned char *data()
    {
      return (*this).m_data;
    }
  private:
    int m_width;
    int m_height;
    int m_maxColor;
    unsigned char *m_data;
  public:
};
namespace std __attribute__((__visibility__("default"))) {
  template < typename _Key, typename _Compare = ::std::less<_Key>, typename _Alloc = ::std::allocator<_Key> >
  class  set
  {
      typedef typename _Alloc::value_type _Alloc_value_type;
    public:
      typedef _Key key_type;
      typedef _Key value_type;
      typedef _Compare key_compare;
      typedef _Compare value_compare;
      typedef _Alloc allocator_type;
    private:
      typedef typename _Alloc::template rebind< _Key>::other _Key_alloc_type;
      typedef ::std::_Rb_tree<typename ::std::set<_Key, _Compare, _Alloc>::key_type, typename ::std::set<_Key, _Compare, _Alloc>::value_type, ::std::_Identity<typename ::std::set<_Key, _Compare, _Alloc>::value_type>, typename ::std::set<_Key, _Compare, _Alloc>::key_compare, typename ::std::set<_Key, _Compare, _Alloc>::_Key_alloc_type> _Rep_type;
      typename ::std::set<_Key, _Compare, _Alloc>::_Rep_type _M_t;
    public:
      typedef typename ::std::set<_Key, _Compare, _Alloc>::_Key_alloc_type::pointer pointer;
      typedef typename ::std::set<_Key, _Compare, _Alloc>::_Key_alloc_type::const_pointer const_pointer;
      typedef typename ::std::set<_Key, _Compare, _Alloc>::_Key_alloc_type::reference reference;
      typedef typename ::std::set<_Key, _Compare, _Alloc>::_Key_alloc_type::const_reference const_reference;
      typedef typename ::std::_Rb_tree<typename ::std::set<_Key, _Compare, _Alloc>::key_type, typename ::std::set<_Key, _Compare, _Alloc>::value_type, ::std::_Identity<typename ::std::set<_Key, _Compare, _Alloc>::value_type>, typename ::std::set<_Key, _Compare, _Alloc>::key_compare, typename ::std::set<_Key, _Compare, _Alloc>::_Key_alloc_type>::const_iterator iterator;
      typedef typename ::std::_Rb_tree<typename ::std::set<_Key, _Compare, _Alloc>::key_type, typename ::std::set<_Key, _Compare, _Alloc>::value_type, ::std::_Identity<typename ::std::set<_Key, _Compare, _Alloc>::value_type>, typename ::std::set<_Key, _Compare, _Alloc>::key_compare, typename ::std::set<_Key, _Compare, _Alloc>::_Key_alloc_type>::const_iterator const_iterator;
      typedef typename ::std::_Rb_tree<typename ::std::set<_Key, _Compare, _Alloc>::key_type, typename ::std::set<_Key, _Compare, _Alloc>::value_type, ::std::_Identity<typename ::std::set<_Key, _Compare, _Alloc>::value_type>, typename ::std::set<_Key, _Compare, _Alloc>::key_compare, typename ::std::set<_Key, _Compare, _Alloc>::_Key_alloc_type>::const_reverse_iterator reverse_iterator;
      typedef typename ::std::_Rb_tree<typename ::std::set<_Key, _Compare, _Alloc>::key_type, typename ::std::set<_Key, _Compare, _Alloc>::value_type, ::std::_Identity<typename ::std::set<_Key, _Compare, _Alloc>::value_type>, typename ::std::set<_Key, _Compare, _Alloc>::key_compare, typename ::std::set<_Key, _Compare, _Alloc>::_Key_alloc_type>::const_reverse_iterator const_reverse_iterator;
      typedef typename ::std::_Rb_tree<typename ::std::set<_Key, _Compare, _Alloc>::key_type, typename ::std::set<_Key, _Compare, _Alloc>::value_type, ::std::_Identity<typename ::std::set<_Key, _Compare, _Alloc>::value_type>, typename ::std::set<_Key, _Compare, _Alloc>::key_compare, typename ::std::set<_Key, _Compare, _Alloc>::_Key_alloc_type>::size_type size_type;
      typedef typename ::std::_Rb_tree<typename ::std::set<_Key, _Compare, _Alloc>::key_type, typename ::std::set<_Key, _Compare, _Alloc>::value_type, ::std::_Identity<typename ::std::set<_Key, _Compare, _Alloc>::value_type>, typename ::std::set<_Key, _Compare, _Alloc>::key_compare, typename ::std::set<_Key, _Compare, _Alloc>::_Key_alloc_type>::difference_type difference_type;
      inline set()
        : _M_t()
      {
      }
      inline explicit set(const _Compare &__comp, const typename ::std::set<_Key, _Compare, _Alloc>::allocator_type &__a  = typename ::std::set<_Key, _Compare, _Alloc>::allocator_type())
        : _M_t(__comp, typename ::std::set<_Key, _Compare, _Alloc>::_Key_alloc_type(__a))
      {
      }
      template < typename _InputIterator >
      inline set(_InputIterator __first, _InputIterator __last)
        : _M_t()
      {
        _M_t._M_insert_unique(__first, __last);
      }
      template < typename _InputIterator >
      inline set(_InputIterator __first, _InputIterator __last, const _Compare &__comp, const typename ::std::set<_Key, _Compare, _Alloc>::allocator_type &__a  = typename ::std::set<_Key, _Compare, _Alloc>::allocator_type())
        : _M_t(__comp, typename ::std::set<_Key, _Compare, _Alloc>::_Key_alloc_type(__a))
      {
        _M_t._M_insert_unique(__first, __last);
      }
      inline set(const ::std::set<_Key, _Compare, _Alloc> &__x)
        : _M_t(__x._M_t)
      {
      }
      inline ::std::set<_Key, _Compare, _Alloc> &operator =(const ::std::set<_Key, _Compare, _Alloc> &__x)
      {
        _M_t = __x._M_t;
        return *this;
      }
      inline typename ::std::set<_Key, _Compare, _Alloc>::key_compare key_comp() const 
      {
        return _M_t.key_comp();
      }
      inline typename ::std::set<_Key, _Compare, _Alloc>::value_compare value_comp() const 
      {
        return _M_t.key_comp();
      }
      inline typename ::std::set<_Key, _Compare, _Alloc>::allocator_type get_allocator() const 
      {
        return typename ::std::set<_Key, _Compare, _Alloc>::allocator_type(_M_t.get_allocator());
      }
      inline typename ::std::set<_Key, _Compare, _Alloc>::iterator begin() const 
      {
        return _M_t.begin();
      }
      inline typename ::std::set<_Key, _Compare, _Alloc>::iterator end() const 
      {
        return _M_t.end();
      }
      inline typename ::std::set<_Key, _Compare, _Alloc>::reverse_iterator rbegin() const 
      {
        return _M_t.rbegin();
      }
      inline typename ::std::set<_Key, _Compare, _Alloc>::reverse_iterator rend() const 
      {
        return _M_t.rend();
      }
      inline bool empty() const 
      {
        return _M_t.empty();
      }
      inline typename ::std::set<_Key, _Compare, _Alloc>::size_type size() const 
      {
        return _M_t.size();
      }
      inline typename ::std::set<_Key, _Compare, _Alloc>::size_type max_size() const 
      {
        return _M_t.max_size();
      }
      inline void swap(::std::set<_Key, _Compare, _Alloc> &__x)
      {
        _M_t.swap(__x._M_t);
      }
      inline ::std::pair<typename ::std::set<_Key, _Compare, _Alloc>::iterator, bool> insert(const typename ::std::set<_Key, _Compare, _Alloc>::value_type &__x)
      {
        ::std::pair<typename ::std::_Rb_tree<typename ::std::set<_Key, _Compare, _Alloc>::key_type, typename ::std::set<_Key, _Compare, _Alloc>::value_type, ::std::_Identity<typename ::std::set<_Key, _Compare, _Alloc>::value_type>, typename ::std::set<_Key, _Compare, _Alloc>::key_compare, typename ::std::set<_Key, _Compare, _Alloc>::_Key_alloc_type>::iterator, bool> __p = _M_t._M_insert_unique(__x);
        return ::std::pair<typename ::std::set<_Key, _Compare, _Alloc>::iterator, bool>(__p.first, __p.second);
      }
      inline typename ::std::set<_Key, _Compare, _Alloc>::iterator insert(typename ::std::set<_Key, _Compare, _Alloc>::const_iterator __position, const typename ::std::set<_Key, _Compare, _Alloc>::value_type &__x)
      {
        return _M_t._M_insert_unique_(__position, __x);
      }
      template < typename _InputIterator >
      inline void insert(_InputIterator __first, _InputIterator __last)
      {
        _M_t._M_insert_unique(__first, __last);
      }
      inline void erase(typename ::std::set<_Key, _Compare, _Alloc>::iterator __position)
      {
        _M_t.erase(__position);
      }
      inline typename ::std::set<_Key, _Compare, _Alloc>::size_type erase(const typename ::std::set<_Key, _Compare, _Alloc>::key_type &__x)
      {
        return _M_t.erase(__x);
      }
      inline void erase(typename ::std::set<_Key, _Compare, _Alloc>::iterator __first, typename ::std::set<_Key, _Compare, _Alloc>::iterator __last)
      {
        _M_t.erase(__first, __last);
      }
      inline void clear()
      {
        _M_t.clear();
      }
      inline typename ::std::set<_Key, _Compare, _Alloc>::size_type count(const typename ::std::set<_Key, _Compare, _Alloc>::key_type &__x) const 
      {
        return _M_t.find(__x) == _M_t.end() ? 0 : 1;
      }
      inline typename ::std::set<_Key, _Compare, _Alloc>::iterator find(const typename ::std::set<_Key, _Compare, _Alloc>::key_type &__x)
      {
        return _M_t.find(__x);
      }
      inline typename ::std::set<_Key, _Compare, _Alloc>::const_iterator find(const typename ::std::set<_Key, _Compare, _Alloc>::key_type &__x) const 
      {
        return _M_t.find(__x);
      }
      inline typename ::std::set<_Key, _Compare, _Alloc>::iterator lower_bound(const typename ::std::set<_Key, _Compare, _Alloc>::key_type &__x)
      {
        return _M_t.lower_bound(__x);
      }
      inline typename ::std::set<_Key, _Compare, _Alloc>::const_iterator lower_bound(const typename ::std::set<_Key, _Compare, _Alloc>::key_type &__x) const 
      {
        return _M_t.lower_bound(__x);
      }
      inline typename ::std::set<_Key, _Compare, _Alloc>::iterator upper_bound(const typename ::std::set<_Key, _Compare, _Alloc>::key_type &__x)
      {
        return _M_t.upper_bound(__x);
      }
      inline typename ::std::set<_Key, _Compare, _Alloc>::const_iterator upper_bound(const typename ::std::set<_Key, _Compare, _Alloc>::key_type &__x) const 
      {
        return _M_t.upper_bound(__x);
      }
      inline ::std::pair<typename ::std::set<_Key, _Compare, _Alloc>::iterator, typename ::std::set<_Key, _Compare, _Alloc>::iterator> equal_range(const typename ::std::set<_Key, _Compare, _Alloc>::key_type &__x)
      {
        return _M_t.equal_range(__x);
      }
      inline ::std::pair<typename ::std::set<_Key, _Compare, _Alloc>::const_iterator, typename ::std::set<_Key, _Compare, _Alloc>::const_iterator> equal_range(const typename ::std::set<_Key, _Compare, _Alloc>::key_type &__x) const 
      {
        return _M_t.equal_range(__x);
      }
    template < typename _K1, typename _C1, typename _A1 >
    friend bool operator ==(const ::std::set<_K1, _C1, _A1> &, const ::std::set<_K1, _C1, _A1> &);
    template < typename _K1, typename _C1, typename _A1 >
    friend bool operator <(const ::std::set<_K1, _C1, _A1> &, const ::std::set<_K1, _C1, _A1> &);
  };
  template < typename _Key, typename _Compare, typename _Alloc >
  inline bool operator ==(const ::std::set<_Key, _Compare, _Alloc> &__x, const ::std::set<_Key, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Compare, typename _Alloc >
  inline bool operator ==(const ::std::set<_Key, _Compare, _Alloc> &__x, const ::std::set<_Key, _Compare, _Alloc> &__y)
  {
    return __x._M_t == __y._M_t;
  }
  template < typename _Key, typename _Compare, typename _Alloc >
  inline bool operator <(const ::std::set<_Key, _Compare, _Alloc> &__x, const ::std::set<_Key, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Compare, typename _Alloc >
  inline bool operator <(const ::std::set<_Key, _Compare, _Alloc> &__x, const ::std::set<_Key, _Compare, _Alloc> &__y)
  {
    return __x._M_t < __y._M_t;
  }
  template < typename _Key, typename _Compare, typename _Alloc >
  inline bool operator !=(const ::std::set<_Key, _Compare, _Alloc> &__x, const ::std::set<_Key, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Compare, typename _Alloc >
  inline bool operator !=(const ::std::set<_Key, _Compare, _Alloc> &__x, const ::std::set<_Key, _Compare, _Alloc> &__y)
  {
    return !(__x == __y);
  }
  template < typename _Key, typename _Compare, typename _Alloc >
  inline bool operator >(const ::std::set<_Key, _Compare, _Alloc> &__x, const ::std::set<_Key, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Compare, typename _Alloc >
  inline bool operator >(const ::std::set<_Key, _Compare, _Alloc> &__x, const ::std::set<_Key, _Compare, _Alloc> &__y)
  {
    return __y < __x;
  }
  template < typename _Key, typename _Compare, typename _Alloc >
  inline bool operator <=(const ::std::set<_Key, _Compare, _Alloc> &__x, const ::std::set<_Key, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Compare, typename _Alloc >
  inline bool operator <=(const ::std::set<_Key, _Compare, _Alloc> &__x, const ::std::set<_Key, _Compare, _Alloc> &__y)
  {
    return !(__y < __x);
  }
  template < typename _Key, typename _Compare, typename _Alloc >
  inline bool operator >=(const ::std::set<_Key, _Compare, _Alloc> &__x, const ::std::set<_Key, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Compare, typename _Alloc >
  inline bool operator >=(const ::std::set<_Key, _Compare, _Alloc> &__x, const ::std::set<_Key, _Compare, _Alloc> &__y)
  {
    return !(__x < __y);
  }
  template < typename _Key, typename _Compare, typename _Alloc >
  inline void swap(::std::set<_Key, _Compare, _Alloc> &__x, ::std::set<_Key, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Compare, typename _Alloc >
  inline void swap(::std::set<_Key, _Compare, _Alloc> &__x, ::std::set<_Key, _Compare, _Alloc> &__y)
  {
    __x.swap(__y);
  }
  template < typename _Key, typename _Compare = ::std::less<_Key>, typename _Alloc = ::std::allocator<_Key> >
  class  multiset
  {
      typedef typename _Alloc::value_type _Alloc_value_type;
    public:
      typedef _Key key_type;
      typedef _Key value_type;
      typedef _Compare key_compare;
      typedef _Compare value_compare;
      typedef _Alloc allocator_type;
    private:
      typedef typename _Alloc::template rebind< _Key>::other _Key_alloc_type;
      typedef ::std::_Rb_tree<typename ::std::multiset<_Key, _Compare, _Alloc>::key_type, typename ::std::multiset<_Key, _Compare, _Alloc>::value_type, ::std::_Identity<typename ::std::multiset<_Key, _Compare, _Alloc>::value_type>, typename ::std::multiset<_Key, _Compare, _Alloc>::key_compare, typename ::std::multiset<_Key, _Compare, _Alloc>::_Key_alloc_type> _Rep_type;
      typename ::std::multiset<_Key, _Compare, _Alloc>::_Rep_type _M_t;
    public:
      typedef typename ::std::multiset<_Key, _Compare, _Alloc>::_Key_alloc_type::pointer pointer;
      typedef typename ::std::multiset<_Key, _Compare, _Alloc>::_Key_alloc_type::const_pointer const_pointer;
      typedef typename ::std::multiset<_Key, _Compare, _Alloc>::_Key_alloc_type::reference reference;
      typedef typename ::std::multiset<_Key, _Compare, _Alloc>::_Key_alloc_type::const_reference const_reference;
      typedef typename ::std::_Rb_tree<typename ::std::multiset<_Key, _Compare, _Alloc>::key_type, typename ::std::multiset<_Key, _Compare, _Alloc>::value_type, ::std::_Identity<typename ::std::multiset<_Key, _Compare, _Alloc>::value_type>, typename ::std::multiset<_Key, _Compare, _Alloc>::key_compare, typename ::std::multiset<_Key, _Compare, _Alloc>::_Key_alloc_type>::const_iterator iterator;
      typedef typename ::std::_Rb_tree<typename ::std::multiset<_Key, _Compare, _Alloc>::key_type, typename ::std::multiset<_Key, _Compare, _Alloc>::value_type, ::std::_Identity<typename ::std::multiset<_Key, _Compare, _Alloc>::value_type>, typename ::std::multiset<_Key, _Compare, _Alloc>::key_compare, typename ::std::multiset<_Key, _Compare, _Alloc>::_Key_alloc_type>::const_iterator const_iterator;
      typedef typename ::std::_Rb_tree<typename ::std::multiset<_Key, _Compare, _Alloc>::key_type, typename ::std::multiset<_Key, _Compare, _Alloc>::value_type, ::std::_Identity<typename ::std::multiset<_Key, _Compare, _Alloc>::value_type>, typename ::std::multiset<_Key, _Compare, _Alloc>::key_compare, typename ::std::multiset<_Key, _Compare, _Alloc>::_Key_alloc_type>::const_reverse_iterator reverse_iterator;
      typedef typename ::std::_Rb_tree<typename ::std::multiset<_Key, _Compare, _Alloc>::key_type, typename ::std::multiset<_Key, _Compare, _Alloc>::value_type, ::std::_Identity<typename ::std::multiset<_Key, _Compare, _Alloc>::value_type>, typename ::std::multiset<_Key, _Compare, _Alloc>::key_compare, typename ::std::multiset<_Key, _Compare, _Alloc>::_Key_alloc_type>::const_reverse_iterator const_reverse_iterator;
      typedef typename ::std::_Rb_tree<typename ::std::multiset<_Key, _Compare, _Alloc>::key_type, typename ::std::multiset<_Key, _Compare, _Alloc>::value_type, ::std::_Identity<typename ::std::multiset<_Key, _Compare, _Alloc>::value_type>, typename ::std::multiset<_Key, _Compare, _Alloc>::key_compare, typename ::std::multiset<_Key, _Compare, _Alloc>::_Key_alloc_type>::size_type size_type;
      typedef typename ::std::_Rb_tree<typename ::std::multiset<_Key, _Compare, _Alloc>::key_type, typename ::std::multiset<_Key, _Compare, _Alloc>::value_type, ::std::_Identity<typename ::std::multiset<_Key, _Compare, _Alloc>::value_type>, typename ::std::multiset<_Key, _Compare, _Alloc>::key_compare, typename ::std::multiset<_Key, _Compare, _Alloc>::_Key_alloc_type>::difference_type difference_type;
      inline multiset()
        : _M_t()
      {
      }
      inline explicit multiset(const _Compare &__comp, const typename ::std::multiset<_Key, _Compare, _Alloc>::allocator_type &__a  = typename ::std::multiset<_Key, _Compare, _Alloc>::allocator_type())
        : _M_t(__comp, typename ::std::multiset<_Key, _Compare, _Alloc>::_Key_alloc_type(__a))
      {
      }
      template < typename _InputIterator >
      inline multiset(_InputIterator __first, _InputIterator __last)
        : _M_t()
      {
        _M_t._M_insert_equal(__first, __last);
      }
      template < typename _InputIterator >
      inline multiset(_InputIterator __first, _InputIterator __last, const _Compare &__comp, const typename ::std::multiset<_Key, _Compare, _Alloc>::allocator_type &__a  = typename ::std::multiset<_Key, _Compare, _Alloc>::allocator_type())
        : _M_t(__comp, typename ::std::multiset<_Key, _Compare, _Alloc>::_Key_alloc_type(__a))
      {
        _M_t._M_insert_equal(__first, __last);
      }
      inline multiset(const ::std::multiset<_Key, _Compare, _Alloc> &__x)
        : _M_t(__x._M_t)
      {
      }
      inline ::std::multiset<_Key, _Compare, _Alloc> &operator =(const ::std::multiset<_Key, _Compare, _Alloc> &__x)
      {
        _M_t = __x._M_t;
        return *this;
      }
      inline typename ::std::multiset<_Key, _Compare, _Alloc>::key_compare key_comp() const 
      {
        return _M_t.key_comp();
      }
      inline typename ::std::multiset<_Key, _Compare, _Alloc>::value_compare value_comp() const 
      {
        return _M_t.key_comp();
      }
      inline typename ::std::multiset<_Key, _Compare, _Alloc>::allocator_type get_allocator() const 
      {
        return typename ::std::multiset<_Key, _Compare, _Alloc>::allocator_type(_M_t.get_allocator());
      }
      inline typename ::std::multiset<_Key, _Compare, _Alloc>::iterator begin() const 
      {
        return _M_t.begin();
      }
      inline typename ::std::multiset<_Key, _Compare, _Alloc>::iterator end() const 
      {
        return _M_t.end();
      }
      inline typename ::std::multiset<_Key, _Compare, _Alloc>::reverse_iterator rbegin() const 
      {
        return _M_t.rbegin();
      }
      inline typename ::std::multiset<_Key, _Compare, _Alloc>::reverse_iterator rend() const 
      {
        return _M_t.rend();
      }
      inline bool empty() const 
      {
        return _M_t.empty();
      }
      inline typename ::std::multiset<_Key, _Compare, _Alloc>::size_type size() const 
      {
        return _M_t.size();
      }
      inline typename ::std::multiset<_Key, _Compare, _Alloc>::size_type max_size() const 
      {
        return _M_t.max_size();
      }
      inline void swap(::std::multiset<_Key, _Compare, _Alloc> &__x)
      {
        _M_t.swap(__x._M_t);
      }
      inline typename ::std::multiset<_Key, _Compare, _Alloc>::iterator insert(const typename ::std::multiset<_Key, _Compare, _Alloc>::value_type &__x)
      {
        return _M_t._M_insert_equal(__x);
      }
      inline typename ::std::multiset<_Key, _Compare, _Alloc>::iterator insert(typename ::std::multiset<_Key, _Compare, _Alloc>::const_iterator __position, const typename ::std::multiset<_Key, _Compare, _Alloc>::value_type &__x)
      {
        return _M_t._M_insert_equal_(__position, __x);
      }
      template < typename _InputIterator >
      inline void insert(_InputIterator __first, _InputIterator __last)
      {
        _M_t._M_insert_equal(__first, __last);
      }
      inline void erase(typename ::std::multiset<_Key, _Compare, _Alloc>::iterator __position)
      {
        _M_t.erase(__position);
      }
      inline typename ::std::multiset<_Key, _Compare, _Alloc>::size_type erase(const typename ::std::multiset<_Key, _Compare, _Alloc>::key_type &__x)
      {
        return _M_t.erase(__x);
      }
      inline void erase(typename ::std::multiset<_Key, _Compare, _Alloc>::iterator __first, typename ::std::multiset<_Key, _Compare, _Alloc>::iterator __last)
      {
        _M_t.erase(__first, __last);
      }
      inline void clear()
      {
        _M_t.clear();
      }
      inline typename ::std::multiset<_Key, _Compare, _Alloc>::size_type count(const typename ::std::multiset<_Key, _Compare, _Alloc>::key_type &__x) const 
      {
        return _M_t.count(__x);
      }
      inline typename ::std::multiset<_Key, _Compare, _Alloc>::iterator find(const typename ::std::multiset<_Key, _Compare, _Alloc>::key_type &__x)
      {
        return _M_t.find(__x);
      }
      inline typename ::std::multiset<_Key, _Compare, _Alloc>::const_iterator find(const typename ::std::multiset<_Key, _Compare, _Alloc>::key_type &__x) const 
      {
        return _M_t.find(__x);
      }
      inline typename ::std::multiset<_Key, _Compare, _Alloc>::iterator lower_bound(const typename ::std::multiset<_Key, _Compare, _Alloc>::key_type &__x)
      {
        return _M_t.lower_bound(__x);
      }
      inline typename ::std::multiset<_Key, _Compare, _Alloc>::const_iterator lower_bound(const typename ::std::multiset<_Key, _Compare, _Alloc>::key_type &__x) const 
      {
        return _M_t.lower_bound(__x);
      }
      inline typename ::std::multiset<_Key, _Compare, _Alloc>::iterator upper_bound(const typename ::std::multiset<_Key, _Compare, _Alloc>::key_type &__x)
      {
        return _M_t.upper_bound(__x);
      }
      inline typename ::std::multiset<_Key, _Compare, _Alloc>::const_iterator upper_bound(const typename ::std::multiset<_Key, _Compare, _Alloc>::key_type &__x) const 
      {
        return _M_t.upper_bound(__x);
      }
      inline ::std::pair<typename ::std::multiset<_Key, _Compare, _Alloc>::iterator, typename ::std::multiset<_Key, _Compare, _Alloc>::iterator> equal_range(const typename ::std::multiset<_Key, _Compare, _Alloc>::key_type &__x)
      {
        return _M_t.equal_range(__x);
      }
      inline ::std::pair<typename ::std::multiset<_Key, _Compare, _Alloc>::const_iterator, typename ::std::multiset<_Key, _Compare, _Alloc>::const_iterator> equal_range(const typename ::std::multiset<_Key, _Compare, _Alloc>::key_type &__x) const 
      {
        return _M_t.equal_range(__x);
      }
    template < typename _K1, typename _C1, typename _A1 >
    friend bool operator ==(const ::std::multiset<_K1, _C1, _A1> &, const ::std::multiset<_K1, _C1, _A1> &);
    template < typename _K1, typename _C1, typename _A1 >
    friend bool operator <(const ::std::multiset<_K1, _C1, _A1> &, const ::std::multiset<_K1, _C1, _A1> &);
  };
  template < typename _Key, typename _Compare, typename _Alloc >
  inline bool operator ==(const ::std::multiset<_Key, _Compare, _Alloc> &__x, const ::std::multiset<_Key, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Compare, typename _Alloc >
  inline bool operator ==(const ::std::multiset<_Key, _Compare, _Alloc> &__x, const ::std::multiset<_Key, _Compare, _Alloc> &__y)
  {
    return __x._M_t == __y._M_t;
  }
  template < typename _Key, typename _Compare, typename _Alloc >
  inline bool operator <(const ::std::multiset<_Key, _Compare, _Alloc> &__x, const ::std::multiset<_Key, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Compare, typename _Alloc >
  inline bool operator <(const ::std::multiset<_Key, _Compare, _Alloc> &__x, const ::std::multiset<_Key, _Compare, _Alloc> &__y)
  {
    return __x._M_t < __y._M_t;
  }
  template < typename _Key, typename _Compare, typename _Alloc >
  inline bool operator !=(const ::std::multiset<_Key, _Compare, _Alloc> &__x, const ::std::multiset<_Key, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Compare, typename _Alloc >
  inline bool operator !=(const ::std::multiset<_Key, _Compare, _Alloc> &__x, const ::std::multiset<_Key, _Compare, _Alloc> &__y)
  {
    return !(__x == __y);
  }
  template < typename _Key, typename _Compare, typename _Alloc >
  inline bool operator >(const ::std::multiset<_Key, _Compare, _Alloc> &__x, const ::std::multiset<_Key, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Compare, typename _Alloc >
  inline bool operator >(const ::std::multiset<_Key, _Compare, _Alloc> &__x, const ::std::multiset<_Key, _Compare, _Alloc> &__y)
  {
    return __y < __x;
  }
  template < typename _Key, typename _Compare, typename _Alloc >
  inline bool operator <=(const ::std::multiset<_Key, _Compare, _Alloc> &__x, const ::std::multiset<_Key, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Compare, typename _Alloc >
  inline bool operator <=(const ::std::multiset<_Key, _Compare, _Alloc> &__x, const ::std::multiset<_Key, _Compare, _Alloc> &__y)
  {
    return !(__y < __x);
  }
  template < typename _Key, typename _Compare, typename _Alloc >
  inline bool operator >=(const ::std::multiset<_Key, _Compare, _Alloc> &__x, const ::std::multiset<_Key, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Compare, typename _Alloc >
  inline bool operator >=(const ::std::multiset<_Key, _Compare, _Alloc> &__x, const ::std::multiset<_Key, _Compare, _Alloc> &__y)
  {
    return !(__x < __y);
  }
  template < typename _Key, typename _Compare, typename _Alloc >
  inline void swap(::std::multiset<_Key, _Compare, _Alloc> &__x, ::std::multiset<_Key, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Compare, typename _Alloc >
  inline void swap(::std::multiset<_Key, _Compare, _Alloc> &__x, ::std::multiset<_Key, _Compare, _Alloc> &__y)
  {
    __x.swap(__y);
  }
}
using namespace ::std;
class  ObjParser
{
    ::RTBox3f sceneAABB;
    ::std::vector< ::RTTL::RTVec3f, ::std::allocator< ::RTTL::RTVec_t<3, float, 0> > > vertex;
    ::std::vector< ::RTTL::RTVec3f, ::std::allocator< ::RTTL::RTVec_t<3, float, 0> > > normal;
    ::std::vector< ::RTTL::RTVec2f, ::std::allocator< ::RTTL::RTVec_t<2, float, 0> > > textureCoord;
    ::std::vector< ::RTTL::RTVec3f, ::std::allocator< ::RTTL::RTVec_t<3, float, 0> > > tmpVtx;
    ::std::vector< ::RTTL::RTVec3f, ::std::allocator< ::RTTL::RTVec_t<3, float, 0> > > tmpNor;
    ::std::vector< ::RTTL::RTVec2f, ::std::allocator< ::RTTL::RTVec_t<2, float, 0> > > tmpTxt;
    ::std::map< ::std::pair<int, ::std::pair<int, int> >, int, ::std::less< ::std::pair<int, ::std::pair<int, int> > >, ::std::allocator< ::std::pair<const ::std::pair<int, ::std::pair<int, int> >, int> > > vertexMap;
    ::std::vector< ::RTTL::RTVec3i, ::std::allocator< ::RTTL::RTVec_t<3, int, 0> > > triangle;
    ::std::vector<int, ::std::allocator<int> > triangleShaderId;
    ::std::vector< ::RTTL::RTVec4i, ::std::allocator< ::RTTL::RTVec_t<4, int, 0> > > quad;
    ::std::vector<int, ::std::allocator<int> > quadShaderId;
    ::std::vector< ::RTTL::RTMaterial, ::std::allocator< ::RTTL::RTMaterial> > material;
    ::std::map< ::std::string, int, ::std::less< ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> > >, ::std::allocator< ::std::pair<const ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> >, int> > > material_map;
    ::std::vector< ::ImagePPM *, ::std::allocator< ::ImagePPM *> > texture;
    inline void ParseMTL(const ::std::string base, const ::std::string fname)
    {
      const char __MERCURIUM_PRETTY_FUNCTION__[69] = "void ::ObjParser::ParseMTL(const ::std::string, const ::std::string)";
      ::std::cout << "base" << " = " << base << ::std::flush<char, ::std::char_traits<char> > << ::std::endl<char, ::std::char_traits<char> >;
      ::std::cout << "fname" << " = " << fname << ::std::flush<char, ::std::char_traits<char> > << ::std::endl<char, ::std::char_traits<char> >;
      ::std::string name;
      const ::std::string filename((base + "/" + fname));
      ::std::fstream file;
      file.::std::basic_fstream<char, ::std::char_traits<char> >::open(filename.::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> >::c_str() /* , ::std::operator |(::std::ios_base::in, ::std::ios_base::out) */ );
      ::std::cout << "parsing material file " << filename << ::std::endl<char, ::std::char_traits<char> >;
      if (!file.::std::basic_fstream<char, ::std::char_traits<char> >::is_open())
        {
          {
            ::std::cerr << "FATAL: " << "Error: cannot open %s for reading!\n" << fname.::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> >::c_str() << "(in " << __MERCURIUM_PRETTY_FUNCTION__ << ")" << ::std::endl<char, ::std::char_traits<char> >;
            ::exit(1);
          }
          ;
        }
      while (!file.::std::basic_ios<char, ::std::char_traits<char> >::eof())
        {
          ::std::string s;
          file >> s;
          if (s.::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> >::operator [](0) == '#')
            {
              ::std::getline /* <char, ::std::char_traits<char>, ::std::allocator<char> > */ (file, s, '\n');
              continue;
            }
          else
            {
              if (s == "newmtl")
                {
                  file >> name;
                  (*this).material_map.::std::map< ::std::string, int, ::std::less< ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> > >, ::std::allocator< ::std::pair<const ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> >, int> > >::operator [](name) = (*this).material.::std::vector< ::RTTL::RTMaterial, ::std::allocator< ::RTTL::RTMaterial> >::size();
                  (*this).material.::std::vector< ::RTTL::RTMaterial, ::std::allocator< ::RTTL::RTMaterial> >::push_back(::RTTL::RTMaterial());
                }
              else
                {
                  if (s == "Ns")
                    {
                      ::RTTL::RTMaterial &m((*this).material.::std::vector< ::RTTL::RTMaterial, ::std::allocator< ::RTTL::RTMaterial> >::operator []((*this).material_map.::std::map< ::std::string, int, ::std::less< ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> > >, ::std::allocator< ::std::pair<const ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> >, int> > >::operator [](name)));
                      file >> m.m_shininess;
                    }
                  else
                    {
                      if (s == "Tr")
                        {
                          ::RTTL::RTMaterial &m((*this).material.::std::vector< ::RTTL::RTMaterial, ::std::allocator< ::RTTL::RTMaterial> >::operator []((*this).material_map.::std::map< ::std::string, int, ::std::less< ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> > >, ::std::allocator< ::std::pair<const ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> >, int> > >::operator [](name)));
                          file >> m.m_transparency;
                        }
                      else
                        {
                          if (s == "Ka")
                            {
                              ::RTTL::RTMaterial &m((*this).material.::std::vector< ::RTTL::RTMaterial, ::std::allocator< ::RTTL::RTMaterial> >::operator []((*this).material_map.::std::map< ::std::string, int, ::std::less< ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> > >, ::std::allocator< ::std::pair<const ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> >, int> > >::operator [](name)));
                              file >> m.m_ambient.x;
                              file >> m.m_ambient.y;
                              file >> m.m_ambient.z;
                            }
                          else
                            {
                              if (s == "Kd")
                                {
                                  ::RTTL::RTMaterial &m((*this).material.::std::vector< ::RTTL::RTMaterial, ::std::allocator< ::RTTL::RTMaterial> >::operator []((*this).material_map.::std::map< ::std::string, int, ::std::less< ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> > >, ::std::allocator< ::std::pair<const ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> >, int> > >::operator [](name)));
                                  file >> m.m_diffuse.x;
                                  file >> m.m_diffuse.y;
                                  file >> m.m_diffuse.z;
                                }
                              else
                                {
                                  if (s == "Ks")
                                    {
                                      ::RTTL::RTMaterial &m((*this).material.::std::vector< ::RTTL::RTMaterial, ::std::allocator< ::RTTL::RTMaterial> >::operator []((*this).material_map.::std::map< ::std::string, int, ::std::less< ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> > >, ::std::allocator< ::std::pair<const ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> >, int> > >::operator [](name)));
                                      file >> m.m_specular.x;
                                      file >> m.m_specular.y;
                                      file >> m.m_specular.z;
                                    }
                                  else
                                    {
                                      if (s == "map_Ka")
                                        {
                                          ::std::string textureName;
                                          file >> textureName;
                                          (*this).texture.::std::vector< ::ImagePPM *, ::std::allocator< ::ImagePPM *> >::push_back(new (::ImagePPM)(((base + "/" + textureName).::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> >::c_str())));
                                        }
                                      else
                                        {
                                          if (s == "map_Kd")
                                            {
                                              ::std::string textureName;
                                              file >> textureName;
                                              (*this).texture.::std::vector< ::ImagePPM *, ::std::allocator< ::ImagePPM *> >::push_back(new (::ImagePPM)(((base + "/" + textureName).::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> >::c_str())));
                                              ::RTTL::RTMaterial &m((*this).material.::std::vector< ::RTTL::RTMaterial, ::std::allocator< ::RTTL::RTMaterial> >::operator []((*this).material_map.::std::map< ::std::string, int, ::std::less< ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> > >, ::std::allocator< ::std::pair<const ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> >, int> > >::operator [](name)));
                                              m.m_textureId = 0;
                                            }
                                          else
                                            {
                                              if (s == "map_Ks")
                                                {
                                                  ::std::string textureName;
                                                  file >> textureName;
                                                  (*this).texture.::std::vector< ::ImagePPM *, ::std::allocator< ::ImagePPM *> >::push_back(new (::ImagePPM)(((base + "/" + textureName).::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> >::c_str())));
                                                }
                                              else
                                                {
                                                  ::std::getline /* <char, ::std::char_traits<char>, ::std::allocator<char> > */ (file, s, '\n');
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
      ::std::cout << "finished parsing material file." << ::std::endl<char, ::std::char_traits<char> >;
    }
    inline __attribute__((always_inline)) int getVertexID(int vtxID, int norID, int txtID)
    {
      ::std::pair<int, ::std::pair<int, int> > v((vtxID), (::std::pair<int, int>(txtID, norID)));
      if ((*this).vertexMap.::std::map< ::std::pair<int, ::std::pair<int, int> >, int, ::std::less< ::std::pair<int, ::std::pair<int, int> > >, ::std::allocator< ::std::pair<const ::std::pair<int, ::std::pair<int, int> >, int> > >::find(v) == (*this).vertexMap.::std::map< ::std::pair<int, ::std::pair<int, int> >, int, ::std::less< ::std::pair<int, ::std::pair<int, int> > >, ::std::allocator< ::std::pair<const ::std::pair<int, ::std::pair<int, int> >, int> > >::end())
        {
          (*this).vertexMap.::std::map< ::std::pair<int, ::std::pair<int, int> >, int, ::std::less< ::std::pair<int, ::std::pair<int, int> > >, ::std::allocator< ::std::pair<const ::std::pair<int, ::std::pair<int, int> >, int> > >::operator [](v) = (*this).vertex.::std::vector< ::RTTL::RTVec3f, ::std::allocator< ::RTTL::RTVec_t<3, float, 0> > >::size();
          (*this).vertex.::std::vector< ::RTTL::RTVec3f, ::std::allocator< ::RTTL::RTVec_t<3, float, 0> > >::push_back((*this).tmpVtx.::std::vector< ::RTTL::RTVec3f, ::std::allocator< ::RTTL::RTVec_t<3, float, 0> > >::operator [](vtxID));
          if (norID >= 0)
            {
              (*this).normal.::std::vector< ::RTTL::RTVec3f, ::std::allocator< ::RTTL::RTVec_t<3, float, 0> > >::push_back((*this).tmpNor.::std::vector< ::RTTL::RTVec3f, ::std::allocator< ::RTTL::RTVec_t<3, float, 0> > >::operator [](norID));
            }
          else
            {
              (*this).normal.::std::vector< ::RTTL::RTVec3f, ::std::allocator< ::RTTL::RTVec_t<3, float, 0> > >::push_back(::RTTL::RTVec_t<3, float, 0>(0.000000000000000000000000e+00f, 0.000000000000000000000000e+00f, 0.000000000000000000000000e+00f));
            }
          if (txtID >= 0)
            {
              (*this).textureCoord.::std::vector< ::RTTL::RTVec2f, ::std::allocator< ::RTTL::RTVec_t<2, float, 0> > >::push_back((*this).tmpTxt.::std::vector< ::RTTL::RTVec2f, ::std::allocator< ::RTTL::RTVec_t<2, float, 0> > >::operator [](txtID));
            }
          else
            {
              (*this).textureCoord.::std::vector< ::RTTL::RTVec2f, ::std::allocator< ::RTTL::RTVec_t<2, float, 0> > >::push_back(::RTTL::RTVec_t<2, float, 0>(0.000000000000000000000000e+00f, 0.000000000000000000000000e+00f));
            }
        }
      return (*this).vertexMap.::std::map< ::std::pair<int, ::std::pair<int, int> >, int, ::std::less< ::std::pair<int, ::std::pair<int, int> > >, ::std::allocator< ::std::pair<const ::std::pair<int, ::std::pair<int, int> >, int> > >::operator [](v);
    }
  public:
    inline __attribute__((always_inline)) int quads()
    {
      return (*this).quad.::std::vector< ::RTTL::RTVec4i, ::std::allocator< ::RTTL::RTVec_t<4, int, 0> > >::size();
    }
    inline __attribute__((always_inline)) int vertices()
    {
      return (*this).vertex.::std::vector< ::RTTL::RTVec3f, ::std::allocator< ::RTTL::RTVec_t<3, float, 0> > >::size();
    }
    inline __attribute__((always_inline)) int triangles()
    {
      return (*this).triangle.::std::vector< ::RTTL::RTVec3i, ::std::allocator< ::RTTL::RTVec_t<3, int, 0> > >::size();
    }
    inline __attribute__((always_inline)) int normals()
    {
      return (*this).normal.::std::vector< ::RTTL::RTVec3f, ::std::allocator< ::RTTL::RTVec_t<3, float, 0> > >::size();
    }
    inline __attribute__((always_inline)) int textureCoordinates()
    {
      return (*this).textureCoord.::std::vector< ::RTTL::RTVec2f, ::std::allocator< ::RTTL::RTVec_t<2, float, 0> > >::size();
    }
    inline __attribute__((always_inline)) int materials()
    {
      return (*this).material.::std::vector< ::RTTL::RTMaterial, ::std::allocator< ::RTTL::RTMaterial> >::size();
    }
    inline __attribute__((always_inline)) int textures()
    {
      return (*this).texture.::std::vector< ::ImagePPM *, ::std::allocator< ::ImagePPM *> >::size();
    }
    inline __attribute__((always_inline)) int triangleShaderIDs()
    {
      return (*this).triangleShaderId.::std::vector<int, ::std::allocator<int> >::size();
    }
    inline __attribute__((always_inline)) int quadShaderIDs()
    {
      return (*this).quadShaderId.::std::vector<int, ::std::allocator<int> >::size();
    }
    inline __attribute__((always_inline)) ::RTBox3f &getSceneAABB()
    {
      return (*this).sceneAABB;
    }
    inline __attribute__((always_inline)) ::RTTL::RTVec3f *getVertexPtr()
    {
      return (*this).vertex.::std::vector< ::RTTL::RTVec3f, ::std::allocator< ::RTTL::RTVec_t<3, float, 0> > >::size() ? & *(*this).vertex.::std::vector< ::RTTL::RTVec3f, ::std::allocator< ::RTTL::RTVec_t<3, float, 0> > >::begin() : 0L;
    }
    inline __attribute__((always_inline)) ::RTTL::RTVec3i *getTrianglePtr()
    {
      return (*this).triangle.::std::vector< ::RTTL::RTVec3i, ::std::allocator< ::RTTL::RTVec_t<3, int, 0> > >::size() ? & *(*this).triangle.::std::vector< ::RTTL::RTVec3i, ::std::allocator< ::RTTL::RTVec_t<3, int, 0> > >::begin() : 0L;
    }
    inline __attribute__((always_inline)) ::RTTL::RTVec4i *getQuadPtr()
    {
      return (*this).quad.::std::vector< ::RTTL::RTVec4i, ::std::allocator< ::RTTL::RTVec_t<4, int, 0> > >::size() ? & *(*this).quad.::std::vector< ::RTTL::RTVec4i, ::std::allocator< ::RTTL::RTVec_t<4, int, 0> > >::begin() : 0L;
    }
    inline __attribute__((always_inline)) ::RTTL::RTVec3f *getNormalPtr()
    {
      return (*this).normal.::std::vector< ::RTTL::RTVec3f, ::std::allocator< ::RTTL::RTVec_t<3, float, 0> > >::size() ? & *(*this).normal.::std::vector< ::RTTL::RTVec3f, ::std::allocator< ::RTTL::RTVec_t<3, float, 0> > >::begin() : 0L;
    }
    inline __attribute__((always_inline)) ::RTTL::RTVec2f *getTextureCoordinatePtr()
    {
      return (*this).textureCoord.::std::vector< ::RTTL::RTVec2f, ::std::allocator< ::RTTL::RTVec_t<2, float, 0> > >::size() ? & *(*this).textureCoord.::std::vector< ::RTTL::RTVec2f, ::std::allocator< ::RTTL::RTVec_t<2, float, 0> > >::begin() : 0L;
    }
    inline __attribute__((always_inline)) ::RTTL::RTMaterial *getMaterialPtr()
    {
      return (*this).material.::std::vector< ::RTTL::RTMaterial, ::std::allocator< ::RTTL::RTMaterial> >::size() ? & *(*this).material.::std::vector< ::RTTL::RTMaterial, ::std::allocator< ::RTTL::RTMaterial> >::begin() : 0L;
    }
    inline __attribute__((always_inline)) int *getTriangleShaderPtr()
    {
      return (*this).triangleShaderId.::std::vector<int, ::std::allocator<int> >::size() ? & *(*this).triangleShaderId.::std::vector<int, ::std::allocator<int> >::begin() : 0L;
    }
    inline __attribute__((always_inline)) int *getQuadShaderPtr()
    {
      return (*this).quadShaderId.::std::vector<int, ::std::allocator<int> >::size() ? & *(*this).quadShaderId.::std::vector<int, ::std::allocator<int> >::begin() : 0L;
    }
    inline __attribute__((always_inline)) ::ImagePPM *getTexture(const int i)
    {
      return (*this).texture.::std::vector< ::ImagePPM *, ::std::allocator< ::ImagePPM *> >::operator [](i);
    }
    inline ObjParser()
    {
      (*this).sceneAABB.::RTTL::RTBox_t<3, float, 0>::reset();
    }
    inline __attribute__((always_inline)) void Free()
    {
      (*this).tmpVtx.::std::vector< ::RTTL::RTVec3f, ::std::allocator< ::RTTL::RTVec_t<3, float, 0> > >::clear();
      (*this).tmpNor.::std::vector< ::RTTL::RTVec3f, ::std::allocator< ::RTTL::RTVec_t<3, float, 0> > >::clear();
      (*this).tmpTxt.::std::vector< ::RTTL::RTVec2f, ::std::allocator< ::RTTL::RTVec_t<2, float, 0> > >::clear();
      (*this).vertexMap.::std::map< ::std::pair<int, ::std::pair<int, int> >, int, ::std::less< ::std::pair<int, ::std::pair<int, int> > >, ::std::allocator< ::std::pair<const ::std::pair<int, ::std::pair<int, int> >, int> > >::clear();
      (*this).vertex.::std::vector< ::RTTL::RTVec3f, ::std::allocator< ::RTTL::RTVec_t<3, float, 0> > >::clear();
      (*this).triangle.::std::vector< ::RTTL::RTVec3i, ::std::allocator< ::RTTL::RTVec_t<3, int, 0> > >::clear();
      (*this).normal.::std::vector< ::RTTL::RTVec3f, ::std::allocator< ::RTTL::RTVec_t<3, float, 0> > >::clear();
      (*this).textureCoord.::std::vector< ::RTTL::RTVec2f, ::std::allocator< ::RTTL::RTVec_t<2, float, 0> > >::clear();
      (*this).triangleShaderId.::std::vector<int, ::std::allocator<int> >::clear();
      (*this).quadShaderId.::std::vector<int, ::std::allocator<int> >::clear();
      for (unsigned int i = 0; i < (*this).texture.::std::vector< ::ImagePPM *, ::std::allocator< ::ImagePPM *> >::size(); i++)
        {
          delete (*this).texture.::std::vector< ::ImagePPM *, ::std::allocator< ::ImagePPM *> >::operator [](i);
        }
      (*this).texture.::std::vector< ::ImagePPM *, ::std::allocator< ::ImagePPM *> >::clear();
      (*this).material_map.::std::map< ::std::string, int, ::std::less< ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> > >, ::std::allocator< ::std::pair<const ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> >, int> > >::clear();
    }
    inline void Parse(::std::string fileName)
    {
      const char __MERCURIUM_PRETTY_FUNCTION__[39] = "void ::ObjParser::Parse(::std::string)";
      ::std::fstream mFile;
      const char *fn(fileName.::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> >::c_str());
      mFile.::std::basic_fstream<char, ::std::char_traits<char> >::open(fn, ::std::ios_base::in);
      int p( -1);
      for (unsigned int i = 0; i < fileName.::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> >::size(); i++)
        {
          if (fileName.::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> >::operator [](i) == '/')
            {
              p = i;
            }
        }
      ::std::string base;
      if (p !=  -1)
        {
          base = fileName.::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> >::substr(0, p);
        }
      else
        {
          base = ".";
        }
      if (!mFile.::std::basic_fstream<char, ::std::char_traits<char> >::is_open())
        {
          ::std::cout << "Error: cannot open " << fileName << " for reading!" << ::std::endl<char, ::std::char_traits<char> >;
          ::perror("Error code");
          ::exit( -1);
        }
      int shaderId(0);
      int count(0);
      while (!mFile.::std::basic_ios<char, ::std::char_traits<char> >::eof())
        {
          count++;
          ::std::string s;
          mFile >> s;
          if (s.::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> >::operator [](0) == '#')
            {
              continue;
            }
          else
            {
              if (s == "mtllib")
                {
                  ::std::string mtllib;
                  mFile >> mtllib;
                  (*this).::ObjParser::ParseMTL(base, mtllib);
                }
              else
                {
                  if (s == "g")
                    {
                      ::std::string temp;
                      mFile >> temp;
                    }
                  else
                    {
                      if (s == "usemtl")
                        {
                          ::std::string material;
                          mFile >> material;
                          shaderId = (*this).material_map.::std::map< ::std::string, int, ::std::less< ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> > >, ::std::allocator< ::std::pair<const ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> >, int> > >::operator [](material);
                        }
                      else
                        {
                          if (s == "v")
                            {
                              ::RTTL::RTVec3f v;
                              mFile >> v.::RTTL::RTVec_t<3, float, 0>::operator [](0);
                              mFile >> v.::RTTL::RTVec_t<3, float, 0>::operator [](1);
                              mFile >> v.::RTTL::RTVec_t<3, float, 0>::operator [](2);
                              (*this).sceneAABB.::RTTL::RTBox_t<3, float, 0>::extend(v);
                              (*this).tmpVtx.::std::vector< ::RTTL::RTVec3f, ::std::allocator< ::RTTL::RTVec_t<3, float, 0> > >::push_back(v);
                            }
                          else
                            {
                              if (s == "vt")
                                {
                                  ::RTTL::RTVec2f c;
                                  mFile >> c.::RTTL::RTVec_t<2, float, 0>::operator [](0);
                                  mFile >> c.::RTTL::RTVec_t<2, float, 0>::operator [](1);
                                  (*this).tmpTxt.::std::vector< ::RTTL::RTVec2f, ::std::allocator< ::RTTL::RTVec_t<2, float, 0> > >::push_back(c);
                                }
                              else
                                {
                                  if (s == "vn")
                                    {
                                      ::RTTL::RTVec3f n;
                                      mFile >> n.::RTTL::RTVec_t<3, float, 0>::operator [](0);
                                      mFile >> n.::RTTL::RTVec_t<3, float, 0>::operator [](1);
                                      mFile >> n.::RTTL::RTVec_t<3, float, 0>::operator [](2);
                                      (*this).tmpNor.::std::vector< ::RTTL::RTVec3f, ::std::allocator< ::RTTL::RTVec_t<3, float, 0> > >::push_back(n);
                                    }
                                  else
                                    {
                                      if (s == "f" || s == "fo")
                                        {
                                          ::std::string dash;
                                          int ta( -1);
                                          int tta(0);
                                          int tna(0);
                                          int tb( -1);
                                          int ttb(0);
                                          int tnb(0);
                                          int tc( -1);
                                          int ttc(0);
                                          int tnc(0);
                                          int td( -1);
                                          int ttd(0);
                                          int tnd(0);
                                          mFile >> dash;
                                          if (((::sscanf(dash.::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> >::c_str(), "%d/%d/%d", &ta, &tta, &tna) != 3 && ::sscanf(dash.::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> >::c_str(), "%d/%d", &ta, &tta) != 2) && ::sscanf(dash.::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> >::c_str(), "%d//%d", &ta, &tna) != 2) && ::sscanf(dash.::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> >::c_str(), "%d", &ta) != 1)
                                            {
                                              ::printf("Parsing error v0: %i\n", count);
                                              ::exit( -1);
                                            }
                                          mFile >> dash;
                                          if (((::sscanf(dash.::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> >::c_str(), "%d/%d/%d", &tb, &ttb, &tnb) != 3 && ::sscanf(dash.::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> >::c_str(), "%d/%d", &tb, &ttb) != 2) && ::sscanf(dash.::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> >::c_str(), "%d//%d", &tb, &tnb) != 2) && ::sscanf(dash.::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> >::c_str(), "%d", &tb) != 1)
                                            {
                                              ::printf("Parsing error v1: %i\n", count);
                                              ::exit( -1);
                                            }
                                          ;
                                          mFile >> dash;
                                          if (((::sscanf(dash.::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> >::c_str(), "%d/%d/%d", &tc, &ttc, &tnc) != 3 && ::sscanf(dash.::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> >::c_str(), "%d/%d", &tc, &ttc) != 2) && ::sscanf(dash.::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> >::c_str(), "%d//%d", &tc, &tnc) != 2) && ::sscanf(dash.::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> >::c_str(), "%d", &tc) != 1)
                                            {
                                              ::printf("Parsing error v2: %i\n", count);
                                              ::exit( -1);
                                            }
                                          ;
                                          bool isQuad(true);
                                          char c;
                                          while (mFile.::std::basic_istream<char, ::std::char_traits<char> >::peek() == ' ')
                                            {
                                              mFile.::std::basic_istream<char, ::std::char_traits<char> >::get(c);
                                            }
                                          if (mFile.::std::basic_istream<char, ::std::char_traits<char> >::peek() == 13 || mFile.::std::basic_istream<char, ::std::char_traits<char> >::peek() == 10)
                                            {
                                              while (mFile.::std::basic_istream<char, ::std::char_traits<char> >::peek() == 13 || mFile.::std::basic_istream<char, ::std::char_traits<char> >::peek() == 10)
                                                {
                                                  mFile.::std::basic_istream<char, ::std::char_traits<char> >::get(c);
                                                }
                                              isQuad = false;
                                            }
                                          else
                                            {
                                              mFile >> dash;
                                              if (((::sscanf(dash.::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> >::c_str(), "%d/%d/%d", &td, &ttd, &tnd) != 3 && ::sscanf(dash.::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> >::c_str(), "%d/%d", &td, &ttd) != 2) && ::sscanf(dash.::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> >::c_str(), "%d//%d", &td, &tnd) != 2) && ::sscanf(dash.::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> >::c_str(), "%d", &td) != 1)
                                                {
                                                  isQuad = false;
                                                }
                                            }
                                          bool has_na(tna != 0);
                                          bool has_nb(tnb != 0);
                                          bool has_nc(tnc != 0);
                                          bool has_nd(tnd != 0);
                                          bool has_ta(tta != 0);
                                          bool has_tb(ttb != 0);
                                          bool has_tc(ttc != 0);
                                          bool has_td(ttd != 0);
                                          if (ta > 0)
                                            {
                                              ta--;
                                            }
                                          if (tb > 0)
                                            {
                                              tb--;
                                            }
                                          if (tc > 0)
                                            {
                                              tc--;
                                            }
                                          if (td > 0)
                                            {
                                              td--;
                                            }
                                          if (tta > 0)
                                            {
                                              tta--;
                                            }
                                          if (ttb > 0)
                                            {
                                              ttb--;
                                            }
                                          if (ttc > 0)
                                            {
                                              ttc--;
                                            }
                                          if (ttd > 0)
                                            {
                                              ttd--;
                                            }
                                          if (tna > 0)
                                            {
                                              tna--;
                                            }
                                          if (tnb > 0)
                                            {
                                              tnb--;
                                            }
                                          if (tnc > 0)
                                            {
                                              tnc--;
                                            }
                                          if (tnd > 0)
                                            {
                                              tnd--;
                                            }
                                          if (ta < 0)
                                            {
                                              ta += (*this).tmpVtx.::std::vector< ::RTTL::RTVec3f, ::std::allocator< ::RTTL::RTVec_t<3, float, 0> > >::size();
                                            }
                                          if (tb < 0)
                                            {
                                              tb += (*this).tmpVtx.::std::vector< ::RTTL::RTVec3f, ::std::allocator< ::RTTL::RTVec_t<3, float, 0> > >::size();
                                            }
                                          if (tc < 0)
                                            {
                                              tc += (*this).tmpVtx.::std::vector< ::RTTL::RTVec3f, ::std::allocator< ::RTTL::RTVec_t<3, float, 0> > >::size();
                                            }
                                          if (td < 0)
                                            {
                                              td += (*this).tmpVtx.::std::vector< ::RTTL::RTVec3f, ::std::allocator< ::RTTL::RTVec_t<3, float, 0> > >::size();
                                            }
                                          if (tta < 0)
                                            {
                                              tta += (*this).tmpTxt.::std::vector< ::RTTL::RTVec2f, ::std::allocator< ::RTTL::RTVec_t<2, float, 0> > >::size();
                                            }
                                          if (ttb < 0)
                                            {
                                              ttb += (*this).tmpTxt.::std::vector< ::RTTL::RTVec2f, ::std::allocator< ::RTTL::RTVec_t<2, float, 0> > >::size();
                                            }
                                          if (ttc < 0)
                                            {
                                              ttc += (*this).tmpTxt.::std::vector< ::RTTL::RTVec2f, ::std::allocator< ::RTTL::RTVec_t<2, float, 0> > >::size();
                                            }
                                          if (ttd < 0)
                                            {
                                              ttd += (*this).tmpTxt.::std::vector< ::RTTL::RTVec2f, ::std::allocator< ::RTTL::RTVec_t<2, float, 0> > >::size();
                                            }
                                          if (tna < 0)
                                            {
                                              tna += (*this).tmpNor.::std::vector< ::RTTL::RTVec3f, ::std::allocator< ::RTTL::RTVec_t<3, float, 0> > >::size();
                                            }
                                          if (tnb < 0)
                                            {
                                              tnb += (*this).tmpNor.::std::vector< ::RTTL::RTVec3f, ::std::allocator< ::RTTL::RTVec_t<3, float, 0> > >::size();
                                            }
                                          if (tnc < 0)
                                            {
                                              tnc += (*this).tmpNor.::std::vector< ::RTTL::RTVec3f, ::std::allocator< ::RTTL::RTVec_t<3, float, 0> > >::size();
                                            }
                                          if (tnd < 0)
                                            {
                                              tnc += (*this).tmpNor.::std::vector< ::RTTL::RTVec3f, ::std::allocator< ::RTTL::RTVec_t<3, float, 0> > >::size();
                                            }
                                          if ((((((ta < 0 || ta >= (int)(*this).tmpVtx.::std::vector< ::RTTL::RTVec3f, ::std::allocator< ::RTTL::RTVec_t<3, float, 0> > >::size()) || tb < 0) || tb >= (int)(*this).tmpVtx.::std::vector< ::RTTL::RTVec3f, ::std::allocator< ::RTTL::RTVec_t<3, float, 0> > >::size()) || tc < 0) || tc >= (int)(*this).tmpVtx.::std::vector< ::RTTL::RTVec3f, ::std::allocator< ::RTTL::RTVec_t<3, float, 0> > >::size()) || (isQuad && (td < 0 || td >= (int)(*this).tmpVtx.::std::vector< ::RTTL::RTVec3f, ::std::allocator< ::RTTL::RTVec_t<3, float, 0> > >::size())))
                                            {
                                              ::std::cout << "td" << " = " << td << ::std::flush<char, ::std::char_traits<char> > << ::std::endl<char, ::std::char_traits<char> >;
                                              ::std::cout << "tmpVtx.size()" << " = " << (*this).tmpVtx.::std::vector< ::RTTL::RTVec3f, ::std::allocator< ::RTTL::RTVec_t<3, float, 0> > >::size() << ::std::flush<char, ::std::char_traits<char> > << ::std::endl<char, ::std::char_traits<char> >;
                                              ::printf("Invalid triangle %i: (%i,%i,%i) (%i,%i,%i) (%i,%i,%i) (%i,%i,%i) (%i,%i,%i) %i %i %i\n", count, ta, tb, tc, tta, ttb, ttc, tna, tnb, tnc, has_na, has_nb, has_nc, has_ta, has_tb, has_tc, (int)(*this).tmpVtx.::std::vector< ::RTTL::RTVec3f, ::std::allocator< ::RTTL::RTVec_t<3, float, 0> > >::size(), (int)(*this).tmpTxt.::std::vector< ::RTTL::RTVec2f, ::std::allocator< ::RTTL::RTVec_t<2, float, 0> > >::size(), (int)(*this).tmpNor.::std::vector< ::RTTL::RTVec3f, ::std::allocator< ::RTTL::RTVec_t<3, float, 0> > >::size());
                                              ::exit( -1);
                                            }
                                          if (!has_ta)
                                            {
                                              tta =  -1;
                                            }
                                          if (!has_tb)
                                            {
                                              ttb =  -1;
                                            }
                                          if (!has_tc)
                                            {
                                              ttc =  -1;
                                            }
                                          if (!has_td)
                                            {
                                              ttd =  -1;
                                            }
                                          if (!has_na)
                                            {
                                              tna =  -1;
                                            }
                                          if (!has_nb)
                                            {
                                              tnb =  -1;
                                            }
                                          if (!has_nc)
                                            {
                                              tnc =  -1;
                                            }
                                          if (!has_nd)
                                            {
                                              tnd =  -1;
                                            }
                                          if (isQuad)
                                            {
                                              const int newA((*this).::ObjParser::getVertexID(ta, tna, tta));
                                              const int newB((*this).::ObjParser::getVertexID(tb, tnb, ttb));
                                              const int newC((*this).::ObjParser::getVertexID(tc, tnc, ttc));
                                              const int newD((*this).::ObjParser::getVertexID(td, tnd, ttd));
                                              (*this).quad.::std::vector< ::RTTL::RTVec4i, ::std::allocator< ::RTTL::RTVec_t<4, int, 0> > >::push_back(::RTTL::RTVec_t<4, int, 0>(newA, newB, newC, newD));
                                              (*this).quadShaderId.::std::vector<int, ::std::allocator<int> >::push_back(shaderId);
                                            }
                                          else
                                            {
                                              const int newA((*this).::ObjParser::getVertexID(ta, tna, tta));
                                              const int newB((*this).::ObjParser::getVertexID(tb, tnb, ttb));
                                              const int newC((*this).::ObjParser::getVertexID(tc, tnc, ttc));
                                              (*this).triangle.::std::vector< ::RTTL::RTVec3i, ::std::allocator< ::RTTL::RTVec_t<3, int, 0> > >::push_back(::RTTL::RTVec_t<3, int, 0>(newA, newB, newC));
                                              (*this).triangleShaderId.::std::vector<int, ::std::allocator<int> >::push_back(shaderId);
                                            }
                                        }
                                      else
                                        {
                                          continue;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
      (*this).::ObjParser::textureCoordinates() == (*this).::ObjParser::vertices() ? static_cast<void>(0) : ::__assert_fail("textureCoordinates() == vertices()", "/home/bsc18/bsc18186/scratch/parsec/raytrace/src/MiniView/ObjParser.hxx", 459, __MERCURIUM_PRETTY_FUNCTION__);
      (*this).::ObjParser::normals() == (*this).::ObjParser::vertices() ? static_cast<void>(0) : ::__assert_fail("normals() == vertices()", "/home/bsc18/bsc18186/scratch/parsec/raytrace/src/MiniView/ObjParser.hxx", 460, __MERCURIUM_PRETTY_FUNCTION__);
    }
};
using namespace ::std;
namespace RTTL {
  namespace Convert {
    static inline __attribute__((always_inline)) ::std::string to_string(int v)
    {
      char s[12];
      ::sprintf(s, "%-10i ", v);
      *::strchr(s, ' ') = 0;
      return ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> >(s /* , ::std::allocator<char>() */ );
    }
    static inline __attribute__((always_inline)) ::std::string to_string(float v)
    {
      char s[16];
      ::sprintf(s, "%-14.7g ", v);
      *::strchr(s, ' ') = 0;
      return ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> >(s /* , ::std::allocator<char>() */ );
    }
    static inline __attribute__((always_inline)) ::std::string to_string(double v)
    {
      char s[24];
      ::sprintf(s, "%-22.14g ", v);
      *::strchr(s, ' ') = 0;
      return ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> >(s /* , ::std::allocator<char>() */ );
    }
    static inline __attribute__((always_inline)) ::std::string to_string(const ::std::string &s)
    {
      return s;
    }
    template < typename DataType >
    static inline DataType to(const ::std::string &s)__attribute__((always_inline));
    template < typename DataType >
    static inline __attribute__((always_inline)) DataType to(const ::std::string &s)
    {
      ::std::cerr << "No default converter...\n" << "This is most likely happen when char* values\n" << "are assigned to (should be const char*).\n\n";
      ::exit(1);
      return DataType(0);
    }
    template <>
    inline __attribute__((always_inline)) int to<int>(const ::std::string &s)
    {
      return ::atoi(s.::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> >::c_str());
    }
    template <>
    inline __attribute__((always_inline)) float to<float>(const ::std::string &s)
    {
      return (float)::atof(s.::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> >::c_str());
    }
    template <>
    inline __attribute__((always_inline)) double to<double>(const ::std::string &s)
    {
      return ::atof(s.::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> >::c_str());
    }
    template <>
    inline __attribute__((always_inline)) const char *to<const char *>(const ::std::string &s)
    {
      return s.::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> >::c_str();
    }
    template <>
    inline __attribute__((always_inline)) ::std::string to< ::std::string>(const ::std::string &s)
    {
      return s;
    }
  }
  typedef ::std::vector< ::std::string, ::std::allocator< ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> > > > vector_of_strings;
  typedef ::std::map< ::std::string, ::RTTL::vector_of_strings *, ::std::less< ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> > >, ::std::allocator< ::std::pair<const ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> >, ::RTTL::vector_of_strings *> > > map_strings_to_vector_of_strings;
  class  MapOptions : public ::std::map< ::std::string, ::RTTL::vector_of_strings *, ::std::less< ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> > >, ::std::allocator< ::std::pair<const ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> >, ::RTTL::vector_of_strings *> > >
  {
    public:
      typedef ::std::map< ::std::string, ::RTTL::vector_of_strings *, ::std::less< ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> > >, ::std::allocator< ::std::pair<const ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> >, ::RTTL::vector_of_strings *> > >::iterator iterator;
      typedef ::std::map< ::std::string, ::RTTL::vector_of_strings *, ::std::less< ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> > >, ::std::allocator< ::std::pair<const ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> >, ::RTTL::vector_of_strings *> > >::const_iterator const_iterator;
      ~MapOptions();
      void clear();
      template < typename DataType >
      inline void add(const ::std::string &name, const DataType value)
      {
        add_string(name, Convert::to_string(value));
      }
      void add_string(const ::std::string &name, const ::std::string &value);
      ::std::string get(::std::string name) const ;
      template < int N, typename DataType >
      inline ::RTTL::RTVec_t<N, DataType, 0> getVector(::std::string name, DataType defvalue  = 0) const 
      {
        ::RTTL::RTVec_t<N, DataType, 0> v;
        getArray<N, DataType>(name, v, defvalue);
        return v;
      }
      ::RTTL::RTVec3f getVec3f(::std::string name, float defvalue  = 0) const ;
      ::RTTL::RTVec3f getVec3i(::std::string name, int defvalue  = 0) const ;
      ::RTTL::RTVec2f getVec2f(::std::string name, float defvalue  = 0) const ;
      ::RTTL::RTVec2i getVec2i(::std::string name, int defvalue  = 0) const ;
      template < int N, typename DataType >
      inline void getArray(::std::string name, DataType *vtgt, DataType defvalue  = 0) const 
      {
        int n((*this).::RTTL::MapOptions::vector_size(name));
        if (N > 0)
          {
            n = ::std::min /* <int> */ (n, N);
          }
        int verboselevel((*this).::RTTL::MapOptions::verbose());
        if (n == 0 && verboselevel >= 1)
          {
            ::std::cout << "MapOptions: parameter " << name << " is undefined; using default value of " << defvalue << std::endl;
          }
        int i(0);
        if (n)
          {
            if (verboselevel >= 2)
              {
                ::std::cout << "MapOptions: using " << name << " = [ ";
              }
            const ::RTTL::vector_of_strings &vs(*(*this).::RTTL::MapOptions::operator [](name));
            for (::std::vector< ::std::string, ::std::allocator< ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> > > >::const_iterator it = vs.::std::vector< ::std::string, ::std::allocator< ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> > > >::begin(); i < n; it++)
              {
                vtgt[i++] = Convert::to<DataType>( *it);
                if (verboselevel >= 2)
                  {
                    ::std::cout << vtgt[i - 1] << " ";
                  }
              }
            if (verboselevel >= 2)
              {
                ::std::cout << "]" << ::std::endl<char, ::std::char_traits<char> >;
              }
          }
        for (; i < N; i++)
          {
            vtgt[i] = defvalue;
          }
      }
      int verbose() const ;
      template < typename DataType >
      inline DataType get(const ::std::string &name, DataType defvalue, unsigned int index  = 0) const 
      {
        ::RTTL::MapOptions::const_iterator it(((*this).::RTTL::MapOptions::find(name)));
        int verboselevel((*this).::RTTL::MapOptions::verbose());
        if (it == (*this).::std::map< ::std::string, ::RTTL::vector_of_strings *, ::std::less< ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> > >, ::std::allocator< ::std::pair<const ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> >, ::RTTL::vector_of_strings *> > >::end())
          {
            const char *parenv(::getenv(name.::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> >::c_str()));
            if (parenv)
              {
                return Convert::to<DataType>(parenv);
              }
            if (verboselevel >= 1)
              {
                ::std::cout << "MapOptions: parameter " << name << "[" << index << "]" << " is undefined; using default value of " << defvalue << std::endl;
              }
            return defvalue;
          }
        else
          {
            const ::RTTL::vector_of_strings &entry(*(*it.::std::_Rb_tree_const_iterator< ::std::pair<const ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> >, ::RTTL::vector_of_strings *> >::operator ->()).second);
            if (index >= entry.::std::vector< ::std::string, ::std::allocator< ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> > > >::size())
              {
                return defvalue;
              }
            if (entry.::std::vector< ::std::string, ::std::allocator< ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> > > >::operator [](index).::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> >::size() == 0)
              {
                return defvalue;
              }
            DataType value = Convert::to<DataType>(entry.::std::vector< ::std::string, ::std::allocator< ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> > > >::operator [](index));
            if (verboselevel >= 2)
              {
                ::std::cout << "MapOptions: using " << name << "[" << index << "] = " << value << std::endl;
              }
            return value;
          }
      }
      unsigned int vector_size(const ::std::string &name) const ;
      bool defined(const char *name, int len) const ;
      bool defined(const ::std::string &name) const ;
      void remove(const ::std::string &name);
      bool parse(int argc, char *argv[], bool keep_all_filenames  = false);
      bool parse(const char *a);
      bool isNumber(const char *s);
      bool parse(int argc, const char *argv[], bool keep_all_filenames  = false);
      bool parse_file(const char *filename);
      const ::RTTL::vector_of_strings *operator [](const ::std::string &name) const ;
      ::RTTL::vector_of_strings *operator [](const ::std::string &name);
    protected:
      void remove_all_entries();
      ::RTTL::MapOptions::iterator find(const ::std::string &name);
      ::RTTL::MapOptions::const_iterator find(const ::std::string &name) const ;
      ::RTTL::MapOptions::iterator find(const char *name, int len);
      ::RTTL::MapOptions::const_iterator find(const char *name, int len) const ;
      ::std::map<void *, bool, ::std::less<void *>, ::std::allocator< ::std::pair<void *const , bool> > > m_used_entries;
    public:
  };
  inline __attribute__((always_inline)) ::std::ostream &operator <<(::std::ostream &out, ::RTTL::MapOptions::const_iterator it)
  {
    const ::RTTL::vector_of_strings &vec(*(*it.::std::_Rb_tree_const_iterator< ::std::pair<const ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> >, ::RTTL::vector_of_strings *> >::operator ->()).second);
    unsigned int sz(vec.::std::vector< ::std::string, ::std::allocator< ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> > > >::size());
    out << (*it.::std::_Rb_tree_const_iterator< ::std::pair<const ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> >, ::RTTL::vector_of_strings *> >::operator ->()).first << " = ";
    if (sz > 1)
      {
        out << "[";
      }
    unsigned int i(0);
    while (true)
      {
        out << vec.::std::vector< ::std::string, ::std::allocator< ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> > > >::operator [](i);
        if (++i == sz)
          {
            break;
          }
        out << ", ";
      }
    if (sz > 1)
      {
        out << "]";
      }
    out << ";" << ::std::endl<char, ::std::char_traits<char> >;
    return out;
  }
  inline __attribute__((always_inline)) ::std::ostream &operator <<(::std::ostream &out, ::RTTL::MapOptions::iterator it)
  {
    out << (::RTTL::MapOptions::const_iterator &)it;
    return out;
  }
  inline __attribute__((always_inline)) ::std::ostream &operator <<(::std::ostream &out, const ::RTTL::MapOptions &mo)
  {
    ::RTTL::MapOptions::const_iterator it;
    unsigned int maxwidth(0);
    for (it = mo.::std::map< ::std::string, ::RTTL::vector_of_strings *, ::std::less< ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> > >, ::std::allocator< ::std::pair<const ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> >, ::RTTL::vector_of_strings *> > >::begin(); it != mo.::std::map< ::std::string, ::RTTL::vector_of_strings *, ::std::less< ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> > >, ::std::allocator< ::std::pair<const ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> >, ::RTTL::vector_of_strings *> > >::end(); it++)
      {
        maxwidth = ::std::max /* <unsigned int> */ (maxwidth, (unsigned int)(*it.::std::_Rb_tree_const_iterator< ::std::pair<const ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> >, ::RTTL::vector_of_strings *> >::operator ->()).first.::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> >::length());
      }
    maxwidth++;
    for (it = mo.::std::map< ::std::string, ::RTTL::vector_of_strings *, ::std::less< ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> > >, ::std::allocator< ::std::pair<const ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> >, ::RTTL::vector_of_strings *> > >::begin(); it != mo.::std::map< ::std::string, ::RTTL::vector_of_strings *, ::std::less< ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> > >, ::std::allocator< ::std::pair<const ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> >, ::RTTL::vector_of_strings *> > >::end(); it++)
      {
        ::std::cout.::std::ios_base::width(maxwidth);
        ::std::cout << it;
      }
    return out;
  }
  extern ::RTTL::MapOptions options;
}
using namespace ::RTTL;
using namespace ::LRT;
enum MouseButton
{
  M_NONE = 0,
  M_LEFT = 1,
  M_MIDDLE = 2,
  M_RIGHT = 3
};
int resX(1024);
int resY(1024);
int mouseButton(::M_NONE);
int lastMouseX( -1);
int lastMouseY( -1);
float moveScale(1.999999955296516418457031e-02f);
float rotateScale(1.000000014901161193847656e-01f);
::RTTL::RTVec3f viewerOrigin((::RTTL::RTVec_t<3, float, 0>(0.00000000000000000000000000000000000000000000000000000e+00, 2.00000000000000000000000000000000000000000000000000000e+00, 5.00000000000000000000000000000000000000000000000000000e-01)));
::RTTL::RTVec3f viewerDirection((::RTTL::RTVec_t<3, float, 0>( -0.00000000000000000000000000000000000000000000000000000e+00,  -9.70142999999999977589482114126440137624740600585937500e-01,  -2.42536000000000001586286657584423664957284927368164062e-01)));
::RTTL::RTVec3f viewerUp((::RTTL::RTVec_t<3, float, 0>(0.00000000000000000000000000000000000000000000000000000e+00,  -2.42536000000000001586286657584423664957284927368164062e-01, 9.70142999999999977589482114126440137624740600585937500e-01)));
float viewerAngle(64);
bool setViewer(false);
::Camera camera;
bool glDisplay(true);
int framesToRender(1);
bool autoMoveCamera(false);
::LRTFrameBufferHandle lrtFrameBuffer;
::LRTContext lrtContext;
::LRTCamera lrtCamera;
void InitGL()
{
  ::glClearColor(0.000000000000000000000000e+00f, 0.000000000000000000000000e+00f, 0.000000000000000000000000e+00f, 0.000000000000000000000000e+00f);
  ::glShadeModel(7424);
  ::glDisable(2929);
  ::glDisable(2896);
}
void render()
{
  ::RTTL::RTVec3f eye((::camera.::Camera::getOrigin()));
  ::RTTL::RTVec3f center((::camera.::Camera::getOrigin() + ::camera.::Camera::getDirection()));
  ::RTTL::RTVec3f up((::camera.::Camera::getUp()));
  ::lrtLookAt(::lrtCamera, eye.x, eye.y, eye.z, center.x, center.y, center.z, up.x, up.y, up.z, ::camera.::Camera::getAngle(), (float)::resX / ::resY);
  ::lrtRenderFrame(::lrtFrameBuffer, ::lrtContext, ::lrtCamera);
  if (::autoMoveCamera)
    {
      const float autoMoveScale(1.00000000000000002081668171172168513294309377670288086e-02);
      ::RTTL::RTVec3f oldOrigin((::camera.::Camera::getOrigin()));
      ::camera.::Camera::moveLocal(autoMoveScale * oldOrigin.::RTTL::RTVec_t<3, float, 0>::length() * up);
      ::RTTL::RTVec3f newOrigin((::camera.::Camera::getOrigin()));
      const float driftRatio(newOrigin.::RTTL::RTVec_t<3, float, 0>::length() / oldOrigin.::RTTL::RTVec_t<3, float, 0>::length());
      oldOrigin.::RTTL::RTVec_t<3, float, 0>::normalize();
      newOrigin.::RTTL::RTVec_t<3, float, 0>::normalize();
      float alpha(::acosf(::RTTL::dot /* <3, float, 0> */ (oldOrigin, newOrigin)) * 1.80000000000000000000000000000000000000000000000000000e+02 / 3.14159265358979311599796346854418516159057617187500000e+00);
      ::camera.::Camera::rotateGlobal(up, alpha);
      ::RTTL::RTVec3f newDirection((::camera.::Camera::getDirection()));
      newDirection.::RTTL::RTVec_t<3, float, 0>::normalize();
      ::camera.::Camera::setOrigin(::camera.::Camera::getOrigin() + (driftRatio - 1.00000000000000000000000000000000000000000000000000000e+00) * newDirection);
    }
}
void display()
{
  ::render();
  if (::glDisplay)
    {
      ::lrtDisplayFB(::lrtFrameBuffer);
    }
  ::glutSwapBuffers();
  ::glutPostRedisplay();
}
void reshape(int w, int h)
{
  ::resX = w;
  ::resY = h;
  ::std::cout << "reshape: " << w << " x " << h << ::std::endl<char, ::std::char_traits<char> >;
  ::std::cout << "\"Ignoring resize\"" << " = " << "Ignoring resize" << ::std::flush<char, ::std::char_traits<char> > << ::std::endl<char, ::std::char_traits<char> >;
}
void mouse(int button, int state, int x, int y)
{
  ::lastMouseX =  -1;
  ::lastMouseY =  -1;
  switch (button)
      {
        case 0 :
        if (state == 0)
          {
            ::mouseButton = ::M_LEFT;
          }
        break;
        case 2 :
        if (state == 0)
          {
            ::mouseButton = ::M_RIGHT;
          }
        break;
        default :
        ::mouseButton = ::M_NONE;
      }
  ::glutPostRedisplay();
}
void motion(int x, int y)
{
  switch (::mouseButton)
      {
        case ::M_RIGHT :
        if (::lastMouseX ==  -1 || ::lastMouseY ==  -1)
          {
            break;
          }
        ::camera.::Camera::moveLocal((::lastMouseY - y) * ::moveScale * ::RTTL::RTVec_t<3, float, 0>(1.000000000000000000000000e+00f, 0.000000000000000000000000e+00f, 0.000000000000000000000000e+00f));
        ::camera.::Camera::moveLocal((x - ::lastMouseX) * ::moveScale * ::RTTL::RTVec_t<3, float, 0>(0.000000000000000000000000e+00f, 1.000000000000000000000000e+00f, 0.000000000000000000000000e+00f));
        break;
        case ::M_LEFT :
        if (::lastMouseX ==  -1 || ::lastMouseY ==  -1)
          {
            break;
          }
        ::camera.::Camera::rotateGlobal(::camera.::Camera::getUp(), ::rotateScale * (::lastMouseX - x));
        ::camera.::Camera::rotateLocal(::RTTL::RTVec_t<3, float, 0>(0.000000000000000000000000e+00f, 1.000000000000000000000000e+00f, 0.000000000000000000000000e+00f), ::rotateScale * (y - ::lastMouseY));
        break;
      }
  ::lastMouseX = x;
  ::lastMouseY = y;
  ::glutPostRedisplay();
}
void keyboardfunc(unsigned char key, int x, int y)
{
  int mod(::glutGetModifiers());
  ::printf("key %i %c\n", key, key);
  switch (key)
      {
        case '+' :
        case '*' :
        ::moveScale *= 5.000000000000000000000000e+00f;
        break;
        case '-' :
        case '/' :
        ::moveScale /= 5.000000000000000000000000e+00f;
        break;
        case '<' :
        break;
        case '>' :
        break;
        case '!' :
        break;
        case 'q' :
        case 27 :
        ::printf("exiting application\n");
        ::exit(0);
        break;
      }
}
void specialfunc(int key, int x, int y)
{
  switch (key)
      {
        case 3 :
        {
          ::RTTL::RTVec3f o((::camera.::Camera::getOrigin()));
          ::RTTL::RTVec3f d((::camera.::Camera::getDirection()));
          ::RTTL::RTVec3f u((::camera.::Camera::getUp()));
          ::std::cout << "Current camera:" << ::std::endl<char, ::std::char_traits<char> >;
          ::std::cout << " -vp " << o.x << " " << o.y << " " << o.z;
          ::std::cout << " -vd " << d.x << " " << d.y << " " << d.z;
          ::std::cout << " -vu " << u.x << " " << u.y << " " << u.z;
          ::std::cout << ::std::endl<char, ::std::char_traits<char> >;
          break;
        }
        case 4 :
        ::std::cout << "Resetting camera" << ::std::endl<char, ::std::char_traits<char> >;
        ::camera.::Camera::initMatrix(::viewerOrigin, ::viewerDirection, ::viewerUp, ::viewerAngle);
        break;
        case 5 :
        break;
        default :
        ::printf("No function associated - sorry!\n");
        break;
      }
}
void parseRTVec3f(int argc, char **argv, int &p, ::RTTL::RTVec3f &vec)
{
  if (p + 3 > argc)
    {
      ::exit( -1);
    }
  vec.::RTTL::RTVec_t<3, float, 0>::operator [](0) = ::atof(argv[p + 0]);
  vec.::RTTL::RTVec_t<3, float, 0>::operator [](1) = ::atof(argv[p + 1]);
  vec.::RTTL::RTVec_t<3, float, 0>::operator [](2) = ::atof(argv[p + 2]);
  p += 3;
}
void parseCommandLine(int argc, char **argv)
{
  ::RTTL::options.::RTTL::MapOptions::parse(argc - 1, argv + 1 /* , false */ );
  ::std::cout << "Options: " << ::RTTL::options << ::std::endl<char, ::std::char_traits<char> >;
  ::setViewer = ::RTTL::options.::RTTL::MapOptions::defined("vp, vd, vi, vu, vangle");
  if (::RTTL::options.::RTTL::MapOptions::defined("vp"))
    {
      ::viewerOrigin = ::RTTL::options.::RTTL::MapOptions::getVec3f("vp" /* , 0 */ );
    }
  if (::RTTL::options.::RTTL::MapOptions::defined("vd"))
    {
      ::viewerDirection = ::RTTL::options.::RTTL::MapOptions::getVec3f("vd" /* , 0 */ );
    }
  if (::RTTL::options.::RTTL::MapOptions::defined("vi"))
    {
      ::viewerDirection = ::RTTL::options.::RTTL::MapOptions::getVec3f("vi" /* , 0 */ );
      ::viewerDirection -= ::viewerOrigin;
    }
  if (::RTTL::options.::RTTL::MapOptions::defined("vu"))
    {
      ::viewerUp = ::RTTL::options.::RTTL::MapOptions::getVec3f("vu" /* , 0 */ );
    }
  ::viewerAngle = ::RTTL::options.::RTTL::MapOptions::get /* <float> */ ("vangle", ::viewerAngle /* , 0 */ );
  ::glDisplay = ::RTTL::options.::RTTL::MapOptions::defined("display");
  ::framesToRender = ::RTTL::options.::RTTL::MapOptions::get /* <int> */ ("frames", ::framesToRender /* , 0 */ );
  ::autoMoveCamera = ::RTTL::options.::RTTL::MapOptions::defined("automove");
  if (::RTTL::options.::RTTL::MapOptions::defined("res"))
    {
      ::RTTL::RTVec2i newRes((::RTTL::options.::RTTL::MapOptions::getVec2i("res" /* , 0 */ )));
      ::resX = newRes.x;
      ::resY = newRes.y;
    }
}
::mesh_t generateUnitCube(::node_t root)
{
  const char __MERCURIUM_PRETTY_FUNCTION__[38] = "::mesh_t ::generateUnitCube(::node_t)";
  static float v[24U] = {  -1.00000000000000000000000000000000000000000000000000000e+00,  -1.00000000000000000000000000000000000000000000000000000e+00,  -1.00000000000000000000000000000000000000000000000000000e+00, 1.00000000000000000000000000000000000000000000000000000e+00,  -1.00000000000000000000000000000000000000000000000000000e+00,  -1.00000000000000000000000000000000000000000000000000000e+00, 1.00000000000000000000000000000000000000000000000000000e+00, 1.00000000000000000000000000000000000000000000000000000e+00,  -1.00000000000000000000000000000000000000000000000000000e+00,  -1.00000000000000000000000000000000000000000000000000000e+00, 1.00000000000000000000000000000000000000000000000000000e+00,  -1.00000000000000000000000000000000000000000000000000000e+00,  -1.00000000000000000000000000000000000000000000000000000e+00,  -1.00000000000000000000000000000000000000000000000000000e+00, 1.00000000000000000000000000000000000000000000000000000e+00, 1.00000000000000000000000000000000000000000000000000000e+00,  -1.00000000000000000000000000000000000000000000000000000e+00, 1.00000000000000000000000000000000000000000000000000000e+00, 1.00000000000000000000000000000000000000000000000000000e+00, 1.00000000000000000000000000000000000000000000000000000e+00, 1.00000000000000000000000000000000000000000000000000000e+00,  -1.00000000000000000000000000000000000000000000000000000e+00, 1.00000000000000000000000000000000000000000000000000000e+00, 1.00000000000000000000000000000000000000000000000000000e+00 };
  static int t[36U] = { 0, 3, 2, 0, 2, 1, 4, 0, 1, 4, 1, 5, 7, 3, 0, 7, 0, 4, 3, 7, 6, 3, 6, 2, 5, 6, 7, 5, 7, 4, 5, 1, 2, 5, 2, 6 };
  ::mesh_t mesh(::rtTriangleMesh(root));
  ::data_t vertex_array(::rtNewCoordArray(mesh, ::ISG::RT_FLOAT3));
  ::rtValidData(vertex_array) ? static_cast<void>(0) : ::__assert_fail("rtValidData(vertex_array)", "/home/bsc18/bsc18186/scratch/parsec/raytrace/src/MiniView/rtview.cxx", 308, __MERCURIUM_PRETTY_FUNCTION__);
  ::rtCoords3f(vertex_array, v, 8, ::RT_PRIVATE);
  ::data_t index_array(::rtNewIndexArray(mesh, ::ISG::RT_INT3));
  ::rtValidData(index_array) ? static_cast<void>(0) : ::__assert_fail("rtValidData(index_array)", "/home/bsc18/bsc18186/scratch/parsec/raytrace/src/MiniView/rtview.cxx", 317, __MERCURIUM_PRETTY_FUNCTION__);
  ::rtIndices3i(index_array, t, 12, ::RT_PRIVATE);
  return mesh;
}
void SetAutoCamera(::RTBox3f &box)
{
  ::RTTL::RTVec3f m_min((box.::RTTL::RTBox_t<3, float, 0>::operator [](0)));
  ::RTTL::RTVec3f m_max((box.::RTTL::RTBox_t<3, float, 0>::operator [](1)));
  ::RTTL::RTVec3f midpoint((5.000000000000000000000000e-01f * (m_min + m_max)));
  float height(m_max.::RTTL::RTVec_t<3, float, 0>::operator [](1) - m_min.::RTTL::RTVec_t<3, float, 0>::operator [](1));
  float width(m_max.::RTTL::RTVec_t<3, float, 0>::operator [](0) - m_min.::RTTL::RTVec_t<3, float, 0>::operator [](0));
  float max_size(height < width ? width : height);
  float dist(5.000000000000000000000000e-01f * max_size / ::tanf(5.000000000000000000000000e-01f * ::viewerAngle * 3.14159265358979311599796346854418516159057617187500000e+00 / 1.800000000000000000000000e+02f));
  ::viewerOrigin = ::RTTL::RTVec_t<3, float, 0>(midpoint.::RTTL::RTVec_t<3, float, 0>::operator [](0), midpoint.::RTTL::RTVec_t<3, float, 0>::operator [](1), m_max.::RTTL::RTVec_t<3, float, 0>::operator [](2) + dist);
  ::viewerUp = ::RTTL::RTVec_t<3, float, 0>(0, 1, 0);
  ::viewerDirection = ::RTTL::RTVec_t<3, float, 0>(0, 0,  -1);
}
int main(int argc, char **argv)
{
  const char __MERCURIUM_PRETTY_FUNCTION__[26] = "int ::main(int, char *[])";
  ::std::cout << "PARSEC Benchmark Suite" << ::std::endl<char, ::std::char_traits<char> > << ::std::flush<char, ::std::char_traits<char> >;
  ::rtInit(&argc, argv);
  ::lrtInit(&argc, argv);
  ::resX = ::LRT::RGBAucharFrameBuffer::Options::defaultRes.x;
  ::resY = ::LRT::RGBAucharFrameBuffer::Options::defaultRes.y;
  ::parseCommandLine(argc, argv);
  if (::glDisplay)
    {
      ::glutInit(&argc, argv);
      ::glutInitDisplayMode(0 | 2);
      ::glutInitWindowSize(::resX, ::resY);
      ::glutInitWindowPosition(0, 0);
      ::glutCreateWindow("rtview");
      ::InitGL();
    }
  else
    {
      ::LRT::RGBAucharFrameBuffer::Options::useMemoryFB = true;
    }
  ::lrtContext = ::lrtCreateContext();
  ::lrtCamera = ::lrtCreateCamera();
  ::lrtFrameBuffer = ::lrtCreateTextureFB(::resX, ::resY);
  bool subdiv(::RTTL::options.::RTTL::MapOptions::defined("subdiv"));
  if (subdiv)
    {
      ::std::cerr << "FATAL: " << "Subdivision surface mode currently not available" << "(in " << __MERCURIUM_PRETTY_FUNCTION__ << ")" << ::std::endl<char, ::std::char_traits<char> >;
      ::exit(1);
    }
  ;
  int numThreads(::RTTL::options.::RTTL::MapOptions::get /* <int> */ ("nthreads", 1 /* , 0 */ ));
  ::lrtSetRenderThreads(::lrtContext, numThreads);
  int nfiles(::RTTL::options.::RTTL::MapOptions::vector_size("files"));
  ::node_t root(::rtNewRoot(::RT_VISIBLE));
  if (nfiles == 0)
    {
      ::generateUnitCube(root);
    }
  else
    {
      ::ObjParser parser;
      for (int fi = 0; fi < nfiles; fi++)
        {
          const ::std::string &fn((*::RTTL::options.::RTTL::MapOptions::operator []("files")).::std::vector< ::std::string, ::std::allocator< ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> > > >::operator [](fi));
          ::std::cout << "Adding obj file: " << fn << ::std::endl<char, ::std::char_traits<char> >;
          parser.::ObjParser::Parse(fn.::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char> >::c_str());
        }
      ::RTBox3f sceneAABB((parser.::ObjParser::getSceneAABB()));
      if (!::setViewer)
        {
          ::std::cout << "Using auto camera..." << ::std::endl<char, ::std::char_traits<char> >;
          ::SetAutoCamera(sceneAABB);
        }
      parser.::ObjParser::vertices() ? static_cast<void>(0) : ::__assert_fail("parser.vertices()", "/home/bsc18/bsc18186/scratch/parsec/raytrace/src/MiniView/rtview.cxx", 416, __MERCURIUM_PRETTY_FUNCTION__);
      ::mesh_t mesh(::rtTriangleMesh(root));
      ::data_t vertex_array(::rtNewCoordArray(mesh, ::ISG::RT_FLOAT3));
      ::rtValidData(vertex_array) ? static_cast<void>(0) : ::__assert_fail("rtValidData(vertex_array)", "/home/bsc18/bsc18186/scratch/parsec/raytrace/src/MiniView/rtview.cxx", 421, __MERCURIUM_PRETTY_FUNCTION__);
      ::rtCoords3f(vertex_array, (const float *)parser.::ObjParser::getVertexPtr(), parser.::ObjParser::vertices(), ::RT_PRIVATE);
      if (parser.::ObjParser::triangles())
        {
          ::data_t index_array(::rtNewIndexArray(mesh, ::ISG::RT_INT3));
          ::rtValidData(index_array) ? static_cast<void>(0) : ::__assert_fail("rtValidData(index_array)", "/home/bsc18/bsc18186/scratch/parsec/raytrace/src/MiniView/rtview.cxx", 429, __MERCURIUM_PRETTY_FUNCTION__);
          ::rtIndices3i(index_array, (const int *)parser.::ObjParser::getTrianglePtr(), parser.::ObjParser::triangles(), ::RT_PRIVATE);
        }
      if (parser.::ObjParser::quads())
        {
          ::data_t index_array(::rtNewIndexArray(mesh, ::ISG::RT_INT4));
          ::rtValidData(index_array) ? static_cast<void>(0) : ::__assert_fail("rtValidData(index_array)", "/home/bsc18/bsc18186/scratch/parsec/raytrace/src/MiniView/rtview.cxx", 437, __MERCURIUM_PRETTY_FUNCTION__);
          ::rtIndices4i(index_array, (const int *)parser.::ObjParser::getQuadPtr(), parser.::ObjParser::quads(), ::RT_PRIVATE);
        }
      for (int i = 0; i < parser.::ObjParser::textures(); i++)
        {
          ::ImagePPM *txt(parser.::ObjParser::getTexture(i));
        }
      parser.::ObjParser::Free();
    }
  if (::RTTL::options.::RTTL::MapOptions::defined("exitafterbuild"))
    {
      ::exit(0);
    }
  ::camera.::Camera::initMatrix(::viewerOrigin, ::viewerDirection, ::viewerUp, ::viewerAngle);
  ::lrtBuildContext(::lrtContext);
  if (::glDisplay)
    {
      ::std::cout << "Starting glut..." << ::std::endl<char, ::std::char_traits<char> >;
      ::glutDisplayFunc(::display);
      ::glutReshapeFunc(::reshape);
      ::glutMouseFunc(::mouse);
      ::glutMotionFunc(::motion);
      ::glutSpecialFunc(::specialfunc);
      ::glutKeyboardFunc(::keyboardfunc);
      ::glutMainLoop();
    }
  else
    {
      ::std::cout << "Rendering " << ::framesToRender << " frames... " << ::std::endl<char, ::std::char_traits<char> > << ::std::flush<char, ::std::char_traits<char> >;
      int frame(0);
      do
        {
          ::render();
          frame++;
        }
      while (!(__builtin_expect(::framesToRender > 0, 0) && frame >= ::framesToRender));
      ::std::cout << "Done" << ::std::endl<char, ::std::char_traits<char> > << ::std::flush<char, ::std::char_traits<char> >;
    }
  return 0;
}
__attribute__((weak)) __attribute__((section("nanos_init"))) ::nanos_init_desc_t __section__nanos_init = { ::nanos_omp_set_interface, (void *)0 };
